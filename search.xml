<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据备份与恢复</title>
      <link href="/posts/73985825.html"/>
      <url>/posts/73985825.html</url>
      
        <content type="html"><![CDATA[<p>在任何数据库环境中，总会有<code>不确定的意外</code>情况发生，比如例外的停电、计算机系统中的各种软硬件故障、人为破坏、管理员误操作等是不可避免的，这些情况可能会导致<code>数据的丢失</code>、<code>服务器瘫痪</code>等严重的后果。存在多个服务器时，会出现主从服务器之间的数据同步问题。</p><p>为了有效防止数据丢失，并将损失降到最低，应定期对MySQL数据库服务器做备份。如果数据库中的数据丢失或者出现错误，可以使用备份的数据进行恢复。主从服务器之间的数据同步问题可以通过复制功能实现。</p><h2 id="1-物理备份与逻辑备份">1. 物理备份与逻辑备份</h2><p>**物理备份：**备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用 <code>xtrabackup</code> 工具来进行物理备份。</p><p>**逻辑备份：**对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为 <code>mysqldump</code> 。逻辑备份就是 <code>备份sql语句</code> ，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p><hr><h2 id="2-mysqldump实现逻辑备份">2. mysqldump实现逻辑备份</h2><p>mysqldump是MySQL提供的一个非常有用的数据库备份工具。</p><h3 id="2-1-备份一个数据库">2.1 备份一个数据库</h3><p>mysqldump命令执行时，可以将数据库备份成一个<code>文本文件</code>，该文件中实际上包含多个<code>CREATE</code>和<code>INSERT</code>语句，使用这些语句可以重新创建表和插入数据。</p><ul><li>查出需要备份的表的结构，在文本文件中生成一个CREATE语句</li><li>将表中的所有记录转换为一条INSERT语句。</li></ul><p><strong>基本语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]<span class="operator">&gt;</span> 备份文件名称.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure><blockquote><p>说明： 备份的文件并非一定要求后缀名为.sql，例如后缀名为.txt的文件也是可以的。</p></blockquote><p>举例：使用root用户备份atguigu数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu<span class="operator">&gt;</span>atguigu.sql #备份文件存储在当前目录下</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigudb1 <span class="operator">&gt;</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu.sql</span><br></pre></td></tr></table></figure><p>备份文件剖析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL dump 10.13 Distrib 8.0.26, for Linux (x86_64)</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Host: localhost Database: atguigu</span></span><br><span class="line"><span class="comment">-- ------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Server version 8.0.26</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET NAMES utf8mb4 */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Current Database: `atguigu`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span> `atguigu` <span class="comment">/*!40100 DEFAULT CHARACTER SET</span></span><br><span class="line"><span class="comment">utf8mb4 COLLATE utf8mb4_0900_ai_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */</span>;</span><br><span class="line"></span><br><span class="line">USE `atguigu`;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `student`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `student`;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET character_set_client = utf8mb4 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">`studentno` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`class` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`studentno`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;张三_back&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;一班&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;王五&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>),</span><br><span class="line">(<span class="number">15</span>,<span class="string">&#x27;赵六&#x27;</span>,<span class="string">&#x27;二班&#x27;</span>),(<span class="number">20</span>,<span class="string">&#x27;钱七&#x27;</span>,<span class="string">&#x27;&gt;三班&#x27;</span>),(<span class="number">22</span>,<span class="string">&#x27;zhang3_update&#x27;</span>,<span class="string">&#x27;1ban&#x27;</span>),(<span class="number">24</span>,<span class="string">&#x27;wang5&#x27;</span>,<span class="string">&#x27;2ban&#x27;</span>);</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `student` ENABLE KEYS */</span>;</span><br><span class="line">UNLOCK TABLES;</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line">        .</span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br><span class="line"><span class="comment">-- Dump completed on 2022-01-07 9:58:23</span></span><br></pre></td></tr></table></figure><h3 id="2-2-备份全部数据库">2.2 备份全部数据库</h3><p>若想用mysqldump备份整个实例，可以使用 --all-databases 或 -A 参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pxxxxxx <span class="comment">--all-databases &gt; all_database.sql</span></span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>pxxxxxx <span class="operator">-</span>A <span class="operator">&gt;</span> all_database.sql</span><br></pre></td></tr></table></figure><h3 id="2-3-备份部分数据库">2.3 备份部分数据库</h3><p>使用 <code>--databases</code> 或 <code>-B</code> 参数了，该参数后面跟数据库名称，多个数据库间用空格隔开。如果指定 databases参数，备份文件中会存在创建数据库的语句，如果不指定参数，则不存在。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u <span class="keyword">user</span> –h host –p <span class="comment">--databases [数据库的名称1 [数据库的名称2...]] &gt; 备份文件名称.sql</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="comment">--databases atguigu atguigu12 &gt;two_database.sql</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>B atguigu atguigu12 <span class="operator">&gt;</span> two_database.sql</span><br></pre></td></tr></table></figure><h3 id="2-4-备份部分表">2.4 备份部分表</h3><p>比如，在表变更前做个备份。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –u <span class="keyword">user</span> –h host –p 数据库的名称 [表名<span class="number">1</span> [表名<span class="number">2.</span>..]] <span class="operator">&gt;</span> 备份文件名称.<span class="keyword">sql</span></span><br></pre></td></tr></table></figure><p>举例：备份atguigu数据库下的book表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu book<span class="operator">&gt;</span> book.sql</span><br></pre></td></tr></table></figure><p>book.sql文件内容如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu book<span class="operator">&gt;</span> book.sql<span class="operator">^</span>C</span><br><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]# ls</span><br><span class="line">kk kubekey kubekey<span class="operator">-</span>v1<span class="number">.1</span><span class="number">.1</span><span class="operator">-</span>linux<span class="operator">-</span>amd64.tar.gz README.md test1.sql two_database.sql</span><br><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]# mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu book<span class="operator">&gt;</span> book.sql</span><br><span class="line">Enter password:</span><br><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]# ls</span><br><span class="line">book.sql kk kubekey kubekey<span class="operator">-</span>v1<span class="number">.1</span><span class="number">.1</span><span class="operator">-</span>linux<span class="operator">-</span>amd64.tar.gz README.md test1.sql</span><br><span class="line">two_database.sql</span><br><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]# vi book.sql</span><br><span class="line"><span class="comment">-- MySQL dump 10.13 Distrib 8.0.26, for Linux (x86_64)</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Host: localhost Database: atguigu</span></span><br><span class="line"><span class="comment">-- ------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Server version 8.0.26</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET NAMES utf8mb4 */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `book`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `book`;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET character_set_client = utf8mb4 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `book` (</span><br><span class="line">`bookid` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`test` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`bookid`),</span><br><span class="line">KEY `Y` (`card`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">101</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Dumping data for table `book`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">LOCK TABLES `book` WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `book` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `book` <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">9</span>,<span class="keyword">NULL</span>),(<span class="number">2</span>,<span class="number">10</span>,<span class="keyword">NULL</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="keyword">NULL</span>),(<span class="number">4</span>,<span class="number">8</span>,<span class="keyword">NULL</span>),(<span class="number">5</span>,<span class="number">7</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">6</span>,<span class="number">10</span>,<span class="keyword">NULL</span>),(<span class="number">7</span>,<span class="number">11</span>,<span class="keyword">NULL</span>),(<span class="number">8</span>,<span class="number">3</span>,<span class="keyword">NULL</span>),(<span class="number">9</span>,<span class="number">1</span>,<span class="keyword">NULL</span>),(<span class="number">10</span>,<span class="number">17</span>,<span class="keyword">NULL</span>),(<span class="number">11</span>,<span class="number">19</span>,<span class="keyword">NULL</span>),(<span class="number">12</span>,<span class="number">4</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">13</span>,<span class="number">1</span>,<span class="keyword">NULL</span>),(<span class="number">14</span>,<span class="number">14</span>,<span class="keyword">NULL</span>),(<span class="number">15</span>,<span class="number">5</span>,<span class="keyword">NULL</span>),(<span class="number">16</span>,<span class="number">5</span>,<span class="keyword">NULL</span>),(<span class="number">17</span>,<span class="number">8</span>,<span class="keyword">NULL</span>),(<span class="number">18</span>,<span class="number">3</span>,<span class="keyword">NULL</span>),(<span class="number">19</span>,<span class="number">12</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">20</span>,<span class="number">11</span>,<span class="keyword">NULL</span>),(<span class="number">21</span>,<span class="number">9</span>,<span class="keyword">NULL</span>),(<span class="number">22</span>,<span class="number">20</span>,<span class="keyword">NULL</span>),(<span class="number">23</span>,<span class="number">13</span>,<span class="keyword">NULL</span>),(<span class="number">24</span>,<span class="number">3</span>,<span class="keyword">NULL</span>),(<span class="number">25</span>,<span class="number">18</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">26</span>,<span class="number">20</span>,<span class="keyword">NULL</span>),(<span class="number">27</span>,<span class="number">5</span>,<span class="keyword">NULL</span>),(<span class="number">28</span>,<span class="number">6</span>,<span class="keyword">NULL</span>),(<span class="number">29</span>,<span class="number">15</span>,<span class="keyword">NULL</span>),(<span class="number">30</span>,<span class="number">15</span>,<span class="keyword">NULL</span>),(<span class="number">31</span>,<span class="number">12</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">32</span>,<span class="number">11</span>,<span class="keyword">NULL</span>),(<span class="number">33</span>,<span class="number">20</span>,<span class="keyword">NULL</span>),(<span class="number">34</span>,<span class="number">5</span>,<span class="keyword">NULL</span>),(<span class="number">35</span>,<span class="number">4</span>,<span class="keyword">NULL</span>),(<span class="number">36</span>,<span class="number">6</span>,<span class="keyword">NULL</span>),(<span class="number">37</span>,<span class="number">17</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">38</span>,<span class="number">5</span>,<span class="keyword">NULL</span>),(<span class="number">39</span>,<span class="number">16</span>,<span class="keyword">NULL</span>),(<span class="number">40</span>,<span class="number">6</span>,<span class="keyword">NULL</span>),(<span class="number">41</span>,<span class="number">18</span>,<span class="keyword">NULL</span>),(<span class="number">42</span>,<span class="number">12</span>,<span class="keyword">NULL</span>),(<span class="number">43</span>,<span class="number">6</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">44</span>,<span class="number">12</span>,<span class="keyword">NULL</span>),(<span class="number">45</span>,<span class="number">2</span>,<span class="keyword">NULL</span>),(<span class="number">46</span>,<span class="number">12</span>,<span class="keyword">NULL</span>),(<span class="number">47</span>,<span class="number">15</span>,<span class="keyword">NULL</span>),(<span class="number">48</span>,<span class="number">17</span>,<span class="keyword">NULL</span>),(<span class="number">49</span>,<span class="number">2</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">50</span>,<span class="number">16</span>,<span class="keyword">NULL</span>),(<span class="number">51</span>,<span class="number">13</span>,<span class="keyword">NULL</span>),(<span class="number">52</span>,<span class="number">17</span>,<span class="keyword">NULL</span>),(<span class="number">53</span>,<span class="number">7</span>,<span class="keyword">NULL</span>),(<span class="number">54</span>,<span class="number">2</span>,<span class="keyword">NULL</span>),(<span class="number">55</span>,<span class="number">9</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">56</span>,<span class="number">1</span>,<span class="keyword">NULL</span>),(<span class="number">57</span>,<span class="number">14</span>,<span class="keyword">NULL</span>),(<span class="number">58</span>,<span class="number">7</span>,<span class="keyword">NULL</span>),(<span class="number">59</span>,<span class="number">15</span>,<span class="keyword">NULL</span>),(<span class="number">60</span>,<span class="number">12</span>,<span class="keyword">NULL</span>),(<span class="number">61</span>,<span class="number">13</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">62</span>,<span class="number">8</span>,<span class="keyword">NULL</span>),(<span class="number">63</span>,<span class="number">2</span>,<span class="keyword">NULL</span>),(<span class="number">64</span>,<span class="number">6</span>,<span class="keyword">NULL</span>),(<span class="number">65</span>,<span class="number">2</span>,<span class="keyword">NULL</span>),(<span class="number">66</span>,<span class="number">12</span>,<span class="keyword">NULL</span>),(<span class="number">67</span>,<span class="number">12</span>,<span class="keyword">NULL</span>),(<span class="number">68</span>,<span class="number">4</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">69</span>,<span class="number">5</span>,<span class="keyword">NULL</span>),(<span class="number">70</span>,<span class="number">10</span>,<span class="keyword">NULL</span>),(<span class="number">71</span>,<span class="number">16</span>,<span class="keyword">NULL</span>),(<span class="number">72</span>,<span class="number">8</span>,<span class="keyword">NULL</span>),(<span class="number">73</span>,<span class="number">14</span>,<span class="keyword">NULL</span>),(<span class="number">74</span>,<span class="number">5</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">75</span>,<span class="number">4</span>,<span class="keyword">NULL</span>),(<span class="number">76</span>,<span class="number">3</span>,<span class="keyword">NULL</span>),(<span class="number">77</span>,<span class="number">2</span>,<span class="keyword">NULL</span>),(<span class="number">78</span>,<span class="number">2</span>,<span class="keyword">NULL</span>),(<span class="number">79</span>,<span class="number">2</span>,<span class="keyword">NULL</span>),(<span class="number">80</span>,<span class="number">3</span>,<span class="keyword">NULL</span>),(<span class="number">81</span>,<span class="number">8</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">82</span>,<span class="number">14</span>,<span class="keyword">NULL</span>),(<span class="number">83</span>,<span class="number">5</span>,<span class="keyword">NULL</span>),(<span class="number">84</span>,<span class="number">4</span>,<span class="keyword">NULL</span>),(<span class="number">85</span>,<span class="number">2</span>,<span class="keyword">NULL</span>),(<span class="number">86</span>,<span class="number">20</span>,<span class="keyword">NULL</span>),(<span class="number">87</span>,<span class="number">12</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">88</span>,<span class="number">1</span>,<span class="keyword">NULL</span>),(<span class="number">89</span>,<span class="number">8</span>,<span class="keyword">NULL</span>),(<span class="number">90</span>,<span class="number">18</span>,<span class="keyword">NULL</span>),(<span class="number">91</span>,<span class="number">3</span>,<span class="keyword">NULL</span>),(<span class="number">92</span>,<span class="number">3</span>,<span class="keyword">NULL</span>),(<span class="number">93</span>,<span class="number">6</span>,<span class="keyword">NULL</span>),(<span class="number">94</span>,<span class="number">1</span>,<span class="keyword">NULL</span>),</span><br><span class="line">(<span class="number">95</span>,<span class="number">4</span>,<span class="keyword">NULL</span>),(<span class="number">96</span>,<span class="number">17</span>,<span class="keyword">NULL</span>),(<span class="number">97</span>,<span class="number">15</span>,<span class="keyword">NULL</span>),(<span class="number">98</span>,<span class="number">1</span>,<span class="keyword">NULL</span>),(<span class="number">99</span>,<span class="number">20</span>,<span class="keyword">NULL</span>),(<span class="number">100</span>,<span class="number">15</span>,<span class="keyword">NULL</span>);</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `book` ENABLE KEYS */</span>;</span><br><span class="line">UNLOCK TABLES;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */</span>;</span><br></pre></td></tr></table></figure><p>可以看到，book文件和备份的库文件类似。不同的是，book文件只包含book表的DROP、CREATE和 INSERT语句。</p><p>备份多张表使用下面的命令，比如备份book和account表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#备份多张表</span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu book account <span class="operator">&gt;</span> <span class="number">2</span>_tables_bak.sql</span><br></pre></td></tr></table></figure><h3 id="2-5-备份单表的部分数据">2.5 备份单表的部分数据</h3><p>有些时候一张表的数据量很大，我们只需要部分数据。这时就可以使用 --where 选项了。where后面附带需要满足的条件。</p><p>举例：备份student表中id小于10的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu student <span class="comment">--where=&quot;id &lt; 10 &quot; &gt; student_part_id10_low_bak.sql</span></span><br></pre></td></tr></table></figure><p>内容如下所示，insert语句只有id小于10的部分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES `student` WRITE;</span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `student` DISABLE KEYS */</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">100002</span>,<span class="string">&#x27;JugxTY&#x27;</span>,<span class="number">157</span>,<span class="number">280</span>),(<span class="number">2</span>,<span class="number">100003</span>,<span class="string">&#x27;QyUcCJ&#x27;</span>,<span class="number">251</span>,<span class="number">277</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="number">100004</span>,<span class="string">&#x27;lATUPp&#x27;</span>,<span class="number">80</span>,<span class="number">404</span>),(<span class="number">4</span>,<span class="number">100005</span>,<span class="string">&#x27;BmFsXI&#x27;</span>,<span class="number">240</span>,<span class="number">171</span>),(<span class="number">5</span>,<span class="number">100006</span>,<span class="string">&#x27;mkpSwJ&#x27;</span>,<span class="number">388</span>,<span class="number">476</span>),</span><br><span class="line">(<span class="number">6</span>,<span class="number">100007</span>,<span class="string">&#x27;ujMgwN&#x27;</span>,<span class="number">259</span>,<span class="number">124</span>),(<span class="number">7</span>,<span class="number">100008</span>,<span class="string">&#x27;HBJTqX&#x27;</span>,<span class="number">429</span>,<span class="number">168</span>),(<span class="number">8</span>,<span class="number">100009</span>,<span class="string">&#x27;dvQSQA&#x27;</span>,<span class="number">61</span>,<span class="number">504</span>),</span><br><span class="line">(<span class="number">9</span>,<span class="number">100010</span>,<span class="string">&#x27;HljpVJ&#x27;</span>,<span class="number">234</span>,<span class="number">185</span>);</span><br></pre></td></tr></table></figure><h3 id="2-6-排除某些表的备份">2.6 排除某些表的备份</h3><p>如果我们想备份某个库，但是某些表数据量很大或者与业务关联不大，这个时候可以考虑排除掉这些表，同样的，选项 <code>--ignore-table</code> 可以完成这个功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="comment">--ignore-table=atguigu.student &gt; no_stu_bak.sql</span></span><br></pre></td></tr></table></figure><p>通过如下指定判定文件中没有student表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;student&quot; no_stu_bak.sql</span><br></pre></td></tr></table></figure><h3 id="2-7-只备份结构或只备份数据">2.7 只备份结构或只备份数据</h3><p>只备份结构的话可以使用 <code>--no-data</code> 简写为 <code>-d</code> 选项；只备份数据可以使用 <code>--no-create-info</code> 简写为 <code>-t</code>选项。</p><ul><li><p>只备份结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="comment">--no-data &gt; atguigu_no_data_bak.sql</span></span><br><span class="line">#使用grep命令，没有找到<span class="keyword">insert</span>相关语句，表示没有数据备份。</span><br><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]# grep &quot;INSERT&quot; atguigu_no_data_bak.sql</span><br><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]#</span><br></pre></td></tr></table></figure></li><li><p>只备份数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="comment">--no-create-info &gt; atguigu_no_create_info_bak.sql</span></span><br><span class="line">#使用grep命令，没有找到<span class="keyword">create</span>相关语句，表示没有数据结构。</span><br><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]# grep &quot;CREATE&quot; atguigu_no_create_info_bak.sql</span><br><span class="line">[root<span class="variable">@node1</span> <span class="operator">~</span>]#</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-8-备份中包含存储过程、函数、事件">2.8 备份中包含存储过程、函数、事件</h3><p>mysqldump备份默认是不包含存储过程，自定义函数及事件的。可以使用 <code>--routines</code> 或 <code>-R</code> 选项来备份存储过程及函数，使用 <code>--events</code> 或 <code>-E</code> 参数来备份事件。</p><p>举例：备份整个atguigu库，包含存储过程及事件：</p><ul><li>使用下面的SQL可以查看当前库有哪些存储过程或者函数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SPECIFIC_NAME,ROUTINE_TYPE ,ROUTINE_SCHEMA <span class="keyword">FROM</span></span><br><span class="line">information_schema.Routines <span class="keyword">WHERE</span> ROUTINE_SCHEMA<span class="operator">=</span>&quot;atguigu&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+--------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> SPECIFIC_NAME <span class="operator">|</span> ROUTINE_TYPE <span class="operator">|</span> ROUTINE_SCHEMA <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+--------------+----------------+</span></span><br><span class="line"><span class="operator">|</span> rand_num      <span class="operator">|</span> <span class="keyword">FUNCTION</span>     <span class="operator">|</span> atguigu        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> rand_string   <span class="operator">|</span> <span class="keyword">FUNCTION</span>     <span class="operator">|</span> atguigu        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> BatchInsert   <span class="operator">|</span> <span class="keyword">PROCEDURE</span>    <span class="operator">|</span> atguigu        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> insert_class  <span class="operator">|</span> <span class="keyword">PROCEDURE</span>    <span class="operator">|</span> atguigu        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> insert_order  <span class="operator">|</span> <span class="keyword">PROCEDURE</span>    <span class="operator">|</span> atguigu        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> insert_stu    <span class="operator">|</span> <span class="keyword">PROCEDURE</span>    <span class="operator">|</span> atguigu        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> insert_user   <span class="operator">|</span> <span class="keyword">PROCEDURE</span>    <span class="operator">|</span> atguigu        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> ts_insert     <span class="operator">|</span> <span class="keyword">PROCEDURE</span>    <span class="operator">|</span> atguigu        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+--------------+----------------+</span></span><br><span class="line"><span class="number">9</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p>下面备份atguigu库的数据，函数以及存储过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>R <span class="operator">-</span>E <span class="comment">--databases atguigu &gt; fun_atguigu_bak.sql</span></span><br></pre></td></tr></table></figure><p>查询备份文件中是否存在函数，如下所示，可以看到确实包含了函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="operator">-</span>C <span class="number">5</span> &quot;rand_num&quot; fun_atguigu_bak.sql</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Dumping routines for database &#x27;atguigu&#x27;</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">/*!50003 DROP FUNCTION IF EXISTS `rand_num` */</span>;</span><br><span class="line"><span class="comment">/*!50003 SET @saved_cs_client = @@character_set_client */</span> ;</span><br><span class="line"><span class="comment">/*!50003 SET @saved_cs_results = @@character_set_results */</span> ;</span><br><span class="line"><span class="comment">/*!50003 SET @saved_col_connection = @@collation_connection */</span> ;</span><br><span class="line"><span class="comment">/*!50003 SET character_set_client = utf8mb3 */</span> ;</span><br><span class="line"><span class="comment">/*!50003 SET character_set_results = utf8mb3 */</span> ;</span><br><span class="line"><span class="comment">/*!50003 SET collation_connection = utf8_general_ci */</span> ;</span><br><span class="line"><span class="comment">/*!50003 SET @saved_sql_mode = @@sql_mode */</span> ;</span><br><span class="line"><span class="comment">/*!50003 SET sql_mode =</span></span><br><span class="line"><span class="comment">&#x27;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISIO</span></span><br><span class="line"><span class="comment">N_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27; */</span> ;</span><br><span class="line">DELIMITER ;;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`<span class="operator">%</span>` <span class="keyword">FUNCTION</span> `rand_num`(from_num <span class="type">BIGINT</span> ,to_num <span class="type">BIGINT</span>) <span class="keyword">RETURNS</span></span><br><span class="line"><span class="type">bigint</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> ;;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> class ( classname,address,monitor ) <span class="keyword">VALUES</span></span><br><span class="line">    (rand_string(<span class="number">8</span>),rand_string(<span class="number">10</span>),rand_num());</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> ;;</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_test (order_id, trans_id ) <span class="keyword">VALUES</span></span><br><span class="line">    (rand_num(<span class="number">1</span>,<span class="number">7000000</span>),rand_num(<span class="number">100000000000000000</span>,<span class="number">700000000000000000</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> ;;</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, name ,age ,classId ) <span class="keyword">VALUES</span></span><br><span class="line">    ((<span class="keyword">START</span><span class="operator">+</span>i),rand_string(<span class="number">6</span>),rand_num(),rand_num());</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> ;;</span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` ( name,age,sex ) <span class="keyword">VALUES</span> (&quot;atguigu&quot;,rand_num(<span class="number">1</span>,<span class="number">20</span>),&quot;male&quot;);</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> ;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="2-9-mysqldump常用选项">2.9 mysqldump常用选项</h3><p>mysqldump其他常用选项如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--add-drop-database：在每个CREATE DATABASE语句前添加DROP DATABASE语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--add-drop-tables：在每个CREATE TABLE语句前添加DROP TABLE语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--add-locking：用LOCK TABLES和UNLOCK TABLES语句引用每个表转储。重载转储文件时插入得更快。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--all-database, -A：转储所有数据库中的所有表。与使用--database选项相同，在命令行中命名所有数据库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--comment[=0|1]：如果设置为0，禁止转储文件中的其他信息，例如程序版本、服务器版本和主机。--skipcomments与--comments=0的结果相同。默认值为1，即包括额外信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--compact：产生少量输出。该选项禁用注释并启用--skip-add-drop-tables、--no-set-names、--skipdisable-keys和--skip-add-locking选项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--compatible=name：产生与其他数据库系统或旧的MySQL服务器更兼容的输出，值可以为ansi、MySQL323、MySQL40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_table_options或者no_field_options。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--complete_insert, -c：使用包括列名的完整的INSERT语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--debug[=debug_options], -#[debug_options]：写调试日志。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--delete，-D：导入文本文件前清空表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--default-character-set=charset：使用charsets默认字符集。如果没有指定，就使用utf8。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--delete--master-logs：在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用-masterdata。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--extended-insert，-e：使用包括几个VALUES列表的多行INSERT语法。这样使得转储文件更小，重载文件时可以加速插入。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--flush-logs，-F：开始转储前刷新MySQL服务器日志文件。该选项要求RELOAD权限。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--force，-f：在表转储过程中，即使出现SQL错误也继续。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lock-all-tables，-x：对所有数据库中的所有表加锁。在整体转储过程中通过全局锁定来实现。该选项自动关闭--single-transaction和--lock-tables。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lock-tables，-l：开始转储前锁定所有表。用READ LOCAL锁定表以允许并行插入MyISAM表。对于事务表（例如InnoDB和BDB），--single-transaction是一个更好的选项，因为它根本不需要锁定表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-create-db，-n：该选项禁用CREATE DATABASE /*!32312 IF NOT EXIST*/db_name语句，如果给出--database或--all-database选项，就包含到输出中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-create-info，-t：只导出数据，而不添加CREATE TABLE语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--no-data，-d：不写表的任何行信息，只转储表的结构。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--opt：该选项是速记，它可以快速进行转储操作并产生一个能很快装入MySQL服务器的转储文件。该选项默认开启，但可以用--skip-opt禁用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--password[=password]，-p[password]：当连接服务器时使用的密码。</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>port<span class="operator">=</span>port_num，<span class="operator">-</span>P port_num：用于连接的TCP<span class="operator">/</span>IP端口号。</span><br><span class="line"></span><br><span class="line"><span class="comment">--protocol=&#123;TCP|SOCKET|PIPE|MEMORY&#125;：使用的连接协议。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--replace，-r –replace和--ignore：控制替换或复制唯一键值已有记录的输入记录的处理。如果指定--replace，新行替换有相同的唯一键值的已有行；如果指定--ignore，复制已有的唯一键值的输入行被跳过。如果不指定这两个选项，当发现一个复制键值时会出现一个错误，并且忽视文本文件的剩余部分。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--silent，-s：沉默模式。只有出现错误时才输出。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--socket=path，-S path：当连接localhost时使用的套接字文件（为默认主机）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--user=user_name，-u user_name：当连接服务器时MySQL使用的用户名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--verbose，-v：冗长模式，打印出程序操作的详细信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--xml，-X：产生XML输出。</span></span><br></pre></td></tr></table></figure><p>运行帮助命令 <code>mysqldump --help</code> ，可以获得特定版本的完整选项列表。</p><blockquote><p>提示 如果运行mysqldump没有–quick或–opt选项，mysqldump在转储结果前将整个结果集装入内 存。如果转储大数据库可能会出现问题，该选项默认启用，但可以用–skip-opt禁用。如果使用最 新版本的mysqldump程序备份数据，并用于恢复到比较旧版本的MySQL服务器中，则不要使用–opt 或-e选项。</p></blockquote><hr><h2 id="3-mysql命令恢复数据">3. mysql命令恢复数据</h2><p>使用mysqldump命令将数据库中的数据备份成一个文本文件。需要恢复时，可以使用<code>mysql命令</code>来恢复备份的数据。</p><p>mysql命令可以执行备份文件中的<code>CREATE语句</code>和<code>INSERT语句</code>。通过CREATE语句来创建数据库和表。通过INSERT语句来插入备份的数据。</p><p>基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –u root –p [dbname] <span class="operator">&lt;</span> backup.sql</span><br></pre></td></tr></table></figure><p>其中，dbname参数表示数据库名称。该参数是可选参数，可以指定数据库名，也可以不指定。指定数据库名时，表示还原该数据库下的表。此时需要确保MySQL服务器中已经创建了该名的数据库。不指定数据库名，表示还原文件中所有的数据库。此时sql文件中包含有CREATE DATABASE语句，不需要MySQL服务器中已存在的这些数据库。</p><h3 id="3-1-单库备份中恢复单库">3.1 单库备份中恢复单库</h3><p>使用root用户，将之前练习中备份的atguigu.sql文件中的备份导入数据库中，命令如下：</p><p>如果备份文件中包含了创建数据库的语句，则恢复的时候不需要指定数据库名称，如下所示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">&lt;</span> atguigu.sql</span><br></pre></td></tr></table></figure><p>否则需要指定数据库名称，如下所示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu4<span class="operator">&lt;</span> atguigu.sql</span><br></pre></td></tr></table></figure><h3 id="3-2-全量备份恢复">3.2 全量备份恢复</h3><p>如果我们现在有昨天的全量备份，现在想整个恢复，则可以这样操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql –u root –p <span class="operator">&lt;</span> all.sql</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>pxxxxxx <span class="operator">&lt;</span> all.sql</span><br></pre></td></tr></table></figure><p>执行完后，MySQL数据库中就已经恢复了all.sql文件中的所有数据库。</p><h3 id="3-3-全量备份恢复">3.3 全量备份恢复</h3><p>可能有这样的需求，比如说我们只想恢复某一个库，但是我们有的是整个实例的备份，这个时候我们可以从全量备份中分离出单个库的备份。</p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="operator">-</span>n <span class="string">&#x27;/^-- Current Database: `atguigu`/,/^-- Current Database: `/p&#x27;</span> all_database.sql <span class="operator">&gt;</span> atguigu.sql</span><br><span class="line">#分离完成后我们再导入atguigu.sql即可恢复单个库</span><br></pre></td></tr></table></figure><h3 id="3-4-从单库备份中恢复单表">3.4 从单库备份中恢复单表</h3><p>这个需求还是比较常见的。比如说我们知道哪个表误操作了，那么就可以用单表恢复的方式来恢复。</p><p>举例：我们有atguigu整库的备份，但是由于class表误操作，需要单独恢复出这张表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat atguigu.sql <span class="operator">|</span> sed <span class="operator">-</span>e <span class="string">&#x27;/./&#123;H;$!d;&#125;&#x27;</span> <span class="operator">-</span>e <span class="string">&#x27;x;/CREATE TABLE `class`/!d;q&#x27;</span> <span class="operator">&gt;</span> class_structure.sql</span><br><span class="line">cat atguigu.sql <span class="operator">|</span> grep <span class="comment">--ignore-case &#x27;insert into `class`&#x27; &gt; class_data.sql</span></span><br><span class="line">#用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复</span><br><span class="line"></span><br><span class="line">use atguigu;</span><br><span class="line">mysql<span class="operator">&gt;</span> source class_structure.sql;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> source class_data.sql;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><hr><h2 id="4-物理备份：直接复制整个数据库">4. 物理备份：直接复制整个数据库</h2><p>直接将MySQL中的数据库文件复制出来。这种方法最简单，速度也最快。MySQL的数据库目录位置不一 定相同：</p><ul><li>在Windows平台下，MySQL 8.0存放数据库的目录通常默认为 “ C:\ProgramData\MySQL\MySQL Server 8.0\Data ”或者其他用户自定义目录；</li><li>在Linux平台下，数据库目录位置通常为/var/lib/mysql/；</li><li>在MAC OSX平台下，数据库目录位置通常为“/usr/local/mysql/data”</li></ul><p>但为了保证备份的一致性。需要保证：</p><ul><li>方式1：备份前，将服务器停止。</li><li>方式2：备份前，对相关表执行 FLUSH TABLES WITH READ LOCK 操作。这样当复制数据库目录中 的文件时，允许其他客户继续查询表。同时，FLUSH TABLES语句来确保开始备份前将所有激活的索 引页写入硬盘。</li></ul><p>这种方式方便、快速，但不是最好的备份方法，因为实际情况可能 <code>不允许停止MySQL服务器</code> 或者 <code>锁住表</code> ，而且这种方法 对InnoDB存储引擎 的表不适用。对于MyISAM存储引擎的表，这样备份和还原很方便，但是还原时最好是相同版本的MySQL数据库，否则可能会存在文件类型不同的情况。</p><p>注意，物理备份完毕后，执行 UNLOCK TABLES 来结算其他客户对表的修改行为。</p><blockquote><p>说明： 在MySQL版本号中，第一个数字表示主版本号，主版本号相同的MySQL数据库文件格式相同。</p></blockquote><p>此外，还可以考虑使用相关工具实现备份。比如， <code>MySQLhotcopy</code> 工具。MySQLhotcopy是一个Perl脚本，它使用LOCK TABLES、FLUSH TABLES和cp或scp来快速备份数据库。它是备份数据库或单个表最快的途径，但它只能运行在数据库目录所在的机器上，并且只能备份MyISAM类型的表。多用于mysql5.5之前。</p><h2 id="5-物理恢复：直接复制到数据库目录">5. 物理恢复：直接复制到数据库目录</h2><p><strong>步骤：</strong></p><p>1）演示删除备份的数据库中指定表的数据</p><p>2）将备份的数据库数据拷贝到数据目录下，并重启MySQL服务器</p><p>3）查询相关表的数据是否恢复。需要使用下面的<code> chown</code> 操作。</p><p><strong>要求：</strong></p><ul><li>必须确保备份数据的数据库和待恢复的数据库服务器的主版本号相同。<ul><li>因为只有MySQL数据库主版本号相同时，才能保证这两个MySQL数据库文件类型是相同的。</li></ul></li><li>这种方式对 <code>MyISAM类型的表比较有效</code> ，对于InnoDB类型的表则不可用。<ul><li>因为InnoDB表的表空间不能直接复制。</li></ul></li><li>在Linux操作系统下，复制到数据库目录后，一定要将数据库的用户和组变成mysql，命令如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="operator">-</span>R mysql.mysql <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>dbname</span><br></pre></td></tr></table></figure><p>其中，两个mysql分别表示组和用户；“-R”参数可以改变文件夹下的所有子文件的用户和组；“dbname”参数表示数据库目录。</p><blockquote><p>提示 Linux操作系统下的权限设置非常严格。通常情况下，MySQL数据库只有root用户和mysql用户 组下的mysql用户才可以访问，因此将数据库目录复制到指定文件夹后，一定要使用chown命令将 文件夹的用户组变为mysql，将用户变为mysql。</p></blockquote><hr><h2 id="6-表的导出与导入">6. 表的导出与导入</h2><h3 id="6-1-表的导出">6.1 表的导出</h3><div class="tabs" id="e07d7d47-d1c0-4a68-b584-44dd00f1d25b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e07d7d47-d1c0-4a68-b584-44dd00f1d25b-1"><i class="fas fa-award"></i>SELECT…INTO OUTFILE导出文本文件</button></li><li class="tab"><button type="button" data-href="#e07d7d47-d1c0-4a68-b584-44dd00f1d25b-2"><i class="fas fa-baseball-ball"></i>mysqldump命令导出文本文件</button></li><li class="tab"><button type="button" data-href="#e07d7d47-d1c0-4a68-b584-44dd00f1d25b-3"><i class="fas fa-bone"></i>mysql命令导出文本文件</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e07d7d47-d1c0-4a68-b584-44dd00f1d25b-1"><p>在MySQL中，可以使用SELECT…INTO OUTFILE语句将表的内容导出成一个文本文件。</p><p>**举例：**使用SELECT…INTO OUTFILE将atguigu数据库中account表中的记录导出到文本文件。</p><p>（1）选择数据库atguigu，并查询account表，执行结果如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use atguigu;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> balance <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> 张三 <span class="operator">|</span> <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> 李四 <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> 王五 <span class="operator">|</span> <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>（2）mysql默认对导出的目录有权限限制，也就是说使用命令行进行导出的时候，需要指定目录进行操作。</p><p>查询secure_file_priv值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%secure%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name            <span class="operator">|</span> <span class="keyword">Value</span>                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> require_secure_transport <span class="operator">|</span> OFF                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> secure_file_priv         <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">-</span>files<span class="operator">/</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-----------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p>参数secure_file_priv的可选值和作用分别是：</p><ul><li><p>如果设置为empty，表示不限制文件生成的位置，这是不安全的设置；</p></li><li><p>如果设買为—个表示路径的字符串，就要求生成的文件只能放在这个指定的目录，或者它的子目录；</p></li><li><p>如果设置为NULL，就表示禁止在这个MySQL实例上执行select… into outfile 操作。</p></li></ul><p>（3）上面结果中显示，secure_file_priv变量的值为/var/lib/mysql-files/，导出目录设置为该目录，SQL语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">INTO</span> OUTFILE &quot;/var/lib/mysql-files/account.txt&quot;;</span><br></pre></td></tr></table></figure><p>（4）查看 /var/lib/mysql-files/account.txt`文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 张三 <span class="number">90</span></span><br><span class="line"><span class="number">2</span> 李四 <span class="number">100</span></span><br><span class="line"><span class="number">3</span> 王五 <span class="number">0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e07d7d47-d1c0-4a68-b584-44dd00f1d25b-2"><p>**举例1：**使用mysqldump命令将将atguigu数据库中account表中的记录导出到文本文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>T &quot;/var/lib/mysql-files/&quot; atguigu account</span><br></pre></td></tr></table></figure><p>mysqldump命令执行完毕后，在指定的目录/var/lib/mysql-files/下生成了account.sql和account.txt文件。</p><p>打开account.sql文件，其内容包含创建account表的CREATE语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> mysql<span class="operator">-</span>files]# cat account.sql</span><br><span class="line"><span class="comment">-- MySQL dump 10.13 Distrib 8.0.26, for Linux (x86_64)</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Host: localhost Database: atguigu</span></span><br><span class="line"><span class="comment">-- ------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Server version 8.0.26</span></span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET NAMES utf8mb4 */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `account`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `account`;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET character_set_client = utf8mb4 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account` (</span><br><span class="line">`id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`balance` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Dump completed on 2022-01-07 23:19:27</span></span><br></pre></td></tr></table></figure><p>打开account.txt文件，其内容只包含account表中的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> mysql<span class="operator">-</span>files]# cat account.txt</span><br><span class="line"><span class="number">1</span> 张三 <span class="number">90</span></span><br><span class="line"><span class="number">2</span> 李四 <span class="number">100</span></span><br><span class="line"><span class="number">3</span> 王五 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>**举例2：**使用mysqldump将atguigu数据库中的account表导出到文本文件，使用FIELDS选项，要求字段之 间使用逗号“，”间隔，所有字符类型字段值用双引号括起来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="operator">-</span>T &quot;/var/lib/mysql-files/&quot; atguigu account <span class="comment">--fields-terminatedby=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>语句mysqldump语句执行成功之后，指定目录下会出现两个文件account.sql和account.txt。</p><p>打开account.sql文件，其内容包含创建account表的CREATE语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> mysql<span class="operator">-</span>files]# cat account.sql</span><br><span class="line"><span class="comment">-- MySQL dump 10.13 Distrib 8.0.26, for Linux (x86_64)</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Host: localhost Database: atguigu</span></span><br><span class="line"><span class="comment">-- ------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Server version 8.0.26</span></span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET NAMES utf8mb4 */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;&#x27; */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `account`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `account`;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!50503 SET character_set_client = utf8mb4 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account` (</span><br><span class="line">`id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`balance` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"><span class="comment">/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */</span>;</span><br><span class="line"><span class="comment">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */</span>;</span><br><span class="line"><span class="comment">-- Dump completed on 2022-01-07 23:36:39</span></span><br></pre></td></tr></table></figure><p>打开account.txt文件，其内容包含创建account表的数据。从文件中可以看出，字段之间用逗号隔开，字 符类型的值被双引号括起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> mysql<span class="operator">-</span>files]# cat account.txt</span><br><span class="line"><span class="number">1</span>,&quot;张三&quot;,<span class="number">90</span></span><br><span class="line"><span class="number">2</span>,&quot;李四&quot;,<span class="number">100</span></span><br><span class="line"><span class="number">3</span>,&quot;王五&quot;,<span class="number">0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e07d7d47-d1c0-4a68-b584-44dd00f1d25b-3"><p>**举例1：**使用mysql语句导出atguigu数据中account表中的记录到文本文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="comment">--execute=&quot;SELECT * FROM account;&quot; atguigu&gt; &quot;/var/lib/mysql-files/account.txt&quot;</span></span><br></pre></td></tr></table></figure><p>打开account.txt文件，其内容包含创建account表的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> mysql<span class="operator">-</span>files]# cat account.txt</span><br><span class="line">id name balance</span><br><span class="line"><span class="number">1</span> 张三 <span class="number">90</span></span><br><span class="line"><span class="number">2</span> 李四 <span class="number">100</span></span><br><span class="line"><span class="number">3</span> 王五 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>**举例2：**将atguigu数据库account表中的记录导出到文本文件，使用–veritcal参数将该条件记录分为多行显示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="comment">--vertical --execute=&quot;SELECT * FROM account;&quot; atguigu &gt; &quot;/var/lib/mysql-files/account_1.txt&quot;</span></span><br></pre></td></tr></table></figure><p>打开account_1.txt文件，其内容包含创建account表的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> mysql<span class="operator">-</span>files]# cat account_1.txt</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">id: <span class="number">1</span></span><br><span class="line">name: 张三</span><br><span class="line">balance: <span class="number">90</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">id: <span class="number">2</span></span><br><span class="line">name: 李四</span><br><span class="line">balance: <span class="number">100</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">id: <span class="number">3</span></span><br><span class="line">name: 王五</span><br><span class="line">balance: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>**举例3：**将atguigu数据库account表中的记录导出到xml文件，使用–xml参数，具体语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p <span class="comment">--xml --execute=&quot;SELECT * FROM account;&quot; atguigu&gt;&quot;/var/lib/mysqlfiles/account_3.xml&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@node1</span> mysql<span class="operator">-</span>files]# cat account_3.xml</span><br><span class="line"><span class="operator">&lt;</span>?xml version<span class="operator">=</span>&quot;1.0&quot;?<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>resultset statement<span class="operator">=</span>&quot;SELECT * FROM account&quot;</span><br><span class="line">xmlns:xsi<span class="operator">=</span>&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="type">row</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">=</span>&quot;id&quot;<span class="operator">&gt;</span><span class="number">1</span><span class="operator">&lt;</span><span class="operator">/</span>field<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">=</span>&quot;name&quot;<span class="operator">&gt;</span>张三<span class="operator">&lt;</span><span class="operator">/</span>field<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">=</span>&quot;balance&quot;<span class="operator">&gt;</span><span class="number">90</span><span class="operator">&lt;</span><span class="operator">/</span>field<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="type">row</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="type">row</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">=</span>&quot;id&quot;<span class="operator">&gt;</span><span class="number">2</span><span class="operator">&lt;</span><span class="operator">/</span>field<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">=</span>&quot;name&quot;<span class="operator">&gt;</span>李四<span class="operator">&lt;</span><span class="operator">/</span>field<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">=</span>&quot;balance&quot;<span class="operator">&gt;</span><span class="number">100</span><span class="operator">&lt;</span><span class="operator">/</span>field<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="type">row</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="type">row</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">=</span>&quot;id&quot;<span class="operator">&gt;</span><span class="number">3</span><span class="operator">&lt;</span><span class="operator">/</span>field<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">=</span>&quot;name&quot;<span class="operator">&gt;</span>王五<span class="operator">&lt;</span><span class="operator">/</span>field<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>field name<span class="operator">=</span>&quot;balance&quot;<span class="operator">&gt;</span><span class="number">0</span><span class="operator">&lt;</span><span class="operator">/</span>field<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="type">row</span><span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>resultset<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>说明：如果要将表数据导出到html文件中，可以使用 <code>--html</code> 选项。然后可以使用浏览器打开。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="6-2-表的导入">6.2 表的导入</h3><div class="tabs" id="2ca277d6-de61-4154-9f69-1b38e2f5ecd3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2ca277d6-de61-4154-9f69-1b38e2f5ecd3-1"><i class="fas fa-seedling"></i>LOAD DATA INFILE方式导入文本文件</button></li><li class="tab"><button type="button" data-href="#2ca277d6-de61-4154-9f69-1b38e2f5ecd3-2"><i class="fas fa-leaf"></i>mysqlimport方式导入文本文件</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2ca277d6-de61-4154-9f69-1b38e2f5ecd3-1"><p><strong>举例1：</strong></p><p>使用SELECT…INTO OUTFILE将atguigu数据库中account表的记录导出到文本文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigu.account <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/lib/mysql-files/account_0.txt&#x27;</span>;</span><br></pre></td></tr></table></figure><p>删除account表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> atguigu.account;</span><br></pre></td></tr></table></figure><p>从文本文件account.txt中恢复数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;/var/lib/mysql-files/account_0.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> atguigu.account;</span><br></pre></td></tr></table></figure><p>查询account表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> balance <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> 张三     <span class="operator">|</span> <span class="number">90</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> 李四     <span class="operator">|</span> <span class="number">100</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> 王五     <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>举例2：</strong> 选择数据库atguigu，使用SELECT…INTO OUTFILE将atguigu数据库account表中的记录导出到文本文件，使用FIELDS选项和LINES选项，要求字段之间使用逗号&quot;，&quot;间隔，所有字段值用双引号括起来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigu.account <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/lib/mysql-files/account_1.txt&#x27;</span> FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;\&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>删除account表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> atguigu.account;</span><br></pre></td></tr></table></figure><p>从/var/lib/mysql-files/account.txt中导入数据到account表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;/var/lib/mysql-files/account_1.txt&#x27;</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> atguigu.account FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;\&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查询account表中的数据，具体SQL如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> balance <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> 张三     <span class="operator">|</span> <span class="number">90</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> 李四     <span class="operator">|</span> <span class="number">100</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> 王五     <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ca277d6-de61-4154-9f69-1b38e2f5ecd3-2"><p><strong>举例：</strong></p><p>导出文件account.txt，字段之间使用逗号&quot;，&quot;间隔，字段值用双引号括起来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> atguigu.account <span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/lib/mysql-files/account.txt&#x27;</span> FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span> ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;\&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>删除account表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> atguigu.account;</span><br></pre></td></tr></table></figure><p>使用mysqlimport命令将account.txt文件内容导入到数据库atguigu的account表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport <span class="operator">-</span>uroot <span class="operator">-</span>p atguigu <span class="string">&#x27;/var/lib/mysql-files/account.txt&#x27;</span> <span class="comment">--fields-terminated-by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span></span><br></pre></td></tr></table></figure><p>查询account表中的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> balance <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> 张三     <span class="operator">|</span> <span class="number">90</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> 李四     <span class="operator">|</span> <span class="number">100</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span> 王五     <span class="operator">|</span> <span class="number">0</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="7-数据库迁移">7. 数据库迁移</h2><h3 id="7-1-概述">7.1 概述</h3><p>数据迁移（data migration）是指选择、准备、提取和转换数据，并<strong>将数据从一个计算机存储系统永久地传输到另一个计算机存储系统的过程</strong>。此外，<code> 验证迁移数据的完整性</code> 和 <code>退役原来旧的数据存储</code> ，也被认为是整个数据迁移过程的一部分。</p><p>数据库迁移的原因是多样的，包括服务器或存储设备更换、维护或升级，应用程序迁移，网站集成，灾难恢复和数据中心迁移。</p><p>根据不同的需求可能要采取不同的迁移方案，但总体来讲，MySQL 数据迁移方案大致可以分为<code>物理迁移</code>和 <code>逻辑迁移</code> 两类。通常以尽可能 <code>自动化</code> 的方式执行，从而将人力资源从繁琐的任务中解放出来。</p><h3 id="7-2-迁移方案">7.2 迁移方案</h3><ul><li>物理迁移</li></ul><p>物理迁移适用于大数据量下的整体迁移。使用物理迁移方案的优点是比较快速，但需要停机迁移并且要 求 MySQL 版本及配置必须和原服务器相同，也可能引起未知问题。</p><p>物理迁移包括拷贝数据文件和使用 XtraBackup 备份工具两种。</p><p>不同服务器之间可以采用物理迁移，我们可以在新的服务器上安装好同版本的数据库软件，创建好相同目录，建议配置文件也要和原数据库相同，然后从原数据库方拷贝来数据文件及日志文件，配置好文件组权限，之后在新服务器这边使用 mysqld 命令启动数据库。</p><ul><li>逻辑迁移</li></ul><p>逻辑迁移适用范围更广，无论是 <code>部分迁移</code> 还是 <code>全量迁移</code> ，都可以使用逻辑迁移。逻辑迁移中使用最多的就是通过 mysqldump 等备份工具。</p><h3 id="7-3-迁移注意点">7.3 迁移注意点</h3><p><strong>1. 相同版本的数据库之间迁移注意点</strong></p><p>指的是在主版本号相同的MySQL数据库之间进行数据库移动。</p><p><code>方式1</code>： 因为迁移前后MySQL数据库的 <code>主版本号相同</code> ，所以可以通过复制数据库目录来实现数据库迁移，但是物理迁移方式只适用于MyISAM引擎的表。对于InnoDB表，不能用直接复制文件的方式备份数据库。</p><p><code>方式2</code>： 最常见和最安全的方式是使用 <code>mysqldump命令</code> 导出数据，然后在目标数据库服务器中使用 MySQL命令导入。</p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#host1的机器中备份所有数据库,并将数据库迁移到名为host2的机器上</span><br><span class="line">mysqldump –h host1 –uroot –p –<span class="operator">-</span><span class="keyword">all</span><span class="operator">-</span>databases<span class="operator">|</span></span><br><span class="line">mysql –h host2 –uroot –p</span><br></pre></td></tr></table></figure><p>在上述语句中，“|”符号表示管道，其作用是将mysqldump备份的文件给mysql命令；“–all-databases”表示要迁移所有的数据库。通过这种方式可以直接实现迁移。</p><p><strong>2. 不同版本的数据库之间迁移注意点</strong></p><p>例如，原来很多服务器使用5.7版本的MySQL数据库，在8.0版本推出来以后，改进了5.7版本的很多缺陷， 因此需要把数据库升级到8.0版本</p><p>旧版本与新版本的MySQL可能使用不同的默认字符集，例如有的旧版本中使用latin1作为默认字符集，而最新版本的MySQL默认字符集为utf8mb4。如果数据库中有中文数据，那么迁移过程中需要对 <code>默认字符集</code> 进行修改 ，不然可能无法正常显示数据。</p><p>高版本的MySQL数据库通常都会 <code>兼容低版本</code> ，因此可以从低版本的MySQL数据库迁移到高版本的MySQL 数据库。</p><p><strong>3. 不同数据库之间迁移注意点</strong></p><p>不同数据库之间迁移是指从其他类型的数据库迁移到MySQL数据库，或者从MySQL数据库迁移到其他类 型的数据库。这种迁移没有普适的解决方法。</p><p>迁移之前，需要了解不同数据库的架构， <code>比较它们之间的差异</code> 。不同数据库中定义相同类型的数据的 <code>关键字可能会不同</code> 。例如，MySQL中日期字段分为DATE和TIME两种，而ORACLE日期字段只有DATE；SQL Server数据库中有ntext、Image等数据类型，MySQL数据库没有这些数据类型；MySQL支持的ENUM和SET 类型，这些SQL Server数据库不支持。</p><p>另外，数据库厂商并没有完全按照SQL标准来设计数据库系统，导致不同的数据库系统的 <code>SQL语句</code> 有差别。例如，微软的SQL Server软件使用的是T-SQL语句，T-SQL中包含了非标准的SQL语句，不能和MySQL的SQL语句兼容。</p><p>不同类型数据库之间的差异造成了互相 <code>迁移的困难</code> ，这些差异其实是商业公司故意造成的技术壁垒。但 是不同类型的数据库之间的迁移并 <code>不是完全不可能</code> 。例如，可以使用<code> MyODBC</code> 实现MySQL和SQL Server之 间的迁移。MySQL官方提供的工具 <code>MySQL Migration Toolkit</code> 也可以在不同数据之间进行数据迁移。 MySQL迁移到Oracle时，需要使用mysqldump命令导出sql文件，然后， <code>手动更改</code> sql文件中的CREATE语句。</p><h3 id="7-4-迁移小结">7.4 迁移小结</h3><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718165515965.png" alt="image-20220718165515965" style="zoom:67%;" /><hr><h2 id="8-删库了不敢跑，能干点啥？">8. 删库了不敢跑，能干点啥？</h2><p>传统的高可用架构是不能预防误删数据的，因为主库的一个<code>drop table</code>命令，会通过binlog传给所有从库和级联从库，进而导致整个集群的实例都会执行这个命令。</p><p>为了找到解决误删数据的更高效的方法，我们需要先对和MySQL相关的误删数据，做下分类：</p><ol><li>使用delete语句误删数据行;</li><li>使用drop table或者truncate table语句误删数据表；</li><li>使用drop database语句误删数据库；</li><li>使用rm命令误删整个MySQL实例。</li></ol><h3 id="8-1-delete：误删行">8.1 delete：误删行</h3><mark class="hl-label green">处理措施1：数据恢复</mark> <p>使用<code>Flashback</code>工具恢复数据。</p><p>原理：修改binlog 内容，拿回原库重放。如果误删数据涉及到了多个事务的话，需要将事务的顺字调过来再执行。</p><p>使用前提：binlog_format=row 和 binlog_row_image=FULL。</p><mark class="hl-label green">处理措施2：预防</mark> <ul><li><p>代码上线前，必须SQL审查、审计。</p></li><li><p>建议可以打开安全模式，把<code>sql_safe_updates</code>参数设置为 on。强制要求加 where 条件且where后需要是索引字段，否则必须使用limit。否则就会报错。</p></li></ul><h3 id="8-2-truncate-drop-：误删库-表">8.2 truncate/drop ：误删库/表</h3><p>背景：</p><p>delete全表是很慢的，需要生成回滚日志、写redo、写binlog。所以，从性能角度考虑，优先考虑使用truncate table或者drop table命令。</p><p>使用delete命令删除的数据，你还可以用Flashback来恢复。而使用truncate /drop table和drop database命令删除的数据，就没办法通过Flashback来恢复了。因为，即使我们配置了 binlog_format=row，执行这三个命令时，记录的 binlog还是statement格式。binlog里面就只有一个truncate/drop 语句，这些信息是恢复不出数据的。</p><p>方案：</p><p>这种情况下恢复数据，需要使用<code>全量备份</code>与<code>增量日志</code>结合的方式。</p><p>方案的前提：有定期的全量备份，并且实时备份binlog。</p><p>举例：有人误删了一个库，时间为下午3点。步骤如下：</p><ol><li><p>取最近一次<code>全量备份</code>。假设设置数据库库是一天一备，最近备份数据是当天凌晨2点；</p></li><li><p>用备份恢复出一个临时库；（注意：这里选择临时库，而不是直接操作主库)</p></li><li><p>取出凌晨2点之后的binlog日志；</p></li><li><p>剔除误删除数据的语句外，其它语句全部应用到临时库。（前面讲过binlog的恢复）</p></li><li><p>最后恢复到主库</p></li></ol><h3 id="8-3-预防使用truncate-drop误删库-表">8.3 预防使用truncate/drop误删库/表</h3><p>上面我们说了使用truncate /drop语句误删库/表的恢复方案，在生产环境中可以通过下面建议的方案来尽量的避免类似的误操作。</p><p>（1) 权限分离</p><ul><li><p>限制帐户权限，核心的数据库，一般都不能随便分配写权限，想要获取写权限需要审批。比如只给业务开发人员DML权限，不给truncate/drop权限。即使是DBA团队成员，日常也都规定只使用只读账号，必要的时候才使用有更新权限的账号。</p></li><li><p>不同的账号，不同的数据之间要进行权限分离，避免一个账号可以删除所有库。</p></li></ul><p>（2)制定操作规范</p><p>比如在删除数据表之前，必须先对表做改名操作（比如加 _to_be_deleted)。然后，观察一段时间，确保对业务无影响以后再删除这张表。</p><p>(3) 设置延迟复制备库</p><p>简单的说延迟复制就是设置一个固定的延迟时间，比如1个小时，让从库落后主库一个小时。出现误删除操作1小时内，到这个备库上执行stop slave，再通过之前介绍的方法，跳过误操作命令，就可以恢复出需要的数据。</p><p>这里通过 CHANGE MASTER TO MASTER_DELAY=N命令，可以指定这个备库持续保持跟主库有N秒的延迟。比如把N设置为3600，即代表1个小时。</p><p>此外，延迟复制还可以用来解决以下问题：</p><p>① 用来做延迟測试，比如做好的数据库读写分离，把从库作为读库，那么想知道当数据产生延迟的时候到底会发生什么，就可以使用这个特性模拟延迟。</p><p>②用于老数据的查询等需求，比如你经常需要查看某天前一个表或者字段的数值，你可能需要把备份恢复后进行查看，如果有延迟从库，比如延迟一周，那么就可以解决这样类似的需求。</p><h3 id="8-4-rm：误删MySQL实例">8.4 rm：误删MySQL实例</h3><p>对于一个有高可用机制的MySQL集群来说，不用担心rm删除数据了。只是删掉了其中某一个节点的数据的话，HA系统就会开始工作，选出一个新的主库，从而保证整个集群的正常工作。我们要做的就是在这个节点上把数据恢复回来，再接入整个集群。</p><p>但如果是恶意地把整个集群删除，那就需要考虑跨机房备份，跨城市备份。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主从复制</title>
      <link href="/posts/351b5179.html"/>
      <url>/posts/351b5179.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-主从复制概述">1. 主从复制概述</h2><h3 id="1-1-如何提升数据库并发能力">1.1 如何提升数据库并发能力</h3><p>在实际工作中，我们常常将<code>Redis</code>作为缓存与<code>MySQL</code>配合来使用，当有请求的时候，首先会从缓存中进行查找，如果存在就直接取出。如果不存在再访问数据库，这样就<code>提升了读取的效率</code>，也减少了对后端数据库的<code>访问压力</code>。Redis的缓存架构是<code>高并发架构</code>中非常重要的一环。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715202237535.png" alt="image-20220715202237535" style="zoom: 67%;" /><p>此外，一般应用对数据库而言都是“<code>读多写少</code>”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做<code>主从架构</code>、进行<code>读写分离</code>，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。</p><p>如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何<code>优化SQL和索引</code>，这种方式 简单有效；其次才是采用<code>缓存的策略</code>，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效率；最后才是对数据库采用<code>主从架构</code>，进行读写分离。</p><p>按照上面的方式进行优化，使用和维护的成本是由低到高的。</p><h3 id="1-2-主从复制的作用">1.2 主从复制的作用</h3><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。</p><span class='p green'>第1个作用：读写分离。</span>我们可以通过主从复制的方式来`同步数据`，然后通过读写分离提高数据库并发处理能力。<img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715212521601.png" alt="image-20220715212521601" style="zoom:50%;" /><p>其中一个是Master主库，负责写入数据，我们称之为：写库。</p><p>其他都是Slave从库，负责读取数据，我们称之为：读库。</p><p>当主库进行更新的时候，会自动将数据复制到从库中，而我们在客户端读取数据的时候，会从从库进行读取。</p><p>面对“读多写少”的需求，采用读写分离的方式，可以实现<code>更高的并发访问</code>。同时，我们还能对从服务器进行<code>负载均衡</code>，让不同的读请求按照策略均匀地分发到不同的从服务器上，让<code>读取更加顺畅</code>。读取顺畅的另一个原因，就是<code>减少了锁表</code>的影响，比如我们让主库负责写，当主库出现写锁的时候，不会影响到从库进行SELECT的读取。</p><span class='p green'>第2个作用就是数据备份。</span>我们通过主从复制将主库上的数据复制到从库上，相当于一种`热备份机制`，也就是在主库正常运行的情况下进行的备份，不会影响到服务。<br/><span class='p green'>第3个作用是具有高可用性。</span>数据备份实际上是一种冗余的机制，通过这种冗余的方式可以换取数据库的高可用性，也就是当服务器出现故障或宕机的情况下，可以切换到从服务器上，保证服务的正常运行。<p>关于高可用性的程度，我们可以用一个指标衡量，即正常可用时间/全年时间。比如要达到全年99.999%的时间都可用，就意味着系统在一年中的不可用时间不得超过 3652460(1-99.999%）=5.256 分钟（含系统崩溃的时间、日常维护操作导致的停机时间等），其他时间都需要保持可用的状态。</p><p>实际上，更高的高可用性，意味着需要付出更高的成本代价。在现实中我们需要结合业务需求和成本来进行选择。</p><hr><h2 id="2-主从复制的原理">2. 主从复制的原理</h2><p><code>Slave</code>会从<code>Master</code>读取<code>binlog</code>来进行数据同步。</p><h3 id="2-1-原理剖析">2.1 原理剖析</h3><mark class="hl-label blue">三个线程</mark> <p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于<code>3个线程</code>来操作，一个主库线程，两个从库线程。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715215944767.png" alt="image-20220715215944767" style="zoom:67%;" /><p><code>二进制日志转储线程</code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进 制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上<code>加锁</code>，读取完成之后，再将锁释放掉。</p><p><code>从库I/O线程</code>会连接到主库，向主库发送请求更新 Binlog。这时从库的 I/O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</p><p><code>从库SQL线程</code>会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715220037213.png" alt="image-20220715220037213" style="zoom:67%;" /><blockquote><p>注意：</p><p>不是所有版本的MySQL都默认开启服务器的二进制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志。</p><p>除非特殊指定，默认情况下从服务器会执行所有主服务器中保存的事件。也可以通过配置，使从服务器执行特定的事件。</p></blockquote><mark class="hl-label green">复制三步骤</mark> <p>步骤1：<code>Master</code>将写操作记录到二进制日志（<code>binlog</code>）。</p><p>步骤2：<code>Slave</code>将<code>Master</code>的binary log events拷贝到它的中继日志（<code>relay log</code>）；</p><p>步骤3：<code>Slave</code>重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从<code>接入点</code>开始复制。</p><mark class="hl-label red">复制的问题</mark> <p>复制的最大问题：<code>延时</code></p><hr><h3 id="2-2-复制的基本原则">2.2 复制的基本原则</h3><ul><li>每个<code>Slave</code>只有一个<code>Master</code></li><li>每个<code>Slave</code>只能有一个唯一的服务器ID</li><li>每个<code>Master</code>可以有多个<code>Slave</code></li></ul><h2 id="3-一主一从架构搭建">3. 一主一从架构搭建</h2><p>一台<code>主机</code>用于处理所有<code>写请求</code>，一台<code>从机</code>负责所有<code>读请求</code>，架构图如下:</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715220852836.png" alt="image-20220715220852836" style="zoom:67%;" /><h3 id="3-1-准备工作">3.1 准备工作</h3><p>1、准备 2台 CentOS 虚拟机</p><p>2、每台虚拟机上需要安装好MySQL (可以是MySQL8.0 )</p><p>说明：前面我们讲过如何克隆一台CentOS。大家可以在一台CentOS上安装好MySQL，进而通过克隆的方式复制出1台包含MySQL的虚拟机。</p><p>注意：克隆的方式需要修改新克隆出来主机的：①<code>MAC地址</code>②<code>hostname</code>③<code>IP 地址</code>④<code>UUID</code>。</p><p>此外，克隆的方式生成的虚拟机（包含MySQL Server），则克隆的虚拟机MySQL Server的UUID相同，必须修改，否则在有些场景会报错。比如：<code>show slave status\G</code>，报如下的错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last_IO_Error: Fatal error: The slave I<span class="operator">/</span>O thread stops because master <span class="keyword">and</span> slave have</span><br><span class="line">equal MySQL server UUIDs; these UUIDs must be different <span class="keyword">for</span> replication <span class="keyword">to</span> work.</span><br></pre></td></tr></table></figure><p>修改MySQL Server 的UUID方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>auto.cnf</span><br><span class="line"></span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><h3 id="3-2-主机配置文件">3.2 主机配置文件</h3><p>建议mysql版本一致且后台以服务运行，主从所有配置项都配置在<code>[mysqld]</code>节点下，且都是小写字母。</p><p>具体参数配置如下：</p><ul><li>必选</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[必须]主服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[必须]启用二进制日志,指名路径。比如：自己本地的路径/log/mysqlbin</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">atguigu-bin</span></span><br></pre></td></tr></table></figure><ul><li>可选</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[可选] 0（默认）表示读写（主机），1表示只读（从机）</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置日志文件保留的时长，单位是秒</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="string">6000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#控制单个二进制日志大小。此参数的最大和默认值是1GB</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="string">200M</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置不要复制的数据库</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=<span class="string">test</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置需要复制的数据库,默认全部记录。比如：binlog-do-db=atguigu_master_slave</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">需要复制的主数据库名字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#[可选]设置binlog格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br></pre></td></tr></table></figure><p>重启后台mysql服务，使配置生效。</p><blockquote><p>注意：</p><p>先搭建完主从复制，再创建数据库。</p><p>MySQL主从复制起始时，从机不继承主机数据。</p></blockquote><p><strong>① binlog格式设置：</strong></p><p>格式1：<code>STATEMENT模式</code>（基于SQL语句的复制(statement-based replication, SBR)）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=<span class="string">STATEMENT</span></span><br></pre></td></tr></table></figure><p>每一条会修改数据的sql语句会记录到binlog中。这是默认的binlog格式。</p><ul><li>SBR 的优点：<ul><li>历史悠久，技术成熟</li><li>不需要记录每一行的变化，减少了binlog日志量，文件较小</li><li>binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况</li><li>binlog可以用于实时的还原，而不仅仅用于复制</li><li>主从版本可以不一样，从服务器版本可以比主服务器版本高</li></ul></li><li>SBR 的缺点：<ul><li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候</li></ul></li><li>使用以下函数的语句也无法被复制：LOAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)<ul><li>INSERT … SELECT 会产生比 RBR 更多的行级锁</li><li>复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁</li><li>对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句</li><li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发 生变化的记录产生影响</li><li>执行复杂语句如果出错的话，会消耗更多资源</li><li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错</li></ul></li></ul><p><strong>② ROW模式（基于行的复制(row-based replication, RBR)）</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=<span class="string">ROW</span></span><br></pre></td></tr></table></figure><p>5.1.5版本的MySQL才开始支持，不记录每条sql语句的上下文信息，仅记录哪条数据被修改了，修改成什么样了。</p><ul><li>RBR 的优点：<ul><li>任何情况都可以被复制，这对复制来说是最<code>安全可靠</code>的。（比如：不会出现某些特定情况下 的存储过程、function、trigger的调用和触发无法被正确复制的问题）</li><li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多</li><li>复制以下几种语句时的行锁更少：INSERT … SELECT、包含 AUTO_INCREMENT 字段的 INSERT、 没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li><li>执行 INSERT，UPDATE，DELETE 语句时锁更少</li><li>从服务器上采用 多线程 来执行复制成为可能</li></ul></li><li>RBR 的缺点：<ul><li>binlog 大了很多</li><li>复杂的回滚时 binlog 中会包含大量的数据</li><li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</li><li>无法从 binlog 中看到都复制了些什么语句</li></ul></li></ul><p><strong>③ MIXED模式（混合模式复制(mixed-based replication, MBR)）</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=<span class="string">MIXED</span></span><br></pre></td></tr></table></figure><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p><p>在Mixed模式下，一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。</p><p>MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</p><h3 id="3-3-从机配置文件">3.3 从机配置文件</h3><p>要求主从所有配置项都配置在<code>my.cnf</code>的<code>[mysqld]</code>栏位下，且都是小写字母。</p><ul><li>必选</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[必须]从服务器唯一ID</span><br><span class="line">server<span class="operator">-</span>id<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>可选</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#[可选]启用中继日志</span><br><span class="line">relay<span class="operator">-</span>log<span class="operator">=</span>mysql<span class="operator">-</span>relay</span><br></pre></td></tr></table></figure><p>重启后台mysql服务，使配置生效。</p><blockquote><p>注意：主从机都关闭防火墙<br>service iptables stop #CentOS 6<br>systemctl stop firewalld.service #CentOS 7</p></blockquote><h3 id="3-4-主机：建立账户并授权">3.4 主机：建立账户并授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在主机MySQL里执行授权主从复制的命令</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;从机器数据库IP&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;abc123&#x27;</span>; #<span class="number">5.5</span>,<span class="number">5.7</span></span><br></pre></td></tr></table></figure><span class='p red'>注意：如果使用的是MySQL8，需要如下的方式建立账户，并授权slave:</span><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#此语句必须执行。否则见下面。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;slave1&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在从机执行show slave status\G时报错：</p><p>Last_IO_Error: error connecting to master ‘slave1@192.168.1.150:3306’ - retry-time: 60 retries: 1 message:</p><p>Authentication plugin ‘caching_sha2_password’ reported error: Authentication requires secure connection.</p></blockquote><p>查询Master的状态，并记录下File和Position的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718140722740.png" alt="image-20220718140722740"></p><ul><li>记录下File和Position的值</li></ul><blockquote><p>注意：执行完此步骤后<span class='p red'>不要再操作主服务器MySQL</span>，防止主服务器状态值变化。</p></blockquote><h3 id="3-5-从机：配置需要复制的主机">3.5 从机：配置需要复制的主机</h3><p>步骤1：从机上复制主机的命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">MASTER_HOST<span class="operator">=</span><span class="string">&#x27;主机的IP地址&#x27;</span>,</span><br><span class="line">MASTER_USER<span class="operator">=</span><span class="string">&#x27;主机用户名&#x27;</span>,</span><br><span class="line">MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;主机用户名的密码&#x27;</span>,</span><br><span class="line">MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;mysql-bin.具体数字&#x27;</span>,</span><br><span class="line">MASTER_LOG_POS<span class="operator">=</span>具体值;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.1.150&#x27;</span>,MASTER_USER<span class="operator">=</span><span class="string">&#x27;slave1&#x27;</span>,MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,MASTER_LOG_F</span><br><span class="line">ILE<span class="operator">=</span><span class="string">&#x27;atguigu-bin.000007&#x27;</span>,MASTER_LOG_POS<span class="operator">=</span><span class="number">154</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718140946747.png" alt="image-20220718140946747"></p><p><strong>步骤2：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#启动slave同步</span><br><span class="line"><span class="keyword">START</span> SLAVE;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718141825228.png" alt="image-20220718141825228"></p><p>如果报错：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718141841862.png" alt="image-20220718141841862"></p><p>可以执行如下操作，删除之前的relay_log信息。然后重新执行 CHANGE MASTER TO …语句即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> reset slave; #删除SLAVE数据库的relaylog日志文件，并重新启用新的relaylog文件</span><br></pre></td></tr></table></figure><p>接着，查看同步状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> SLAVE STATUS\G;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718141951374.png" alt="image-20220718141951374"></p><blockquote><p>上面两个参数都是Yes，则说明主从配置成功！</p></blockquote><p>显式如下的情况，就是不正确的。可能错误的原因有：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 网络不通</span><br><span class="line"><span class="bullet">2.</span> 账户密码错误</span><br><span class="line"><span class="bullet">3.</span> 防火墙</span><br><span class="line"><span class="bullet">4.</span> mysql配置文件问题</span><br><span class="line"><span class="bullet">5.</span> 连接服务器时语法</span><br><span class="line"><span class="bullet">6.</span> 主服务器mysql权限</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718142045114.png" alt="image-20220718142045114" style="zoom:80%;" /><h3 id="3-6-测试">3.6 测试</h3><p>主机新建库、新建表、insert记录，从机复制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE atguigu_master_slave;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytbl(id <span class="type">INT</span>,NAME <span class="type">VARCHAR</span>(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytbl <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;zhang3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytbl <span class="keyword">VALUES</span>(<span class="number">2</span>,@<span class="variable">@hostname</span>);</span><br></pre></td></tr></table></figure><h3 id="3-7-停止主从同步">3.7 停止主从同步</h3><ul><li>停止主从同步命令：</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure><ul><li><p>如何重新配置主从</p><p>如果停止从服务器复制功能，再使用需要重新配置主从。否则会报错如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718142549168.png" alt="image-20220718142549168"></p></li></ul><p>重新配置主从，需要在从机上执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line"></span><br><span class="line">reset master; #删除Master中所有的binglog文件，并将日志索引文件清空，重新开始所有新的日志文件(慎用)</span><br></pre></td></tr></table></figure><h3 id="3-8-搭建主从复制：双主双从">3.8 搭建主从复制：双主双从</h3><p>一个主机m1用于处理所有写请求，它的从机s1和另一台主机m2还有它的从机s2负责所有读请求。当m1主机宕机后，m2主机负责写请求，m1、m2互为备机。结构图如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718143705843.png" alt="image-20220718143705843" style="zoom:67%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718143716620.png" alt="image-20220718143716620" style="zoom:67%;" /><hr><h2 id="4-同步数据一致性问题">4. 同步数据一致性问题</h2><p><strong>主从同步的要求：</strong></p><ul><li>读库和写库的数据一致(最终一致)；</li><li>写数据必须写到写库；</li><li>读数据必须到读库(不一定)；</li></ul><h3 id="4-1-理解主从延迟问题">4.1 理解主从延迟问题</h3><p>进行主从同步的内容是二进制日志，它是一个文件，在进行<code>网络传输</code>的过程中就一定会<code>存在主从延迟</code>（比如 500ms），这样就可能造成用户在从库上读取的数据不是最新的数据，也就是主从同步中的<code>数据不一致性</code>问题。</p><p>举例：导致主从延迟的时间点主要包括以下三个：</p><ol><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1；</li><li>之后传给从库B，我们把从库B接收完这个binlog的时刻记为T2;</li><li>从库B执行完成这个事务，我们把这个时刻记为T3。</li></ol><hr><h3 id="4-2-主从延迟问题原因">4.2 主从延迟问题原因</h3><p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。</p><span class='p red'>主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。</span>造成原因：<p>1、从库的机器性能比主库要差</p><p>2、从库的压力大</p><p>3、大事务的执行</p><p>举例1：一次性用delete语句删除太多数据</p><p>结论：后续再删除数据的时候，要控制每个事务删除的数据量，分成多次删除。</p><p>举例2：一次性用insert…select插入太多数据</p><p>举例3：大表DDL</p><p>比如在主库对一张500W的表添加一个字段耗费了10分钟，那么从节点上也会耗费10分钟。</p><hr><h3 id="4-3-如何减少主从延迟">4.3 如何减少主从延迟</h3><p>若想要减少主从延迟的时间，可以采取下面的办法：</p><ol><li>降低多线程大事务并发的概率，优化业务逻辑</li><li>优化SQL，避免慢SQL，<code>减少批量操作</code>，建议写脚本以update-sleep这样的形式完成。<br>3.<code>提高从库机器的配置</code>，减少主库写binlog和从库读binlog的效率差。</li><li>尽量采用<code>短的链路</code>，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</li><li>实时性要求的业务读强制走主库，从库只做灾备，备份。</li></ol><hr><h3 id="4-4-如何解决一致性问题">4.4 如何解决一致性问题</h3><p>如果操作的数据存储在同一个数据库中，那么对数据进行更新的时候，可以对记录加写锁，这样在读取的时候就不会发生数据不一致的情况。但这时从库的作用就是<code>备份</code>，并没有起到<code>读写分离</code>，分担主库<code>读压力</code>的作用。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718144341584.png" alt="image-20220718144341584" style="zoom: 67%;" /><p>读写分离情况下，解决主从同步中数据不一致的问题， 就是解决主从之间<code>数据复制方式</code>的问题，如果按照数据一致性<code>从弱到强</code>来进行划分，有以下 3 种复制方式。</p><hr><div class="tabs" id="2ca9db54-a14a-42f7-8fa9-449c9b638852"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2ca9db54-a14a-42f7-8fa9-449c9b638852-1"><i class="fas fa-cat"></i>方法 1：异步复制</button></li><li class="tab"><button type="button" data-href="#2ca9db54-a14a-42f7-8fa9-449c9b638852-2"><i class="fas fa-horse"></i>方法 2：半同步复制</button></li><li class="tab"><button type="button" data-href="#2ca9db54-a14a-42f7-8fa9-449c9b638852-3"><i class="fas fa-dove"></i>方法 3：组复制</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2ca9db54-a14a-42f7-8fa9-449c9b638852-1"><p>异步模式就是客户端提交 COMMIT 之后不需要等从库返回任何结果，而是直接将结果返回给客户端，这样做的好处是不会影响主库写的效率，但可能会存在主库宕机，而Binlog还没有同步到从库的情况，也就是此时的主库和从库数据不一致。这时候从从库中选择一个作为新主，那么新主则可能缺少原来主服务器中已提交的事务。所以，这种复制模式下的数据一致性是最弱的。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718144410731.png" alt="image-20220718144410731" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ca9db54-a14a-42f7-8fa9-449c9b638852-2"><p>MysQL5.5版本之后开始支持半同步复制的方式。原理是在客户端提交 COMMIT 之后不直接将结果返回给客户端， 而是等待至少有一个从库接收到了 Binlog，并且写入到中继日志中，再返回给客户端。</p><p>这样做的好处就是提高了数据的一致性，当然相比于异步复制来说，至少多增加了一个网络连接的延迟，降低了主库写的效率。</p><p>在MysQL5.7版本中还增加了一个<code>rpl_semi_sync_master_wait_for_slave_count</code>参数，可以对应答的从库数量进行设置，默认为1，也就是说只要有1个从库进行了响应，就可以返回给客户端。如果将这个参数调大， 可以提升数据一致性的强度，但也会增加主库等待从库响应的时间。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718144958357.png" alt="image-20220718144958357" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ca9db54-a14a-42f7-8fa9-449c9b638852-3"><p>异步复制和半同步复制都无法最终保证数据的一致性问题，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。</p><p>组复制技术，简称 MGR（MySQL Group Replication）。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 Paxos 协议的状态机复制。</p><p><mark class="hl-label green">MGR是如何工作的</mark></p><p>首先我们将多个节点共同组成一个复制组，在<code>执行读写（RW）事务</code>的时候，需要通过一致性协议层 （Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节 点）的同意，大多数指的是同意的节点数量需要大于 （N/2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<code>只读（RO）事务</code>则不需要经过组内同意，直接 COMMIT 即可。</p><p>在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消 息和全局有序消息，从而保证组内数据的一致性。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718145235499.png" alt="image-20220718145235499" style="zoom:67%;" /><p>MGR 将 MySQL 带入了数据强一致性的时代，是一个划时代的创新，其中一个重要的原因就是MGR 是基 于 Paxos 协议的。Paxos 算法是由 2013 年的图灵奖获得者 Leslie Lamport 于 1990 年提出的，有关这个算法的决策机制可以搜一下。事实上，Paxos 算法提出来之后就作为<code>分布式一致性算法</code>被广泛应用，比如 Apache 的 ZooKeeper 也是基于 Paxos 实现的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="5-知识延伸">5. 知识延伸</h2><p>在主从架构的配置中，如果想要采取读写分离的策略，我们可以<code>自己编写程序</code>，也可以通过<code>第三方的中间件</code>来实现。</p><ul><li>自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要 求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。</li><li>采用中间件的方法有很明显的优势，<code>功能强大</code>，<code>使用简单</code>。但因为在客户端和数据库之间增加了 中间件层会有一些<code>性能损耗</code>，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具。</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718145428456.png" alt="image-20220718145428456" style="zoom:67%;" /><p>①<code>Cobar</code>属于阿里B2B事业群，始于2008年，在阿里服役3年多，接管3000+个MySQL数据库的 schema,集群日处理在线SQL请求50亿次以上。由于Cobar发起人的离职，Cobar停止维护。</p><p>②<code>Mycat</code>是开源社区在阿里cobar基础上进行二次开发，解决了cobar存在的问题，并且加入了许 多新的功能在其中。青出于蓝而胜于蓝。</p><p>③<code>OneProxy</code>基于MySQL官方的proxy思想利用c语言进行开发的，OneProxy是一款商业 收费 的中 间件。舍弃了一些功能，专注在 性能和稳定性上 。</p><p>④<code>kingshard</code>由小团队用go语言开发，还需要发展，需要不断完善。</p><p>⑤<code>Vitess</code>是Youtube生产在使用，架构很复杂。不支持MySQL原生协议，使用 需要大量改造成 本 。</p><p>⑥<code>Atlas</code>是360团队基于mysql proxy改写，功能还需完善，高并发下不稳定。</p><p>⑦<code>MaxScale</code>是mariadb（MySQL原作者维护的一个版本） 研发的中间件</p><p>⑧<code>MySQLRoute</code>是MySQL官方Oracle公司发布的中间件</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718145523643.png" alt="image-20220718145523643" style="zoom:67%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718145534856.png" alt="image-20220718145534856" style="zoom:67%;" /><p>主备切换：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220718145548526.png" alt="image-20220718145548526" style="zoom:67%;" /><ul><li>主动切换</li><li>被动切换</li><li>如何判断主库出问题了？如何解决过程中的数据不一致性问题 ?</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他数据库日志</title>
      <link href="/posts/a42250fc.html"/>
      <url>/posts/a42250fc.html</url>
      
        <content type="html"><![CDATA[<p>我们在讲解数据库事务时，讲过两种日志：重做日志、回滚日志。</p><p>对于线上数据库应用系统，突然遭遇<code>数据库宕机</code>怎么办？在这种情况下，<code>定位宕机的原因</code>就非常关键。我们可以查看数据库的<code>错误日志</code>。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如：</p><p>从日志中发现某个连接中的 SQL 操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。</p><p>除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。</p><p><strong>千万不要小看日志</strong>。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才 能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数 据库应用开发能力至关重要。</p><p>MySQL8.0 官网日志地址： <a href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html">https://dev.mysql.com/doc/refman/8.0/en/server-logs.html</a></p><hr><h2 id="1-MySQL支持的日志">1. MySQL支持的日志</h2><h3 id="1-1-日志类型">1.1 日志类型</h3><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的4种。MySQL 8又新增两种支持的日志： 中继日志 和 数据定义语句日志 。使用这些日志文件，可以查看MySQL内部发生的事情。</p><p>这6类日志分别为：</p><ul><li><strong>慢查询日志</strong>：记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</li><li><strong>通用查询日志</strong>：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令， 对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</li><li><strong>错误日志</strong>：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的 状态，从而对服务器进行维护。</li><li><strong>二进制日志</strong>：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故 障时数据的无损失恢复。</li><li><strong>中继日志</strong>：用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。 从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li><li><strong>数据定义语句日志</strong>：记录数据定义语句执行的元数据操作。</li></ul><p>除二进制日志外，其他日志都是<code>文本文件</code>。默认情况下，所有日志创建于<code>MySQL数据目录</code>中。</p><h3 id="1-2-日志的弊端">1.2 日志的弊端</h3><ul><li>日志功能会<code>降低MySQL数据库的性能</code>。例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。</li><li>日志会<code>占用大量的磁盘空间</code>。对于用户量非常大，操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。</li></ul><hr><h2 id="2-慢查询日志-slow-query-log">2. 慢查询日志(slow query log)</h2><p>前面章节《性能分析工具的使用》已经详细讲述。</p><div class="tag link"><a class="link-card" title="性能分析工具的使用" href="/posts/2678f2d3.html#4-定位执行慢的SQL-慢查询日志"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/favicon.png"/></div><div class="right"><p class="text">性能分析工具的使用</p><p class="url">/posts/2678f2d3.html#4-定位执行慢的SQL-慢查询日志</p></div></a></div><hr><h2 id="3-通用查询日志-general-query-log">3. 通用查询日志(general query log)</h2><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止 时间、发给 MySQL数据库服务器的所有 SQL指令等。当我们的数据发生异常时，<span class='p green'>查看通用查询日志， 还原操作时的具体场景</span>，可以帮助我们准确定位问题。</p><h3 id="3-1-问题场景">3.1 问题场景</h3><p>在电商系统中，购买商品并且使用微信支付完成以后，却发现支付中心的记录并没有新增，此时用户再次使用支付宝支付，就会出现重复支付的问题。但是当去数据库中查询数据的时候，会发现只有一条记录存在。那么此时给到的现象就是只有一条支付记录，但是用户却支付了两次。</p><p>我们对系统进行了仔细检查，没有发现数据问题，因为用户编号和订单编号以及第三方流水号都是对的。可是用户确实支付了两次，这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。</p><p>查看之后，发现：1月1日下午2点，用户使用微信支付完以后，但是由于网络故障，支付中心没有及时收到微信支付的回调通知，导致当时没有写入数据。1月1日下午2点30，用户又使用支付宝支付，此时记录更新到支付中心。1月1日晚上9点，微信的回调通知过来了，但是支付中心已经存在了支付宝的记录，所以只能覆盖记录了。</p><p>由于网络的原因导致了重复支付。至于解决问题的方案就很多了，这里省略。</p><p>可以看到通用查询日志可以帮助我们了解操作发生的具体时间和操作的细节，对找出异常发生的原因极其关键。</p><hr><h3 id="2-查看当前状态">2 查看当前状态</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                          <span class="operator">|</span> #通用查询日志处于关闭状态</span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>fortune01.log <span class="operator">|</span> #通用查询日志文件的名称 主机名</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+------------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><p>说明1：系统变量 genera_log 的值是OFF，即通用查询日志处于关闭状态。在MySQL中，这个参数的<code>默认值是关闭的</code>。因为一旦开启记录通用查询日志，MySQL会记录所有的连接起止和相关的SQL操作，这样会消耗系统资源并且占用磁盘空间。我们可以通过手动修改变量的值，在需要的时候开启日志。</p><p>说明2：通用查询日志文件的名称是fortune01.log。存储路径是/var/ib/mysql，默认也是数据路径。这样我们就知道在哪里可以查看通用查询日志的内容了。</p><hr><h3 id="3-3-启动日志">3.3 启动日志</h3><p><strong>方式1：永久性方式</strong></p><p>修改my.cnf或者my.ini配置文件来设置。在[mysqld]组下加入log选项，并重启MySQL服务。格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="string">ON</span></span><br><span class="line"><span class="attr">general_log_file</span>=<span class="string">[path[filename]] #日志文件所在目录路径，filename为日志文件</span></span><br></pre></td></tr></table></figure><p>如果不指定目录和文件名，通用查询日志将默认存储在MySQL数据目录中的hostname.log文件中， hostname表示主机名。</p><p><strong>方式2：临时性方式</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span><span class="keyword">on</span>; # 开启通用查询日志</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log_file<span class="operator">=</span>’path<span class="operator">/</span>filename’; # 设置日志文件保存位置</span><br></pre></td></tr></table></figure><p>对应的，关闭操作SQL命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span>off; # 关闭通用查询日志</span><br></pre></td></tr></table></figure><p>查看设置后情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-4-查看日志">3.4 查看日志</h3><p>通用查询日志是以<code>文本文件</code>的形式存储在文件系统中的，可以使用<code>文本编辑器</code>直接打开日志文件。每台 MySQL服务器的通用查询日志内容是不同的。</p><ul><li>在Windows操作系统中，使用文本文件查看器；</li><li>在Linux系统中，可以使用vi工具或者gedit工具查看；</li><li>在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。</li></ul><p>从<code>SHOW VARIABLES LIKE 'general_log%'</code>; 结果中可以看到通用查询日志的位置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span>usr<span class="operator">/</span>sbin<span class="operator">/</span>mysqld, Version: <span class="number">8.0</span><span class="number">.26</span> (MySQL Community Server <span class="operator">-</span> GPL). started <span class="keyword">with</span>:</span><br><span class="line">Tcp port: <span class="number">3306</span> Unix socket: <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql.sock</span><br><span class="line"><span class="type">Time</span> Id Command Argument</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">44</span>:<span class="number">58.052890</span>Z <span class="number">10</span> Query <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span></span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">45</span>:<span class="number">15.666672</span>Z <span class="number">10</span> Query <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span></span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">45</span>:<span class="number">28.970765</span>Z <span class="number">10</span> Query <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">47</span>:<span class="number">38.706804</span>Z <span class="number">11</span> <span class="keyword">Connect</span> root<span class="variable">@localhost</span> <span class="keyword">on</span> <span class="keyword">using</span> Socket</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">47</span>:<span class="number">38.707435</span>Z <span class="number">11</span> Query <span class="keyword">select</span> @<span class="variable">@version</span>_comment limit <span class="number">1</span></span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">21.384886</span>Z <span class="number">12</span> <span class="keyword">Connect</span> root<span class="variable">@172</span><span class="number">.16</span><span class="number">.210</span><span class="number">.1</span> <span class="keyword">on</span> <span class="keyword">using</span> TCP<span class="operator">/</span>IP</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">21.385253</span>Z <span class="number">12</span> Query <span class="keyword">SET</span> NAMES utf8</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">21.385640</span>Z <span class="number">12</span> Query USE`atguigu12`</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">21.386179</span>Z <span class="number">12</span> Query <span class="keyword">SHOW</span> <span class="keyword">FULL</span> TABLES <span class="keyword">WHERE</span> Table_Type <span class="operator">!=</span></span><br><span class="line"><span class="string">&#x27;VIEW&#x27;</span></span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">23.901778</span>Z <span class="number">13</span> <span class="keyword">Connect</span> root<span class="variable">@172</span><span class="number">.16</span><span class="number">.210</span><span class="number">.1</span> <span class="keyword">on</span> <span class="keyword">using</span> TCP<span class="operator">/</span>IP</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">23.902128</span>Z <span class="number">13</span> Query <span class="keyword">SET</span> NAMES utf8</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">23.905179</span>Z <span class="number">13</span> Query USE`atguigu`</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">23.905825</span>Z <span class="number">13</span> Query <span class="keyword">SHOW</span> <span class="keyword">FULL</span> TABLES <span class="keyword">WHERE</span> Table_Type <span class="operator">!=</span></span><br><span class="line"><span class="string">&#x27;VIEW&#x27;</span></span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">32.163833</span>Z <span class="number">14</span> <span class="keyword">Connect</span> root<span class="variable">@172</span><span class="number">.16</span><span class="number">.210</span><span class="number">.1</span> <span class="keyword">on</span> <span class="keyword">using</span> TCP<span class="operator">/</span>IP</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">32.164451</span>Z <span class="number">14</span> Query <span class="keyword">SET</span> NAMES utf8</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">32.164840</span>Z <span class="number">14</span> Query USE`atguigu`</span><br><span class="line"><span class="number">2022</span><span class="number">-01</span><span class="number">-04</span>T07:<span class="number">48</span>:<span class="number">40.006687</span>Z <span class="number">14</span> Query <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account</span><br></pre></td></tr></table></figure><p>在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。</p><h3 id="3-5-停止日志">3.5 停止日志</h3><p><strong>方式1：永久性方式</strong></p><p>修改<code>my.cnf</code>或者<code>my.ini</code>文件，把[mysqld]组下的<code>general_log</code>值设置为<code>OFF</code>或者把general_log一项 注释掉。修改保存后，再<code>重启MySQL服务</code>，即可生效。</p><p>举例1：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">general_log</span>=<span class="string">OFF</span></span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#general_log=ON</span></span><br></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><p>使用SET语句停止MySQL通用查询日志功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> general_log<span class="operator">=</span>off;</span><br></pre></td></tr></table></figure><p>查询通用日志功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="3-6-删除-刷新日志">3.6 删除\刷新日志</h3><p>如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。</p><p><strong>手动删除文件</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;general_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以看出，通用查询日志的目录默认为MySQL数据目录。在该目录下手动删除通用查询日志 atguigu01.log</p><p>使用如下命令重新生成查询日志文件，具体命令如下。刷新MySQL数据目录，发现创建了新的日志文 件。前提一定要开启通用日志。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br></pre></td></tr></table></figure><p>如果希望备份旧的通用查询日志，就必须先将旧的日志文件复制出来或者改名，然后执行上面的mysqladmin命令。正确流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd mysql-data-directory # 输入自己的通用日志文件所在目录</span><br><span class="line">mv mysql.general.log mysql.general.log.old # 指定旧的文件名 以及 新的文件名</span><br><span class="line">mysqladmin -uroot -p flush-logs</span><br></pre></td></tr></table></figure><h2 id="4-错误日志-error-log">4. 错误日志(error log)</h2><p>错误日志记录了 MySQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括<code>错误</code>、<code>警告</code>和<code>提示</code>等。</p><p>通过错误日志可以查看系统的运行状态，便于即时发现故障、修复故障。如果MySQL服务<code>出现异常</code>，错误日志是发现问题、解决故障的<code>首选</code>。</p><h3 id="4-1-启动日志">4.1 启动日志</h3><p>在MySQL数据库中，错误日志功能是<code>默认开启</code>的。而且，错误日志<code>无法被禁止</code>。</p><p>默认情况下，错误日志存储在MySQL数据库的数据文件夹下，名称默认为<code>mysqld.log</code>（Linux系统）或<code>hostname.err</code>（mac系统）。如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">log-error</span>=<span class="string">[path/[filename]] #path为日志文件所在的目录路径，filename为日志文件名</span></span><br></pre></td></tr></table></figure><p>修改配置项后，需要重启MySQL服务以生效。</p><h3 id="4-2-查看日志">4.2 查看日志</h3><p>MySQL错误日志是以文本文件形式存储的，可以使用文本编辑器直接查看。</p><p>查询错误日志的存储路径：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;log_err%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name              <span class="operator">|</span> <span class="keyword">Value</span>                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_error                  <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_error_services         <span class="operator">|</span> log_filter_internal; log_sink_internal <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_error_suppression_list <span class="operator">|</span>                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_error_verbosity        <span class="operator">|</span> <span class="number">2</span>                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------------+----------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>执行结果中可以看到错误日志文件是mysqld.log，位于MySQL默认的数据目录下。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715160657093.png" alt="image-20220715160657093"  /><h3 id="4-3-删除-刷新日志">4.3 删除\刷新日志</h3><p>对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除， 以保证MySQL服务器上的<code>硬盘空间</code>。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以<code>直接删除</code>。</p><ul><li>第一步（方式1）：删除操作</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm <span class="operator">-</span>f <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysqld.log</span><br></pre></td></tr></table></figure><p>在运行状态下删除错误日志文件后，MySQL并不会自动创建日志文件。</p><ul><li>第一步（方式2）：重命名文件</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log.old</span><br></pre></td></tr></table></figure><ul><li>第二步：重建日志</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br></pre></td></tr></table></figure><p>可能会报错</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@atguigu01</span> log]# mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p flush<span class="operator">-</span>logs</span><br><span class="line">Enter password:</span><br><span class="line">mysqladmin: refresh failed; error: <span class="string">&#x27;Could not open file &#x27;</span><span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log<span class="string">&#x27; for</span></span><br><span class="line"><span class="string">error logging.&#x27;</span></span><br></pre></td></tr></table></figure><p>官网提示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715161132368.png" alt="image-20220715161132368"></p><p>补充操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install <span class="operator">-</span>omysql <span class="operator">-</span>gmysql <span class="operator">-</span>m0644 <span class="operator">/</span>dev<span class="operator">/</span><span class="keyword">null</span> <span class="operator">/</span>var<span class="operator">/</span>log<span class="operator">/</span>mysqld.log</span><br></pre></td></tr></table></figure><p><code>flush-logs</code>指令操作：</p><ul><li><p>MysQL 5.5.7以前的版本，flush-logs将错误日志文件重命名为flename.err_old，并创建新的日志文件。</p></li><li><p>从MySQL5.5.7开始，flush-ogs只是重新打开日志文件，并不做日志备份和创建的操作。</p></li><li><p>如果日志文件不存在，MySQL启动或者执行flush-logs时会自动创建新的日志文件。重新创建错误日志，大小为0字节。</p></li></ul><h3 id="4-4-MySQL-8-0-新特性">4.4 MySQL 8.0 新特性</h3><p>MySQL8.0里对错误日志的改进。MySQL8.0的错误日志可以理解为一个全新的日志，在这个版本里，接受了来自社区的广泛批评意见，在这些意见和建议的基础上生成了新的日志， 下面这些是来自社区的意见：</p><ul><li><p>默认情况下内容过于冗长</p></li><li><p>遗漏了有用的信息</p></li><li><p>难以过滤某些信息</p></li><li><p>没有标识错误信息的子系统源</p></li><li><p>没有错误代码，解析消息需要识别错误</p></li><li><p>引导消息可能会丢失</p></li><li><p>固定格式</p></li></ul><p>针对这些意见，MySQL做了如下改变：</p><ul><li><p>采用组件架构，通过不同的组件执行日志的写入和过滤功能</p></li><li><p>写入错误日志的全部信息都具有唯一的错误代码从10000开始</p></li><li><p>增加了一个新的消息分类《system》用于在错误日志中始终可见的非错误但服务器状态更改事件的消息增加了额外的附加信息，例如关机时的版本信息，谁发起的关机等等</p></li><li><p>两种过滤方式，Internal和Dragnet</p></li><li><p>三种写入形式，经典、JSON和syseventlog</p></li></ul><blockquote><p>小结：</p><p>通常情况下，管理员不需要查看错误日志。但是，MySQL服务器发生异常时，管理员可以从错误日志中找到发生异常的时间、原因，然后根据这些信息来解决异常。</p></blockquote><hr><h2 id="5-二进制日志-bin-log">5. 二进制日志(bin log)</h2><p>binlog可以说是MySQL中比较<code>重要</code>的日志了，在日常开发及运维过程中，经常会遇到。</p><p>binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的<code>DDL</code>和<code>DML</code>等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、 show等）。</p><p>它以<code>事件形式</code>记录并保存在<code>二进制文件</code>中。通过这些信息，我们可以再现数据更新操作的全过程。</p><blockquote><p>如果想要记录所有语句（例如，为了识别有问题的查询），需要使用通用查询日志。</p></blockquote><p>binlog主要应用场景：</p><ul><li><p>一是用于<code>数据恢复</code>，如果MysQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</p></li><li><p>二是用于<code>数据复制</code>，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。</p></li></ul><p>可以说MysQL数据库的<span class='p red'>数据备份、主备、主主、主从</span>都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715161842703.png" alt="image-20220715161842703"></p><h3 id="5-1-查看默认情况">5.1 查看默认情况</h3><p>查看记录二进制日志是否开启：在MySQL8中默认情况下，二进制文件是开启的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>binlog.index      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><code>log_bin_basename</code>：是binlog日志的基本文件名，后面会追加标识来表示每一个文件</p><p><code>log_bin_ index</code>：是binlog文件的索引文件，这个文件管理了所有的binlog文件的目录</p><p><code>log_bin_trust_function_creators</code>：限制存储过程，前面我们己经讲过了，这是因为二进制日志的一个重要功能是用于主从复制，而存储函数有可能导致主从的数据不一致。所以当开启二进制日志后，需要限制存储函数的创建、修改、调用</p><p><code>log_bin_use_v1_row_events</code>此只读系统变量已弃用。ON表示使用版本1二进制日志行，OFF表示使用版本2 二进制日志行(MySQL 5.6 的默认值为2）</p><hr><h3 id="5-2-日志参数设置">5.2 日志参数设置</h3><p><strong>方式1：永久性方式</strong></p><p>修改MySQL的<code>my.cnf</code>或<code>my.ini</code>文件可以设置二进制日志的相关参数：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">atguigu-bin</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span>=<span class="string">600</span></span><br><span class="line"><span class="attr">max_binlog_size</span>=<span class="string">100M</span></span><br></pre></td></tr></table></figure><blockquote><p>提示：</p><ol><li>log-bin=mysql-bin #打开日志(主机需要打开)，这个mysql-bin也可以自定义，这里也可以加上路径， 如：/home/www/mysql_bin_log/mysql-bin</li><li>binlog_expire_logs_seconds：此参数控制二进制日志文件保留的时长，单位是秒，默认2592000 30天 --14400 4小时；86400 1天；259200 3天；</li><li>max_binlog_size：控制单个二进制日志大小，当前日志文件大小超过此变量时，执行切换动作。此参数的<code>最大和默认值是1GB</code>，该设置并<code>不能严格控制Binlog的大小</code>，尤其是Binlog比比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性，可能不做切换日志的动作，只能将该事务的所有SQL都记录进当前日志，直到事务结束。一般情况下可采取默认值。</li></ol></blockquote><p>重新启动MySQL服务，查询二进制日志的信息，执行结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>bin       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>atguigu<span class="operator">-</span>bin.index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+----------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>设置带文件夹的bin-log日志存放目录</strong></p><p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">&quot;/var/lib/mysql/binlog/atguigu-bin&quot;</span></span><br></pre></td></tr></table></figure><p>注意：新建的文件夹需要使用mysql用户，使用下面的命令即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown <span class="operator">-</span>R <span class="operator">-</span>v mysql:mysql binlog</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715164107352.png" alt="image-20220715164107352" /><p><strong>方式2：临时性方式</strong></p><p>如果不希望通过修改配置文件并重启的方式设置二进制日志的话，还可以使用如下指令，需要注意的是 在mysql8中只有<code>会话级别</code>的设置，没有了global级别的设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">global</span> 级别</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> sql_log_bin<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">ERROR <span class="number">1228</span> (HY000): Variable <span class="string">&#x27;sql_log_bin&#x27;</span> <span class="keyword">is</span> a SESSION variable <span class="keyword">and</span> can`t be used</span><br><span class="line"><span class="keyword">with</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span></span><br><span class="line"></span><br><span class="line"># session级别</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> sql_log_bin<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure><h3 id="5-3-查看日志">5.3 查看日志</h3><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一 个以“filename”为名称、以“.000001”为后缀的文件。</p><p>MySQL服务<code>重新启动一次</code>，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的 个数与MySQL服务启动的次数相同；如果日志长度超过了<code>max_binlog_size</code>的上限（默认是1GB），就会创建一个新的日志文件。</p><p>查看当前的二进制日志文件列表及大小。指令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="type">BINARY</span> LOGS;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> File_size <span class="operator">|</span> Encrypted <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> <span class="number">156</span>       <span class="operator">|</span> <span class="keyword">No</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------+</span></span><br><span class="line"><span class="number">1</span> 行于数据集 (<span class="number">0.02</span> 秒)</span><br></pre></td></tr></table></figure><p>所有对数据库的修改都会记录在binlog中。但binlog是二进制文件，无法直接查看，想要更直观的观测它就要借助<code>mysqlbinlog</code>命令工具了。指令如下：在查看执行，先执行一条SQL语句，如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;张三_back&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>开始查看binlog</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715164718970.png" alt="image-20220715164718970"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715164743351.png" alt="image-20220715164743351" /><p>执行结果可以看到，这是一个简单的日志文件，日志中记录了用户的一些操作，这里并没有出现具体的SQL语句，这是因为binlog关键字后面的内容是经过编码后的<code>二进制日志</code>。</p><p>这里一个update语句包含如下事件</p><ul><li><p>Query 事件负责开始一个事务(BEGIN)</p></li><li><p>Table_map事件负责映射需要的表</p></li><li><p>Update_rows事件负责写入数据</p></li><li><p>Xid事件负责结束事务</p></li></ul><p>下面命令将行事件以<code>伪SQL的形式</code>表现出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>v &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;</span><br><span class="line">#<span class="number">220105</span> <span class="number">9</span>:<span class="number">16</span>:<span class="number">37</span> server id <span class="number">1</span> end_log_pos <span class="number">324</span> CRC32 <span class="number">0x6b31978b</span> Query thread_id<span class="operator">=</span><span class="number">10</span></span><br><span class="line">exec_time<span class="operator">=</span><span class="number">0</span> error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1641345397</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.pseudo_thread_id<span class="operator">=</span><span class="number">10</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.foreign_key_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.sql_auto_is_null<span class="operator">=</span><span class="number">0</span>,</span><br><span class="line">@<span class="variable">@session</span>.unique_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.autocommit<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.sql_mode<span class="operator">=</span><span class="number">1168113696</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.auto_increment_increment<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.auto_increment_offset<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!\C utf8mb3 */</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">@<span class="variable">@session</span>.character_set_client<span class="operator">=</span><span class="number">33</span>,@<span class="variable">@session</span>.collation_connection<span class="operator">=</span><span class="number">33</span>,@<span class="variable">@session</span>.collatio</span><br><span class="line">n_server<span class="operator">=</span><span class="number">255</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.lc_time_names<span class="operator">=</span><span class="number">0</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.collation_database<span class="operator">=</span><span class="keyword">DEFAULT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80011 SET @@session.default_collation_for_utf8mb4=255*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">324</span></span><br><span class="line">#<span class="number">220105</span> <span class="number">9</span>:<span class="number">16</span>:<span class="number">37</span> server id <span class="number">1</span> end_log_pos <span class="number">391</span> CRC32 <span class="number">0x74f89890</span> Table_map:</span><br><span class="line">`atguigu14`.`student`mapped <span class="keyword">to</span> number <span class="number">85</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">391</span></span><br><span class="line">#<span class="number">220105</span> <span class="number">9</span>:<span class="number">16</span>:<span class="number">37</span> server id <span class="number">1</span> end_log_pos <span class="number">470</span> CRC32 <span class="number">0xc9920491</span> Update_rows: <span class="keyword">table</span> id</span><br><span class="line"><span class="number">85</span> flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">dfHUYRMBAAAAQwAAAIcBAAAAAFUAAAAAAAEACWF0Z3VpZ3UxNAAHc3R1ZGVudAADAw8PBDwAHgAG</span></span><br><span class="line"><span class="string">AQEAAgEhkJj4dA==</span></span><br><span class="line"><span class="string">dfHUYR8BAAAATwAAANYBAAAAAFUAAAAAAAEAAgAD//8AAQAAAAblvKDkuIkG5LiA54+tAAEAAAAL</span></span><br><span class="line"><span class="string">5byg5LiJX2JhY2sG5LiA54+tkQSSyQ==</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line">### <span class="keyword">UPDATE</span>`atguigu`.`student`</span><br><span class="line">### <span class="keyword">WHERE</span></span><br><span class="line">### <span class="variable">@1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">### <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;张三&#x27;</span></span><br><span class="line">### <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;一班&#x27;</span></span><br><span class="line">### <span class="keyword">SET</span></span><br><span class="line">### <span class="variable">@1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">### <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;张三_back&#x27;</span></span><br><span class="line">### <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;一班&#x27;</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">470</span></span><br><span class="line">#<span class="number">220105</span> <span class="number">9</span>:<span class="number">16</span>:<span class="number">37</span> server id <span class="number">1</span> end_log_pos <span class="number">501</span> CRC32 <span class="number">0xca01d30f</span> Xid <span class="operator">=</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br></pre></td></tr></table></figure><p>前面的命令同时显示binlog格式的语句，使用如下命令不显示它</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>v <span class="comment">--base64-output=DECODE-ROWS &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;</span></span><br><span class="line">#<span class="number">220105</span> <span class="number">9</span>:<span class="number">16</span>:<span class="number">37</span> server id <span class="number">1</span> end_log_pos <span class="number">324</span> CRC32 <span class="number">0x6b31978b</span> Query thread_id<span class="operator">=</span><span class="number">10</span></span><br><span class="line">exec_time<span class="operator">=</span><span class="number">0</span> error_code<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1641345397</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.pseudo_thread_id<span class="operator">=</span><span class="number">10</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.foreign_key_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.sql_auto_is_null<span class="operator">=</span><span class="number">0</span>,</span><br><span class="line">@<span class="variable">@session</span>.unique_checks<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.autocommit<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.sql_mode<span class="operator">=</span><span class="number">1168113696</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.auto_increment_increment<span class="operator">=</span><span class="number">1</span>, @<span class="variable">@session</span>.auto_increment_offset<span class="operator">=</span><span class="number">1</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!\C utf8mb3 */</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">@<span class="variable">@session</span>.character_set_client<span class="operator">=</span><span class="number">33</span>,@<span class="variable">@session</span>.collation_connection<span class="operator">=</span><span class="number">33</span>,@<span class="variable">@session</span>.collatio</span><br><span class="line">n_server<span class="operator">=</span><span class="number">255</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.lc_time_names<span class="operator">=</span><span class="number">0</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.collation_database<span class="operator">=</span><span class="keyword">DEFAULT</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment">/*!80011 SET @@session.default_collation_for_utf8mb4=255*/</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">324</span></span><br><span class="line">#<span class="number">220105</span> <span class="number">9</span>:<span class="number">16</span>:<span class="number">37</span> server id <span class="number">1</span> end_log_pos <span class="number">391</span> CRC32 <span class="number">0x74f89890</span> Table_map:</span><br><span class="line">`atguigu14`.`student`mapped <span class="keyword">to</span> number <span class="number">85</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">391</span></span><br><span class="line">#<span class="number">220105</span> <span class="number">9</span>:<span class="number">16</span>:<span class="number">37</span> server id <span class="number">1</span> end_log_pos <span class="number">470</span> CRC32 <span class="number">0xc9920491</span> Update_rows: <span class="keyword">table</span> id</span><br><span class="line"><span class="number">85</span> flags: STMT_END_F</span><br><span class="line">### <span class="keyword">UPDATE</span>`atguigu14`.`student`</span><br><span class="line">### <span class="keyword">WHERE</span></span><br><span class="line">### <span class="variable">@1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">### <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;张三&#x27;</span></span><br><span class="line">### <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;一班&#x27;</span></span><br><span class="line">### <span class="keyword">SET</span></span><br><span class="line">### <span class="variable">@1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">### <span class="variable">@2</span><span class="operator">=</span><span class="string">&#x27;张三_back&#x27;</span></span><br><span class="line">### <span class="variable">@3</span><span class="operator">=</span><span class="string">&#x27;一班&#x27;</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">470</span></span><br><span class="line">#<span class="number">220105</span> <span class="number">9</span>:<span class="number">16</span>:<span class="number">37</span> server id <span class="number">1</span> end_log_pos <span class="number">501</span> CRC32 <span class="number">0xca01d30f</span> Xid <span class="operator">=</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><p>关于mysqlbinlog工具的使用技巧还有很多，例如只解析对某个库的操作或者某个时间段内的操作等。简单分享几个常用的语句，更多操作可以参考官方文档。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 可查看参数帮助</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --help</span></span><br><span class="line"># 查看最后<span class="number">100</span>行</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail</span></span><br><span class="line"><span class="number">-100</span></span><br><span class="line"># 根据position查找</span><br><span class="line">mysqlbinlog <span class="comment">--no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A</span></span><br><span class="line"><span class="number">20</span> <span class="string">&#x27;4939002&#x27;</span></span><br></pre></td></tr></table></figure><p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events [<span class="keyword">IN</span> <span class="string">&#x27;log_name&#x27;</span>] [<span class="keyword">FROM</span> pos] [LIMIT [<span class="keyword">offset</span>,] row_count];</span><br></pre></td></tr></table></figure><p>*<code>IN 'log_name'</code>：指定要查询的binlog文件名（不指定就是第一个binlog文件）　<br>*<code>FROM pos</code>：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）<br>*<code>LIMIT [offset]</code>：偏移量(不指定就是0)<br>*<code>row_count</code>:查询总条数（不指定就是所有行）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;atguigu-bin.000002&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Log_name           <span class="operator">|</span> Pos <span class="operator">|</span> Event_type     <span class="operator">|</span> Server_id <span class="operator">|</span> End_log_pos <span class="operator">|</span> Info                                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">4</span>   <span class="operator">|</span> Format_desc    <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">125</span>         <span class="operator">|</span> Server ver: <span class="number">8.0</span><span class="number">.26</span>, Binlog ver: <span class="number">4</span>                      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">125</span> <span class="operator">|</span> Previous_gtids <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">156</span>         <span class="operator">|</span>                                                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">156</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">235</span>         <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">235</span> <span class="operator">|</span> Query          <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">324</span>         <span class="operator">|</span> <span class="keyword">BEGIN</span>                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">324</span> <span class="operator">|</span> Table_map      <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">391</span>         <span class="operator">|</span> table_id: <span class="number">85</span>(atguigu14.student)                        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">391</span> <span class="operator">|</span> Update_rows    <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">470</span>         <span class="operator">|</span> table_id: <span class="number">85</span>flags: STMT_END_F                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">470</span> <span class="operator">|</span> Xid            <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">501</span>         <span class="operator">|</span> <span class="keyword">COMMIT</span> <span class="comment">/*xid=15 */</span>                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">501</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">578</span>         <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">578</span> <span class="operator">|</span> Query     <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> <span class="number">721</span> <span class="operator">|</span> use`atguigu14`; <span class="keyword">create</span> <span class="keyword">table</span> test(id <span class="type">int</span>, title <span class="type">varchar</span>(<span class="number">100</span>)) <span class="comment">/* xid=19 */</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">721</span> <span class="operator">|</span> Anonymous_Gtid <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">800</span>         <span class="operator">|</span> <span class="keyword">SET</span> @<span class="variable">@SESSION</span>.GTID_NEXT<span class="operator">=</span> <span class="string">&#x27;ANONYMOUS&#x27;</span>                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">800</span> <span class="operator">|</span> Query          <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">880</span>         <span class="operator">|</span> <span class="keyword">BEGIN</span>                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">880</span> <span class="operator">|</span> Table_map      <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">943</span>         <span class="operator">|</span> table_id: <span class="number">89</span>(atguigu14.test)                           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">943</span> <span class="operator">|</span> Write_rows     <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">992</span>         <span class="operator">|</span> table_id: <span class="number">89</span> flags: STMT_END_F                         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> atguigu<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">|</span> <span class="number">992</span> <span class="operator">|</span> Xid            <span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">1023</span>        <span class="operator">|</span> <span class="keyword">COMMIT</span> <span class="comment">/*xid=21 */</span>                                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----+----------------+-----------+-------------+--------------------------------------------------------+</span></span><br><span class="line"><span class="number">14</span> 行于数据集 (<span class="number">0.02</span> 秒)</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715165603879.png" alt="image-20220715165603879"  /><p>上面我们讲了这么多都是基于binlog的默认格式，binlog格式查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_format&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> binlog_format <span class="operator">|</span> <span class="type">ROW</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> 行于数据集 (<span class="number">0.02</span> 秒)</span><br></pre></td></tr></table></figure><p>除此之外，binlog还有2种格式，分别是<code>Statement</code>和<code>Mixed</code></p><ul><li><p>Statement</p><p>每一条会修改数据的sql都会记录在binlog中。</p><p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p></li><li><p>Row</p><p>5.1.5版本的MySQL才开始支持row level 的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p><p>优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下 的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</p></li><li><p>Mixed</p><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p><p>详细情况，下章讲解。</p></li></ul><h3 id="5-4-使用日志恢复数据">5.4 使用日志恢复数据</h3><p>如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间点的日志中回复数据。</p><p>mysqlbinlog恢复数据的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename<span class="operator">|</span>mysql –uuser <span class="operator">-</span>ppass;</span><br></pre></td></tr></table></figure><p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。</p><p>*<code>filename</code>：是日志文件名。</p><p>*<code>option</code>：可选项，比较重要的两对option参数是–start-date、–stop-date 和 --start-position、-- stop-position。<br>*<code>--start-date</code>和<code>--stop-date</code>：可以指定恢复数据库的起始时间点和结束时间点。<br>*<code>--start-position</code>和<code>--stop-position</code>：可以指定恢复数据的开始位置和结束位置。</p><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><p>详见p189，由于翻页过快，这部分没办法记录。</p><h3 id="5-5-删除二进制日志">5.5 删除二进制日志</h3><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。<code>PURGE MASTER LOGS</code>只删除指定部分的二进制日志文件，<code>RESET MASTER</code>删除所有的二进制日志文 件。具体如下：</p><p><strong>1. PURGE MASTER LOGS：删除指定日志文件</strong></p><p>PURGE MASTER LOGS语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS <span class="keyword">TO</span> ‘指定日志文件名’</span><br><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS BEFORE ‘指定日期’</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715165603879.png" alt="image-20220715165603879"  /><p>上面我们讲了这么多都是基于binlog的默认格式，binlog格式查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_format&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> binlog_format <span class="operator">|</span> <span class="type">ROW</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> 行于数据集 (<span class="number">0.02</span> 秒)</span><br></pre></td></tr></table></figure><p>除此之外，binlog还有2种格式，分别是<code>Statement</code>和<code>Mixed</code></p><ul><li><p>Statement</p><p>每一条会修改数据的sql都会记录在binlog中。</p><p>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。</p></li><li><p>Row</p><p>5.1.5版本的MySQL才开始支持row level 的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p><p>优点：row level 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下 的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。</p></li><li><p>Mixed</p><p>从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。</p><p>详细情况，下章讲解。</p></li></ul><h3 id="5-4-使用日志恢复数据-2">5.4 使用日志恢复数据</h3><p>如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间点的日志中回复数据。</p><p>mysqlbinlog恢复数据的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [option] filename<span class="operator">|</span>mysql –uuser <span class="operator">-</span>ppass;</span><br></pre></td></tr></table></figure><p>这个命令可以这样理解：使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中。</p><p>*<code>filename</code>：是日志文件名。</p><p>*<code>option</code>：可选项，比较重要的两对option参数是–start-date、–stop-date 和 --start-position、-- stop-position。<br>*<code>--start-date</code>和<code>--stop-date</code>：可以指定恢复数据库的起始时间点和结束时间点。<br>*<code>--start-position</code>和<code>--stop-position</code>：可以指定恢复数据的开始位置和结束位置。</p><blockquote><p>注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必须在atguigu-bin.000002之前恢复。</p></blockquote><h3 id="5-5-删除二进制日志-2">5.5 删除二进制日志</h3><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。<code>PURGE MASTER LOGS</code>只删除指定部分的二进制日志文件，<code>RESET MASTER</code>删除所有的二进制日志文 件。具体如下：</p><p><strong>1. PURGE MASTER LOGS：删除指定日志文件</strong></p><p>PURGE MASTER LOGS语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS <span class="keyword">TO</span> ‘指定日志文件名’</span><br><span class="line">PURGE &#123;MASTER <span class="operator">|</span> <span class="type">BINARY</span>&#125; LOGS BEFORE ‘指定日期’</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715171712026.png" alt="image-20220715171712026"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715172015185.png" alt="image-20220715172015185"  /><p><strong>2. RESET MASTER: 删除所有二进制日志文件</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715172104967.png" alt="image-20220715172104967"  /><h3 id="5-6-其它场景">5.6 其它场景</h3><p>二进制日志可以通过数据库的<code>全量备份</code>和二进制日志中保存的<code>增量信息</code>，完成数据库的<code>无损失恢复</code>。 但是，如果遇到数据量大、数据库和数据表很多（比如分库分表的应用）的场景，用二进制日志进行数据恢复，是很有挑战性的，因为起止位置不容易管理。</p><p>在这种情况下，一个有效的解决办法是<code>配置主从数据库服务器</code>，甚至是<code>一主多从</code>的架构，把二进制日志文件的内容通过中继日志，同步到从数据库服务器中，这样就可以有效避免数据库故障导致的数据异常等问题。</p><hr><h2 id="6-再谈二进制日志-binlog">6. 再谈二进制日志(binlog)</h2><h3 id="6-1-写入机制">6.1 写入机制</h3><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。binlog日志刷盘流程如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715172958729.png" alt="image-20220715172958729" style="zoom: 50%;" /><blockquote><ul><li>上图的write，是指把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度比较快</li><li>上图的fsync，才是将数据持久化到磁盘的操作</li></ul></blockquote><p>write和fsync的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。为0的时候，表示每次提交事务都只 write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的 binglog 会丢失。如下图：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715193749462.png" alt="image-20220715193749462" style="zoom:50%;" /><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行fsync，就如同<strong>redo log 刷盘流程</strong>一样。 最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715194624080.png" alt="image-20220715194624080" style="zoom:50%;" /><p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p><h3 id="6-2-binlog与redolog对比">6.2 binlog与redolog对比</h3><ul><li>redo log 它是<code>物理日志</code>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li><li>而 binlog 是<code>逻辑日志</code>，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于 MySQL Server 层。</li><li>虽然它们都属于持久化的保证，但是侧重点不同。<ul><li>redo log让InnoDB存储引擎拥有了崩溃恢复能力。</li><li>binlog保证了MySQL集群架构的数据一致性。</li></ul></li></ul><h3 id="6-3-两阶段提交">6.3 两阶段提交</h3><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的<code>写入时机</code>不一样。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715194959405.png" alt="image-20220715194959405" style="zoom:67%;" /><p><strong>redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？</strong></p><p>以update语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段c值更新为<code>1</code>，SQL语句为update T set c = 1 where id = 2。</p><p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715195016492.png" alt="image-20220715195016492" style="zoom:67%;" /><p>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值为0，而原库因为redo log日志恢复，这一行c的值是1，最终数据不一致。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715195521986.png" alt="image-20220715195521986" style="zoom:67%;" /><p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是<strong>两阶段提交</strong>。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715195635196.png" alt="image-20220715195635196" style="zoom:67%;" /><p>使用两阶段提交后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715200248193.png" alt="image-20220715200248193" style="zoom:67%;" /><p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715200321717.png" alt="image-20220715200321717" style="zoom:67%;" /><p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p><hr><h2 id="7-中继日志-relay-log">7. 中继日志(relay log)</h2><h3 id="7-1-介绍">7.1 介绍</h3><p><strong>中继日志只在主从服务器架构的从服务器上存在</strong>。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入<code>本地的日志文件</code>中，这个从服务器本地的日志文件就叫<code>中继日志</code>。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主 从服务器的 数据同步 。</p><p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p><p>文件名的格式是：<code>从服务器名-relay-bin.序号</code>。中继日志还有一个索引文件：<code>从服务器名-relaybin.index</code>，用来定位当前正在使用的中继日志。</p><h3 id="7-2-查看中继日志">7.2 查看中继日志</h3><p>中继日志与二进制日志的格式相同，可以用<code>mysqlbinlog</code>工具进行查看。下面是中继日志的一个片段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="type">TIMESTAMP</span><span class="operator">=</span><span class="number">1618558728</span><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">950</span></span><br><span class="line">#<span class="number">210416</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">48</span> server id <span class="number">1</span> end_log_pos <span class="number">832</span> CRC32 <span class="number">0xcc16d651</span> Table_map:</span><br><span class="line">`atguigu`.`test`mapped <span class="keyword">to</span> number <span class="number">91</span></span><br><span class="line"># <span class="keyword">at</span> <span class="number">1000</span></span><br><span class="line">#<span class="number">210416</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">48</span> server id <span class="number">1</span> end_log_pos <span class="number">872</span> CRC32 <span class="number">0x07e4047c</span> Delete_rows: <span class="keyword">table</span> id</span><br><span class="line"><span class="number">91</span> flags: STMT_END_F <span class="comment">-- server id 1 是主服务器，意思是主服务器删了一行数据</span></span><br><span class="line">BINLOG <span class="string">&#x27;</span></span><br><span class="line"><span class="string">CD95YBMBAAAAMgAAAEADAAAAAFsAAAAAAAEABGRlbW8ABHRlc3QAAQMAAQEBAFHWFsw=</span></span><br><span class="line"><span class="string">CD95YCABAAAAKAAAAGgDAAAAAFsAAAAAAAEAAgAB/wABAAAAfATkBw==</span></span><br><span class="line"><span class="string">&#x27;</span><span class="comment">/*!*/</span>;</span><br><span class="line"># <span class="keyword">at</span> <span class="number">1040</span></span><br></pre></td></tr></table></figure><p>这一段的意思是，主服务器（“server id 1”）对表 atguigu.test 进行了 2 步操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定位到表 atguigu.test 编号是 <span class="number">91</span> 的记录，日志位置是 <span class="number">832</span>；</span><br><span class="line">删除编号是 <span class="number">91</span> 的记录，日志位置是 <span class="number">872</span></span><br></pre></td></tr></table></figure><h3 id="7-3-恢复的典型错误">7.3 恢复的典型错误</h3><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的<code>服务器名称</code>与之前<code>不同</code>。而中继日志里是<code>包含从服务器名</code>的。在这种情况下，就可能导致你恢复从服务器的时候，无法 从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。</p><p>解决的方法也很简单，把从服务器的名称改回之前的名称。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL多版本并发控制</title>
      <link href="/posts/1f4b46b6.html"/>
      <url>/posts/1f4b46b6.html</url>
      
        <content type="html"><![CDATA[<p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code>。这项技术使得在InnoDB的事务隔离级别下执行<code>一致性读</code>操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁。</p><p>MVCC没有正式的标准，在不同的DBMS中MVCC的实现方式可能是不同的，也不是普遍使用的（大家可以参考相关的DBMS文档）。这里讲解InnoDB中MVCC的实现机制（MySQL其他的存储引擎并不支持它）</p><hr><h2 id="1-快照读与当前读">1. 快照读与当前读</h2><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理<code>读-写冲突</code>，做到即使有读写冲突时，也能做到<code>不加锁</code>，<code>非阻塞并发读</code>，而这个读指的就是<code>快照读</code>, 而非<code>当前读</code>。当前 读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p><div class="tabs" id="3c12d972-9050-44fe-9000-e79d518eb69e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3c12d972-9050-44fe-9000-e79d518eb69e-1"><i class="fas fa-cat"></i>快照读</button></li><li class="tab"><button type="button" data-href="#3c12d972-9050-44fe-9000-e79d518eb69e-2"><i class="fas fa-horse"></i>当前读</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3c12d972-9050-44fe-9000-e79d518eb69e-1"><p>快照读又叫一致性读，读取的是快照数据。<span class='p green'>不加锁的简单的 SELECT 都属于快照读</span>，即不加锁的非阻塞读；比如这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><p>之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下， 避免了加锁操作，降低了开销。</p><p>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</p><p>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c12d972-9050-44fe-9000-e79d518eb69e-2"><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。加锁的 SELECT，或者对数据进行增删改都会进行当前读。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LOCK <span class="keyword">IN</span> SHARE MODE; # 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; # 排他锁</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">values</span> ... # 排他锁</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> ... # 排他锁</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> ... # 排他锁</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="2-再谈隔离级别">2. 再谈隔离级别</h2><p>我们知道事务有 4 个隔离级别，可能存在三种并发问题：</p><p>在MySQL中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，如果仅从定义的角度来看，它并不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。</p><p>MVCC可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题！它可以在大多数情况下替代行级锁，降低系统的开销。</p><h2 id="3-隐藏字段、Undo-Log版本链">3. 隐藏字段、Undo Log版本链</h2><p>回顾一下undo日志的版本链，对于使用 InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p><p>*<code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给<code>trx_id</code>隐藏列。<br>*<code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然 后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p><p>举例：student表数据如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name <span class="operator">|</span> class<span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span>   <span class="operator">|</span> 张三  <span class="operator">|</span> 一班 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br></pre></td></tr></table></figure><p>假设插入该记录的<code>事务id</code>为<code>8</code>，那么此刻该条记录的示意图如下所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714140801595.png" alt="image-20220714140801595"></p><blockquote><p>insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。</p></blockquote><p>假设之后两个事务id分别为<code>10</code>、<code>20</code>的事务对这条记录进行<code>UPDATE</code>操作，操作流程如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714140846658.png" alt="image-20220714140846658"></p><p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个<code>roll_pointer</code>属性 （<code>INSERT</code>操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些<code>undo日志</code>都连起来，串成一个链表：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714141012874.png" alt="image-20220714141012874"></p><p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数 的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。</p><p>每个版本中还包含生成该版本时对应的<code>事务id</code>。</p><hr><h2 id="4-MVCC实现原理之ReadView">4. MVCC实现原理之ReadView</h2><p>MVCC 的实现依赖于：<code>隐藏字段</code>、<code>Undo Log</code>、<code>Read View</code>。</p><h3 id="4-1-什么是ReadView">4.1 什么是ReadView</h3><p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在 Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到 Readview了，它帮我们解决了行的可见性问题。</p><p>Readview就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB 为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务</code>的D（“活跃”指的就是，启动了但还没提交）</p><h3 id="4-2-设计思路">4.2 设计思路</h3><p>使用<code>READ UNCOMMITTED</code>隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p><p>使用<code>SERIALIZABLE</code>隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p><p>使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务，都必须保证读到<code>已经提交了的</code>事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p><p>这个ReadView中主要包含4个比较重要的内容，分别如下：</p><p>1.<code>creator_trx_id</code>，创建这个Read View的事务ID。</p><blockquote><p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为 事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p></blockquote><p>2.<code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的<code>事务id列表</code>。</p><p>3.<code>up_limit_id</code>，活跃的事务中最小的事务 ID。</p><p>4.<code>low_limit_id</code>，表示生成ReadView时系统中应该分配给下一个事务的 id 值。low_limit_id 是系 统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID。</p><blockquote><p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时， trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p></blockquote><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714142254768.png" alt="image-20220714142254768"  /><hr><h3 id="4-3-ReadView的规则">4.3 ReadView的规则</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p><ul><li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判断一下trx_id属性值是不是在 trx_ids 列表中。<ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><hr><h3 id="4-4-MVCC整体操作流程">4.4 MVCC整体操作流程</h3><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p><ol><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取 ReadView；</li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ol><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><blockquote><p>InnoDB 中，MVCC是通过 Undo Log + Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见。</p></blockquote><p>在隔离级别为读已提交（Read Committed）时，一个事务中的每一次 SELECT 查询都会重新获取一次 Read View。</p><p>如表所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715130843147.png" alt="image-20220715130843147" style="zoom:67%;" /><blockquote><p>注意，此时同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。</p></blockquote><p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View，如下表所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715130916437.png" alt="image-20220715130916437" style="zoom:67%;" /><hr><h2 id="5-举例说明">5. 举例说明</h2><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715131200077.png" alt="image-20220715131200077"  /><h3 id="5-1-READ-COMMITTED级别">5.1 READ COMMITTED级别</h3><p><strong>READ COMMITTED ：每次读取数据前都生成一个ReadView。</strong></p><p>现在有两个<code>事务id</code>分别为<code>10</code>、<code>20</code>的事务在执行:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>说明：事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。所以我们才在事务2中更新一些别的表的记录，目的是让它分配事务id。</p></blockquote><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715133640655.png" alt="image-20220715133640655"></p><p>假设现在有一个使用<code>READ COMMITTED</code>隔离级别的事务开始执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715134540737.png" alt="image-20220715134540737"  /><p>之后，我们把<code>事务id</code>为<code>10</code>的事务提交一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>然后再到<code>事务id</code>为<code>20</code>的事务中更新一下表<code>student</code>中<code>id</code>为<code>1</code>的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此刻，表student中<code>id</code>为<code>1</code>的记录的版本链就长这样：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715134839081.png" alt="image-20220715134839081"></p><p>然后再到刚才使用<code>READ COMMITTED</code>隔离级别的事务中继续查找这个 id 为 1 的记录，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;王五&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715135017000.png" alt="image-20220715135017000"  /><blockquote><p>强调：使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p></blockquote><hr><h3 id="5-2-REPEATABLE-READ级别">5.2 REPEATABLE READ级别</h3><p>使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个<code>ReadView</code>，之后的查询就不会重复生成了。</p><p>比如，系统里有两个<code>事务id</code>分别为<code>10</code>、<code>20</code>的事务在执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715140006061.png" alt="image-20220715140006061"></p><p>假设现在有一个使用<code>REPEATABLE READ</code>隔离级别的事务开始执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715140155744.png" alt="image-20220715140155744"  /><p>之后，我们把<code>事务id</code>为<code>10</code>的事务提交一下，就像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">10</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;李四&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;王五&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>然后再到<code>事务id</code>为<code>20</code>的事务中更新一下表<code>student</code>中<code>id</code>为<code>1</code>的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">20</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;钱七&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> name<span class="operator">=</span>&quot;宋八&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此刻，表student 中<code>id</code>为<code>1</code>的记录的版本链长这样：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715140354217.png" alt="image-20220715140354217"></p><p>然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>id</code>为<code>1</code>的记录，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"># SELECT1：Transaction <span class="number">10</span>、<span class="number">20</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张三&#x27;</span></span><br><span class="line"># SELECT2：Transaction <span class="number">10</span>提交，Transaction <span class="number">20</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值仍为<span class="string">&#x27;张三&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715140555172.png" alt="image-20220715140555172"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715140620328.png" alt="image-20220715140620328"  /><p>这次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>张三</code>，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>20</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>id</code>为<code>1</code>的记录，得到的结果还是<code>张三</code>，具体执行过程大家可以自己分析一下。</p><hr><h3 id="5-3-如何解决幻读">5.3 如何解决幻读</h3><p>接下来说明InnoDB 是如何解决幻读的。</p><p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下图所示。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715141002035.png" alt="image-20220715141002035" style="zoom:80%;" /><p>假设现在有事务 A 和事务 B 并发执行，<code>事务 A</code>的事务 id 为<code>20</code>，<code>事务 B</code>的事务 id 为<code>30</code>。</p><p>步骤1：事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView，此时 ReadView 的内容如下：<code>trx_ids= [20,30] ， up_limit_id=20 ， low_limit_id=31 ， creator_trx_id=20</code>。</p><p>由于此时表 student 中只有一条数据，且符合 where id&gt;=1 条件，因此会查询出来。然后根据 ReadView 机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id，这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p><p>结论：事务 A 的第一次查询，能读取到一条数据，id=1。</p><p>步骤2：接着事务 B(trx_id=30)，往表 student 中新插入两条数据，并提交事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(id,name) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;王五&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此时表student 中就有三条数据了，对应的 undo 如下图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715141208667.png" alt="image-20220715141208667"></p><p>步骤3：接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成 ReadView。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据 ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><p>1）首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。</p><p>2）然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之 间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表 示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p><p>3）同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220715141243993.png" alt="image-20220715141243993"></p><p>结论：最终事务 A 的第二次查询，只能查询出 id=1 的这条数据。这和事务 A 的第一次查询的结果是一样 的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p><h2 id="6-总结">6. 总结</h2><p>这里介绍了 MVCC 在<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行快照读操作时 访问记录的版本链的过程。这样使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。</p><p>核心点在于 ReadView 的原理，<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同 就是生成ReadView的时机不同：</p><p>*<code>READ COMMITTD</code>在每一次进行普通SELECT操作前都会生成一个ReadView<br>*<code>REPEATABLE READ</code>只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复 使用这个ReadView就好了。</p><blockquote><p>说明：我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除， 而是执行一个所谓的deletemark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的。</p></blockquote><p>通过MVCC我们可以解决：</p><ol><li><p>读写之间阻寨的问题。通过MVCC可以让读写互相不阳塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</p></li><li><p>降低了死锁的概率。这是因为MVCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</p></li><li><p>解决快照读的问题。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Contrastive Multiview Coding</title>
      <link href="/posts/b456fe1.html"/>
      <url>/posts/b456fe1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-摘要">1. 摘要</h2><div class="tabs" id="6798128c-286b-444b-b400-a070611978b1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b1-1"><i class="fas fa-cat"></i>翻译</button></li><li class="tab"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b1-2"><i class="fas fa-dove"></i>原文</button></li><li class="tab"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b1-3"><i class="fas fa-horse"></i>分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6798128c-286b-444b-b400-a070611978b1-1"><p>人类通过多种感官通道来观察世界，例如左眼看到的长波长光通道，或右耳听到的高频振动通道。每个视角都存在噪声和不完整性，但重要因素（例如物理、几何和语义）往往在所有视角之间共享（例如，“狗”可以被看到、听到和感受到）。我们研究了一个经典假设，即强大的表示应该模拟视角不变的因素。我们在多视角对比学习框架下研究了这个假设，学习一个旨在最大化相同场景不同视角之间的互信息的表示，但其它方面则非常紧凑。我们的方法适用于任意数量的视角，并且是视角无关的。我们分析了使其有效的关键属性，发现对比损失优于基于交叉视图预测的流行替代方案，并且我们从越多视角学习，结果表示就越好地捕捉底层场景语义。我们的方法在图像和视频无监督学习基准测试中取得了最先进的结果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6798128c-286b-444b-b400-a070611978b1-2"><p>Humans view the world through many sensory channels,e.g., the long-wavelength light channel, viewed by the left eye, or the high-frequency vibrations channel, heard by the right ear. Each view is noisy and incomplete, but important factors, such as physics, geometry, and semantics, tend to be shared between all views (e.g., a “dog” can be seen, heard, and felt). We investigate the classic hypothesis that a powerful representation is one that models view-invariant factors. We study this hypothesis under the framework of multiview contrastive learning, where we learn a representation that aims to maximize mutual information between different views of the same scene but is otherwise compact. Our approach scales to any number of views, and is viewagnostic. We analyze key properties of the approach that make it work, finding that the contrastive loss outperforms a popular alternative based on cross-view prediction, and that the more views we learn from, the better the resulting representation captures underlying scene semantics. Our approach achieves state-of-the-art results on image and video unsupervised learning benchmarks.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6798128c-286b-444b-b400-a070611978b1-3"><p>这篇论文主要探讨了一个假设，即强大的表示是一种模拟视角不变因素的表示。作者们在多视角对比学习的框架下，通过学习一个旨在最大化同一场景的不同视角之间的互信息的表示来验证这个假设。他们发现，对比损失胜过基于跨视图预测的流行替代方案，并且从更多的视角学习，结果表示能够更好地捕获基础场景语义。该方法在图像和视频无监督学习基准测试中实现了最先进的结果。这些发现可能会为进一步研究视角不变性在计算机视觉领域的应用提供启示。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-Introduction">2. Introduction</h2><div class="tabs" id="6798128c-286b-444b-b400-a070611978b2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b2-1"><i class="fas fa-cat"></i>翻译</button></li><li class="tab"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b2-2"><i class="fas fa-dove"></i>原文</button></li><li class="tab"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b2-3"><i class="fas fa-horse"></i>分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6798128c-286b-444b-b400-a070611978b2-1"><p>编码理论中的一个基本思想是学习压缩表示，但仍然可以用于重构原始数据。这个想法以自编码器[65]和生成模型[40,24]的形式出现在当代表示学习中，它们试图尽可能地无损地表示数据点或分布。然而，无损表示可能并不是我们真正想要的，而且实际上很容易实现——原始数据本身就是一种无损表示。相反，我们可能更喜欢保留“好”的信息（信号）并扔掉其余的信息（噪声）。我们如何确定哪些信息是信号，哪些是噪声呢？</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6798128c-286b-444b-b400-a070611978b2-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6798128c-286b-444b-b400-a070611978b2-3"><p>本段引入了编码理论中的基本思想：学习压缩表示，并介绍了在当代表示学习中出现的两种方法：自编码器和生成模型，它们旨在尽可能无损地表示数据点或分布。然而，作者指出无损表示可能不是我们真正需要的，因为原始数据本身就是一种无损表示。相反，我们更希望保留有用的信息（信号）而去掉无用的信息（噪声）。然后作者提出了问题：如何确定哪些信息是信号，哪些是噪声？这个问题是本文研究的出发点。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="6798128c-286b-444b-b400-a070611978b3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b3-1"><i class="fas fa-cat"></i>翻译</button></li><li class="tab"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b3-2"><i class="fas fa-dove"></i>原文</button></li><li class="tab"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b3-3"><i class="fas fa-horse"></i>分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6798128c-286b-444b-b400-a070611978b3-1"><p>对于自编码器或最大似然生成模型来说，一个比特就是一个比特。没有一个比特比其他任何比特更好。本文的猜测是，实际上有些比特比其他比特更好。一些比特编码了重要的属性，如语义、物理和几何，而其他一些比特编码的是我们可能认为不太重要的属性，如偶然的光照条件或相机传感器中的热噪声。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6798128c-286b-444b-b400-a070611978b3-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6798128c-286b-444b-b400-a070611978b3-3"><p>本段指出，对于自编码器或最大似然生成模型来说，所有比特都是平等的，没有一个比特比其他任何比特更好。但本文的猜测是，有些比特确实比其他比特更好。作者认为，一些比特编码了重要的属性，如语义、物理和几何，而其他一些比特编码的是我们可能认为不太重要的属性，如偶然的光照条件或相机传感器中的热噪声。这个猜测是本文的一个重要假设，是研究的出发点。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="6798128c-286b-444b-b400-a070611978b4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b4-1"><i class="fas fa-cat"></i>翻译</button></li><li class="tab"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b4-2"><i class="fas fa-dove"></i>原文</button></li><li class="tab"><button type="button" data-href="#6798128c-286b-444b-b400-a070611978b4-3"><i class="fas fa-horse"></i>分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6798128c-286b-444b-b400-a070611978b4-1"><p>我们重新审视了一个经典假设，即好的比特是在多种世界观的多个视图之间共享的，例如视觉、听觉和触觉等多个感官模式之间 [70]。从这个角度来看，“存在狗”的信息是好的信息，因为狗可以被看到、听到和感受到，但“相机姿态”的信息是不好的信息，因为相机的姿态对成像场景的声学和触觉属性几乎没有影响。这个假设对应于归纳偏差，即观察场景的方式不应影响其语义。在认知科学和神经科学文献中有大量证据表明，大脑编码这种视图不变的表示方法（例如，[70、15、32]）。在本文中，我们特别研究了不同图像通道之间的不同视图的情况，例如亮度、色度、深度和光流。我们利用自然数据中相同场景的多个视图的共现作为基本监督信号。例如，我们将Lab颜色空间中的图像视为场景两个视图的共现示例，即L视图和ab视图的配对示例：{L，ab}。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6798128c-286b-444b-b400-a070611978b4-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6798128c-286b-444b-b400-a070611978b4-3"><p>本段阐述了作者重新审视了一个经典假设，即好的比特是在多种世界观的多个视图之间共享的。在这种假设下，“存在狗”的信息是好的信息，因为狗可以被看到、听到和感受到，但“相机姿态”的信息是不好的信息。这个假设对应于归纳偏差，即观察场景的方式不应影响其语义。作者研究了不同图像通道之间的不同视图的情况，并将自然数据中相同场景的多个视图的共现作为基本监督信号。这个假设与认知科学和神经科学文献中的研究相吻合。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="d5826f3f-2acb-4f14-a9ab-ed8955cd90f5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d5826f3f-2acb-4f14-a9ab-ed8955cd90f5-1"><i class="fas fa-cat"></i>翻译</button></li><li class="tab"><button type="button" data-href="#d5826f3f-2acb-4f14-a9ab-ed8955cd90f5-2"><i class="fas fa-dove"></i>原文</button></li><li class="tab"><button type="button" data-href="#d5826f3f-2acb-4f14-a9ab-ed8955cd90f5-3"><i class="fas fa-horse"></i>分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d5826f3f-2acb-4f14-a9ab-ed8955cd90f5-1"><p>我们的目标是学习能够捕获多个传感通道之间共享信息的表示，同时抛弃通道特定的无用因素（如噪声）。为此，我们采用对比学习方法，学习一个特征嵌入，使得同一场景的不同视角映射到相邻的点（在表示空间中用欧几里得距离测量），而不同场景的视角映射到相距遥远的点。具体而言，我们改进了最近提出的对比预测编码（Contrastive Predictive Coding，CPC）方法[57]，去除了递归网络的部分，并将其推广到任意图像通道集合，而非仅限于时序或空间预测。我们称之为对比多视角编码（Contrastive Multiview Coding，CMC），尽管我们注意到，我们的公式与实例判别式[79] 也有很大关系。我们公式中的对比目标与 CPC 和实例判别式一样，可以理解为试图最大化数据多个视角表示之间的互信息。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d5826f3f-2acb-4f14-a9ab-ed8955cd90f5-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d5826f3f-2acb-4f14-a9ab-ed8955cd90f5-3"><p>本段介绍了作者的目标，即学习多个传感通道之间共享信息的紧凑表示，并抛弃通道特定的无用因素。为了达到这个目的，作者采用对比学习方法，学习一个特征嵌入，使得同一场景的不同视角映射到相邻的点，而不同场景的视角映射到相距遥远的点。作者改进了最近提出的对比预测编码方法，并将其推广到任意图像通道集合，称之为对比多视角编码。作者还提到，这个方法与实例判别式也有很大关系，其对比目标可以理解为试图最大化数据多个视角表示之间的互信息。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="42284e68-1044-410d-94bb-d148db3bbad1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#42284e68-1044-410d-94bb-d148db3bbad1-1"><i class="fas fa-cat"></i>翻译</button></li><li class="tab"><button type="button" data-href="#42284e68-1044-410d-94bb-d148db3bbad1-2"><i class="fas fa-dove"></i>原文</button></li><li class="tab"><button type="button" data-href="#42284e68-1044-410d-94bb-d148db3bbad1-3"><i class="fas fa-horse"></i>分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="42284e68-1044-410d-94bb-d148db3bbad1-1"><p>我们有意地将“好的位”（good bits）的定义保持宽泛，并将其定义作为一个经验问题。最终的证明在于实践：我们认为，如果一种表示能够使得后续的问题解决更容易，那么它就是一个好的表示，因为这些问题是与人类利益相关的。例如，图像的有用表示可能是一个特征空间，在这个特征空间中容易学习识别对象。因此，我们通过测试学习到的表示是否能够很好地转移应用于标准的语义识别任务来评估我们的方法。在几个基准任务中，我们的方法在自监督表示学习方面的表现与最先进的方法相比具有竞争力。我们还发现，表示的质量随着训练所用的视角数量的增加而提高。最后，我们将多视图学习的对比公式与最近流行的交叉视图预测方法进行比较，发现在比较中，对比方法学习到了更强的表示。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="42284e68-1044-410d-94bb-d148db3bbad1-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="42284e68-1044-410d-94bb-d148db3bbad1-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁</title>
      <link href="/posts/d940f18d.html"/>
      <url>/posts/d940f18d.html</url>
      
        <content type="html"><![CDATA[<p><code>锁</code>是计算机协调多个进程或线程<code>并发访问某一资源</code>的机制。在程序开发中会存在多线程同步的问题，当多个线程并发访问某个数据的时候，尤其是针对一些敏感的数据（比如订单、金额等），我们就需要保证这个数据在任何时刻<code>最多只有一个线程</code>在访问，保证数据的完整性和一致性。在开发过程中加锁是为了保证数据的一致性，这个思想在数据库领域中同样很重要。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的 资源。为保证数据的一致性，需要对<code>并发操作进行控制</code>，因此产生了<code>锁</code>。同时<code>锁机制</code>也为实现MySQL 的各个隔离级别提供了保证。<code>锁冲突</code>也是影响数据库<code>并发访问性能</code>的一个重要因素。所以锁对数据库而言显得尤其重要，也更加复杂。</p><hr><h2 id="1-MySQL并发事务访问相同记录">1. MySQL并发事务访问相同记录</h2><p>并发事务访问相同记录的情况大致可以划分为3种：</p><h3 id="1-1-读-读情况">1.1 读-读情况</h3><p><code>读-读</code>情况，即并发事务相继<code>读取相同的记录</code>。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p><h3 id="1-2-写-写情况">1.2 写-写情况</h3><p><code>写-写</code>情况，即并发事务相继对相同的记录做出改动。</p><p>在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<code>排队执行</code>，这个排队的过程其实是通过<code>锁</code>来实现的。这个所谓的锁其实是一个内存中的结构 ，在事务执行前本来是没有锁的，也就是说一开始是没有<code>锁结构</code>和<code>记录</code>进行关联的，如图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711181120639.png" alt="image-20220711181120639"></p><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的<code>锁结构</code>，当没有的时候 就会在内存中生成一个<code>锁结构</code>与之关联。比如，事务<code>T1</code>要对这条记录做改动，就需要生成一个<code>锁结构</code>与之关联：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711192633239.png" alt="image-20220711192633239" style="zoom:67%;" /><p>在<code>锁结构</code>里有很多信息，为了简化理解，只把两个比较重要的属性拿了出来：</p><p>*<code>trx信息</code>：代表这个锁结构是哪个事务生成的。<br>*<code>is_waiting</code>：代表当前事务是否在等待。</p><p>在事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称值为<code>获取锁成功</code>，或者<code>加锁成功</code>，然后就可以继续执行操作了。</p><p>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<code>获取锁失败</code>，或者<code>加锁失败</code>，图示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711193732567.png" alt="image-20220711193732567" style="zoom:50%;" /><p>在事务T1提交之后，就会把该事务生成的<code>锁结构释放</code>掉，然后看看还有没有别的事务在等待获取锁，发现了事务T2还在等待获取锁，所以把事务T2对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务T2就算获取到锁了。效果就是这样。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711194904328.png" alt="image-20220711194904328" style="zoom:50%;" /><p>小结几种说法：</p><ul><li><p>不加锁</p><p>意思就是不需要在内存中生成对应的<code>锁结构</code>，可以直接执行操作。</p></li><li><p>获取锁成功，或者加锁成功</p><p>意思就是在内存中生成了对应的<code>锁结构</code>，而且锁结构的<code>is_waiting</code>属性为<code>false</code>，也就是事务可以继续执行操作。</p></li><li><p>获取锁失败，或者加锁失败，或者没有获取到锁</p><p>意思就是在内存中生成了对应的<code>锁结构</code>，不过锁结构的<code>is_waiting</code>属性为<code>true</code>，也就是事务 需要等待，不可以继续执行操作。</p></li></ul><h3 id="1-3-读-写或写-读情况">1.3 读-写或写-读情况</h3><p><code>读-写</code>或<code>写-读</code>，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读 、不可重复读 、幻读</code>的问题。</p><p>各个数据库厂商对<code>SQL标准</code>的支持都可能不一样。比如MySQL在<code>REPEATABLE READ</code>隔离级别上就已经解决了<code>幻读</code>问题。</p><h3 id="1-4-并发问题的解决方案">1.4 并发问题的解决方案</h3><p>怎么解决<code>脏读 、不可重复读 、幻读</code>这些问题呢？其实有两种可选的解决方案：</p><ul><li><p>方案一：读操作利用多版本并发控制（<code>MVCC</code>，下章讲解），写操作进行<code>加锁</code>。</p><p>所谓的<code>MVCC</code>，就是生成一个<code>ReadView</code>，通过Readview找到符合条件的记录版本（历史版本由<code>undo日志</code>构建）。查询语句只能<code>读</code>到在生成ReadView之前<code>己提交事务所做的更改</code>，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而<code>写操作</code>肯定针对的是<code>最新版本的记录</code>，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，<code>读-写</code>操作并不冲突。</p></li></ul><blockquote><p>普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。</p><ul><li>在<code>READ COMMITTED</code>隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一 个ReadView，ReadView的存在本身就保证了<code>事务不可以读取到未提交的事务所做的更改</code>，也就是避免了脏读现象；</li><li>在<code>REPEATABLE READ</code>隔离级别下，一个事务在执行过程中只有<code>第一次执行SELECT操作</code>才会生成一个ReadView，之后的SELECT操作都<code>复用</code>这个ReadView，这样也就避免了不可重复读和幻读的问题。</li></ul></blockquote><ul><li><p>方案二：读、写操作都采用<code>加锁</code>的方式。</p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去<code>读取记录的最新版本</code>。比如，在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候就需要对其进行<code>加锁</code>操作，这样也就意味着<code>读操作</code>和<code>写操作</code>也像写-写操作那样排队执行。</p></li></ul><p><code>脏读</code>的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p><p><code>不可重复读</code>的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录， 自然也不会发生不可重复读了。</p><p><code>幻读</code>问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录。采用加锁的方式解决幻读问题就有一些麻烦，因为当前事务在第一次读取记录时幻影记录并不存在，所以读取的时候加锁就有点尴尬（因为你并不知道给谁加锁）</p><ul><li><p>小结对比发现：</p><ul><li>采用<code>MVCC</code>方式的话， 读-写操作彼此并不冲突， 性能更高 。</li><li>采用<code>加锁</code>方式的话， 读-写操作彼此需要<code>排队执行</code>，影响性能。</li></ul><p>一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行。下面就讲解下MySQL中不同类别的锁。</p></li></ul><hr><h2 id="2-锁的不同角度分类">2. 锁的不同角度分类</h2><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711203519162.png" alt="image-20220711203519162" style="zoom: 67%;" /><hr><h2 id="3-读锁-写锁">3. 读锁/写锁</h2><blockquote><mark class="hl-label green">从数据操作的类型划分：读锁、写锁</mark> </blockquote><p>对于数据库中并发事务的<code>读-读</code>情况并不会引起什么问题。对于<code>写-写</code>、<code>读-写</code>或<code>写-读</code>这些情况可能会引起一些问题，需要使用<code>MVCC</code>或者<code>加锁</code>的方式来解决它们。在使用<code>加锁</code>的方式解决问题时，由于既要允许<code>读-读</code>情况不受影响，又要使<code>写-写</code>、<code>读-写</code>或<code>写-读</code>情况中的操作相互阻塞，所以MySQL实现一个由两种类型的锁组成的锁系统来解决。这两种类型的锁通常被称为<span class='p red'>共享锁 Shared Lock</span>和<span class='p green'>排他锁 Exclusive Lock</span>也叫<span class='p red'>读锁 readlock</span>和<span class='p green'>写锁 write lock</span></p><p>*<code>读锁</code>：也称为<code>共享锁</code>、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。<br>*<code>写锁</code>：也称为<code>排他锁</code>、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p><span class='p blue'>需要注意的是对于InnoDB引擎来说，读锁和写锁可以加在表上，也可以加在行上。</span><br/><p>举例行级读写锁 ：如果一个事务T1已经获得了某个行r的读锁，那么此时另外的一个事务 T2 是可以去获得这个行r的读锁的，因为读取操作并没有改变行r的数据；但是，如果某个事务 T3 想获得行r的写锁，则它必须等待事务 T1、T2释放掉行r上的读锁才行。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">写锁</th><th style="text-align:center">读锁</th></tr></thead><tbody><tr><td style="text-align:center">写</td><td style="text-align:center">不兼容</td><td style="text-align:center">不兼容</td></tr><tr><td style="text-align:center">读锁</td><td style="text-align:center">不兼容</td><td style="text-align:center">兼容</td></tr></tbody></table><p>总结：这里的兼容是指对同一张表或记录的锁的兼容性情况。</p><hr><mark class="hl-label pink">锁定读</mark> <p>在采用<code>加锁</code>方式解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题时，读取一条记录时需要获取该记录的<code>S锁</code>，其实是不严谨的，有时候需要在读取记录时就获取记录的<code>X锁</code>，来禁止别的事务读写该记录，为此MySQL提出了两种比较特殊的<code>SELECT</code>语句格式：</p><ul><li>对读取的记录加<code>S锁</code>：</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE; #(<span class="number">8.0</span>新增语法)</span><br></pre></td></tr></table></figure><p>在普通的<code>SELECT</code>语句后边加<code>LOCK IN SHARE MODE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>S锁</code>，这样允许别的事务继续获取这些记录的<code>S锁</code>（比方说别的事务也使用 SELECT … LOCK IN SHARE MODE 语句来读取这些记录），但是不能获取这些记录的<code>X锁</code>（比如使用<code>SELECT .... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>S锁</code>释放掉。</p><ul><li>对读取的记录加<code>X锁</code>：</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>在普通的<code>SELECT</code>语句后边加<code>FOR UPDATE</code>，如果当前事务执行了该语句，那么它会为读取到的记录加<code>X锁</code>， 这样既不允许别的事务获取这些记录的<code>S锁</code>（比方说别的事务使用<code>SELECT .... LOCK IN SHARE MODE</code>语句来读取这些记录），也不允许获取这些记录的<code>X锁</code>（比如使用<code>SELECT ... FOR UPDATE</code>语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的<code>S锁</code>或者<code>X锁</code>，那么它们会阻塞，直到当前事务提交之后将这些记录上的<code>X锁</code>释放掉。</p><span class='p red'>MySQL8.0新特性</span><p>在5.7及之前的版本，<code>SELECT ...FOR UPDATE</code>，如果获取不到锁，会一直等待，直到<code>innodb_ lock_wait_timeout</code>超时。在8.0版本中，<code>SELECT ... FOR UPDATE</code>,<code>SELECT ... FOR SHARE</code>添加<code>NOWAIT</code>、<code>SKIP LOCKED</code>语法，跳过锁等待，或者跳过锁定。</p><ul><li>通过添加NOWAIT、SKIP LOCKED语法，能够立即返回。如果查询的行已经加锁：<ul><li>那么NOWAIT会立即报错返回</li><li>而SKIP LOCKED也会立即返回，只是返回的结果中不包含被锁定的行。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># session1:</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysgl<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>  c1  <span class="operator">|</span>  c2  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span>   <span class="operator">|</span> <span class="number">60530</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span>   <span class="operator">|</span> <span class="number">24678</span><span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"># session2:</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span> nowait；</span><br><span class="line">ERROR <span class="number">3572</span> (HY000): Statement aborted because lock(s) could <span class="keyword">not</span> be acquired immediately <span class="keyword">and</span> NOWAIT <span class="keyword">is</span> set.</span><br><span class="line">mysgl<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> c1 <span class="operator">=</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">skip</span> locked;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><hr><blockquote><mark class="hl-label pink">写操作</mark> </blockquote><p>平常所用到的写操作无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种：</p><p>-<code>DELETE</code></p><p>对一条记录做DELETE操作的过程其实是先在<code>B+树</code>中定位到这条记录的位置，然后获取这条记录的<code>X锁</code>，再执行<code>delete mark</code>操作。我们也可以把这个定位待删除记录在B+树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p><p>-<code>UPDATE</code>： 在对一条记录做UPDATE操作时分为三种情况</p><ul><li>情况1：未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在<code>B+树</code>中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+ 树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</li><li>情况2：未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在<code>B+树</code>中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在B+ 树中位置的过程看成是一个获取〉 锁的锁定读，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li><li>情况3：修改了该记录的健值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。</li></ul><p>-<code>INSERT</code></p><p>一般情况下，新插入一条记录的操作并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p><hr><h2 id="4-表级锁-页级锁-行锁">4. 表级锁/页级锁/行锁</h2><blockquote><mark class="hl-label green">从数据操作的粒度划分：表级锁、页级锁、行锁</mark> </blockquote><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很<code>耗资源</code>的事情（涉及获取、检查、释放锁等动作）。因此数据库系统需要在<code>高并发响应</code>和<code>系统性能</code>两方面进行平衡，这样就产生了：<code>锁粒度(Lock granularity)</code>的概念。</p><p>对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在<code>表级别</code>进行加锁，自然就被称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。锁的粒度主要分为表级锁、页级锁和行锁。</p><hr><h3 id="4-1-表锁（Table-Lock）">4.1 表锁（Table Lock）</h3><p>该锁会锁定整张表，它是 MySQL 中最基本的锁策略，<code>并不依赖于存储引擎</code>（不管你是 MySQL 的什么存储引擎， 对于表锁的策略都是一样的），并且表锁是<code>开销最小</code>的策略（因为粒度比较大）。由于表级锁一次会将整个表锁定，所以可以很好的<code>避免死锁</code>问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致<code>并发率大打折扣</code>。</p><hr><h4 id="4-1-1-表级别的S锁、X锁">4.1.1 表级别的S锁、X锁</h4><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的<code>S锁</code>或者<code>X锁</code>的。在对某个表执行一些诸如<code>ALTER TABLE 、 DROP TABLE</code>这类的 DDL 语句时，其 他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行<code>DDL</code>语句也会 发生阻塞。这个过程其实是通过在 server层使用一种称之为<code>元数据锁</code>（英文名： Metadata Locks ， 简称 MDL ）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的<code>S锁</code>和<code>X锁</code>。只会在一些特殊情况下，比方说<code>崩溃恢复</code>过程中用到。比如，在系统变量<code>autocommit=0，innodb_table_locks = 1</code>时， 手动 获取 InnoDB存储引擎提供的表t 的<code>S锁</code>或者<code>X锁</code>可以这么写：</p><p>*<code>LOCK TABLES t READ</code>：InnoDB存储引擎会对表 t 加表级别的<code>S锁</code>。</p><p>*<code>LOCK TABLES t WRITE</code>：InnoDB存储引擎会对表 t 加表级别的<code>X锁</code>。</p><p>不过尽量避免在使用InnoDB存储引擎的表上使用<code>LOCK TABLES</code>这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的厉害之处还是实现了更细粒度的<code>行锁</code>，关于 InnoDB表级别的<code>S锁</code>和<code>X锁</code>大家了解一下就可以了。</p><mark class="hl-label blue">举例：下面我们讲解MyISAM引擎下的表锁</mark>  <div class="tabs" id="0f4dc028-1f6c-4356-9c0f-108a3a87687e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0f4dc028-1f6c-4356-9c0f-108a3a87687e-1"><i class="fas fa-atom"></i>创建表并添加数据</button></li><li class="tab"><button type="button" data-href="#0f4dc028-1f6c-4356-9c0f-108a3a87687e-2"><i class="far fa-sun"></i>查看表上加过的锁</button></li><li class="tab"><button type="button" data-href="#0f4dc028-1f6c-4356-9c0f-108a3a87687e-3"><i class="fas fa-wind"></i>手动增加表锁命令</button></li><li class="tab"><button type="button" data-href="#0f4dc028-1f6c-4356-9c0f-108a3a87687e-4"><i class="fas fa-fire-alt"></i>释放表锁</button></li><li class="tab"><button type="button" data-href="#0f4dc028-1f6c-4356-9c0f-108a3a87687e-5"><i class="fas fa-heartbeat"></i>加读锁</button></li><li class="tab"><button type="button" data-href="#0f4dc028-1f6c-4356-9c0f-108a3a87687e-6"><i class="fas fa-cookie-bite"></i>加写锁</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0f4dc028-1f6c-4356-9c0f-108a3a87687e-1"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mylock(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY auto_increment,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)ENGINE MYISAM;</span><br><span class="line"></span><br><span class="line"># 插入一条数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mylock(NAME) <span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 查询表中所有数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mylock;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> Name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> a    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0f4dc028-1f6c-4356-9c0f-108a3a87687e-2"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES; # 主要关注In_use字段的值</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> TABLES <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711220342251.png" alt="image-20220711220342251" style="zoom: 50%;" /><p>或者</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711220418859.png" alt="image-20220711220418859"  /><p>上面的结果表明，当前数据库中没有被锁定的表</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0f4dc028-1f6c-4356-9c0f-108a3a87687e-3"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES t READ; # 存储引擎会对表t加表级别的共享锁。共享锁也叫读锁或S锁（Share的缩写）</span><br><span class="line">LOCK TABLES t WRITE; # 存储引擎会对表t加表级别的排他锁。排他锁也叫独占锁、写锁或X锁（exclusive的缩写）</span><br></pre></td></tr></table></figure><p>比如：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711220442269.png" alt="image-20220711220442269"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0f4dc028-1f6c-4356-9c0f-108a3a87687e-4"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNLOCK TABLES; # 使用此命令解锁当前加锁的表</span><br></pre></td></tr></table></figure><p>比如：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711220502141.png" alt="image-20220711220502141"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0f4dc028-1f6c-4356-9c0f-108a3a87687e-5"><p>我们为mylock表加read锁（读阻塞写），观察阻塞的情况，流程如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711220553225.png" alt="image-20220711220553225" style="zoom:67%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711220616537.png" alt="image-20220711220616537" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0f4dc028-1f6c-4356-9c0f-108a3a87687e-6"><p>为mylock表加write锁，观察阻塞的情况，流程如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711220711630.png" alt="image-20220711220711630" style="zoom:67%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711220730112.png" alt="image-20220711220730112" style="zoom: 67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <mark class="hl-label blue">总结</mark> <p>MyISAM在执行查询语句（SELECT）前，会给涉及的所有表加读锁，在执行增删改操作前，会给涉及的表加写锁。InnoDB存储引擎是不会为这个表添加表级别的读锁和写锁的。</p><p>MySQL的表级锁有两种模式：（以MyISAM表进行操作的演示）</p><ul><li><p>表共享读锁（Table Read Lock）</p></li><li><p>表独占写锁（Table Write Lock）</p><table><thead><tr><th style="text-align:center">锁类型</th><th style="text-align:center">自己可读</th><th style="text-align:center">自己可写</th><th style="text-align:center">自己可操作其他表</th><th style="text-align:center">他人可读</th><th style="text-align:center">他人可写</th></tr></thead><tbody><tr><td style="text-align:center">读锁</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否，等</td></tr><tr><td style="text-align:center">写锁</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否，等</td><td style="text-align:center">否，等</td></tr></tbody></table></li></ul><hr><h4 id="4-1-2-意向锁-intention-lock">4.1.2 意向锁(intention lock)</h4><p>InnoDB 支持<code>多粒度锁（multiple granularity locking）</code>，它允许<code>行级锁</code>与<code>表级锁</code>共存，而<code>意向锁</code>就是其中的一种<code>表锁</code>。</p><ol><li>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁和行锁）的锁并存。</li><li>意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。</li><li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li></ol><p>意向锁分为两种：</p><ul><li>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><ul><li>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>即：意向锁是由存储引擎<code>自己维护的</code>，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前， InooDB 会先获取该数据行<code>所在数据表的对应意向锁</code>。</p><mark class="hl-label green">意向锁要解决的问题</mark> <p>现在有两个事务，分别是T1和T2，其中T2试图在该表级别上应用共享或排它锁，如果没有意向锁存在，那么T2就需要去检查各个页或行是否存在锁；如果存在意向锁，那么此时就会受到由T1控制的<code>表级别意向锁的阻塞</code>。T2在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。简单来说就是给更大一级别的空间示意里面是否已经上过锁。</p><p>在数据表的场景中，<span class='p red'>如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表己经有人上过排它锁了</span>，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。</p><ul><li><p>如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。</p></li><li><p>如果事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。</p></li></ul><p>这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录。</p><blockquote><p>举例</p></blockquote><div class="tabs" id="bd12d2a2-cd7b-45bd-9379-5b0ad79a5758"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#bd12d2a2-cd7b-45bd-9379-5b0ad79a5758-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#bd12d2a2-cd7b-45bd-9379-5b0ad79a5758-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#bd12d2a2-cd7b-45bd-9379-5b0ad79a5758-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#bd12d2a2-cd7b-45bd-9379-5b0ad79a5758-4"><i class="fas fa-tree"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="bd12d2a2-cd7b-45bd-9379-5b0ad79a5758-1"><p>创建表teacher,插入6条数据，事务的隔离级别默认为<code>Repeatable-Read</code>，如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`teacher`(</span><br><span class="line">`id`<span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name`<span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`teacher`<span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;zhaoliu&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;songhongkang&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;leifengyang&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@transaction</span>_isolation <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd12d2a2-cd7b-45bd-9379-5b0ad79a5758-2"><p>假设事务A获取了某一行的排他锁，并未提交，语句如下所示:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>事务B想要获取teacher表的表读锁，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd12d2a2-cd7b-45bd-9379-5b0ad79a5758-3"><p>因为共享锁与排他锁互斥，所以事务B 在试图对 teacher 表加共享锁的时候，必须保证两个条件。</p><p>(1) 当前没有其他事务持有 teacher 表的排他锁</p><p>(2) 当前没有其他事务持有 teacher 表中任意一行的排他锁。</p><p>为了检测是否满足第二个条件，事务B必须在确保 teacher 表不存在任何排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd12d2a2-cd7b-45bd-9379-5b0ad79a5758-4"><p>意向锁是怎么解决这个问题的呢？首先，我们需要知道意向锁之间的兼容互斥性，如下所示。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220712124209006.png" alt="image-20220712124209006"  /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>此时teacher表存在两把锁：teacher表上的意向排他锁与id未6的数据行上的排他锁。事务B想要获取teacher表的共享锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>此时事务B检测事务A持有teacher表的意向排他锁，就可以得知事务A必须持有该表中某些数据行的排他锁，那么事务B对teacher表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排他锁。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label green">意向锁的并发性</mark> <p>意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）</p><p>我们扩展一下上面 teacher表的例子来概括一下意向锁的作用（一条数据从被锁定到被释放的过程中，可 能存在多种不同锁，但是这里我们只着重表现意向锁）。</p><p>事务A先获得了某一行的排他锁，并未提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>事务A获取了teacher表上的意向排他锁。事务A获取了id为6的数据行上的排他锁。之后事务B想要获取teacher表上的共享锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">LOCK TABLES teacher READ;</span><br></pre></td></tr></table></figure><p>事务B检测到事务A持有teacher表的意向排他锁。事务B对teacher表的加锁请求被阻塞（排斥）。最后事务C也想获取teacher表中某一行的排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>事务C申请teacher表的意向排他锁。事务C检测到事务A持有teacher表的意向排他锁。因为意向锁之间并不互斥，所以事务C获取到了teacher表的意向排他锁。因为id为5的数据行上不存在任何排他锁，最终事务C成功获取到了该数据行上的排他锁。</p><p>从上面的案例可以得到如下结论：</p><ol><li>InnoDB 支持<code>多粒度锁</code>，特定场景下，行级锁可以与表级锁共存。</li><li>意向锁之间互不排斥，但除了 IS 与 S 兼容外，<code>意向锁会与 共享锁 / 排他锁 互斥</code>。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li><li>意向锁在保证并发性的前提下，实现了<code>行锁和表锁共存</code>且<code>满足事务隔离性</code>的要求。</li></ol><hr><h4 id="4-1-3-自增锁-AUTO-INC锁">4.1.3 自增锁(AUTO-INC锁)</h4><p>在使用MySQL过程中，我们可以为表的某个列添加<code>AUTO_INCREMENT</code>属性。举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`teacher`(</span><br><span class="line">`id`<span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`name`<span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci;</span><br></pre></td></tr></table></figure><p>由于这个表的id字段声明了AUTO_INCREMENT，意味着在书写插入语句时不需要为其赋值，SQL语句修改 如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`teacher`(name) <span class="keyword">VALUES</span> (<span class="string">&#x27;zhangsan&#x27;</span>), (<span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上边的插入语句并没有为id列显式赋值，所以系统会自动为它赋上递增的值，结果如下所示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> teacher;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> zhangsan <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> lisi     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>现在我们看到的上面插入数据只是一种简单的插入模式，所有插入数据的方式总共分为三类，分别是 “<code>Simple inserts</code>”，“<code>Bulk inserts</code>”和“<code>Mixed-mode inserts</code>”。</p><div class="tabs" id="4434cedb-9dd6-40ab-a889-79476e2dbea7"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4434cedb-9dd6-40ab-a889-79476e2dbea7-1"><i class="fas fa-atom"></i>1.Simple inserts(简单插入)</button></li><li class="tab"><button type="button" data-href="#4434cedb-9dd6-40ab-a889-79476e2dbea7-2"><i class="far fa-sun"></i>2.Bulk inserts(批量插入)</button></li><li class="tab"><button type="button" data-href="#4434cedb-9dd6-40ab-a889-79476e2dbea7-3"><i class="fas fa-wind"></i>3.Mixed-mode inserts(混合模式插入)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4434cedb-9dd6-40ab-a889-79476e2dbea7-1"><p>可以<code>预先确定要插入的行数</code>（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行<code>INSERT...VALUES()</code>和<code>REPLACE</code>语句。比如我们上面举的例子就属于该类插入，已经确定要插入的行 数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4434cedb-9dd6-40ab-a889-79476e2dbea7-2"><p><code>事先不知道要插入的行数</code>（和所需自动递增值的数量）的语句。比如<code>INSERT ... SELECT</code>，<code>REPLACE ... SELECT</code>和<code>LOAD DATA</code>语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4434cedb-9dd6-40ab-a889-79476e2dbea7-3"><p>这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如<code>INSERT INTO teacher (id,name) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');</code>只是指定了部分id的值。另一种类型的“混合模式插入”是<code>INSERT ... ON DUPLICATE KEY UPDATE</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>对于上面数据插入的案例，MysQL中采用了<code>自增锁</code>的方式来实现，<span class='p red'>AUTO-INC锁是当向使用含有AUTO_INCREMENT 列的表中插入数据时需要获取的一种特殊的表级锁</span>，在执行插入语句时就在表级别加一个AUTO-INC锁，然后为每条待插入记录的AUTO_INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC锁释放掉。<span class='p red'>一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞</span>，可以保证一个语句中分配的递增值是连续的。也正因为此，其并发性显然并不高，当我们向一个有AUTO_INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争，这样的并发潜力其实是很低下的，所以innodb通过<code>innodb_autoinc-lock-mode</code>的不同取值来提供不同的锁定机制，来显著提高SQL语句的可伸缩性和性能。</p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><div class="tabs" id="651b2759-d9b3-4f0d-a0dd-ea3da71236e5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#651b2759-d9b3-4f0d-a0dd-ea3da71236e5-1"><i class="fas fa-award"></i>0(“传统”锁定模式)</button></li><li class="tab"><button type="button" data-href="#651b2759-d9b3-4f0d-a0dd-ea3da71236e5-2"><i class="fas fa-baseball-ball"></i>1(“连续”锁定模式)</button></li><li class="tab"><button type="button" data-href="#651b2759-d9b3-4f0d-a0dd-ea3da71236e5-3"><i class="fas fa-bone"></i>2(“交错”锁定模式)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="651b2759-d9b3-4f0d-a0dd-ea3da71236e5-1"><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。这种模式其实就如我们上面的例子，即每当执行insert的时候，都会得到一个 表级锁(AUTO-INC锁)，使得语句中生成的auto_increment为顺序，且在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会<code>限制并发</code>能力。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="651b2759-d9b3-4f0d-a0dd-ea3da71236e5-2"><p>在 MySQL 8.0 之前，连续锁定模式是<code>默认</code>的。</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。这适用于所有INSERT … SELECT，REPLACE … SELECT和LOAD DATA语句。同一时刻只有一个语句可以持有AUTO-INC锁。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在<code>mutex（轻量锁）</code>的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="651b2759-d9b3-4f0d-a0dd-ea3da71236e5-3"><p>从 MySQL 8.0 开始，交错锁模式是<code>默认</code>设置。</p><p>在此锁定模式下，自动递增值<code>保证</code>在所有并发执行的所有类型的insert语句中是<code>唯一</code>且<code>单调递增</code>的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能不是连续的。</p><p>如果执行的语句是“simple inserts&quot;，其中要插入的行数已提前知道，除了&quot;Mixed-mode inserts&quot;之外，为单个语句生成的数字不会有间隙。然后，当执行&quot;bulk inserts&quot;时，在由任何给定语句分配的自动递增值中可能存在间隙。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h4 id="4-1-4-元数据锁-MDL锁">4.1.4 元数据锁(MDL锁)</h4><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个<code>表结构做变更</code>，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删查改。读写锁之间、写锁之间都是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。<code>不需要显式使用</code>，在访问一个表的时候会被自动加上。</p><p>举例：元数据锁的使用场景模拟</p><p>会话A：从表中查询数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> teacher;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="type">int</span> <span class="keyword">set</span> (<span class="number">7.46</span> sec)</span><br></pre></td></tr></table></figure><p>会话B：修改表结构，增加新列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>会话C：查看当前MySQL的进程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713142808924.png" alt="image-20220713142808924"></p><p>通过会话C可以看出会话B被阻塞，这是由于会话A拿到了teacher表的元数据读锁，会话B想申请teacher表的元数据写锁，由于读写锁互斥，会话B需要等待会话A释放元数据锁才能执行。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713143156759.png" alt="image-20220713143156759" /><hr><h3 id="4-2-行锁（Row-Lock）">4.2 行锁（Row Lock）</h3><p>行锁（Row Lock）也称为记录锁，顾名思义，就是锁住某一行（某条记录 row）。需要注意的是，MySQL服务器层并没有实现行锁机制，<span class='p green'>行级锁只在存储引擎层实现</span>。</p><p>优点：锁定力度小，发生<code>锁冲突概率低</code>，可以实现的<code>并发度高</code>。</p><p>缺点：对于<code>锁的开销比较大</code>，加锁会比较慢，容易出现<code>死锁</code>情况。</p><p>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。</p><p>首先我们创建表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    class <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>向这个表里插入几条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;一班&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;一班&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;二班&#x27;</span>),</span><br><span class="line">(<span class="number">15</span>, <span class="string">&#x27;赵六&#x27;</span>, <span class="string">&#x27;二班&#x27;</span>),</span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;钱七&#x27;</span>, <span class="string">&#x27;三班&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713161549241.png" alt="image-20220713161549241"  /><p>student表中的聚簇索引的简图如下所示。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713163353648.png" alt="image-20220713163353648"></p><p>这里把B+树的索引结构做了超级简化，只把索引中的记录给拿了出来，下面看看都有哪些常用的行锁类型。</p><hr><h4 id="4-2-1-记录锁">4.2.1 记录锁</h4><p>记录锁也就是仅仅把一条记录锁，官方的类型名称为：<code>LOCK_REC_NOT_GAP</code>。比如我们把id值为8的那条记录加一个记录锁的示意图如果所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713164811567.png" alt="image-20220713164811567" style="zoom:50%;" /><p>举例如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713164948405.png" alt="image-20220713164948405" style="zoom: 50%;" /><p>记录锁是有S锁和X锁之分的，称之为<code>S型记录锁</code>和<code>X型记录锁</code>。</p><ul><li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li><li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li></ul><hr><h4 id="4-2-2-间隙锁">4.2.2 间隙锁</h4><p><code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方 案解决，也可以采用<code>加锁</code>方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些<code>幻影记录</code>加上<code>记录锁</code>。InnoDB提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们可以简称为<code>gap锁</code>。比如，把id值为8的那条记录加一个gap锁的示意图如下。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713171650888.png" alt="image-20220713171650888" style="zoom:50%;" /><p>图中id值为8的记录加了gap锁，意味着<code>不允许别的事务在id值为8的记录前边的间隙插入新记录</code>，其实就是id列的值(3, 8)这个区间的新记录是不允许立即插入的。比如，有另外一个事务再想插入一条id值为4的新记录，<span class='p green'>它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作</span> ，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3, 8)中的新记录才可以被插入。<span class='p red'>gap锁的提出仅仅是为了防止插入幻影记录而提出的。</span>虽然共享gap锁和独占gap锁这样的说法，但是它们起到的作用是相同的。而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p><p>举例：</p><table><thead><tr><th style="text-align:left">Session1</th><th>Session2</th></tr></thead><tbody><tr><td style="text-align:left">select * from student where id=5 lock in share mode;</td><td></td></tr><tr><td style="text-align:left"></td><td>select * from student where id=5 for update;</td></tr></tbody></table><p>这里session2并不会被堵住。因为表里并没有id=5这条记录，因此session1加的是间隙锁(3,8)。而session2也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙锁，不允许插入值。但，它们之间是不冲突的。<span class='p red'>(PS:若Session1和Session2都想在这个间隙插入数据，那就会发生死锁，都在等待对方的间隙锁释放)</span></p><p>注意，给一条记录加了<code>gap锁</code>只是<code>不允许</code>其他事务往这条记录前边的间隙<code>插入新记录</code>，那对于最后一条记录之后的间隙，也就是student 表中id值为<code>20</code>的记录之后的间隙该咋办呢？也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>id</code>值在<code>(20，+∞）</code>这个区间的新记录呢？这时候我们在讲数据页时介绍的两条伪记录派上用场了：</p><p>*<code>Infimum</code>记录，表示该页面中最小的记录。<br>*<code>Supremun</code>记录，表示该页面中最大的记录。</p><p>为了实现阻止其他事务插入id值再(20,正无穷)这个区间的新纪录，我们可以给索引中的最后一条记录，也就是id值为20的那条记录所在页面的Supremun记录加 上一个gap锁，如图所示。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713174108634.png" alt="image-20220713174108634" style="zoom:50%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">20</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>检测：</p><div class="fj-gallery"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230414220905714.png" alt="image-20230414220905714"></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230414220939203.png" alt="image-20230414220939203"></p>          </div><p>这样就可以阻止其他事务插入id值在(20，+∞)这个区间的新记录。</p><p>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。下面的例子会产生<code>死锁</code></p><table><thead><tr><th>Session1</th><th>Session2</th></tr></thead><tbody><tr><td>begin;<br/>select * from student where id = 5 for update;</td><td>begin;<br/>select * from student where id 5 for update;</td></tr><tr><td></td><td>INSERT INTO student VALUES (5, ‘宋红康’，'‘二班’);阻塞</td></tr><tr><td>INSERT INTO student VALUES (5,‘宋红康’，‘二班’）; <br/> (ERROR 1213 (40001): Deadlock found when trying to get lock;try restarting transaction)</td><td></td></tr></tbody></table><p>(1) session 1执行 select… for update 语句，由于id=5这一行并不存在，因此会加上间隙锁(3, 8)；</p><p>(2) session 2 执行 select… for update 语句，同样会加上间隙锁（3，8)，间隙锁之间不会冲突，因此这个语句可以执行成功</p><p>(3) session 2 试图插入一行(5,‘宋红康’，‘二班’），被 session 1 的间隙锁挡住了，只好进入等待；</p><p>(4) session 1 试图插入一行(5,‘宋红康’，‘二班’），被 session 2 的间隙锁挡住了。至此，两个 session 进入互相等待状态，形成死锁。当然，InnoDB 的死锁检测马上就发现了这对死锁关系，让 session 1 的 insert 语句报错返回。</p><hr><h4 id="4-2-3-临键锁">4.2.3 临键锁</h4><p>有时候我们既想<code>锁住某条记录</code>，又想阻止其他事务在该记录前边的间隙插入新记录 ，所以InnoDB就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， <span class='p green'>innodb默认的锁就是Next-Key locks。</span>比如，我们把id值为8的那条记录加一个next-key锁的示意图如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713192549340.png" alt="image-20220713192549340" style="zoom:50%;" /><p><code>next-key锁</code>的本质就是一个<code>记录锁</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">8</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="4-2-4-插入意向锁">4.2.4 插入意向锁</h4><p>我们说一个事务在<code>插入</code>一条记录时需要判断一下插入位置是不是被别的事务加了<code>gap锁</code>(<code>next-key锁</code>也包含<code>gap锁</code>），如果有的话，插入操作需要等待，直到拥有 gap锁的那个事务提交。但是<span class='p red'>InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构</span>，表明有事务想在某个<code>间隙</code>中<code>插入</code>新记录，但是现在在等待。InnoDB就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们称为<code>插入意向锁</code>。插入意向锁是一种<code>Gap锁</code>，不是意向锁，在insert操作时产生。</p><p>插入意向锁是在插入一条记录行前，由<code>INSERT 操作产生的一种间隙锁</code>。该锁用以表示插入意向，当多个事务在同一区间（gap)插入位置不同的多条数据时，事务之间不需要互相等待。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为5和6的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7）之间的间隙锁，但是因为数据行之间并<code>不冲突</code>，所以两个事务之间并不会产生冲突（阻塞等待）， 总结来说，插入意向锁的特性可以分成两部分：</p><p>(1）插入意向锁是一种<code>特殊的间隙锁</code>—间隙锁可以锁定开区间内的部分记录。</p><p>(2) 插入意向锁之间<code>互不排斥</code>，所以即使多个事务在同一区间插入多条记录，只要记录本身（主键、唯一索引）不冲突，那么事务之问就不会出现冲突等待。</p><p>注意，虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是<code>行锁</code>。</p><div class="fj-gallery"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713203532124.png" alt="image-20220713203532124"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713203619704.png" alt="image-20220713203619704" />          </div><hr><h3 id="4-3-页锁（Page-Lock）">4.3 页锁（Page Lock）</h3><p>页锁就是在<code>页的粒度</code>上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我 们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<span class='p green'>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</span></p><p>每个层级的锁数量是有限制的，因为锁会占用内存空间，<code>锁空间的大小是有限的</code>。当某个层级的锁数量 超过了这个层级的阈值时，就会进行<code>锁升级</code>。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p><hr><h2 id="5-乐观锁-悲观锁">5. 乐观锁/悲观锁</h2><mark class="hl-label green">从对待锁的态度划分:乐观锁、悲观锁</mark> <p>从对待锁的态度来看锁的话，可以将锁分成乐观锁和悲观锁，从名字中也可以看出这两种锁是两种看待<code>数据并发的思维方式</code>。需要注意的是，乐观锁和悲观锁并不是锁，而是锁的<code>设计思想</code>。</p><h3 id="5-1-悲观锁-Pessimistic-Locking">5.1 悲观锁(Pessimistic Locking)</h3><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。</p><p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>阻塞</code>直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p><strong>秒杀案例1：</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713204544767.png" alt="image-20220713204544767"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713205010502.png" alt="image-20220713205010502"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713205135694.png" alt="image-20220713205135694"  /><hr><h3 id="5-2-乐观锁-Optimistic-Locking">5.2 乐观锁(Optimistic Locking)</h3><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<span class='p green'>不采用数据库自身的锁机制</span>，而是通过程序来实现。在程序上，我们可以采用<code>版本号机制</code>或者<code>CAS机制</code>实现。<span class='p green'>乐观锁适用于多读的应用类型， 这样可以提高吞吐量</span>。在Java中<code>java.util.concurrent.atomic</code>包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p><mark class="hl-label pink">1.乐观锁的版本号机制</mark> <p>在表中设计一个<code>版本字段 version</code>，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行<code>UPDATE ... SET version=version+1 WHERE version=version</code>。此时 如果已经有事务对这条数据进行了更改，修改就不会成功。</p><p>这种方式类似我们熟悉的SVN、CVS版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p><mark class="hl-label pink">2.乐观锁的时间戳机制</mark> <p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行 比较，如果两者一致则更新成功，否则就是版本冲突。</p><p>你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或者时间戳），从而证明当前拿到的数据是否最新。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713210951100.png" alt="image-20220713210951100"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713211139670.png" alt="image-20220713211139670"  /><hr><h3 id="5-3-两种锁的适用场景">5.3 两种锁的适用场景</h3><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p><p>1.<code>乐观锁</code>适合<code>读操作多</code>的场景，相对来说写的操作比较少。它的优点在于<code>程序实现</code>，<code>不存在死锁</code>问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。<br>2.<code>悲观锁</code>适合<code>写操作多</code>的场景，因为写的操作具有<code>排它性</code>。采用悲观锁的方式，可以在数据库层 面阻止其他事务对该数据的操作权限，防止<code>读 - 写</code>和<code>写 - 写</code>的冲突。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713211417909.png" alt="image-20220713211417909" /><hr><h2 id="6-显式锁-隐式锁">6. 显式锁/隐式锁</h2><mark class="hl-label green">按加锁的方式划分：显式锁、隐式锁</mark> <h3 id="6-1-隐式锁">6.1 隐式锁</h3><p>一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT</code>操作是不加锁的。那如果一个事务首先插入了一条记录（此时并没有在内存生产与该记录关联的锁结构），然后另一个事务：</p><ul><li><p>立即使用<code>SELECT ... LOCK IN SHARE MODE</code>语句读取这条记录，也就是要获取这条记录的S锁，或者使用<code>SELECT ... FOR UPDATE</code>语句读取这条记录，也就是要获取这条记录的<code>X锁</code>，怎么办？</p><p>如果允许这种情况的发生，那么可能产生脏读问题。</p></li><li><p>立即修改这条记录，也就是要获取这条记录的x锁，怎么办？</p><p>如果允许这种情况的发生，那么可能产生脏写问题。</p></li></ul><p>这时候我们前边提过的<code>事务id</code>又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：</p><ul><li><strong>情景一</strong>：对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务 id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</li><li><strong>情景二</strong>：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。</li></ul><p>即：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构， 然后自己再生成一个锁结构后进入等待状态。隐式锁是一种<code>延迟加锁</code>的机制，从而来减少加锁的数量。</p><p>隐式锁在实际内存对象中并不含有这个锁信息。只有当产生锁等待时，隐式锁转化为显式锁。</p><p>InnoDB 的 insert操作，对插入的记录不加锁，但是此时如果另一个线程进行当前读，类似以下的用例，session 2 会锁等待 session 1， 那么这是如何实现的呢？</p><p><strong>session 1:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">34</span>,&quot;周八&quot;,&quot;二班&quot;);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>session 2:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student lock <span class="keyword">in</span> share mode; #执行完，当前事务被阻塞</span><br></pre></td></tr></table></figure><p>执行下述语句，输出结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema.data_lock_waits\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">              ENGINE: INNODB</span><br><span class="line">   REQUESTING_ENGINE_LOCK_ID: <span class="number">140562531358232</span>:<span class="number">7</span>:<span class="number">4</span>:<span class="number">9</span>:<span class="number">140562535668584</span></span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: <span class="number">422037508068888</span></span><br><span class="line">      REQUESTING_THREAD_ID: <span class="number">64</span></span><br><span class="line">       REQUESTING_EVENT_ID: <span class="number">6</span></span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: <span class="number">140562535668584</span></span><br><span class="line">     BLOCKING_ENGINE_LOCK_ID: <span class="number">140562531351768</span>:<span class="number">7</span>:<span class="number">4</span>:<span class="number">9</span>:<span class="number">140562535619104</span></span><br><span class="line">  BLOCKING_ENGINE_TRANSACTION_ID: <span class="number">15902</span></span><br><span class="line">        BLOCKING_THREAD_ID: <span class="number">64</span></span><br><span class="line">         BLOCKING_EVENT_ID: <span class="number">6</span></span><br><span class="line">  BLOCKING_OBJECT_INSTANCE_BEGIN: <span class="number">140562535619104</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>隐式锁的逻辑过程如下：</p><p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。</p><p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活动的事务，首先将<code>隐式锁</code>转换为<code>显式锁</code>(就是为该事务添加一个锁)。</p><p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。</p><p>D. 等待加锁成功，被唤醒，或者超时。</p><p>E. 写数据，并将自己的trx_id写入trx_id字段。</p><hr><h3 id="6-2-显式锁">6.2 显式锁</h3><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如：</p><p>显示加共享锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> .... lock <span class="keyword">in</span> share mode</span><br></pre></td></tr></table></figure><p>显示加排它锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> .... <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><hr><h2 id="7-其它锁之：全局锁">7. 其它锁之：全局锁</h2><p>全局锁就是对<code>整个数据库实例</code>加锁。当你需要让整个库处于<code>只读状态</code>的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用<code>场景</code>是：做<code>全库逻辑备份</code>。</p><p>全局锁的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure><hr><h2 id="8-其它锁之：死锁">8. 其它锁之：死锁</h2><h3 id="8-1-概念">8.1 概念</h3><p>两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁。</p><p><strong>举例1：</strong></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713220714098.png" alt="image-20220713220714098"></p><p><strong>举例2：</strong></p><p>用户A给用户B转账100，再次同时，用户B也给用户A转账100。这个过程，可能导致死锁。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713220936236.png" alt="image-20220713220936236" style="float:left;" /><h3 id="8-2-产生死锁的必要条件">8.2 产生死锁的必要条件</h3><ol><li>两个或者两个以上事务</li><li>每个事务都已经持有锁并且申请新的锁</li><li>锁资源同时只能被同一个事务持有或者不兼容</li><li>事务之间因为持有锁和申请锁导致彼此循环等待</li></ol><blockquote><p>死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。</p></blockquote><h3 id="8-3-如何处理死锁">8.3 如何处理死锁</h3><p>**方式1：**等待，直到超时（innodb_lock_wait_timeout=50s)</p><p>即当两个事务互相等待时，当—个事务等待时间超过设置的國值时，就将其回滚，另外事务继续进行。这种方法简单有效，在innodb中，参数<code>innodb_lock_wait_timeout</code>用来设置超时时间。</p><p>缺点：对于在线服务来说，这个等待时间往往是无法接受的。</p><p>那将此值修改短一些，比如1s，0.1s是否合适？不合适，容易误伤到普通的锁等待。</p><p>**方式2：**使用死锁检测处理死锁程序</p><p>方式1检测死锁太过被动，innodb还提供了<code>wait-for graph算法</code>来主动进行死锁检测，每当加锁请求无法立即满足需要并进入等待时，wait-for graph算法都会被触发。</p><p>这是一种较为<code>主动的死锁检测机制</code>，要求数据库保存<code>锁的信息链表</code>和<code>事务等待链表</code>两部分信息。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713221758941.png" alt="image-20220713221758941" style="zoom:67%;" /><p>基于这两个信息，可以绘制wait-for graph（等待图）</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220713221830455.png" alt="image-20220713221830455" style="zoom:67%;" /><blockquote><p>死锁检测的原理是构建一个以事务为顶点，锁为边的有向图，判断有向图是否存在环，存在既有死锁。</p></blockquote><p>一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择<code>回滚undo量最小的事务</code>，让其他事务继续执行（<code>innodb_deadlock_detect=on</code>表示开启这个逻辑）。</p><p>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是O(n)。如果100个并发线程同时更新同一行，意味着要检测100*100=1万次，1万个线程就会有1千万次检测。</p><p><strong>如何解决？</strong></p><ul><li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li><li>方式2：控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作。</li></ul><p><strong>进一步的思路：</strong></p><p>可以考虑通过将一行改成逻辑上的多行来减少<code>锁冲突</code>。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</p><hr><h3 id="8-4-如何避免死锁">8.4 如何避免死锁</h3><ul><li><p>合理设计索引，使业务 SQL 尽可能通过索引定位更少的行，减少锁竞争。</p></li><li><p>调整业务逻辑 SQL执行顺序，避免 update/delete 长时间持有锁的SQL 在事务前面。</p></li><li><p>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。</p></li><li><p>在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select… for update 语句，如果是在事务里运行了 start transaction 或设置了autocommit 等于0，那么就会锁定所查找到的记录。</p></li><li><p>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</p></li></ul><hr><h2 id="9-锁的内部结构">9. 锁的内部结构</h2><p>我们前边说对一条记录加锁的本质就是在内存中创建一个<code>锁结构</code>与之关联，那么是不是一个事务对多条记录加锁，就要创建多个<code>锁结构</code>呢？比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 事务T1</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure><p>理论上创建多个<code>锁结构</code>没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了！所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放在一个<code>锁结构</code>中。</p><ul><li>在同一个事务中进行加锁操作</li><li>被加锁的记录在同一个页面中</li><li>加锁的类型是一样的</li><li>等待状态是一样的</li></ul><p><code>InnoDB</code>存储引擎中的<code>锁结构</code>如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714132306208.png" alt="image-20220714132306208" style="zoom:67%;" /><p>结构解析：</p><p><code>1. 锁所在的事务信息</code>：</p><p>不论是<code>表锁</code>还是<code>行锁</code>，都是在事务执行过程中生成的，哪个事务生成了这个锁结构 ，这里就记录这个 事务的信息。</p><p>此<code>锁所在的事务信息</code>在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p><p><code>2. 索引信息</code>：</p><p>对于<code>行锁</code>来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。</p><p><code>3. 表锁／行锁信息</code>：</p><p><code>表锁结构</code>和<code>行锁结构</code>在这个位置的内容是不同的：</p><ul><li><p>表锁：</p><p>记载着是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁：</p><p>记载了三个重要的信息：</p><p>*<code>Space ID</code>：记录所在表空间。<br>*<code>Page Number</code>：记录所在页号。<br>*<code>n_bits</code>：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<code>n_bis</code>属性代表使用了多少比特位。</p><blockquote><p>n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后 也不至于重新分配锁结构</p></blockquote></li></ul><p><code>4. type_mode</code>：</p><p>这是一个32位的数，被分成了<code>lock_mode</code>、<code>lock_type</code>和<code>rec_lock_type</code>三个部分，如图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714133319666.png" alt="image-20220714133319666"></p><ul><li>锁的模式（<code>lock_mode</code>），占用低4位，可选的值如下：<br>*<code>LOCK_IS</code>（十进制的 0 ）：表示共享意向锁，也就是<code>IS锁</code>。<br>*<code>LOCK_IX</code>（十进制的 1 ）：表示独占意向锁，也就是<code>IX锁</code>。<br>*<code>LOCK_S</code>（十进制的 2 ）：表示共享锁，也就是<code>S锁</code>。<br>*<code>LOCK_X</code>（十进制的 3 ）：表示独占锁，也就是<code>X锁</code>。<br>*<code>LOCK_AUTO_INC</code>（十进制的 4 ）：表示<code>AUTO-INC锁</code>。</li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p><ul><li>锁的类型（<code>lock_type</code>），占用第5～8位，不过现阶段只有第5位和第6位被使用：<br>*<code>LOCK_TABLE</code>（十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。<br>*<code>LOCK_REC</code>（十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li><li>行锁的具体类型（<code>rec_lock_type</code>），使用其余的位来表示。只有在<code>lock_type</code>的值为<code>LOCK_REC</code>时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<br>*<code>LOCK_ORDINARY</code>（十进制的 0 ）：表示<code>next-key锁</code>。<br>*<code>LOCK_GAP</code>（十进制的 512 ）：也就是当第10个比特位置为1时，表示<code>gap锁</code>。<br>*<code>LOCK_REC_NOT_GAP</code>（十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经<code>记录锁</code>。<br>*<code>LOCK_INSERT_INTENTION</code>（十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。<br>*<code>is_waiting</code>属性呢？基于内存空间的节省，所以把<code>is_waiting</code>属性放到了<code>type_mode</code>这个32 位的数字中：<br>*<code>LOCK_WAIT</code>（十进制的 256 ） ：当第9个比特位置为 1 时，表示<code>is_waiting</code>为<code>true</code>，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示<code>is_waiting</code>为<code>false</code>，也就是当前事务获取锁成功。</li></ul><p><code>5. 其他信息</code>：</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p><p><code>6. 一堆比特位</code>：</p><p>如果是<code>行锁结构</code>的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的<code>n_bits</code>属性 表示的。InnoDB数据页中的每条记录在<code>记录头信息</code>中都包含一个<code>heap_no</code>属性，伪记录<code>Infimum</code>的<code>heap_no</code>值为 0 ，<code>Supremum</code>的<code>heap_no</code>值为 1 ，之后每插入一条记录，<code>heap_no</code>值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个<code>heap_no</code>，即一个比特位映射 到页内的一条记录。</p><hr><h2 id="10-锁监控">10. 锁监控</h2><p>关于MySQL锁的监控，我们一般可以通过检查 InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_current_waits <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time          <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_avg      <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_max      <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_waits         <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>对各个状态量的说明如下：</p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；<br>*<code>Innodb_row_lock_time</code>：从系统启动到现在锁定总时间长度；（等待总时长）<br>*<code>Innodb_row_lock_time_avg</code>：每次等待所花平均时间；（等待平均时长）</li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；<br>*<code>Innodb_row_lock_waits</code>：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><p>对于这5个状态变量，比较重要的3个见上面（灰色）。</p><p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p><p><strong>其他监控方法：</strong></p><p>MySQL把事务和锁的信息记录在了<code>information_schema</code>库中，涉及到的三张表分别是<code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>和<code>INNODB_LOCK_WAITS</code>。</p><p><code>MySQL5.7及之前</code>，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事 务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了<code>performance_schema.data_locks</code>，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同， performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被<code>performance_schema.data_lock_waits</code>所代 替。</p><p>我们模拟一个锁等待的场景，以下是从这三张表收集的信息</p><p>锁等待场景，我们依然使用记录锁中的案例，当事务2进行等待时，查询情况如下：</p><p>（1）查询正在被锁阻塞的sql语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure><p>重要属性代表含义已在上述中标注。</p><p>（2）查询锁等待情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> data_lock_waits\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">ENGINE: INNODB</span><br><span class="line">REQUESTING_ENGINE_LOCK_ID: <span class="number">139750145405624</span>:<span class="number">7</span>:<span class="number">4</span>:<span class="number">7</span>:<span class="number">139747028690608</span></span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID: <span class="number">13845</span> #被阻塞的事务ID</span><br><span class="line">REQUESTING_THREAD_ID: <span class="number">72</span></span><br><span class="line">REQUESTING_EVENT_ID: <span class="number">26</span></span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN: <span class="number">139747028690608</span></span><br><span class="line">BLOCKING_ENGINE_LOCK_ID: <span class="number">139750145406432</span>:<span class="number">7</span>:<span class="number">4</span>:<span class="number">7</span>:<span class="number">139747028813248</span></span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID: <span class="number">13844</span> #正在执行的事务ID，阻塞了<span class="number">13845</span></span><br><span class="line">BLOCKING_THREAD_ID: <span class="number">71</span></span><br><span class="line">BLOCKING_EVENT_ID: <span class="number">24</span></span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN: <span class="number">139747028813248</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>（3）查询锁的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.data_locks\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: <span class="number">139750145405624</span>:<span class="number">1068</span>:<span class="number">139747028693520</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">13847</span></span><br><span class="line">THREAD_ID: <span class="number">72</span></span><br><span class="line">EVENT_ID: <span class="number">31</span></span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: <span class="keyword">user</span></span><br><span class="line">PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">INDEX_NAME: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139747028693520</span></span><br><span class="line">LOCK_TYPE: <span class="keyword">TABLE</span></span><br><span class="line">LOCK_MODE: IX</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: <span class="number">139750145405624</span>:<span class="number">7</span>:<span class="number">4</span>:<span class="number">7</span>:<span class="number">139747028690608</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">13847</span></span><br><span class="line">THREAD_ID: <span class="number">72</span></span><br><span class="line">EVENT_ID: <span class="number">31</span></span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: <span class="keyword">user</span></span><br><span class="line">PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">INDEX_NAME: <span class="keyword">PRIMARY</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139747028690608</span></span><br><span class="line">LOCK_TYPE: RECORD</span><br><span class="line">LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">LOCK_STATUS: WAITING</span><br><span class="line">LOCK_DATA: <span class="number">1</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: <span class="number">139750145406432</span>:<span class="number">1068</span>:<span class="number">139747028816304</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">13846</span></span><br><span class="line">THREAD_ID: <span class="number">71</span></span><br><span class="line">EVENT_ID: <span class="number">28</span></span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: <span class="keyword">user</span></span><br><span class="line">PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">INDEX_NAME: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139747028816304</span></span><br><span class="line">LOCK_TYPE: <span class="keyword">TABLE</span></span><br><span class="line">LOCK_MODE: IX</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">4.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">ENGINE: INNODB</span><br><span class="line">ENGINE_LOCK_ID: <span class="number">139750145406432</span>:<span class="number">7</span>:<span class="number">4</span>:<span class="number">7</span>:<span class="number">139747028813248</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">13846</span></span><br><span class="line">THREAD_ID: <span class="number">71</span></span><br><span class="line">EVENT_ID: <span class="number">28</span></span><br><span class="line">OBJECT_SCHEMA: atguigu</span><br><span class="line">OBJECT_NAME: <span class="keyword">user</span></span><br><span class="line">PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">INDEX_NAME: <span class="keyword">PRIMARY</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139747028813248</span></span><br><span class="line">LOCK_TYPE: RECORD</span><br><span class="line">LOCK_MODE: X,REC_NOT_GAP</span><br><span class="line">LOCK_STATUS: GRANTED</span><br><span class="line">LOCK_DATA: <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line"><span class="keyword">No</span> query specified</span><br></pre></td></tr></table></figure><p>从锁的情况可以看出来，两个事务分别获取了IX锁，我们从意向锁章节可以知道，IX锁互相时兼容的。所 以这里不会等待，但是事务1同样持有X锁，此时事务2也要去同一行记录获取X锁，他们之间不兼容，导 致等待的情况发生。</p><hr><h2 id="附录-间隙锁加锁规则">附录:间隙锁加锁规则</h2><p>间隙锁加锁规则（共11个案例）</p><p>间隙锁是在可重复读隔离级别下才会生效的： next-key lock实际上是由间隙锁加行锁实现的，如果切换到读提交隔离级别 (read-committed) 的话，就好理解了，过程中去掉间隙锁的部分，也就是只剩下行锁的部分。而在读提交隔离级别下间隙锁就没有了，为了解决可能出现的数据和日志不一致问题，需要把 binlog格式设置为 row 。也就是说，许多公司的配置为：读提交隔离级别加 binlog_format=row。业务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。</p><p>next-key lock的加锁规则</p><p>总结的加锁规则里面，包含了两个原则、两个优化和一个bug 。</p><ol><li>原则1：加锁的基本单位是 next-key lock 。 next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。任何辅助索引上的锁，或者非索引列上的锁，最终都要回溯到主键上，在主键上也要加一把锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候， next-key lock退化为记录锁。也就是说如果 InnoDB扫描的是一个主键、或是一个唯一索引的话，那InnoDB只会采用记录锁方式来加锁</li><li>优化2：索引上(不一定是唯一索引)的等值查询，向右遍历时且最后一个值不满足等值条件的时候， next-key lock退化为间隙锁。</li><li>一个 bug ：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>我们以表test作为例子，建表语句和初始化语句如下：其中id为主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`test`(</span><br><span class="line">`id`<span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`col1`<span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`col2`<span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY`c`(`col1`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span></span><br><span class="line">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),</span><br><span class="line">(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),</span><br><span class="line">(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),</span><br><span class="line">(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure><div class="tabs" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-3"><i class="fas fa-dove"></i>3</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-4"><i class="fas fa-dragon"></i>4</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-5"><i class="fas fa-seedling"></i>5</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-6"><i class="fas fa-leaf"></i>6</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-7"><i class="fab fa-apple"></i>7</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-8"><i class="fas fa-tree"></i>8</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-9"><i class="fas fa-heartbeat"></i>9</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-10"><i class="fas fa-cookie-bite"></i>10</button></li><li class="tab"><button type="button" data-href="#2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-11"><i class="fas fa-child"></i>11</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-1"><p><mark class="hl-label blue">案例一：唯一索引等值查询间隙锁</mark></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714134603698.png" alt="image-20220714134603698" style="zoom:67%;" /><p>由于表 test 中没有 id=7 的记录</p><p>根据原则 1 ，加锁单位是 next-key lock ， sessionA加锁范围就是 (5,10] ； 同时根据优化2 ，这是一个等值查询 (id=7) ，而 id=10不满足查询条件， next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-2"><p><mark class="hl-label blue">案例二：非唯一索引等值查询锁</mark></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714134623052-16577775838551.png" alt="image-20220714134623052" style="zoom:67%;" /><p>这里 session A 要给索引col1上col1=5的这一行加上读锁。</p><ol><li>根据原则 1 ，加锁单位是 next-key lock ，左开右闭，5是闭上的，因此会给 (0,5] 加上 next-key lock 。</li><li>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的（可能有col1=5的其他记录），需要向右遍历，查到c=10才放弃。根据原则 2 ，访问到的都要加锁，因此要给 (5,10] 加 next-key lock 。</li><li>但是同时这个符合优化 2 ：等值判断，向右遍历，最后一个值不满足 col1=5 这个等值条件，因此退化成间隙锁 (5,10) 。</li><li>根据原则 2 ,只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</li></ol><p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住 这个例子说明，锁是加在索引上的。</p><p>执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p><p>如果你要用 lock in share mode来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，因为覆盖索引不会访问主键索引，不会给主键索引上加锁</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-3"><p><mark class="hl-label blue">案例三：主键索引范围查询锁</mark></p><p>上面两个例子是等值查询的，这个例子是关于范围查询的，也就是说下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714134742049.png" alt="image-20220714134742049" style="zoom:67%;" /><ol><li>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10] 。 根据优化 1 ，主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</li><li>它是范围查询， 范围查找就往后继续找，找到 id=15 这一行停下来，不满足条件，因此需要加 next-key lock(10,15] 。</li></ol><p>session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15] 。首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-4"><p><mark class="hl-label blue">案例四：非唯一索引范围查询锁</mark></p><p>与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c ，它是普通索引</p><p>这两条查语句肯定是等价的，但是它们的加锁规则不太一样</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714134822160.png" alt="image-20220714134822160" style="zoom:67%;" /><p>在第一次用 col1=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 col1 是非唯 一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-keylock 。</p><p>这里需要扫描到 col1=15 才停止扫描，是合理的，因为 InnoDB 要扫到 col1=15 ，才知道不需要继续往后找了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-5"><p><mark class="hl-label blue">案例五：唯一索引范围查询锁bug</mark></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714134846740.png" alt="image-20220714134846740" style="zoom:67%;" /><p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock ，并且因 为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p><p>但是实现上， InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20 。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15 ，就可以确定不用往后再找了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-6"><p><mark class="hl-label blue">案例六：非唯一索引上存在等值的例子</mark></p><p>这里，我给表 t 插入一条新记录：insert into t values(30,10,30);也就是说，现在表里面有两个c=10的行</p><p>但是它们的主键值 id 是不同的（分别是 10 和 30 ），因此这两个c=10 的记录之间，也是有间隙的。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714134923414.png" alt="image-20220714134923414" style="zoom:67%;" /><p>这次我们用 delete 语句来验证。注意， delete 语句加锁的逻辑，其实跟 select … for update 是类似的， 也就是我在文章开始总结的两个 “ 原则 ” 、两个 “ 优化 ” 和一个 “bug” 。</p><p>这时， session A 在遍历的时候，先访问第一个 col1=10 的记录。同样地，根据原则 1 ，这里加的是 (col1=5,id=5) 到 (col1=10,id=10) 这个 next-key lock 。</p><p>由于c是普通索引，所以继续向右查找，直到碰到 (col1=15,id=15) 这一行循环才结束。根据优化 2 ，这是 一个等值查询，向右查找到了不满足条件的行，所以会退化成 (col1=10,id=10) 到 (col1=15,id=15) 的间隙锁。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714134945012.png" alt="image-20220714134945012" style="zoom:67%;" /><p>这个 delete 语句在索引 c 上的加锁范围，就是上面图中蓝色区域覆盖的部分。这个蓝色区域左右两边都 是虚线，表示开区间，即 (col1=5,id=5) 和 (col1=15,id=15) 这两行上都没有锁</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-7"><p><mark class="hl-label blue">案例七：limit语句加锁</mark></p><p>例子 6 也有一个对照案例，场景如下所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714135007118.png" alt="image-20220714135007118" style="zoom:67%;" /><p>session A 的 delete 语句加了 limit 2 。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2 ，删除的效果都是一样的。但是加锁效果却不一样</p><p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (col1=10, id=30) 这一行之后， 满足条件的语句已经有两条，循环就结束了。因此，索引 col1 上的加锁范围就变成了从（ col1=5,id=5) 到（ col1=10,id=30) 这个前开后闭区间，如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714135025045-16577778257713.png" alt="image-20220714135025045" style="zoom:67%;" /><p>这个例子对我们实践的指导意义就是， 在删除数据的时候尽量加 limit 。</p><p>这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-8"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714135047760.png" alt="image-20220714135047760" style="zoom:67%;" /><ol><li>session A 启动事务后执行查询语句加 lock in share mode ，在索引 col1 上加了 next-keylock(5,10] 和 间隙锁 (10,15) （索引向右遍历退化为间隙锁）；</li><li>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待； 实际上分成了两步， 先是加 (5,10) 的间隙锁，加锁成功；然后加 col1=10 的行锁，因为sessionA上已经给这行加上了读 锁，此时申请死锁时会被阻塞</li><li>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁， InnoDB 让 session B 回滚</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-9"><p><mark class="hl-label blue">案例九：orderby索引排序的间隙锁1</mark></p><p>如下面一条语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">9</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">12</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>下图为这个表的索引id的示意图。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714135130668.png" alt="image-20220714135130668"></p><ol><li>首先这个查询语句的语义是 order by id desc ，要拿到满足条件的所有行，优化器必须先找到 “ 第 一个 id&lt;12 的值 ” 。</li><li>这个过程是通过索引树的搜索过程得到的，在引擎内部，其实是要找到 id=12 的这个值，只是最终 没找到，但找到了 (10,15) 这个间隙。（ id=15 不满足条件，所以 next-key lock 退化为了间隙锁 (10, 15) 。）</li><li>然后向左遍历，在遍历过程中，就不是等值查询了，会扫描到 id=5 这一行，又因为区间是左开右 闭的，所以会加一个next-key lock (0,5] 。 也就是说，在执行过程中，通过树搜索的方式定位记录 的时候，用的是 “ 等值查询 ” 的方法。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-10"><p><mark class="hl-label blue">案例十：orderby索引排序的间隙锁2</mark></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714135206504.png" alt="image-20220714135206504" style="zoom: 67%;" /><ol><li><p>由于是 order by col1 desc ，第一个要定位的是索引 col1 上 “ 最右边的 ”col1=20 的行。这是一个非唯一索引的等值查询：</p><p>左开右闭区间，首先加上 next-key lock (15,20] 。 向右遍历，col1=25不满足条件，退化为间隙锁 所以会 加上间隙锁(20,25) 和 next-key lock (15,20] 。</p></li><li><p>在索引 col1 上向左遍历，要扫描到 col1=10 才停下来。同时又因为左开右闭区间，所以 next-key lock 会加到 (5,10] ，这正是阻塞session B 的 insert 语句的原因。</p></li><li><p>在扫描过程中， col1=20 、 col1=15 、 col1=10 这三行都存在值，由于是 select * ，所以会在主键 id 上加三个行锁。 因此， session A 的 select 语句锁的范围就是：</p><ol><li>索引 col1 上 (5, 25) ；</li><li>主键索引上 id=15 、 20 两个行锁。</li></ol></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2dd36c9e-3786-4eba-9e69-1329ee7eaa1b-11"><p><mark class="hl-label blue">案例十一：update修改数据的例子-先插入后删除</mark></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714135300189.png" alt="image-20220714135300189" style="zoom:67%;" /><p>注意：根据 col1&gt;5 查到的第一个记录是 col1=10 ，因此不会加 (0,5] 这个 next-key lock 。</p><p>session A 的加锁范围是索引 col1 上的 (5,10] 、 (10,15] 、 (15,20] 、 (20,25] 和(25,supremum] 。</p><p>之后 session B 的第一个 update 语句，要把 col1=5 改成 col1=1 ，你可以理解为两步：</p><ol><li>插入 (col1=1, id=5) 这个记录；</li><li>删除 (col1=5, id=5) 这个记录。</li></ol><p>通过这个操作， session A 的加锁范围变成了图 7 所示的样子:</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220714135333089.png" alt="image-20220714135333089" style="zoom:67%;" /><p>好，接下来 session B 要执行 update t set col1 = 5 where col1 = 1 这个语句了，一样地可以拆成两步：</p><ol><li>插入 (col1=5, id=5) 这个记录；</li><li>删除 (col1=1, id=5) 这个记录。 第一步试图在已经加了间隙锁的 (1,10) 中插入数据，所以就被堵住了。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务日志</title>
      <link href="/posts/46982315.html"/>
      <url>/posts/46982315.html</url>
      
        <content type="html"><![CDATA[<p>事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？</p><ul><li>事务的隔离性由<code>锁机制</code>实现。</li><li>而事务的原子性、一致性和持久性由事务的 redo 日志和undo 日志来保证。<ul><li>REDO LOG 称为<code>重做日志</code>，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li><li>UNDO LOG 称为<code>回滚日志</code>，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</li></ul></li></ul><p>有的DBA或许会认为 UNDO 是 REDO 的逆过程，其实不然。REDO 和 UNDO都可以视为是一种<code>恢复操作</code>，但是：</p><ul><li>redo log: 是存储引擎层 (innodb) 生成的日志，记录的是<code>&quot;物理级别&quot;</code>上的页修改操作，比如页号xxx，偏移量yyy写入了’zzz’数据。主要为了保证数据的可靠性。</li><li>undo log: 是存储引擎层 (innodb) 生成的日志，记录的是<code>逻辑操作</code>日志，比如对某一行数据进行了INSERT语句操作，那么undo log就记录一条与之相反的DELETE操作。主要用于<code>事务的回滚</code>(undo log 记录的是每个修改操作的<code>逆操作</code>) 和<code>一致性非锁定读</code>(undo log 回滚行记录到某种特定的版本——MVCC，即多版本并发控制)。</li></ul><hr><h2 id="1-redo日志">1. redo日志</h2><p>InnoDB存储引擎是以<code>页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在<code>磁盘上</code>的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。所有的变更都必须<code>先更新缓冲池</code>中的数据，然后缓冲池中的<code>脏页</code>会以一定的频率被刷入磁盘 (<code>checkPoint</code>机制)，通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p><hr><h3 id="1-1-为什么需要redo日志">1.1 为什么需要redo日志</h3><p>一方面，缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint<code>并不是每次变更的时候就触发</code>的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。</p><p>另一方面，事务包含<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。</p><p>那么如何保证这个持久性呢？<code>一个简单的做法</code>：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题:</p><ul><li><p><strong>修改量与刷新磁盘工作量严重不成比例</strong></p><p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个默认页面时16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是小题大做了。</p></li><li><p><strong>随机IO刷新较慢</strong></p><p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，假如该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面<code>刷新到磁盘</code>时，需要进行很多的<code>随机IO</code>，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p></li></ul><p><code>另一个解决的思路</code>：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好。比如，某个事务将系统表空间中第10号页面中偏移量为100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表 空间的10号页面的偏移量为100处的值更新为 2</p><p>InnoDB引擎的事务采用了WAL技术 (<code>Write-Ahead Logging</code>)，<span class='p red'>这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。</span>当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710202517977.png" alt="image-20220710202517977" style="zoom:50%;" /><hr><h3 id="1-2-redo日志的好处、特点">1.2 redo日志的好处、特点</h3><ol><li>好处</li></ol><ul><li>redo日志降低了刷盘频率</li><li>redo日志占用的空间非常小</li></ul><p>存储表空间ID、页号、偏移量以及需要更新的值，所需的存储空间是很小的，刷盘快。</p><ol start="2"><li>特点</li></ol><ul><li><p><strong>redo日志是顺序写入磁盘的</strong></p><p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照<code>产生的顺序写入磁盘的</code>，也就是使用顺序ID，效率比随机IO快。</p></li><li><p><strong>事务执行过程中，redo log不断记录</strong></p><p>redo log跟bin log的区别，redo log是<code>存储引擎层</code>产生的，而bin log是<code>数据库层</code>产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p></li></ul><hr><h3 id="1-3-redo的组成">1.3 redo的组成</h3><p>Redo log可以简单分为以下两个部分：</p><p>*<code>重做日志的缓冲 (redo log buffer)</code>，保存在内存中，是易失的。</p><p>在服务器启动时就会向操作系统申请了一大片称之为 redo log buffer 的<code>连续内存</code>空间，翻译成中文就是redo日志缓冲区。这片内存空间被划分为若干个连续的<code>redo log block</code>。一个redo log block占用<code>512字节</code>大小。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710204114543.png" alt="image-20220710204114543"></p><p><strong>参数设置：innodb_log_buffer_size：</strong></p><p>redo log buffer 大小，默认<code>16M</code>，最大值是4096M，最小值为1M。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_log_buffer_size%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_buffer_size <span class="operator">|</span> <span class="number">16777216</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+----------+</span></span><br></pre></td></tr></table></figure><p>*<code>重做日志文件 (redo log file)</code>，保存在硬盘中，是持久的。</p><p>REDO日志文件如图所示，其中<code>ib_logfile0</code>和<code>ib_logfile1</code>即为REDO日志。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710204427616.png" alt="image-20220710204427616" style="zoom:50%;" /><hr><h3 id="1-4-redo的整体流程">1.4 redo的整体流程</h3><p>以一个更新事务为例，redo log 流转过程，如下图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710204810264-16574572910841.png" alt="image-20220710204810264"></p><p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝<br>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值<br>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式<br>第4步：定期将内存中修改的数据刷新到磁盘中</p><blockquote><p>体会： Write-Ahead Log(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的日志页持久化。</p></blockquote><hr><h3 id="1-5-redo-log的刷盘策略">1.5 redo log的刷盘策略</h3><p>redo log的写入并不是直接写入磁盘的，InnoDB引擎会在写redo log的时候先写redo log buffer，之后以<code>一定的频率</code>刷入到真正的redo log file 中。这里的一定频率怎么看待呢？这就是我们要说的刷盘策略。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710205015302.png" alt="image-20220710205015302"></p><p>注意，redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到<code>文件系统缓存 （page cache）</code>中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了（虽然整个系统宕机的概率还是比较小的）。</p><p>针对这种情况，InnoDB给出<code>innodb_flush_log_at_trx_commit</code>参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file中。它支持三种策略：</p><p>*<code>设置为0</code>：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步<br>*<code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）<br>*<code>设置为2</code>：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710205948156.png" alt="image-20220710205948156" /><p>另外，InnoDB存储引擎有一个后台线程，每隔<code>1秒</code>，就会把<code>redo log buffer</code>中的内容写到文件系统缓存(<code>page cache</code>)，然后调用刷盘操作。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710210339724.png" alt="image-20220710210339724" style="zoom:67%;" /><p>也就是说，一个没有提交事务的<code>redo log</code>记录，也可能会刷盘。因为在事务执行过程 redo log 记录是会写入<code>redo log buffer</code>中，这些redo log 记录会被<code>后台线程</code>刷盘。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710210532805.png" alt="image-20220710210532805" style="zoom:50%;" /><p>除了后台线程每秒<code>1次</code>的轮询操作，还有一种情况，当<code>redo log buffer</code>占用的空间即将达到<code>innodb_log_buffer_size</code>（这个参数默认是16M）的一半的时候，后台线程会主动刷盘。</p><hr><h3 id="1-6-不同刷盘策略演示">1.6 不同刷盘策略演示</h3><div class="tabs" id="8923db4d-3949-4b45-b62b-a27aeef05192"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8923db4d-3949-4b45-b62b-a27aeef05192-1"><i class="fas fa-atom"></i>设置为0</button></li><li class="tab"><button type="button" data-href="#8923db4d-3949-4b45-b62b-a27aeef05192-2"><i class="far fa-sun"></i>设置为1</button></li><li class="tab"><button type="button" data-href="#8923db4d-3949-4b45-b62b-a27aeef05192-3"><i class="fas fa-wind"></i>设置为2</button></li><li class="tab"><button type="button" data-href="#8923db4d-3949-4b45-b62b-a27aeef05192-4"><i class="fas fa-fire-alt"></i>举例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8923db4d-3949-4b45-b62b-a27aeef05192-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230414104240464.png" alt="image-20230414104240464" style="zoom:50%;" /><blockquote><p>小结：innodb_flush_log_at_trx_commit=0</p><p>为0时，master thread中每1秒进行一次重做日志的fsync操作，因此实例 crash 最多丢失1秒钟内的事务。</p><p>(master thread是负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性）</p><p>数值0的话，是一种折中的做法，它的IO效率理论是高于1的，低于2的，这种策略也有丟失数据的风险，也无法保证D。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8923db4d-3949-4b45-b62b-a27aeef05192-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230414104841508.png" alt="image-20230414104841508" style="zoom:50%;" /><blockquote><p>小结：innodb_flush_log_at_trx_commit=1</p><p>为1时，只要事务提交成功，redo log 记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务行期间 MySQL 挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。可以保证ACID的D，数据绝对<code>不会丢失</code>，但是<code>效率最差</code>的。</p><p>建议使用默认值，虽然操作系统宕机的概率理论小于数据库宕机的概率，但是一般既然使用了事务，那么数据的安全相对来说更重要些。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8923db4d-3949-4b45-b62b-a27aeef05192-3"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230414105342602.png" alt="image-20230414105342602" style="zoom:50%;" /><blockquote><p>小结innodb_flush_log_at _trx_commit=2</p><p>为2时，只要事务提交成功，redo log buffer 中的内容只写入文件系统缓存( page cache )</p><p>如果仅仅只是 MySQL 挂了不会有任何数据丢失，但是操作系统宕机可能会有1秒数据的丢失，这种情况下无法满足ACID中的D。但是数值2肯定是效率最高的。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8923db4d-3949-4b45-b62b-a27aeef05192-4"><p>比较innodb_flush_log_at_trx_commit对事务的影响。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_load(</span><br><span class="line">a <span class="type">INT</span>,</span><br><span class="line">b <span class="type">CHAR</span>(<span class="number">80</span>)</span><br><span class="line">)ENGINE<span class="operator">=</span>INNODB;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER<span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p_load(COUNT <span class="type">INT</span> UNSIGNED)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> s <span class="type">INT</span> UNSIGNED <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> c <span class="type">CHAR</span>(<span class="number">80</span>) <span class="keyword">DEFAULT</span> REPEAT(<span class="string">&#x27;a&#x27;</span>,<span class="number">80</span>);</span><br><span class="line">WHILE s<span class="operator">&lt;=</span>COUNT DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_load <span class="keyword">SELECT</span> <span class="keyword">NULL</span>, c;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">SET</span> s<span class="operator">=</span>s<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER;</span><br></pre></td></tr></table></figure><p>存储过程代码中，每插入一条数据就进行一次显式的COMMIT操作。在默认的设置下，即参数 innodb_ flush _log_at_trx_commit为1的情况下，InnoDB存储引擎会将重做日志缓冲中的日志写入文件，并调用一次fsync操作。</p><p>执行命令CALL p_load（30000），向表中插入3万行的记录，并执行3万次的fsync操作。在默认情况下所需的时问：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CALL</span> p_load(<span class="number">30000</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected(<span class="number">1</span> min <span class="number">23</span> sec)</span><br></pre></td></tr></table></figure><p><code>1 min 23 sec</code>的时间显然是不能接受的。而造成时间比较长的原因就在于fsync操作所需要的时间。</p><p>修改参数innodb_flush_log_at_trx_commit，设置为0：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> innodb_flush_log_at_trx_commit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CALL</span> p_load(<span class="number">30000</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected(<span class="number">38</span> sec)</span><br></pre></td></tr></table></figure><p>修改参数innodb_flush_log_at_trx_commit，设置为2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> innodb_flush_log_at_trx_commit <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CALL</span> p_load(<span class="number">30000</span>);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected(<span class="number">46</span> sec)</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710215353893.png" alt="image-20220710215353893" style="float:left;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="1-7-写入redo-log-buffer-过程">1.7 写入redo log buffer 过程</h3><h4 id="1-7-1-Mini-Transaction">1.7.1 Mini-Transaction</h4><p>MySQL把对底层页面中的一次原子访问过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如，向某个索引对应的B+树中插入一条记录的过程就是一个<code>Mini-Transaction</code>。一个所谓的<code>mtr</code>可以包含一组redo日志，在进行崩溃恢复时这一组<code>redo</code>日志可以作为一个不可分割的整体。</p><p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条 redo日志，画个图表示它们的关系就是这样：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710220653131.png" alt="image-20220710220653131" style="zoom:33%;" /><h4 id="1-7-2-redo-日志写入log-buffer">1.7.2  redo 日志写入log buffer</h4><p>向<code>log buffer</code>中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入redo日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移是处，所以 InnoDB的设计者特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的 redo日志应该写入到log buffer中的哪个位置，如图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710220919271.png" alt="image-20220710220919271" style="zoom:50%;" /><p>—个mtr执行过程中可能产生若干条redo日志，<code>这些redo日志是一个不可分割的组</code>，所以其实并不是每生成一条 redo日志，就将其插入到log bufer中，而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中。我们现在假设有两个名为<code>T1、T2</code>的事务，每个事务都包含2个mtr，我们给这几个mtr命名一下：</p><ul><li><p>事务T1 的两个mtr分别称为mtr_T1_1 和mtr_T1_2。</p></li><li><p>事务 T2 的两个mtr分别称为 mtr_T2_1 和mtr_T2_2。</p></li></ul><p>每个mtr都会产生一组redo日志，用示意图来描述一下这些mtr产生的日志情况：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710221318271.png" alt="image-20220710221318271" style="zoom:50%;" /><p>不同的事务可能是<code>并发</code>执行的，所以 T1 、 T2 之间的 mtr 可能是<code>交替执行</code>的。没当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图（为了美观，我们把一个mtr中产生的所有redo日志当做一个整体来画）：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710221620291.png" alt="image-20220710221620291" style="zoom:50%;" /><p>有的mtr产生的redo日志量非常大，比如<code>mtr_t1_2</code>产生的redo日志占用空间比较大，占用了3个block来存储。</p><h4 id="1-7-3-redo-log-block的结构图">1.7.3 redo log block的结构图</h4><p>一个redo log block是由<code>日志头、日志体、日志尾</code>组成。日志头占用12字节，日志尾占用8字节，所以一个block真正能存储的数据是512-12-8=492字节。</p><blockquote><span class='p red'>为什么一个block设计成512字节？</span><p>这个和磁盘的扇区有关，机械磁盘默认的扇区就是512字节，如果你要写入的数据大于512字节，那么要写入的扇区肯定不止一个，这时就要涉及到盘片的转动，找到下一个扇区，假设现在需要写入两个扇区A和B，如果扇区A写入成功，而扇区B写入失败，那么就会出现<code>非原子性</code>的写入，而如果每次只写入和扇区的大小一样的512字节，那么每次的写入都是原子性的。</p></blockquote><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710223135374.png" alt="image-20220710223135374" style="zoom:50%;" /><p>真正的redo日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。我们来看看这些所谓<code>管理信息</code>都有什么。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711144546439.png" alt="image-20220711144546439" style="zoom: 67%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711144608223.png" alt="image-20220711144608223"/><hr><hr><h3 id="1-8-redo-log-file">1.8 redo log file</h3><h4 id="1-8-1-相关参数设置">1.8.1 相关参数设置</h4><p>*<code>innodb_log_group_home_dir</code>：指定 redo log 文件组所在的路径，默认值为<code>./</code>，表示在数据库 的数据目录下。MySQL的默认数据目录（<code>var/lib/mysql</code>）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志 文件位置还可以修改。</p><p>*<code>innodb_log_files_in_group</code>：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1… iblogfilen。默认2个，最大100个。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_files_in_group&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_files_in_group <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line">#ib_logfile0</span><br><span class="line">#ib_logfile1</span><br></pre></td></tr></table></figure><p>*<code>innodb_flush_log_at_trx_commit</code>：控制 redo log 刷新到磁盘的策略，默认为1。</p><p>*<code>innodb_log_file_size</code>：单个 redo log 文件设置大小，默认值为<code>48M</code>。最大值为512G，注意最大值 指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大 于最大值512G。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_log_file_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name        <span class="operator">|</span> <span class="keyword">Value</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_log_file_size <span class="operator">|</span> <span class="number">50331648</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br></pre></td></tr></table></figure><p>根据业务修改其大小，以便容纳较大的事务。编辑my.cnf文件并重启数据库生效，如下所示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@localhost</span> <span class="operator">~</span>]# vim <span class="operator">/</span>etc<span class="operator">/</span>my.cnf</span><br><span class="line">innodb_log_file_size<span class="operator">=</span><span class="number">200</span>M</span><br></pre></td></tr></table></figure><blockquote><p>在数据库实例更新比较频繁的情况下，可以适当加大 redo log 数组和大小。但也不推荐 redo log 设置过大，在MySQL崩溃时会重新执行REDO日志中的记录。</p></blockquote><h4 id="1-8-2-日志文件组">1.8.2 日志文件组</h4><p>从上边的描述中可以看到，磁盘上的<code>redo</code>日志文件不只一个，而是以一个<code>日志文件组</code>的形式出现的。这些文件以ib_logfile[数字] (数字可以是0、1、2…)的形式进行命名，每个的redo日志文件大小都是一样的。</p><p>在将redo日志写入日志文件组时，是从<code>ib-1ogfile0</code>开始写，如果<code>ib_logfile0</code>写满了，就接着<code>ib-1ogfile1</code>写。同理,<code>ib_1ogfile1</code>写满了就去写<code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办？那就重新转到<code>ib_logfile0</code>继续写，所以整个过程如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711152242300.png" alt="image-20220711152242300" style="zoom:67%;" /><p>总共的redo日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code></p><p>采用循环使用的方式向redo日志文件组里写数据的话，会导致后写入的redo日志覆盖掉前边写的redo日志？当然！所以InnoDB的设计者提出了checkpoint的概念。</p><h4 id="1-8-3-checkpoint">1.8.3 checkpoint</h4><p>在整个日志文件组中还有两个重要的属性，分别是 write pos、checkpoint</p><p>*<code>write pos</code>是当前记录的位置，一边写一边后移<br>*<code>checkpoint</code>是当前要擦除的位置，也是往后推移</p><p>每次刷盘 redo log 记录到日志文件组中，write pos 位置就会后移更新。每次MySQL加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把check point后移更新。write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711152631108.png" alt="image-20220711152631108" style="zoom: 50%;" /><p>如果 write pos 追上 checkpoint ，表示<code>日志文件组</code>满了，这时候不能再写入新的 redo log记录，MySQL 得 停下来，清空一些记录，把 checkpoint 推进一下。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711152802294.png" alt="image-20220711152802294" style="zoom: 50%;" /><hr><h3 id="1-9-redo-log-小结">1.9 redo log 小结</h3><p>相信大家都知道 redo log 的作用和它的刷盘时机、存储形式：</p><span class='p red'>InnoDB 的更新操作采用的是 Write Ahead Log(预先日志持久化)策略，即先写日志，再写入磁盘。</span><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230414113010900.png" alt="image-20230414113010900" style="zoom:67%;" /><hr><h2 id="2-Undo日志">2. Undo日志</h2><p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中<code>更新数据</code>的<code>前置操作</code>其实是要先写入一个<code>undo log</code>。</p><hr><h3 id="2-1-如何理解Undo日志">2.1 如何理解Undo日志</h3><p>事务需要保证<code>原子性</code>，也就是事务中的操作要么全部完成，要么什么也不做。但有时候事务执行到一半会出现一些情况，比如：</p><ul><li>情况一：事务执行过程中可能遇到各种错误，比如<code>服务器本身的错误</code>，<code>操作系统错误</code>，甚至是突然<code>断电</code>导致的错误。</li><li>情况二：程序员可以在事务执行过程中手动输入<code>ROLLBACK</code>语句结束当前事务的执行。</li></ul><p>以上情况出现，我们需要把数据改回原先的样子，这个过程称之为<code>回滚</code>，这样就可以造成一个假象：这个事务看起来什么都没做，所以符合<code>原子性</code>要求。</p><p>每当我们要对一条记录做改动时（这里的<code>改动</code>可以指<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>），都需要&quot;留一手&quot;–把回滚时所需的东西记下来。比如：</p><ul><li><p>你<code>插入一条记录</code>，至少要把这条记录的<code>主键值</code>记下来，之后回滚的时候只需要把这个主键值对应的记录<code>删掉</code>就好了。（对于每个INSERT， InnoDB存储引擎会完成一个DELETE)</p></li><li><p>你<code>删除了一条记录</code>，至少要把这条记录中的<code>内容</code>都记下来，这样之后回滚时再把由这些内容组成的记录<code>插入</code>到表中就好了。（对于每个DELETE， InnoDB存储引擎会执行一个INSERT)</p></li><li><p>你<code>修改了一条记录</code>，至少要把修改这条记录前的<code>旧值</code>都记录下来，这样之后回滚时再把这条记录<code>更新为旧值</code>就好了。（对于每个UPDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去）</p></li></ul><p>MySQL把这些为了回滚而记录的这些内容称之为<code>撤销日志</code>或者<code>回滚日志</code>（即 undo log)。注意，由于查询操作 (<code>SELECT</code>）并不会修改任何用户记录，所以在查询操作执行时，并<code>不需要记录</code>相应的undo日志。</p><p>此外，undo log<code>会产生redo log</code>，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p><hr><h3 id="2-2-Undo日志的作用">2.2 Undo日志的作用</h3><ul><li><p>作用1：回滚数据</p><p>用户对undo日志可能<code>有误解</code>：undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事实并非如此。</p><p>undo是<code>逻辑日志</code>，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，<span class='p green'>但是数据结构和页本身在回滚之后可能大不相同。</span></p><p>这是因为在多用户并发系统中，可能会有数十、数百甚至数干个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。</p></li><li><p>作用2：MVCC</p><p>undo的另一个作用是MVCC，即在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录以及被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。</p></li></ul><hr><h3 id="2-3-undo的存储结构">2.3 undo的存储结构</h3><h4 id="2-3-1-回滚段与undo页">2.3.1 回滚段与undo页</h4><p>InnoDB对undo log的管理采用段的方式，也就是<code>回滚段（rollback segment）</code>。每个回滚段记录了<code>1024</code>个<code>undo log segment</code>，而在每个undo log segment段中进行<code>undo页</code>的申请。</p><ul><li>在<code>InnoDB1.1版本之前</code>（不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为<code>1024</code>。虽然对绝大多数的应用来说都已经够用。</li><li>从1.1版本开始InnoDB支持最大<code>128个rollback segment</code>，故其支持同时在线的事务限制提高到 了<code>128*1024</code>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_logs&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_logs <span class="operator">|</span> <span class="number">128</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure><p>虽然InnoDB1.1版本支持了128个rolback segment，但是这些rollback segment都存储于共享表空间ibdata中。从 InnoDB1.2版本开始，可通过参数对rollback segment做进一步的设置。这些参数包括：</p><p>-<code>innodb_undo_directory</code>：设置rollback segment文件所在的路径。这意味着rollback segment可以存放在共享表空间以外的位置，即可以设置为独立表空间。该参数的默认值为&quot;./&quot;，表示当前InnoDB存储引擎的目录。</p><p>-<code>innodb_undo_logs</code>：设置rollback segment的个数，默认值为128。在InnoDB1.2版本中，该参数用来替换之前版本的参数innodb_rollback_segments。</p><p>-<code>innodb_undo_tablespaces</code>：设置构成rollback segment文件的数量，这样rollback segment可以较为平均地分布在多个文件中。设置该参数后，会在路径imnodb_undo_directory看到undo为前缀的文件，该文件就代表 rollback segment文件。</p><p>undo log 相关参数一般很少改动。</p><span class='p red'>undo页的重用</span><p>当我们开启一个事务需要写undo log的时候，就得先去undo log segment中去找到一个空闲的位置，当有空位的时候，就去申请undo页，在这个申请到的undo页中进行undo log的写入。我们知道mysql默认一页的大小是16k。</p><p>为每一个事务分配一个页，是非常浪费的（除非你的事务非常长），假设你的应用的TPS（每秒处理的事务数目）为1000，那么1s就需要1000个页，大概需要16M的存储，1分钟大概需要1G的存储。如果照这样下去除非 MySQL清理的非常勤快，否则随着时间的推移，磁盘空间会增长的非常快，而且很多空间都是浪费的。</p><p>于是undo页就被设计的可以<code>重用</code>了，当事务提交时，并不会立刻删除undo页。因为重用，所以这个undo页可能混杂着其他事务的undo log。undo log在commit后，会被放到一个<code>链表</code>中，然后判断undo页的使用空间是否<code>小于 3/4</code>，如果小于3/4的话，则表示当前的undo页可以被重用，那么它就不会被回收，其他事务的undo log可以记录在当前undo页的后面。由于undo log是<code>离散</code>的，所以清理对应的磁盘空间时，效率不高。</p><hr><h4 id="2-3-2-回滚段与事务">2.3.2 回滚段与事务</h4><ol><li><p>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</p></li><li><p>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</p></li><li><p>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够 用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘 区或者在回滚段允许的情况下扩展新的盘区来使用。</p></li><li><p>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个 undo表空间。</p></li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_undo_tablespaces&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_undo_tablespaces <span class="operator">|</span> <span class="number">2</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"># undo log的数量，最少为<span class="number">2.</span> undo log的<span class="keyword">truncate</span>操作有purge协调线程发起。在<span class="keyword">truncate</span>某个undo log表空间的过程中，保证有一个可用的undo log可用。</span><br></pre></td></tr></table></figure><ol start="5"><li><p>当事务提交时，InnoDB存储引擎会做以下两件事情：</p><ul><li>将undo log放入列表中，以供之后的purge操作</li><li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li></ul></li></ol><hr><h4 id="2-3-3-回滚段中的数据分类">2.3.3 回滚段中的数据分类</h4><p>1.<code>未提交的回滚数据(uncommitted undo information)</code>：该数据所关联的事务并未提交，用于实现读一致性，所以该数据不能被其他事务的数据覆盖。<br>2.<code>已经提交但未过期的回滚数据(committed undo information)</code>：该数据关联的事务已经提交，但是仍受到undo retention参数的保持时间的影响。<br>3.<code>事务已经提交并过期的数据(expired undo information)</code>：事务已经提交，而且数据保存时间已经超过 undo retention参数指定的时间，属于已经过期的数据。当回滚段满了之后，就优先覆盖“事务已经提交并过期的数据&quot;。</p><p>事务提交后不能马上删除undo log及undo log所在的页。这是因为可能还有其他事务需要通过undo log来得到行记录之前的版本。故事务提交时将undo log放入一个链表中，是否可以最终删除undo log以undo log所在页由purge线程来判断。</p><hr><h3 id="2-4-undo的类型">2.4 undo的类型</h3><p>在InnoDB存储引擎中，undo log分为：</p><ul><li><p>insert undo log</p><p>insert undo log是指insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log可以在事务提交后直接删除。不需要进行purge操作。</p></li><li><p>update undo log</p><p>update undo log记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p></li></ul><hr><h3 id="2-5-undo-log的生命周期">2.5 undo log的生命周期</h3><h4 id="2-5-1-简要生成过程">2.5.1 简要生成过程</h4><p>以下是undo+redo事务的简化过程</p><p>假设有两个数值，分别为A=1和B=2，然后将A修改为3，B修改为4</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711162414928.png" alt="image-20220711162414928"  /><p><strong>只有Buffer Pool的流程：</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711162505008.png" alt="image-20220711162505008" style="zoom: 67%;" /><p><strong>有了Redo Log和Undo Log之后：</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711162642305.png" alt="image-20220711162642305" style="zoom:67%;" /><p>在更新Buffer Pool中的数据之前，我们需要先将该数据事务开始之前的状态写入Undo Log中。假设更新到一半出错了，我们就可以通过Undo Log来回滚到事务开始前。</p><hr><h4 id="2-5-2-详细生成过程">2.5.2 详细生成过程</h4><p>对于InnoDB引擎来说，每个行记录除了记录本身的数据之外，还有几个隐藏的列：</p><p>-<code>DB_ROW_ID</code>：如果没有为表显式的定义主键，并且表中也没有定义唯一索引，那么InnoDB会自动为表添加一个row_id的隐藏列作为主键。</p><p>-<code>DB_TRX_ID</code>：每个事务都会分配一个事务ID，当对某条记录发生变更时，就会将这个事务的事务ID写入trx_id 中。</p><p>-<code>DB_ ROLL_PTR</code>： 回滚指针，本质上就是指向 undo log 的指针。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230414112728356.png" alt="image-20230414112728356"></p><p><strong>当我们执行INSERT时：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (name) <span class="keyword">VALUES</span> (&quot;tom&quot;);</span><br></pre></td></tr></table></figure><p>插入的数据都会生成一条insert undo log，并且数据的回滚指针会指向它。undo log会记录undo log的序号、插入主键的列和值…，那么在进行rollback的时候，通过主键直接把对应的数据删除即可。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711163725129.png" alt="image-20220711163725129" style="zoom:50%;" /><p><strong>当我们执行UPDATE时：</strong></p><p>对应更新的操作会产生update undo log，并且会分更新主键和不更新主键的，假设现在执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span>&quot;Sun&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711164138414.png" alt="image-20220711164138414" style="zoom:50%;" /><p>这时会把老的记录写入新的undo log，让回滚指针指向新的undo log，它的undo no是1，并且新的undo log会指向老的undo log（undo no=0）。</p><p>假设现在执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711164421494.png" alt="image-20220711164421494" style="zoom:50%;" /><p>对于更新主键的操作，会先把原来的数据deletemark标识打开，这时并没有真正的删除数据，真正的删除会交给清理线程去判断，然后在后面插入一条新的数据，新的数据也会产生undo log，并且undo log的序号会递增。</p><p>可以发现每次对数据的变更都会产生一个undo log，当一条记录被变更多次时，那么就会产生多条undo log，undo log记录的是变更前的日志，并且每个undo log的序号是递增的，那么当要回滚的时候，按照序号<code>依次向前推</code>，就可以找到我们的原始数据了。</p><hr><h4 id="2-5-3-undo-log是如何回滚的">2.5.3 undo log是如何回滚的</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p><ol><li>通过undo no=3的日志把id=2的数据删除</li><li>通过undo no=2的日志把id=1的数据的deletemark还原成0</li><li>通过undo no=1的日志把id=1的数据的name还原成Tom</li><li>通过undo no=0的日志把id=1的数据删除</li></ol><h4 id="2-5-4-undo-log的删除">2.5.4 undo log的删除</h4><ul><li><p>针对于insert undo log</p><p>因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p></li><li><p>针对于update undo log</p><p>该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p></li></ul><blockquote><p>补充：</p><p>purge线程两个主要作用是：<code>清理undo页</code>和<code>清理page里面带有Delete_Bit标识的数据行</code>。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种“假删除”，只是做了个标记，真正的删除工作需要后台purge线程去完成。</p></blockquote><hr><h3 id="2-6-小结">2.6 小结</h3><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220711165612956.png" alt="image-20220711165612956" style="zoom:67%;" /><p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p><p>redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务基础</title>
      <link href="/posts/2ba1a1a7.html"/>
      <url>/posts/2ba1a1a7.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据库事务概述">1. 数据库事务概述</h2><h3 id="1-1-存储引擎支持情况">1.1 存储引擎支持情况</h3><p><code>SHOW ENGINES</code>命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220708124306444.png" alt="image-20220708124306444"></p><p>能看出在 MySQL 中，只有InnoDB 是支持事务的。</p><hr><h3 id="1-2-基本概念">1.2 基本概念</h3><p>事务：一组逻辑操作单，使数据从一种状态变换到另一种状态。</p><p>事务处理的原则：保证所有事务都作为<code>一个工作单</code>来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就<code>永久</code>地保<code>存下来</code>；要么数据库管理系统将<code>放弃</code>所作的所有<code>修改</code>，整个事务回滚( rollback )到最初状态。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 案例：AA用户给BB用户转<span class="number">100</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"># 服务器宕机</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">100</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-事务的ACID特性">1.3 事务的ACID特性</h3><ul><li><p>原子性（atomicity）：</p><p>原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。即要么成功，要么转失败，是不存在中间的状态。如果无法保证原子性会怎么样？就会出现数据不一致的情形，A减去100，而B增加100操作失败，系统将无故丢失100。</p></li><li><p>一致性（consistency）：</p><p>（国内很多网站上对一致性的阐述有误，具体你可以参考 Wikipedia 对Consistency的阐述）</p><p>根据定义，一致性是指事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code>。这种状态是<code>语义上</code>的而不是语法上的，跟具体的业务有关。那什么是合法的数据状态呢？满足<code>预定的约束</code>的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就 是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作 之前的状态。</p><p>举例1：A有200，转300出去，此时A余额为-100。你自然就发现此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须&gt;=0。</p><p>举例2：A有200，转50给B，A的钱扣了，但是B因为各种意外，余额并没有增加。你也知道此时的数据是不一致的，为什么呢？因为你定义了一个状态，要求A+B的总余额必须不变。</p><p>举例3：在数据表中我们将<code>姓名</code>字段设置为<code>唯一性约束</code>，这时当事务进行提交或者事务发生回滚的时候，如果数据表的姓名不唯一，就破坏了事务的一致性要求。</p></li><li><p>隔离型（isolation）：</p><p>事务的隔离性是指一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。如果无法保证隔离性会怎么样？假设A有200，B0。A往B转两次，每次金额为50 ，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220708164610193.png" alt="image-20220708164610193" style="zoom:50%;" /><ul><li><p>持久性（durability）：</p><p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库 故障不应该对其有任何影响。</p><p>持久性是通过<code>事务日志</code>来保证的。日志包括了<code>重做日志</code>和<code>回滚日志</code>。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做 的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执 行，从而使事务具有持久性。</p></li></ul><blockquote><p>总结</p><p>ACID是事务的四大特征，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件， 而持久性是我们的目的。</p><p>数据库事务，其实就是数据库设计者为了方便起见，把需要保证<code>原子性</code>、<code>隔离性</code>、<code>一致性</code>和<code>持久性</code>的一个或多个数据库操作称为一个事务。</p></blockquote><h3 id="1-4-事务的状态">1.4 事务的状态</h3><p>我们现在知道<code>事务</code>是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执 行的不同阶段把<code>事务</code>大致划分成几个状态：</p><ul><li><p>活动的（active）</p><p>事务对应的数据库操作正在执行过程中时，我们就说该事务处在<code>活动的</code>状态。</p></li><li><p>部分提交的（partially committed）</p><p>当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并<code>没有刷新到磁盘</code>时，我们就说该事务处在<code>部分提交的</code>状态。</p></li><li><p>失败的（failed）</p><p>当事务处在<code>活动的</code>或者 部分提交的 状态时，可能遇到了某些错误（数据库自身的错误、操作系统 错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失 败的 状态。</p></li><li><p>中止的（aborted）</p><p>如果事务执行了一部分而变为<code>失败的</code>状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为<code>回滚</code>。当<code>回滚</code>操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了<code>中止的</code>状态。</p><p>举例：</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;AA&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">50</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;BB&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>提交的（committed）</p><p>当一个处在<code>部分提交的</code>状态的事务将修改过的数据都<code>同步到磁盘</code>上之后，我们就可以说该事务处在了<code>提交的</code>状态。</p><p>一个基本的状态转换图如下所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220708171859055.png" alt="image-20220708171859055" style="zoom: 33%;" /><p>图中可见，只有当事务处于<code>提交的</code>或者<code>中止的</code>状态时，一个事务的生命周期才算是结束了。对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，对于处于中止状态的事务，该事务对数据库所做的所有修改都会被回滚到没执行该事务之前的状态。</p></li></ul><hr><h2 id="2-如何使用事务">2. 如何使用事务</h2><p>使用事务有两种方式，分别为<code>显式事务</code>和<code>隐式事务</code>。</p><h3 id="2-1-显式事务">2.1 显式事务</h3><p>步骤1： START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">#或者</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br></pre></td></tr></table></figure><p><code>START TRANSACTION</code>语句相较于<code>BEGIN</code>特别之处在于，后边能跟随几个<code>修饰符</code>：</p><p>①<code>READ ONLY</code>：标识当前事务是一个<code>只读事务</code>，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p><blockquote><p>补充：只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用 CREATE TMEPORARY TABLE 创建的表），由于它们只能再当前会话中可见，所有只读事务其实也是可以对临时表进行增、删、改操作的。</p></blockquote><p>②<code>READ WRITE</code>：标识当前事务是一个<code>读写事务</code>，也就是属于该事务的数据库操作既可以读取数据， 也可以修改数据。</p><p>③<code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读。</p><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>; # 开启一个只读事务</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>, <span class="keyword">WITH</span> CONSISTENT SNAPSHOT # 开启只读事务和一致性读</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION READ WRITE, <span class="keyword">WITH</span> CONSISTENT SNAPSHOT # 开启读写事务和一致性读</span><br></pre></td></tr></table></figure><p>注意：</p><p>*<code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事务<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时即设置为<code>只读</code>的也设置为<code>读写</code>的，所以不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边。</p><ul><li>如果我们不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式</li></ul><p>步骤2：一系列事务中的操作（主要是DML，不含DDL）</p><p>步骤3：提交事务 或 中止事务（即回滚事务）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 提交事务。当提交事务后，对数据库的修改是永久性的。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 回滚事务。即撤销正在进行的所有没有提交的修改</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"># 将事务回滚到某个保存点。</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>]</span><br></pre></td></tr></table></figure><p>其中关于SAVEPOINT相关操作有：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。</span><br><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除某个保存点</span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称;</span><br></pre></td></tr></table></figure><h3 id="2-2-隐式事务">2.2 隐式事务</h3><p>MySQL中有一个系统变量<code>autocommit</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit    <span class="operator">|</span>  <span class="keyword">ON</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>当然，如果我们想关闭这种<code>自动提交</code>的功能，可以使用下边两种方法之一：</p><ul><li><p>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p></li><li><p>把系统变量<code>autocommit</code>的值设置为<code>OFF</code>，就像这样：</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> OFF;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-隐式提交数据的情况">2.3 隐式提交数据的情况</h3><ul><li><p>数据定义语言（Data definition language，缩写为：DDL）</p><p>数据库对象，指的就是<code>数据库、表、视图、存储过程</code>等结构。当我们<code>CREATE、ALTER、DROP</code>等语句去修改数据库对象时，就会隐式的提交前边语句所属于的事务。即：</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... # 事务中的一条语句</span><br><span class="line"><span class="keyword">UPDATE</span> ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其他语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ... # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure><ul><li><p>隐式使用或修改mysql数据库中的表</p><p>当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。</p></li><li><p>事务控制或关于锁定的语句</p><p>① 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会隐式的提交上一个事务。即：</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... # 事务中的一条语句</span><br><span class="line"><span class="keyword">UPDATE</span> ... # 事务中的一条语句</span><br><span class="line">... # 事务中的其他语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>; # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure><p>② 当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交前边语句所属的事务。</p><p>③ 使用 LOCK TABLES 、 UNLOCK TABLES 等关于锁定的语句也会 隐式的提交 前边语句所属的事务。</p><ul><li><p>加载数据的语句</p><p>使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会<code>隐式的提交</code>前边语句所属的事务。</p></li><li><p>关于MySQL复制的一些语句</p><p>使用<code>START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO</code>等语句会隐式的提交前边语句所属的事务</p></li><li><p>其他的一些语句</p><p>使用<code>ANALYZE TABLE、CACHE INDEX、CAECK TABLE、FLUSH、LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET</code>等语句也会隐式的提交前边语句所属的事务。</p></li></ul><h3 id="2-4-举例1-提交与回滚">2.4 举例1:提交与回滚</h3><p>我们看下在 MySQL 的默认状态下，下面这个事务最后的处理结果是什么。</p><p>情况1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(name <span class="type">varchar</span>(<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>运行结果（1 行数据）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> 秒)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> 秒)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> 秒)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">Duplicate entry <span class="string">&#x27;李四&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;user.PRIMARY&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> 秒)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 张三    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">1</span> 行于数据集 (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure><p>情况2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (name <span class="type">varchar</span>(<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>运行结果（2 行数据）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 张三    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 李四    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">2</span> 行于数据集 (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure><p>情况3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(name <span class="type">varchar</span>(<span class="number">255</span>), <span class="keyword">PRIMARY</span> KEY (name)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@completion</span>_type <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">SELECT</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>运行结果（1 行数据）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> name   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> 张三    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="number">1</span> 行于数据集 (<span class="number">0.01</span> 秒)</span><br></pre></td></tr></table></figure><p>你能看到相同的 SQL代码，只是在事务开始之前设置了<code>SET @@completion_type=1;</code>结果就和我们第一次处理的一样，只有一个“张三”。这是为什么呢？</p><p>这里我讲解下 MySQL 中<code>completion_type</code>参数的作用，实际上这个参数有3种可能：</p><p>1.<code>completion=0</code>，这是<code>默认情况</code>。当我们执行 COMMIT 的时候会提交事务，在执行下一个事务时，还需要使用<code>START TRANSACTION</code>或者<code>BEGIN</code>来开启。</p><p>2.<code>completion=1</code>，这种情况下，当我们提交事务后，相当于执行了<code>COMMIT AND CHAIN</code>， 也就是开启一个链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务。<br>3.<code>completion=2</code>，这种情况下<code>COMMIT=COMMIT AND RELEASE</code>，也就是当我们提交后，会自动与服务器断开连接。</p><blockquote><p>当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事 务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。</p><p>当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效， 在 ROLLBACK 时才会回滚。</p></blockquote><h3 id="2-5-举例2-测试不支持事务的引擎">2.5 举例2:测试不支持事务的引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(i <span class="type">INT</span>) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test2(i <span class="type">INT</span>) ENGINE<span class="operator">=</span>MYISAM;</span><br></pre></td></tr></table></figure><p>针对于InnoDB表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test1;</span><br></pre></td></tr></table></figure><p>结果：没有数据</p><p>针对于MYISAM表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test2;</span><br></pre></td></tr></table></figure><p>结果：有一条数据</p><h3 id="2-6-举例3-SAVEPOINT">2.6 举例3:SAVEPOINT</h3><p>创建表并添加数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">15</span>),</span><br><span class="line">balance <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account(NAME,balance)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;张三&#x27;</span>,<span class="number">1000</span>),</span><br><span class="line">(<span class="string">&#x27;李四&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> s1; # 设置保存点</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> s1; # 回滚到保存点</span><br></pre></td></tr></table></figure><p>结果：张三：800.00</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>结果：张三：1000.00</p><hr><h2 id="3-事务隔离级别">3. 事务隔离级别</h2><p>MySQL是一个<code>客户端／服务器</code>架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个会话（<code>Session</code>）。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。事务有<code>隔离性</code>的特性，理论上在某个事务<code>对某个数据进行访问</code>时，其他事务应该进行<code>排队</code>，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对<code>性能影响太大</code>，我们既想保持事务的隔离性，又想让服务器在处理访问同一数据的多个事务时<code>性能尽量高些</code>，那就看二者如何权衡取 舍了。</p><h3 id="3-1-数据准备">3.1 数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">    studentno <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    class <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (studentno)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>然后向这个表里插入一条数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小谷&#x27;</span>, <span class="string">&#x27;1班&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在表里的数据就是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span> studentno <span class="operator">|</span> name   <span class="operator">|</span> class <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span>    <span class="operator">|</span>   小谷  <span class="operator">|</span> <span class="number">1</span>班   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+--------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="3-2-数据并发问题">3.2 数据并发问题</h3><p>针对事务的隔离性和并发性，我们怎么做取舍呢？先看一下访问相同数据的事务在 不保证串行执行 （也 就是执行完一个再执行另一个）的情况下可能会出现哪些问题：</p><div class="tabs" id="296a7c8a-bce6-4082-a822-baf07e15611f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#296a7c8a-bce6-4082-a822-baf07e15611f-1"><i class="fas fa-award"></i>脏写(Dirty Write)</button></li><li class="tab"><button type="button" data-href="#296a7c8a-bce6-4082-a822-baf07e15611f-2"><i class="fas fa-baseball-ball"></i>脏读(Dirty Read)</button></li><li class="tab"><button type="button" data-href="#296a7c8a-bce6-4082-a822-baf07e15611f-3"><i class="fas fa-bone"></i>不可重复读(Non-Repeatable Read)</button></li><li class="tab"><button type="button" data-href="#296a7c8a-bce6-4082-a822-baf07e15611f-4"><i class="fas fa-anchor"></i>幻读(Phantom)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="296a7c8a-bce6-4082-a822-baf07e15611f-1"><p>对于两个事务 Session A、Session B，如果事务Session A<code>修改了</code>另一个<code>未提交</code>事务Session B<code>修改过</code>的数据，那就意味着发生了<code>脏写</code>，示意图如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220708214453902.png" alt="image-20220708214453902" style="zoom:50%;" /><p>Session A 和 Session B 各开启了一个事务，Sesssion B 中的事务先将studentno列为1的记录的name列更新为’李四’，然后Session A中的事务接着又把这条studentno列为1的记录的name列更新为’张三’。如果之后Session B中的事务进行了回滚，那么Session A中的更新也将不复存在，这种现象称之为脏写。这时Session A中的事务就没有效果了，明明把数据更新了，最后也提交事务了，最后看到的数据什么变化也没有。这里大家对事务的隔离性比较了解的话，会发现默认隔离级别下，上面Session A中的更新语句会处于等待状态，这里只是跟大家说明一下会出现这样的现象。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="296a7c8a-bce6-4082-a822-baf07e15611f-2"><p>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/10b513008ea35ee880c592a88adcb12f.png" alt="图片" style="zoom:50%;" /><p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，<strong>如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="296a7c8a-bce6-4082-a822-baf07e15611f-3"><p>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/f5b4f8f0c0adcf044b34c1f300a95abf.png" alt="图片" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="296a7c8a-bce6-4082-a822-baf07e15611f-4"><p><strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</strong></p><p>举个栗子。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/d19a1019dc35dfe8cfe7fbff8cd97e31.png" alt="图片" style="zoom:50%;" /><p>接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。</p><p>然后事务 B 再次查询余额大于 100 万的记录，此时查询到的记录数量有 6 条，<strong>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="3-3-SQL中的四种隔离级别">3.3 SQL中的四种隔离级别</h3><p>上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题 按照严重性来排一下序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏写 <span class="operator">&gt;</span> 脏读 <span class="operator">&gt;</span> 不可重复读 <span class="operator">&gt;</span> 幻读</span><br></pre></td></tr></table></figure><p>我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，并发问题发生的就越多。<code>SQL标准</code>中设立了4个<code>隔离级别</code>：</p><p>*<code>READ UNCOMMITTED</code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。<br>*<code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。<br>*<code>REPEATABLE READ</code>：可重复读，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。<br>*<code>SERIALIZABLE</code>：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</p><p><code>SQL标准</code>中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/4e98ea2e60923b969790898565b4d643.png" alt="图片" style="zoom:50%;" /><p><code>脏写</code>怎么没涉及到？因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p><p>不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4 种事务隔离级别与并发性能的关系如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220708220957108.png" alt="image-20220708220957108" style="zoom: 50%;" /><h3 id="3-4-MySQL支持的四种隔离级别">3.4 MySQL支持的四种隔离级别</h3><p>不同的数据库厂商对SQL标准中规定的四种隔离级别支持不一样。比如，<code>Oracle</code>就只支持<code>READ COMMITTED (默认隔离级别）</code>和<code>SERIALIZABLE隔离级别</code>。MysQL虽然支持4种隔离级别，但与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL在<code>REPEATABLE READ隔离级别</code>下，是可以禁止幻读问题的发生的。</p><p>MySQL的默认隔离级别为<code>REPEATABLE READ</code>，我们可以手动修改一下事务的隔离级别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本之前：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> tx_isolation  <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"># MySQL <span class="number">5.7</span><span class="number">.20</span>版本之后，引入transaction_isolation来替换tx_isolation</span><br><span class="line"></span><br><span class="line"># 查看隔离级别，MySQL <span class="number">5.7</span><span class="number">.20</span>的版本及之后：</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">#或者不同MySQL版本中都可以使用的：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure><h3 id="3-5-如何设置事务的隔离级别">3.5 如何设置事务的隔离级别</h3><p>通过下面的语句修改事务的隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;</span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;隔离级别&#x27;</span></span><br><span class="line">#其中，隔离级别格式：</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>UNCOMMITTED</span><br><span class="line"><span class="operator">&gt;</span> READ<span class="operator">-</span>COMMITTED</span><br><span class="line"><span class="operator">&gt;</span> REPEATABLE<span class="operator">-</span>READ</span><br><span class="line"><span class="operator">&gt;</span> SERIALIZABLE</span><br></pre></td></tr></table></figure><p>关于设置时使用GLOBAL或SESSION的影响：</p><ul><li>使用 GLOBAL 关键字（在全局范围影响）：</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure><p>则：</p><ul><li>当前已经存在的会话无效</li><li>只对执行完该语句之后产生的会话起作用</li></ul><ul><li>使用<code>SESSION</code>关键字（在会话范围影响）：</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION_ISOLATION <span class="operator">=</span> <span class="string">&#x27;SERIALIZABLE&#x27;</span>;</span><br></pre></td></tr></table></figure><p>则：</p><ul><li>对当前会话的所有后续的事务有效</li><li>如果在事务之间执行，则对后续的事务有效</li><li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</li></ul><p>如果在服务器启动时想改变事务的默认隔离级别，可以修改启动参数<code>transaction_isolation</code>的值。比如，在启动服务器时指定了<code>transaction_isolation=SERIALIZABLE</code>，那么事务的默认隔离界别就从原来的<code>REPEATABLE-READ</code>变成了<code>SERIALIZABLE</code>。</p><blockquote><p>小结：</p><p>数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。</p></blockquote><h3 id="3-6-不同隔离级别举例">3.6 不同隔离级别举例</h3><p>初始化数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> account;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;100&#x27;</span>), (<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220708223250773.png" alt="image-20220708223250773"  /><div class="tabs" id="90081ba8-8d47-4c08-8151-408cee1640d0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#90081ba8-8d47-4c08-8151-408cee1640d0-1"><i class="fas fa-cat"></i>读未提交之脏读</button></li><li class="tab"><button type="button" data-href="#90081ba8-8d47-4c08-8151-408cee1640d0-2"><i class="fas fa-horse"></i>读已提交</button></li><li class="tab"><button type="button" data-href="#90081ba8-8d47-4c08-8151-408cee1640d0-3"><i class="fas fa-dove"></i>不可重复读</button></li><li class="tab"><button type="button" data-href="#90081ba8-8d47-4c08-8151-408cee1640d0-4"><i class="fas fa-dragon"></i>幻读</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="90081ba8-8d47-4c08-8151-408cee1640d0-1"><p>设置隔离级别为未提交读：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710193920008.png" alt="image-20220710193920008"></p><p>脏读就是指当前事务就在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了这个数据。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="90081ba8-8d47-4c08-8151-408cee1640d0-2"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710194440101.png" alt="image-20220710194440101"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="90081ba8-8d47-4c08-8151-408cee1640d0-3"><p>设置隔离级别为可重复读，事务的执行流程如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710194144826.png" alt="image-20220710194144826"></p><p>当我们将当前会话的隔离级别设置为可重复读的时候，当前会话可以重复读，就是每次读取的结果集都相同，而不管其他事务有没有提交。但是在可重复读的隔离级别上会出现幻读的问题。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="90081ba8-8d47-4c08-8151-408cee1640d0-4"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220710194042096.png" alt="image-20220710194042096"></p><p>这里要灵活的<code>理解读取</code>的意思，第一次select是读取，第二次的 insert 其实也属于隐式的读取，只不过是在mysql 的机制中读取的，插入数据也是要先读取一下有没有主健冲突才能决定是否执行插入。</p><p>幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。</p><p>在RR隔离级别下，step1、step2 是会正常执行的，step3 则会报错主键冲突，对于事务1的业务来说是执行失败的，这里事务1就是发生了幻读，因为事务1在step1 中读取的数据状态并不能支撑后续的业务操作，事务1： 见鬼了，我刚才读到的结果应该可以支持我这样操作才对啊，为什么现在不可以”。事务1不敢相信的又执行了 step4，发现和 setpi 读取的结果是一样的（RR下的 MVCC机制）。此时，幻读无疑已经发生，事务1无论读取多少次，都查不到 id=3的记录，但它的确无法插入这条他通过读取来认定不存在的记录（此数据已被事务2插入），对于事务1来说，它幻读了。</p><p>其实 RR 也是可以避免幻读的，通过对 select 操作手动加<code>行X锁(独占锁）</code>（SELECT … FOR UPDATE 这也正是 SERIALIZABLE 隔离级别下会隐式为你做的事情）。同时，即便当前记录不存在，比如d=3 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加<code>行X锁</code>，不存在就加<code>间隙锁</code>），其他事务则无法插入此索引的记录，故杜绝了幻读。</p><p>在<code>SERIALIZABLE 隔离级别</code>下，step1 执行时是会隐式的添加<code>行(x)锁/ gap(x)锁</code>的，从而 step2 会被阻塞， step3 会正常执行，待事务1提交后，事务2才能继续执行（主键冲突执行失败），对于事务1来说业务是正确的，成功的阻塞扼杀了扰乱业务的事务2，对于事务1来说他前期读取的结果是可以支撑其后续业务的。</p><p>所以MySQL 的幻读并非什么读取两次返回结果集不同，而是事务在插入事先检测不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测读获取到的数据如同鬼影一般。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="4-事务的常见分类">4. 事务的常见分类</h2><p>从事务理论的角度来看，可以把事务分为以下几种类型：</p><ul><li>扁平事务（Flat Transactions）</li><li>带有保存点的扁平事务（Flat Transactions with Savepoints）</li><li>链事务（Chained Transactions）</li><li>嵌套事务（Nested Transactions）</li><li>分布式事务（Distributed Transactions）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库其他调优策略</title>
      <link href="/posts/acde6505.html"/>
      <url>/posts/acde6505.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据库调优的措施">1. 数据库调优的措施</h2><h3 id="1-1-调优的目标">1.1 调优的目标</h3><ul><li>尽可能节省系统资源 ，以便系统可以提供更大负荷的服务。（吞吐量更大）</li><li>合理的结构设计和参数调整，以提高用户操作响应的速度 。（响应速度更快）</li><li>减少系统的瓶颈，提高MySQL数据库整体的性能。</li></ul><h3 id="1-2-如何定位调优问题">1.2 如何定位调优问题</h3><p>不过随着用户量的不断增加，以及应用程序复杂度的提升，我们很难用<code>“更快”</code>去定义数据库调优的目标，因为用户在不同时间段访问服务器遇到的瓶颈不同，比如双十一促销的时候会带来大规模的<code>并发访问</code>；还有用户在进行不同业务操作的时候，数据库的<code>事务处理</code>和<code>SQL查询</code>都会有所不同。因此我们还需要更加精细的定位，去确定调优的目标。</p><p>如何确定呢？一般情况下，有如下几种方式：</p><ul><li><span class='p red'>用户的反馈（主要）</span><p>用户是我们的服务对象，因此他们的反馈是最直接的。虽然他们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们要重视用户的反馈，找到和数据相关的问题。</p></li><li><span class='p red'>日志分析（主要）</span><p>我们可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。</p></li><li><span class='p red'>服务器资源使用监控</span><p>通过监控服务器的 CPU、内存、V/0 等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。</p></li><li><span class='p red'>数据库内部状况监控</span><p>在数据库的监控中，活动会话 (Active Session）监控是一个重要的指标。通过它，你可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在 SQL 堆积等。</p></li><li><p>其它</p><p>除了活动会话监控以外，我们也可以对事务、锁等待等进行监控，这些都可以帮助我们对数据库的运行状态有更全面的认识。</p></li></ul><hr><h3 id="1-3-调优的维度和步骤">1.3 调优的维度和步骤</h3><p>我们需要调优的对象是整个数据库管理系统，它不仅包括 SQL 查询，还包括数据库的部署配置、架构 等。从这个角度来说，我们思考的维度就不仅仅局限在 SQL 优化上了。通过如下的步骤我们进行梳理：</p><div class="tabs" id="6631c936-75d9-471b-8fe1-72604ed5d199"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6631c936-75d9-471b-8fe1-72604ed5d199-1"><i class="fas fa-atom"></i>1</button></li><li class="tab"><button type="button" data-href="#6631c936-75d9-471b-8fe1-72604ed5d199-2"><i class="far fa-sun"></i>2</button></li><li class="tab"><button type="button" data-href="#6631c936-75d9-471b-8fe1-72604ed5d199-3"><i class="fas fa-wind"></i>3</button></li><li class="tab"><button type="button" data-href="#6631c936-75d9-471b-8fe1-72604ed5d199-4"><i class="fas fa-fire-alt"></i>4</button></li><li class="tab"><button type="button" data-href="#6631c936-75d9-471b-8fe1-72604ed5d199-5"><i class="fas fa-heartbeat"></i>5</button></li><li class="tab"><button type="button" data-href="#6631c936-75d9-471b-8fe1-72604ed5d199-6"><i class="fas fa-cookie-bite"></i>6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6631c936-75d9-471b-8fe1-72604ed5d199-1"><blockquote><p>第1步：选择适合的 DBMS</p></blockquote><p>如果对<code>事务性处理</code>以及<code>安全性要求高</code>的话，可以选择商业的数据库产品。这些数据库在事务处理和查询性能上都比较强，比如采用 SQL Server、 Oracle，那么<code>单表存储上亿条数据</code>是没有问题的。如果数据表设计得好，即使不采用<code>分库分表</code>的方式，查询效率也不差。</p><p>除此以外，你也可以采用开源的 MySQL 进行存储，它有很多存储引擎可以选择，如果进行事务处理的话可以选择 InnoDB，非事务处理可以选择 MyISAM。</p><p>NoSQL阵营包括<code>键值型数据库</code>、<code>文档型数据库</code>、<code>搜索引擎</code>、<code>列式存储</code>和<code>图形数据库</code>。这些数据库的优缺点和使用场景各有不同，比如列式存储数据库可以大幅度降低系统的V/0，适合于分布式文件系统，但如果数据需要频繁地增删改，那么列式存储就不太适用了。</p><p><span class='p red'>DBMS 的选择关系到了后面的整个设计过程，所以第一步就是要选择适合的 DBMS。</span>如果已经确定好了 DBMS，那么这步可以跳过。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6631c936-75d9-471b-8fe1-72604ed5d199-2"><blockquote><p>第2步：优化表设计</p></blockquote><p>选择了 DBMS 之后，我们就需要进行表设计了。而数据表的设计方式也直接影响了后续的 SQL 查询语句。RDBMS 中，每个对象都可以定义为一张表，表与表之间的关系代表了对象之间的关系。如果用的是 MysQL，我们还可以根据不同表的使用需求，选择不同的存储引|擎。除此以外，还有一些优化的原则可以参考：</p><ol><li><p>表结构要尽量<code>遵循三范式的原则</code>。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新，插入和删除数据时等异常情况的发生。</p></li><li><p>如果<code>查询</code>应用比较多，尤其是需要进行<code>多表联查</code>的时候，可以采用<code>反范式</code>进行优化。反范式采用<code>空间换时间</code>的方式，通过增加冗余字段提高查询的效率。<br>3.<code>表字段的数据类型选择</code>，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用宁符类型；宁符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时， 就可以采用 CHAR 类型；当长度不固定时，通常采用VARCHAR类型。</p></li></ol><p>数据表的结构设计很基础，也很关键。<span class='p red'>好的表结构可以在业务发展和用户量增加的情况下依然发挥作用，不好的表结构设计会让数据表变得非常臃肿，查询效率也会降低。</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6631c936-75d9-471b-8fe1-72604ed5d199-3"><blockquote><p>第3步：优化逻辑查询</p></blockquote><p>当我们建立好数据表之后，就可以对数据表进行增删改查的操作了。这时我们首先需要考虑的是逻辑查询优化。</p><p>SQL 查询优化，可以分为<code>逻辑查询优化</code>和<code>物理查询优化</code>。逻辑查询优化就是通过改变 SQL语句的内容让 SQL执行效率更高效，采用的方式是对 SQL语句进行等价变换，对查询进行重写。</p><p><span class='p red'>SQL的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连接消除和嵌套连接消除等.</span></p><p>比如我们在讲解 EXISTS 子查询和IN子查询的时候，会根据<code>小表驱动大表</code>的原则选择适合的子查询。在 WHERE 子句中会尽量避免对字段进行函数运算，它们会让字段的索引失效。</p><p>举例：查询评论内容开头为 abc 的内容都有哪些，如果在 WHERE 子句中使用了函数，语句就会写成下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  comment_id,comment.text,comment_time</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">  product_comment</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  <span class="built_in">SUBSTRING</span>(comment.text,<span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure><p>采用查询重写的方式进行等价替换：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  comment_id,comment_text,comment_time </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">  product_comment </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  comment_text <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6631c936-75d9-471b-8fe1-72604ed5d199-4"><blockquote><p>第4步：优化物理查询</p></blockquote><p>物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过计算代价模型对 各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。<strong>在这个部分中，我们需要掌握的重点是对索引的创建和使用。</strong></p><p>但索引不是万能的，我们需要根据实际情况来创建索引。那么都有哪些情况需要考虑呢？我们在前面几章中已经进行了细致的剖析。</p><p>SQL 查询时需要对不同的数据表进行查询，因此在物理查询优化阶段也需要确定这些查询所采用的路径，具体的情况包括：</p><ol><li><p>单表扫描：对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。</p></li><li><p>两张表的连接：常用的连接方式包括了嵌套循环连接、HASH 连接和合并连接。</p></li><li><p>多张表的连接：多张数据表进行连接的时候，顺序很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到很高的数据量级，巨大的搜索空间显然会占用更多的资源，因此我们需要通过调整连接顺序，将搜索空间调整在一个可接受的范围内。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6631c936-75d9-471b-8fe1-72604ed5d199-5"><blockquote><p>第5步：使用 Redis 或 Memcached 作为缓存</p></blockquote><p>除了可以对 SQL 本身进行优化以外，我们还可以请外援提升查询的效率。</p><p>因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作，当用 户量增大的时候，如果频繁地进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放 到内存中，就会大幅提升查询的效率。</p><p>键值存储数据库可以帮我们解决这个问题。</p><p>常用的键值存储数据库有 Redis 和 Memcached，它们都可以将数据存放到内存中。</p><p>从可靠性来说，Redis 支持持久化，可以让我们的数据保存在硬盘上，不过这样一来性能消耗也会比较大。而 Memcached 仅仅是内存存储，不支持持久化。</p><p>从支持的数据类型来说，Redis 比 Memcached 要多，它不仅支持 key-value 类型的数据，还支持 List, Set, Hash 等数据结构。当我们有持久化需求或者是更高级的数据处理需求的时候，就可以使用 Redis。如果是简单的 key value 存储，则可以使用 Memcached。</p><p><span class='p red'>通常我们对于查询响应要求高的场景（响应时间短，吞吐量大），可以考虑内存数据库，毕竟术业有专攻。</span>传统的 RDBMS 都是将数据存储在硬盘上，而内存数据库则存放在内存中，查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6631c936-75d9-471b-8fe1-72604ed5d199-6"><blockquote><p>第6步：库级优化</p></blockquote><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707202732911.png" alt="image-20220707202732911"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707203538155.png" alt="image-20220707203538155"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707203607993.png" alt="image-20220707203607993"  /><blockquote><p>但需要注意的是，分拆在提升数据库性能的同时，也会增加维护和使用成本。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h2 id="2-优化MySQL服务器">2. 优化MySQL服务器</h2><p>优化MySQL服务器主要从两个方面来优化，一方面是对硬件进行优化；另一方面是对MySQL 服务的参数进行优化。这部分的内容需要较全面的知识，一般只有专业的数据库管理员才能进行这一类的优化。对于可以定制参数的操作系统，也可以针对MySQL进行操作系统优化。</p><h3 id="2-1-优化服务器硬件">2.1 优化服务器硬件</h3><p>服务器的硬件性能直接决定着MySQL数据库的性能。硬件的性能瓶颈直接决定MySQL数据库的运行速度 和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。</p><p>（1）<code>配置较大的内存</code>。足够大的显存是提高MySQL数据库性能的方法之一。内存的速度比磁盘I/O快得多，可以通过增加系统的<code>缓冲区容量</code>使数据在内存中停留的时间更长，以<code>减少磁盘I/O</code>。</p><p>（2）<code>配置高速磁盘系统</code>，以减少读盘的等待时间，提高响应速度。磁盘的I/O能力，也就是它的寻道能力，目前的SCSI高速旋转的是7200转/分钟，这样的速度，一旦访问的用户量上去，磁盘的压力就会过大，如果是每天的网站pv (page view) 在150w，这样的一般的配置就无法满足这样的需求了。现在SSD盛行，在SSD上随机访问和顺序访问性能差不多，使用SSD可以减少随机IO带来的性能损耗。</p><p>（3）<code>合理分布磁盘I/O</code>，把磁盘I/O分散在多个设备，以减少资源竞争，提高冰箱操作能力。</p><p>（4）<code>配置多处理器</code>, MySQL是多线程的数据库，多处理器可同时执行多个线程。</p><h3 id="2-2-优化MySQL的参数">2.2 优化MySQL的参数</h3><p>通过优化MySQL的参数可以提高资源利用率，从而达到提高MySQL服务器性能的目的。</p><p>MySQL服务的配置参数都在my.cnf 或者my.ini 文件的[mysqld组中。配置完参数以后，需要重新启动MySQL服务才会生效。</p><p>下面对几个对性能影响比较大的参数进行详细介绍。</p><ul><li><p>innodb_buffer_pool_size ：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的 表 和索引的最大缓存 。它不仅仅缓存 索引数据 ，还会缓存 表的数据 。这个值越大，查询的速度就会越 快。但是这个值太大会影响操作系统的性能。</p></li><li><p>key_buffer_size ：表示 索引缓冲区的大小 。索引缓冲区是所有的 线程共享 。增加索引缓冲区可 以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存 的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 4GB 左右 的服务器该参数可设置为 256M 或 384M 。</p></li><li><p>table_cache ：表示 同时打开的表的个数 。这个值越大，能够同时打开的表的个数越多。物理内 存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表 太多会影响操作系统的性能。</p></li><li><p>query_cache_size ：表示 查询缓冲区的大小 。可以通过在MySQL控制台观察，如果 Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size 的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效 率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很 多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。</p></li><li><p>query_cache_type 的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type=0并不 会导致MySQL释放query_cache_size所配置的缓存区内存。</p><ul><li>当query_cache_type=1时，所有的查询都将使用查询缓存区，除非在查询语句中指定 SQL_NO_CACHE ，如SELECT SQL_NO_CACHE * FROM tbl_name。</li><li>当query_cache_type=2时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓 存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的 查询操作的情况。</li></ul></li><li><p>sort_buffer_size ：表示每个 需要进行排序的线程分配的缓冲区的大小 。增加这个参数的值可以 提高 ORDER BY 或 GROUP BY 操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB 左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。</p></li><li><p>join_buffer_size = 8M ：表示 联合查询操作所能使用的缓冲区大小 ，和sort_buffer_size一样， 该参数对应的分配内存也是每个连接独享。</p></li><li><p>read_buffer_size ：表示 每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节） 。当线 程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size=n可以临时设置该参 数的值。默认为64K，可以设置为4M。</p></li><li><p>innodb_flush_log_at_trx_commit ：表示 何时将缓冲区的数据写入日志文件 ，并且将日志文件 写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值 为1。</p><ul><li>值为 0 时，表示 每秒1次 的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的 commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导 致上一秒钟所有事务数据的丢失。</li><li>值为 1 时，表示 每次提交事务时 将数据写入日志文件并将日志文件写入磁盘进行同步。该模 式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入 （flush）硬盘。</li><li>值为 2 时，表示 每次提交事务时 将数据写入日志文件， 每隔1秒 将日志文件写入磁盘。该模 式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数 据才可能丢失。</li></ul></li><li><p>innodb_log_buffer_size ：这是 InnoDB 存储引擎的 事务日志所使用的缓冲区 。为了提高性能， 也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条 件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</p></li><li><p>max_connections ：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接 数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的 服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大 越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</p></li><li><p>back_log ：用于 控制MySQL监听TCP端口时设置的积压请求栈大小 。如果MySql的连接数达到 max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即 back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默 认值为 50 ， 之后的版本默认为 50 + （max_connections / 5）， 对于Linux系统推荐设置为小于512 的整数，但最大不超过900。</p><p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p></li><li><p>thread_cache_size ： 线程池缓存线程数量的大小 ，当客户端断开连接后将当前线程缓存起来， 当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可 以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为 120。</p><p>可以通过如下几个MySQL状态值来适当调整线程池的大小：</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Thread%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Threads_cached <span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_connected <span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_created <span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_running <span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>当 Threads_cached 越来越少，但 Threads_connected 始终不降，且 Threads_created 持续升高，可 适当增加 thread_cache_size 的大小。</p><ul><li><p>wait_timeout ：指定 一个请求的最大连接时间 ，对于4GB左右内存的服务器可以设置为5-10。</p></li><li><p>interactive_timeout ：表示服务器在关闭连接前等待行动的秒数。</p></li></ul><p>这里给出一份my.cnf的参考配置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysqld]</span><br><span class="line">port <span class="operator">=</span> <span class="number">3306</span> </span><br><span class="line">serverid <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line">socket <span class="operator">=</span> <span class="operator">/</span>tmp<span class="operator">/</span>mysql.sock </span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>locking #避免MySQL的外部锁定，减少出错几率增强稳定性。 </span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>name<span class="operator">-</span>resolve #禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ </span><br><span class="line">back_log <span class="operator">=</span> <span class="number">384</span></span><br><span class="line">key_buffer_size <span class="operator">=</span> <span class="number">256</span>M </span><br><span class="line">max_allowed_packet <span class="operator">=</span> <span class="number">4</span>M </span><br><span class="line">thread_stack <span class="operator">=</span> <span class="number">256</span>K</span><br><span class="line">table_cache <span class="operator">=</span> <span class="number">128</span>K </span><br><span class="line">sort_buffer_size <span class="operator">=</span> <span class="number">6</span>M </span><br><span class="line">read_buffer_size <span class="operator">=</span> <span class="number">4</span>M</span><br><span class="line">read_rnd_buffer_size<span class="operator">=</span><span class="number">16</span>M </span><br><span class="line">join_buffer_size <span class="operator">=</span> <span class="number">8</span>M </span><br><span class="line">myisam_sort_buffer_size <span class="operator">=</span><span class="number">64</span>M </span><br><span class="line">table_cache <span class="operator">=</span> <span class="number">512</span> </span><br><span class="line">thread_cache_size <span class="operator">=</span> <span class="number">64</span> </span><br><span class="line">query_cache_size <span class="operator">=</span> <span class="number">64</span>M</span><br><span class="line">tmp_table_size <span class="operator">=</span> <span class="number">256</span>M </span><br><span class="line">max_connections <span class="operator">=</span> <span class="number">768</span> </span><br><span class="line">max_connect_errors <span class="operator">=</span> <span class="number">10000000</span></span><br><span class="line">wait_timeout <span class="operator">=</span> <span class="number">10</span> </span><br><span class="line">thread_concurrency <span class="operator">=</span> <span class="number">8</span> #该参数取值为服务器逻辑CPU数量<span class="operator">*</span><span class="number">2</span>，在本例中，服务器有<span class="number">2</span>颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为<span class="number">4</span><span class="operator">*</span><span class="number">2</span><span class="operator">=</span><span class="number">8</span></span><br><span class="line"><span class="keyword">skip</span><span class="operator">-</span>networking #开启该选项可以彻底关闭MySQL的TCP<span class="operator">/</span>IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！ </span><br><span class="line">table_cache<span class="operator">=</span><span class="number">1024</span></span><br><span class="line">innodb_additional_mem_pool_size<span class="operator">=</span><span class="number">4</span>M #默认为<span class="number">2</span>M </span><br><span class="line">innodb_flush_log_at_trx_commit<span class="operator">=</span><span class="number">1</span></span><br><span class="line">innodb_log_buffer_size<span class="operator">=</span><span class="number">2</span>M #默认为<span class="number">1</span>M </span><br><span class="line">innodb_thread_concurrency<span class="operator">=</span><span class="number">8</span> #你的服务器CPU有几个就设置为几。建议用默认一般为<span class="number">8</span> </span><br><span class="line">tmp_table_size<span class="operator">=</span><span class="number">64</span>M #默认为<span class="number">16</span>M，调到<span class="number">64</span><span class="number">-256</span>最挂</span><br><span class="line">thread_cache_size<span class="operator">=</span><span class="number">120</span> </span><br><span class="line">query_cache_size<span class="operator">=</span><span class="number">32</span>M</span><br></pre></td></tr></table></figure><p>很多情况还需要具体情况具体分析！</p><p><strong>举例：</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707210351452.png" alt="image-20220707210351452"  /><p><strong>(1) 调整系统参数 InnoDB_flush_log_at_trx_commit</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707210447501.png" alt="image-20220707210447501"  /><p><strong>(2)  调整系统参数 InnoDB_buffer_pool_size</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707210555848.png" alt="image-20220707210555848"  /><p><strong>(3) 调整系统参数 InnoDB_buffer_pool_instances</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707210720394.png" alt="image-20220707210720394"  /><h2 id="3-优化数据库结构">3. 优化数据库结构</h2><p>一个好的数据库设计方案对于数据库的性能常常会起到事半功倍的效果！合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计需要考虑<code>数据冗余</code>、<code>查询和更新的速度</code>、<code>字段的数据类型</code>是否合理等多方面的内容。</p><hr><h3 id="3-1-拆分表：冷热数据分离">3.1 拆分表：冷热数据分离</h3><p>拆分表的思路是，把1个包含很多字段的表拆分成2个或者多个相对较小的表。这样做的原因是，这些表中某些字段的操作频率很高（<code>热数据</code>），经常要进行查询或者更新操作，而另外一些字段的使用频率却很低（<code>冷数据</code>），<code>冷热数据分离</code>，可以减小表的宽度。如果放在一个表里面，每次查询都要读取大记录，会消耗较多的资源。</p><p>MySQL限制每个表最多存储<code>4096列</code>，并且每一行数据的大小不能超过<code>65535字节</code>。表越宽，把表装载进内存缓冲池时所占用的内存也就越大，也会消耗更多的10。<code>冷热数据分离的目的</code>是：①减少磁盘IO，保证热数据的内存缓存命中率。②更有效的利用缓存，避免读入无用的冷数据。</p><p>举例1：**<code>会员members表</code>存储会员登录认证信息，该表中有很多字段，如id、姓名、密码、地址、电 话、个人描述字段。其中地址、电话、个人描述等字段并不常用，可以将这些不常用的字段分解出另一 个表。将这个表取名叫members_detail，表中有member_id、address、telephone、description等字段。 这样就把会员表分成了两个表，分别为<code>members表</code>和<code>members_detail表</code>。</p><p>创建这两个表的SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members (</span><br><span class="line">    id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_login_time datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_login_ip <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(Id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members_detail (</span><br><span class="line">    Member_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    address <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    telephone <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    description text</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果需要查询会员的基本信息或详细信息，那么可以用会员的id来查询。如果需要将会员的基本信息和 详细信息同时显示，那么可以将members表和members_detail表进行联合查询，查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> members <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> members_detail <span class="keyword">on</span> members.id <span class="operator">=</span></span><br><span class="line">members_detail.member_id;</span><br></pre></td></tr></table></figure><p>通过这种分解可以提高表的查询效率。对于字段很多且有些字段使用不频繁的表，可以通过这种分解的方式来优化数据库的性能。</p><h3 id="3-2-增加中间表">3.2 增加中间表</h3><p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，<span class='p red'>把需要经常联合查询的数据插入中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</span></p><p>首先，分析经常联合查询表中的字段；然后，使用这些字段建立一个中间表，并将原来联合查询的表的数据插入中间表中；最后，使用中间表来进行查询。</p><p>举例1： 学生信息表 和 班级表 的SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`class`(</span><br><span class="line">`id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`className`<span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`address`<span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`monitor`<span class="type">INT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`student`(</span><br><span class="line">`id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`stuno`<span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">`name`<span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`age`<span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`classId`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>现在有一个模块需要经常查询带有学生名称（name）、学生所在班级名称（className）、学生班级班 长（monitor）的学生信息。根据这种情况可以创建一个 temp_student 表。temp_student表中存储学生名称（stu_name）、学生所在班级名称（className）和学生班级班长（monitor）信息。创建表的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`temp_student`(</span><br><span class="line">`id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`stu_name`<span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">`className`<span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`monitor`<span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>接下来，从学生信息表和班级表中查询相关信息存储到临时表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_student(stu_name,className,monitor)</span><br><span class="line">            <span class="keyword">select</span> s.name,c.className,c.monitor</span><br><span class="line">            <span class="keyword">from</span> student <span class="keyword">as</span> s,class <span class="keyword">as</span> c</span><br><span class="line">            <span class="keyword">where</span> s.classId <span class="operator">=</span> c.id</span><br></pre></td></tr></table></figure><p>以后，可以直接从temp_student表中查询学生名称、班级名称和班级班长，而不用每次都进行联合查 询。这样可以提高数据库的查询速度。</p><h3 id="3-3-增加冗余字段">3.3 增加冗余字段</h3><p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。 但是，合理地加入冗余字段可以提高查询速度。</p><p>表的规范化程度越高，表与表之间的关系就越多，需要连接查询的情况也就越多。尤其在数据量大，而 且需要频繁进行连接的时候，为了提升效率，我们也可以考虑增加冗余字段来减少连接。</p><p>这部分内容在《数据库的设计规范》章节中 反范式化小节 中具体展开讲解了。这里省略。</p><h3 id="3-4-优化数据类型">3.4 优化数据类型</h3><p>改进表的设计时，可以考虑优化字段的数据类型。这个问题在大家刚从事开发时基本不算是问题。但是，随着你的经验越来越丰富，参与的项目越来越大，数据量也越来越多的时候，你就不能只从系统稳定性的角度来思考问题了，还要考虑到系统整体的稳定性和效率。此时，<span class='p red'>优先选择符合存储需要的最小的数据类型。</span></p><p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少，在遍历时所需要的IO次数也就越多， 素引的性能也就越差。</p><p><strong>情况1：对整数类型数据进行优化。</strong></p><p>遇到整数类型的字段可以用 INT 型 。这样做的理由是，INT 型数据有足够大的取值范围，不用担心数 据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以 的。但在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。</p><p>对于 非负型 的数据（如自增ID、整型IP）来说，要优先使用无符号整型 UNSIGNED 来存储。因为无符号 相对于有符号，同样的字节数，存储的数值范围更大。如tinyint有符号为-128-127，无符号为0-255，多 出一倍的存储空间。</p><p><strong>情况2：既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</strong></p><p>跟文本类型数据相比，大整数往往占用更少的存储空间 ，因此，在存取和比对的时候，可以占用更少的 内存空间。所以，在二者皆可用的情况下，尽量使用整数类型，这样可以提高查询的效率。如：将IP地 址转换成整型数据。</p><p><strong>情况3：避免使用TEXT、BLOB数据类型</strong></p><p>MySQL<code>内存临时表</code>不支持TEXT、BLOB这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用<code>磁盘临时表</code>进行。并且对于这种数据，MySQL还是要进行二次查询，会使SQL性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p>如果一定要使用，建议把BLOB或是TEXT列<code>分离到单独的扩展表</code>中，查询时一定不要使用select*，而只需要取出必要的列，不需要TEXT列的数据时不要对该列进行查询。</p><p><strong>情况4：避免使用ENUM类型</strong></p><p>修改ENUM值需要使用ALTER语句。</p><p>ENUM类型的ORDER BY 操作效率低，需要额外操作。使用TINYINT来代替ENUM类型。</p><p><strong>情况5：使用TIMESTAMP存储时间</strong></p><p>TIMESTAMP存储的时间范围1970-01-01 00:00:01 ~ 2038-01_19-03:14:07。TIMESTAMP使用4字节，DATETIME使用8个字节，同时TIMESTAMP具有自动赋值以及自动更新的特性。</p><p><strong>情况6：用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</strong></p><ol><li>非精准浮点： float, double</li><li>精准浮点：decimal</li></ol><p>Decimal类型为精准浮点数，在计算时不会丢失精度，尤其是财务相关的金融类数据。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</p><p><strong>总之，遇到数据量大的项目时，一定要在充分了解业务需求的前提下，合理优化数据类型，这样才能充 分发挥资源的效率，使系统达到最优。</strong></p><h3 id="3-5-优化插入记录的速度">3.5 优化插入记录的速度</h3><p>插入记录时，影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。根据这些情况可以分别进行优化。这里我们分为MyISAM引擎和InnoDB引擎来讲。</p><p><strong>1. MyISAM引擎的表：</strong></p><p><strong>① 禁用索引</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707215305640.png" alt="image-20220707215305640"  /><p><strong>② 禁用唯一性检查</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707215356893.png" alt="image-20220707215356893"  /><p><strong>③ 使用批量插入</strong></p><p>插入多条记录时，可以使用一条INSERT语句插入一条数据，也可以使用一条INSERT语句插入多条数据。插入一条记录的INSERT语句情形如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">18</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="number">19</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>使用一条INSERT语句插入多条记录的情形如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">18</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="number">17</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="number">4</span>,<span class="string">&#x27;zhaoliu&#x27;</span>,<span class="number">19</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>第2种情形的插入速度要比第1种情形快。</p><p><strong>④ 使用LOAD DATA INFILE 批量导入</strong></p><p>当需要批量导入数据时，如果能用LOAD DATA INFILE语句，就尽量使用。因为LOAD DATA INFILE语句导入数据的速度比INSERT语句块。</p><p><strong>2. InnoDB引擎的表：</strong></p><p><strong>① 禁用唯一性检查</strong></p><p>插入数据之前执行<code>set unique_checks=0</code>来禁止对唯一索引的检查，数据导入完成之后再运行<code>set unique_check=1</code>。这个和MyISAM引擎的使用方法一样。</p><p><strong>② 禁用外键检查</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707220034534.png" alt="image-20220707220034534"  /><p><strong>③ 禁止自动提交</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707220131891.png" alt="image-20220707220131891"  /><h3 id="3-6-使用非空约束">3.6 使用非空约束</h3><span class='p red'>在设计字段的时候，如果业务允许，建议尽量使用非空约束。</span>这样做的好处是：<p>①进行比较和计算时，省去要对NULL值的字段判断是否为空的开销，提高存储效率。</p><p>②非空字段也容易创建索引。因为索引NULL列需要额外的空间来保存，所以要占用更多的空间。使用非空约束，就可以节省存储空间（每个字段1 个bit)</p><h3 id="3-7-分析表、检查表与优化表">3.7 分析表、检查表与优化表</h3><p>MySQL提供了分析表、检查表和优化表的语句。<code>分析表</code>主要是分析关键字的分布，<code>检查表</code>主要是检查表是否存在错误，<code>优化表</code>主要是消除删除或者更新造成的空间浪费。</p><h4 id="1-分析表">1. 分析表</h4><p>MySQL中提供了ANALYZE TABLE语句分析表，ANALYZE TABLE语句的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name[,tbl_name]…</span><br></pre></td></tr></table></figure><p>默认的，MySQL服务会将 ANALYZE TABLE语句写到binlog中，以便在主从架构中，从服务能够同步数据。 可以添加参数LOCAL 或者 NO_WRITE_TO_BINLOG取消将语句写到binlog中。</p><p>使用<code>ANALYZE TABLE</code>分析表的过程中，数据库系统会自动对表加一个<code>只读锁</code>。在分析期间，只能读取 表中的记录，不能更新和插入记录。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p><p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复 的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用</strong>。也就是索引列的cardinality的值与表中数据的总条数差距越大，即使查询的时候使用了该索引作为查 询条件，存储引擎实际查询的时候使用的概率就越小。下面通过例子来验证下。cardinality可以通过 SHOW INDEX FROM 表名查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> ANALYZE <span class="keyword">TABLE</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------+----------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>        <span class="operator">|</span> Op      <span class="operator">|</span> Msg_type <span class="operator">|</span>Msg_text <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------+----------+---------+</span></span><br><span class="line"><span class="operator">|</span> atguigu.user <span class="operator">|</span> analyze <span class="operator">|</span> status   <span class="operator">|</span> Ok      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+----------+---------+---------+</span></span><br></pre></td></tr></table></figure><p>上面结果显示的信息说明如下：</p><ul><li>Table: 表示分析的表的名称。</li><li>Op: 表示执行的操作。analyze表示进行分析操作。</li><li>Msg_type: 表示信息类型，其值通常是状态 (status) 、信息 (info) 、注意 (note) 、警告 (warning) 和 错误 (error) 之一。</li><li>Msg_text: 显示信息。</li></ul><h4 id="2-检查表">2. 检查表</h4><p>MySQL中可以使用<code>CHECK TABLE</code>语句来检查表。CHECK TABLE语句能够检查InnoDB和MyISAM类型的表 是否存在错误。CHECK TABLE语句在执行过程中也会给表加上<code>只读锁</code>。</p><p>对于MyISAM类型的表，CHECK TABLE语句还会更新关键字统计数据。而且，CHECK TABLE也可以检查视 图是否有错误，比如在视图定义中被引用的表已不存在。该语句的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option <span class="operator">=</span> &#123;QUICK <span class="operator">|</span> FAST <span class="operator">|</span> MEDIUM <span class="operator">|</span> EXTENDED <span class="operator">|</span> CHANGED&#125;</span><br></pre></td></tr></table></figure><p>其中，tbl_name是表名；option参数有5个取值，分别是QUICK、FAST、MEDIUM、EXTENDED和 CHANGED。各个选项的意义分别是：</p><ul><li>QUICK ：不扫描行，不检查错误的连接。</li><li>FAST ：只检查没有被正确关闭的表。</li><li>CHANGED ：只检查上次检查后被更改的表和没有被正确关闭的表。</li><li>MEDIUM ：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算出的校验和验证这一点。</li><li>EXTENDED ：对每行的所有关键字进行一个全面的关键字查找。这可以确保表是100%一致的，但 是花的时间较长。</li></ul><p>option只对MyISAM类型的表有效，对InnoDB类型的表无效。比如：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707221707254.png" alt="image-20220707221707254"></p><p>该语句对于检查的表可能会产生多行信息。最后一行有一个状态的 Msg_type 值，Msg_text 通常为 OK。 如果得到的不是 OK，通常要对其进行修复；是 OK 说明表已经是最新的了。表已经是最新的，意味着存 储引擎对这张表不必进行检查。</p><h4 id="3-优化表">3. 优化表</h4><p><strong>方式1：OPTIMIZE TABLE</strong></p><p>MySQL中使用<code>OPTIMIZE TABLE</code>语句来优化表。但是，OPTILMIZE TABLE语句只能优化表中的<code>VARCHAR</code>、<code>BLOB</code>或<code>TEXT</code>类型的字段。一个表使用了这些字段的数据类型，若已经<code>删除</code>了表的一大部 分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多<code>更新</code>，则 应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的<code>碎片</code>。</p><p>OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上<code>只读锁</code>。</p><p>OPTILMIZE TABLE语句的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><p>LOCAL | NO_WRITE_TO_BINLOG关键字的意义和分析表相同，都是指定不写入二进制日志。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707221901664.png" alt="image-20220707221901664"></p><p>执行完毕，Msg_text显示</p><blockquote><p>‘numysql.SYS_APP_USER’, ‘optimize’, ‘note’, ‘Table does not support optimize, doing recreate + analyze instead’</p></blockquote><p>原因是我服务器上的MySQL是InnoDB存储引擎。</p><p>到底优化了没有呢？看官网！</p><p><a><a href="https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html">MySQL :: MySQL 8.0 Reference Manual :: 13.7.3.4 OPTIMIZE TABLE Statement</a></a></p><p>在MyISAM中，是先分析这张表，然后会整理相关的MySQL datafile，之后回收未使用的空间；在InnoDB 中，回收空间是简单通过Alter table进行整理空间。在优化期间，MySQL会创建一个临时表，优化完成之 后会删除原始表，然后会将临时表rename成为原始表。</p><blockquote><p>说明： 在多数的设置中，根本不需要运行OPTIMIZE TABLE。即使对可变长度的行进行了大量的更 新，也不需要经常运行，<code>每周一次</code>或<code>每月一次</code>即可，并且只需要对<code>特定的表</code>运行。</p></blockquote><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707222156765.png" alt="image-20220707222156765"  /><p><strong>方式二：使用mysqlcheck命令</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707222305302.png" alt="image-20220707222305302"  /><p>小结</p><p>上述这些方法都是有利有弊的。比如：</p><ul><li>修改数据类型，节省存储空间的同时，你要考虑到数据不能超过取值范围；</li><li>增加冗余字段的时候，不要忘了确保数据一致性；</li><li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li></ul><p>因此，你一定要结合实际的业务需求进行权衡。</p><hr><h2 id="4-大表优化">4. 大表优化</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><h3 id="4-1-限定查询的范围">4.1 限定查询的范围</h3><p>禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制 在一个月的范围内；</p><h3 id="4-2-读-写分离">4.2 读/写分离</h3><p>经典的数据库拆分方案，主库负责写，从库负责读。</p><ul><li>一主一从模式：</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707222606097.png" alt="image-20220707222606097"></p><ul><li>双主双从模式：</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707222623485.png" alt="image-20220707222623485"></p><h3 id="4-3-垂直拆分">4.3 垂直拆分</h3><p>当数据量级达到<code>千万级</code>以上时，有时候我们需要把一个数据库切成多份，放到不同的数据库服务器上， 减少对单一数据库服务器的访问压力。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707222648112.png" alt="image-20220707222648112"></p><ul><li>如果数据库的数据表过多，可以采用<code>垂直分库</code>的方式，将关联的数据库部署在同一个数据库上。</li><li>如果数据库中的列过多，可以采用<code>垂直分表</code>的方式，将一张数据表分拆成多张数据表，把经常一起使用的列放在同一张表里。</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707222910740.png" alt="image-20220707222910740"></p><p><code>垂直拆分的优点</code>： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p><p><code>垂直拆分的缺点</code>： 主键会出现冗余，需要管理冗余列，并会引起 JOIN 操作。此外，垂直拆分会让事务变得更加复杂。</p><h3 id="4-4-水平拆分">4.4 水平拆分</h3><ul><li><p>尽量控制单表数据量的大小，建议控制在1000万以内。1000万并不是MySQL数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题。此时可以用<code>历史数据归档</code>（应用于日志数据），<code>水平分表</code>（应用于业务数据）等手段来控制数据量大小。</p></li><li><p>这里我们主要考虑业务数据的水平分表策略。将大的数据表按照<code>某个属性维度</code>分拆成不同的小表，每张小表保持相同的表结构。比如你可以按照年份来划分，把不同年份的数据放到不同的数据表中。2017 年、2018 年和2019 年的数据就可以分别放到三张数据表中。</p></li><li><p>4.4 水平拆分水平分表仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以<code>水平拆分最好分库</code>，从而达到分布式的目的。</p></li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707222739120.png" alt="image-20220707222739120"></p><p>水平拆分能够支持非常大的数据量存应用端改造也少，但<code>分片事务难以解决，跨节点Join性能较差</code>，逻辑复杂。《Java工程师修炼之道》的作者推荐<span class='p red'>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</span>，一般的数据表在优化得当的情况下支撑干万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/0。</p><p>下面补充一下数据库分片的两种常见方案：</p><ul><li><strong>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li><li>**中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。**我们现在 谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul><h2 id="5-其它调优策略">5. 其它调优策略</h2><h3 id="5-1-服务器语句超时处理">5.1 服务器语句超时处理</h3><p>在MySQL 8.0中可以设置 服务器语句超时的限制 ，单位可以达到 毫秒级别 。当中断的执行语句超过设置的 毫秒数后，服务器将终止查询影响不大的事务或连接，然后将错误报给客户端。</p><p>设置服务器语句超时的限制，可以通过设置系统变量 MAX_EXECUTION_TIME 来实现。默认情况下， MAX_EXECUTION_TIME的值为0，代表没有时间限制。 例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION MAX_EXECUTION_TIME<span class="operator">=</span><span class="number">2000</span>; #指定该会话中<span class="keyword">SELECT</span>语句的超时时间</span><br></pre></td></tr></table></figure><h3 id="5-2-创建全局通用表空间">5.2 创建全局通用表空间</h3><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707223246684.png" alt="image-20220707223246684"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707223349879.png" alt="image-20220707223349879"  /><h3 id="5-3-MySQL-8-0新特性：隐藏索引对调优的帮助">5.3 MySQL 8.0新特性：隐藏索引对调优的帮助</h3><p>不可见索引的特性对于性能调试非常有用。在MySQL 8.0中，索引可以被”隐藏”和“显示”，<span class='p red'>当一个索引被隐藏时， 它不会被查询优化器所使用。</span>也就是说，管理员可以隐藏一个索引，然后观察对数据库的影响。如果数据库性能有所下降，就说明这个索引是有用的，于是将其恢复显示&quot;即可；如果数据库性能看不出变化，就说明这个索引是多余的，可以删掉了。</p><p>需要注意的是当索引被隐藏时，它的内容仍然是和正常索引一样<code>实时更新</code>的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p><p>数据表中的主键不能被设置为invisible。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计规范</title>
      <link href="/posts/95870c9e.html"/>
      <url>/posts/95870c9e.html</url>
      
        <content type="html"><![CDATA[<span class='p red'>我们在设计数据表的时候，要考虑很多问题。</span>比如：<ul><li><p>用户都需要什么数据？需要在数据表中保存哪些数据？</p></li><li><p>如何保证数据表中数据的<code>正确性</code>，当插入、删除、更新的时候该进行怎样的约束检查？</p></li><li><p>如何降低数据表的<code>数据冗余度</code>，保证数据表不会因为用户量的增长而迅速扩张？</p></li><li><p>如何让负责数据库维护的人员更方便地使用数据库？</p></li><li><p>使用数据库的应用场景也各不相同，可以说针对不同的情况，设计出来的数据表可能<code>千差万别</code>。</p></li></ul><span class='p red'>现实情况中，面临的场景：</span><p>当数据库运行了一段时间之后，我们才发现数据表设计的有问题。重新调整数据表的结构，就需要做数据迁移，还有可能影响程序的业务逻辑，以及网站正常的访问。</p><span class='p red'>如果是糟糕的数据库设计可能会造成以下问题：</span><ul><li><p>数据冗余、信息重复，存储空间浪费</p></li><li><p>数据更新、插入、删除的异常</p></li><li><p>无法正确表示信息</p></li><li><p>丢失有效信息</p></li><li><p>程序性能差</p></li></ul><span class='p red'>良好的数据库设计则有以下优点：</span><ul><li><p>节省数据的存储空间</p></li><li><p>能够保证数据的完整性</p></li><li><p>方便进行数据库应用系统的开发</p></li></ul><p>总之，开始设置数据库的时候，我们就需要重视数据表的设计。为了建立<code>冗余较小、结构合理</code>的数据库，设计数据库时必须遵循一定的规则。</p><hr><h2 id="1-范式">1. 范式</h2><span class='p red'>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。</span>可以理解为，一张数据表的设计结构需要满足的某种设计标准级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。<p>范式的英文名称是<code>Normal Form</code>，简称<code>NF</code>。它是英国人 E.F.Codd 在上个世纪70年代提出关系数据库模型后总结出来的。范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的<code>规则</code>和<code>指导方法</code>。</p><p>目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：<span class='p red'>第一范式（1NF）、第二范式 （2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</span></p><p>数据库的范式设计越高阶，冗余度就越低，同时高阶的范式一定符合低阶范式的要求，满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范的要求称为第二范式（2NF），其余范式以此类推。</p><p>一般来说，在关系型数据库设计中，最高也就遵循到<code>BCNF</code>, 普遍还是<code>3NF</code>。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是<code>反规范化</code>。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706165020939.png" alt="image-20220706165020939" style="zoom:67%;" /><p>范式的定义会使用到主键和候选键，数据库中的键(Key)由一个或者多个属性组成。数据表中常用的几种键和属性的定义：</p><p>-<code>超键</code>：能唯一标识元组的属性集叫做超键。</p><p>-<code>候选键</code>：如果超键不包括多余的属性，那么这个超键就是候选键。</p><p>-<code>主键</code>：用户可以从候选键中选择一个作为主键。</p><p>-<code>外键</code>：如果数据表 R1中的某属性集不是 R1 的主键，而是另一个数据表 R2 的主键，那么这个属性集就是数据表 R1的外键。</p><p>-<code>主属性</code>：包含在任一候选键中的属性称为主属性。</p><p>-<code>非主属性</code>：与主属性相对，指的是不包含在任何一个候选键中的属性。</p><p>通常，我们也将候选键称之为“码”，把主键也称为“主码”。因为键可能是由多个属性组成的，针对单个属性，我们还可以用主属性和非主属性来进行区分。</p><p><strong>举例:</strong></p><p>这里有两个表：</p><p><code>球员表(player)</code>：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号</p><p><code>球队表(team)</code>：球队编号 | 主教练 | 球队所在地</p><ul><li>超键 ：对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号） （球员编号，姓名）（身份证号，年龄）等。</li><li>候选键 ：就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。</li><li>主键 ：我们自己选定，也就是从候选键中选择一个，比如（球员编号）。</li><li>外键 ：球员表中的球队编号。</li><li>主属性 、 非主属性 ：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名） （年龄）（球队编号）都是非主属性。</li></ul><hr><h3 id="1-1-第一范式-1st-NF">1.1 第一范式(1st NF)</h3><p>第一范式主要确保数据库中每个字段的值必须具有<code>原子性</code>，也就是说数据表中每个字段的值为<code>不可再次拆分</code>的最小数据单元。</p><p>我们在设计某个字段的时候，对于字段X来说，不能把字段X拆分成字段X-1和字段X-2。事实上，任何的DBMS都会满足第一范式的要求，不会将字段进行拆分。</p><p><strong>举例1：</strong></p><p>假设一家公司要存储员工的姓名和联系方式。它创建一个如下表：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706171057270.png" alt="image-20220706171057270"></p><p>该表不符合 1NF ，因为规则说“表的每个属性必须具有原子（单个）值”，lisi和zhaoliu员工的 emp_mobile 值违反了该规则。为了使表符合 1NF ，我们应该有如下表数据：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706171130851.png" alt="image-20220706171130851"></p><p><strong>举例2：</strong></p><p>user 表的设计不符合第一范式</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706171225292.png" alt="image-20220706171225292"></p><p>其中，user_info字段为用户信息，可以进一步拆分成更小粒度的字段，不符合数据库设计对第一范式的 要求。将user_info拆分后如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706171242455.png" alt="image-20220706171242455"></p><p><strong>举例3：</strong></p><p>属性的原子性是主观的 。例如，Employees关系中雇员姓名应当使用1个（fullname）、2个（firstname 和lastname）还是3个（firstname、middlename和lastname）属性表示呢？答案取决于应用程序。如果应 用程序需要分别处理雇员的姓名部分（如：用于搜索目的），则有必要把它们分开。否则，不需要。</p><p>表1：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706171442919.png" alt="image-20220706171442919"></p><p>表2：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706171456873.png" alt="image-20220706171456873"></p><hr><h3 id="1-2-第二范式-2nd-NF">1.2 第二范式(2nd NF)</h3><p>第二范式要求，在满足第一范式的基础上，<span class='p red'>还要满足数据库里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键，不能只依赖主键的一部分。</span>如果知道主键的所有属性的值，就可以检索到任何元组（行）的任何属性的任何值。（要求中的主键，其实可以扩展替换为候选键）。</p><p><strong>举例1：</strong></p><p><code>成绩表</code>（学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以“（学号，课程号）→成绩”就是<code>完全依赖关系</code>。</p><p><strong>举例2：</strong></p><p><code>比赛表 player_game</code>，里面包含球员编号、姓名、年龄、比赛编号、比赛时间和比赛场地等属性，这里候选键和主键都为（球员编号，比赛编号），我们可以通过候选键（或主键）来决定如下的关系：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)</span><br></pre></td></tr></table></figure><p>但是这个数据表不满足第二范式，因为数据表中的字段之间还存在着如下的部分依赖关系：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(球员编号) → (姓名，年龄)</span><br><span class="line"></span><br><span class="line">(比赛编号) → (比赛时间, 比赛场地)</span><br></pre></td></tr></table></figure><p>对于非主属性来说，并非完全依赖候选键。这样会产生怎样的问题呢？</p><p>1.<code>数据冗余</code>：如果一个球员可以参加 m 场比赛，那么球员的姓名和年龄就重复了 m-1 次。一个比赛 也可能会有 n 个球员参加，比赛的时间和地点就重复了 n-1 次。<br>2.<code>插入异常</code>：如果我们想要添加一场新的比赛，但是这时还没有确定参加的球员都有谁，那么就没法插入。<br>3.<code>删除异常</code>：如果我要删除某个球员编号，如果没有单独保存比赛表的话，就会同时把比赛信息删除掉。<br>4.<code>更新异常</code>：如果我们调整了某个比赛的时间，那么数据表中所有这个比赛的时间都需要进行调 整，否则就会出现一场比赛时间不同的情况。</p><p>为了避免出现上述的情况，我们可以把球员比赛表设计为下面的三张表。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707122639894.png" alt="image-20220707122639894"></p><p>这样的话，每张数据表都符合第二范式，也就避免了异常情况的发生。</p><blockquote><p>1NF 告诉我们字段属性需要是原子性的，而2NF告诉我们一张表就是一个独立的对象，一张表只表达一个意思。</p></blockquote><p><strong>举例3：</strong></p><p>定义了一个名为 Orders 的关系，表示订单和订单行的信息：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707123038469.png" alt="image-20220707123038469"></p><p>违反了第二范式，因为有非主键属性仅依赖于候选键（或主键）的一部分。例如，可以仅通过orderid找 到订单的 orderdate，以及 customerid 和 companyname，而没有必要再去使用productid。</p><p>修改：</p><p>Orders表和OrderDetails表如下，此时符合第二范式。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707123104009.png" alt="image-20220707123104009"></p><blockquote><p>小结：第二范式（2NF）要求实体的属性完全依赖主关键字。如果存在不完全依赖，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与元实体之间是一对多的关系。</p></blockquote><hr><h3 id="1-3-第三范式-3rd-NF">1.3 第三范式(3rd NF)</h3><p>第三范式是在第二范式的基础上，确保数据表中的每一个非主键字段都和主键字段直接相关，也就是说，<span class='p red'>要求数据表中的所有非主键字段不能依赖于其他非主键字段。</span>（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在“A-&gt;B-&gt;C&quot;的决定关系）通俗地讲，该规则的意思是所有<code>非主键属性</code>之间不能由依赖关系，必须<code>相互独立</code>。</p><p>这里的主键可以扩展为候选键。</p><p><strong>举例1：</strong></p><p><code>部门信息表</code>：每个部门有部门编号（dept_id）、部门名称、部门简介等信息。</p><p><code>员工信息表</code>：每个员工有员工编号、姓名、部门编号。列出部门编号后就不能再将部门名称、部门简介 等与部门有关的信息再加入员工信息表中。</p><p>如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p><p><strong>举例2：</strong></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707124011654.png" alt="image-20220707124011654"></p><p>商品类别名称依赖于商品类别编号，不符合第三范式。</p><p>修改：</p><p>表1：符合第三范式的<code>商品类别表</code>的设计</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707124040899.png" alt="image-20220707124040899"></p><p>表2：符合第三范式的<code>商品表</code>的设计</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707124058174.png" alt="image-20220707124058174"></p><p>商品表goods通过商品类别id字段（category_id）与商品类别表goods_category进行关联。</p><p><strong>举例3：</strong></p><p><code>球员player表</code>：球员编号、姓名、球队名称和球队主教练。现在，我们把属性之间的依赖关系画出来，如下图所示:</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707124136228.png" alt="image-20220707124136228"></p><p>你能看到球员编号决定了球队名称，同时球队名称决定了球队主教练，非主属性球队主教练就会传递依 赖于球员编号，因此不符合 3NF 的要求。</p><p>如果要达到 3NF 的要求，需要把数据表拆成下面这样：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707124152312.png" alt="image-20220707124152312"></p><p><strong>举例4：</strong></p><p>修改第二范式中的举例3。</p><p>此时的Orders关系包含 orderid、orderdate、customerid 和 companyname 属性，主键定义为 orderid。 customerid 和companyname均依赖于主键——orderid。例如，你需要通过orderid主键来查找代表订单中 客户的customerid，同样，你需要通过 orderid 主键查找订单中客户的公司名称（companyname）。然 而， customerid和companyname也是互相依靠的。为满足第三范式，可以改写如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707124212114.png" alt="image-20220707124212114"></p><blockquote><p>符合3NF后的数据模型通俗地讲，2NF和3NF通常以这句话概括：“每个非键属性依赖于键，依赖于 整个键，并且除了键别无他物”。</p></blockquote><hr><h3 id="1-4-小结">1.4 小结</h3><p>关于数据表的设计，有三个范式要遵循。</p><ol><li><p>第一范式（1NF)，确保每列保持<code>原子性</code></p><p>数据库的每一列都是不可分割的原子数据项，不可再分的最小数据单元，而不能是集合、数组、记录等非原子数据项。</p></li><li><p>第二范式（2NF）确保每列都和主键<code>完全依赖</code></p><p>尤其在复合主键的情况下，非主键部分不应该依赖于部分主键。</p></li><li><p>第三范式（3NF）确保每列都和主键列<code>直接相关</code>，而不是间接相关</p></li></ol><span class='p red'>范式的优点</span>：数据的标准化有助于消除数据库中的数据冗余，第三范式(3NF）通常被认为在性能、扩展性和数据完整性方面达到了最好的平衡。<br/><span class='p red'>范式的缺点</span>：范式的使用，可能降低查询的效率。因为范式等级越高，设计出来的数据表就越多、越精细，数据的冗余度就越低，进行数据查询的时候就可能需要关联多张表，这不但代价昂贵，也可能使一些索引策略无效。<p><br/>范式只是提出了设计的标准，实际上设计数据表时，未必一定要符合这些标准。开发中，我们会出现为了性能和读取效率违反范式化的原则，通过<code>增加少量的冗余</code>或重复的数据来提高数据库的<code>读性能</code>，减少关联查询，join 表的次数，实现<code>空间换取时间</code>的目的。因此在实际的设计过程中要理论结合实际，灵活运用。</p><blockquote><p>范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中， 还需要根据需求将范式和反范式混合使用。</p></blockquote><hr><h2 id="2-反范式">2. 反范式</h2><p>有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵循<code>业务优先</code>的原则，首先满足业务需求，再尽量减少冗余。</p><p>如果数据库中的数据量比较大，系统的UV和PV访问频次比较高，则完全按照MySQL的三大范式设计数据表，读数据时会产生大量的关联查询，在一定程度上会影响数据库的读性能。如果我们想对查询效率进行优化，<code>反范式优化</code>也是一种优化思路。此时，可以通过在数据表中<code>增加冗余字段</code>来提高数据库的读性能。</p><p><strong>规范化 vs 性能</strong></p><blockquote><ol><li>为满足某种商业目标 , 数据库性能比规范化数据库更重要</li><li>在数据规范化的同时 , 要综合考虑数据库的性能</li><li>通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间</li><li>通过在给定的表中插入计算列，以方便查询</li></ol></blockquote><hr><h3 id="2-1-应用举例">2.1 应用举例</h3><div class="tabs" id="041f1c1d-0ba6-4483-89f6-cee4dc2da113"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#041f1c1d-0ba6-4483-89f6-cee4dc2da113-1"><i class="fas fa-bug"></i>举例1：</button></li><li class="tab"><button type="button" data-href="#041f1c1d-0ba6-4483-89f6-cee4dc2da113-2"><i class="fas fa-cannabis"></i>举例2</button></li><li class="tab"><button type="button" data-href="#041f1c1d-0ba6-4483-89f6-cee4dc2da113-3"><i class="fas fa-candy-cane"></i>举例3</button></li><li class="tab"><button type="button" data-href="#041f1c1d-0ba6-4483-89f6-cee4dc2da113-4"><i class="fas fa-child"></i>举例4</button></li><li class="tab"><button type="button" data-href="#041f1c1d-0ba6-4483-89f6-cee4dc2da113-5"><i class="fas fa-cookie-bite"></i>实验验证</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="041f1c1d-0ba6-4483-89f6-cee4dc2da113-1"><p>员工的信息存储在<code>employees 表</code>中，部门信息存储在<code>departments 表</code>中。通过 employees 表中的 department_id字段与 departments 表建立关联关系。如果要查询一个员工所在部门的名称：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> employee_id,department_name</span><br><span class="line"><span class="keyword">from</span> employees e <span class="keyword">join</span> departments d</span><br><span class="line"><span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure><p>如果经常需要进行这个操作，连接查询就会浪费很多时间。可以在 employees 表中增加一个冗余字段 department_name，这样就不用每次都进行连接操作了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="041f1c1d-0ba6-4483-89f6-cee4dc2da113-2"><p>反范式化的<code>goods商品信息表</code>设计如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707125118808.png" alt="image-20220707125118808"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="041f1c1d-0ba6-4483-89f6-cee4dc2da113-3"><p>我们有 2 个表，分别是<code>商品流水表（atguigu.trans ）</code>和<code>商品信息表 （atguigu.goodsinfo）</code>。商品流水表里有 400 万条流水记录，商品信息表里有 2000 条商品记录。</p><p>商品流水表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707125401029.png" alt="image-20220707125401029" style="zoom: 50%;" /><p>商品信息表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707125447317.png" alt="image-20220707125447317" style="zoom:50%;" /><p>新的商品流水表如下所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707125500378.png" alt="image-20220707125500378" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="041f1c1d-0ba6-4483-89f6-cee4dc2da113-4"><p><code>课程评论表 class_comment</code>，对应的字段名称及含义如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707125531172.png" alt="image-20220707125531172" style="zoom:50%;" /><p><code>学生表 student</code>，对应的字段名称及含义如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707125545891.png" alt="image-20220707125545891" style="zoom: 50%;" /><p>在实际应用中，我们在显示课程评论的时候，通常会显示这个学生的昵称，而不是学生 ID，因此当我们 想要查询某个课程的前 1000 条评论时，需要关联 class_comment 和 student这两张表来进行查询。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="041f1c1d-0ba6-4483-89f6-cee4dc2da113-5"><p><strong>实验数据：模拟两张百万量级的数据表</strong></p><p>为了更好地进行 SQL 优化实验，我们需要给学生表和课程评论表随机模拟出百万量级的数据。我们可以 通过存储过程来实现模拟数据。</p><p><strong>反范式优化实验对比</strong></p><p>如果我们想要查询课程 ID 为 10001 的前 1000 条评论，需要写成下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.comment_text, p.comment_time, stu.stu_name</span><br><span class="line"><span class="keyword">FROM</span> class_comment <span class="keyword">AS</span> p <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">AS</span> stu</span><br><span class="line"><span class="keyword">ON</span> p.stu_id <span class="operator">=</span> stu.stu_id</span><br><span class="line"><span class="keyword">WHERE</span> p.class_id <span class="operator">=</span> <span class="number">10001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> p.comment_id <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>运行结果（1000 条数据行）：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707125642908.png" alt="image-20220707125642908" style="zoom: 50%;" /><p>运行时长为 0.395 秒，对于网站的响应来说，这已经很慢了，用户体验会非常差。</p><p>如果我们想要提升查询的效率，可以允许适当的数据冗余，也就是在商品评论表中增加用户昵称字段， 在 class_comment 数据表的基础上增加 stu_name 字段，就得到了 class_comment2 数据表。</p><p>这样一来，只需单表查询就可以得到数据集结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> comment_text, comment_time, stu_name</span><br><span class="line"><span class="keyword">FROM</span> class_comment2</span><br><span class="line"><span class="keyword">WHERE</span> class_id <span class="operator">=</span> <span class="number">10001</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> class_id <span class="keyword">DESC</span> LIMIT <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>运行结果（1000 条数据）：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707125718469.png" alt="image-20220707125718469" style="zoom:80%;" /><p>优化之后只需要扫描一次聚集索引即可，运行时间为 0.039 秒，查询时间是之前的 1/10。 你能看到， 在数据量大的情况下，查询效率会有显著的提升。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-2-反范式的新问题">2.2 反范式的新问题</h3><ul><li>存储空间变大了</li><li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致</li><li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常消耗系统资源</li><li>在 数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂</li></ul><h3 id="2-3-反范式的适用场景">2.3 反范式的适用场景</h3><p>当冗余信息有价值或者能<code>大幅度提高查询效率</code>的时候，我们才会采取反范式的优化。</p><blockquote><p>增加冗余字段的建议</p></blockquote><p>增加冗余字段一定要符合如下两个条件。只要满足这两个条件，才可以考虑增加夯余字段。</p><p>1）这个冗余字段<code>不需要经常进行修改</code>。</p><p>2）这个冗余字段<code>查询的时候不可或缺</code>。</p><blockquote><p>历史快照、历史数据的需要</p></blockquote><p>在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每 次发生的<code>订单收货信息</code>都属于<code>历史快照</code>，需要进行保存，但用户可以随时修改自己的信息，这时保存这 些冗余信息是非常有必要的。</p><p>反范式优化也常用在<code>数据仓库</code>的设计中，因为数据仓库通常<code>存储历史数据</code>，对增删改的实时性要求不 强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</p><p>我简单总结下数据仓库和数据库在使用上的区别：</p><ol><li>数据库设计的目的在于<code>捕捉数据</code>，而数据仓库设计的目的在于<code>分析数据</code>。</li><li>数据库对数据的<code>增删改实时性</code>要求强，需要存储在线的用户数据，而数据仓库存储的一般是<code>历史数据</code>。</li><li>数据库设计需要<code>尽量避免冗余</code>，但为了提高查询效率也允许一定的<code>冗余度</code>，而数据仓库在设计上更偏向采用反范式设计，</li></ol><hr><h2 id="3-BCNF-巴斯范式">3. BCNF(巴斯范式)</h2><p>人们在3NF的基础上进行了改进，提出了巴斯范式（BCNF），页脚巴斯 - 科德范式（Boyce - Codd Normal Form）。BCNF被认为没有新的设计规范加入，只是对第三范式中设计规范要求更强，使得数据库冗余度更小。所以，称为是<code>修正的第三范式</code>，或<code>扩充的第三范式</code>，BCNF不被称为第四范式。</p><p>若一个关系达到了第三范式，并且它只有一个候选键，或者它的每个候选键都是单属性，则该关系自然达到BC范式。</p><p>一般来说，一个数据库设符合3NF或者BCNF就可以了。</p><p><strong>1. 案例</strong></p><p>我们分析如下表的范式情况：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707131428597.png" alt="image-20220707131428597" style="zoom: 50%;" /><p>在这个表中，一个仓库只有一个管理员，同时一个管理员也只管理一个仓库。我们先来梳理下这些属性之间的依赖关系。</p><p>仓库名决定了管理员，管理员也决定了仓库名，同时（仓库名，物品名）的属性集合可以决定数量这个 属性。这样，我们就可以找到数据表的候选键。</p><p><code>候选键</code>：是（管理员，物品名）和（仓库名，物品名），然后我们从候选键中选择一个作为主键 ，比 如（仓库名，物品名）。</p><p><code>主属性</code>：包含在任一候选键中的属性，也就是仓库名，管理员和物品名。</p><p><code>非主属性</code>：数量这个属性。</p><p><strong>2. 是否符合三范式</strong></p><p>如何判断一张表的范式呢？我们需要根据范式的等级，从低到高来进行判断。</p><p>首先，数据表每个属性都是原子性的，符合 1NF 的要求；</p><p>其次，数据表中非主属性”数量“都与候选键全部依赖，（仓库名，物品名）决定数量，（管理员，物品名）决定数量。因此，数据表符合 2NF 的要求；</p><p>最后，数据表中的非主属性，不传递依赖于候选键。因此符合 3NF 的要求。</p><p><strong>3. 存在的问题</strong></p><p>既然数据表已经符合了 3NF 的要求，是不是就不存在问题了呢？我们来看下面的情况：</p><ol><li>增加一个仓库，但是还没有存放任何物品。根据数据表实体完整性的要求，主键不能有空值，因此会出现插入异常 ；</li><li>如果仓库更换了管理员，我们就可能会修改数据表中的多条记录 ；</li><li>如果仓库里的商品都卖空了，那么此时仓库名称和相应的管理员名称也会随之被删除。</li></ol><p>你能看到，即便数据表符合 3NF 的要求，同样可能存在插入，更新和删除数据的异常情况。</p><p><strong>4. 问题解决</strong></p><p>首先我们需要确认造成异常的原因：主属性仓库名对于候选键（管理员，物品名）是部分依赖的关系， 这样就有可能导致上面的异常情况。因此引入BCNF，<span class='p red'>它在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。</span></p><ul><li>如果在关系R中，U为主键，A属性是主键的一个属性，若存在A-&gt;Y，Y为主属性，则该关系不属于 BCNF。</li></ul><p>根据 BCNF 的要求，我们需要把仓库管理关系 warehouse_keeper 表拆分成下面这样：</p><p><code>仓库表</code>：（仓库名，管理员）</p><p><code>库存表</code>：（仓库名，物品名，数量）</p><p>这样就不存在主属性对于候选键的部分依赖或传递依赖，上面数据表的设计就符合 BCNF。</p><p>再举例：</p><p>有一个<code>学生导师表</code>，其中包含字段：学生ID，专业，导师，专业GPA，这其中学生ID和专业是联合主键。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707132038425.png" alt="image-20220707132038425"></p><p>这个表的设计满足三范式，但是这里存在另一个依赖关系，“专业”依赖于“导师”，也就是说每个导师只做一个专业方面的导师，只要知道了是哪个导师，我们自然就知道是哪个专业的了。</p><p>所以这个表的部分主键Major依赖于非主键属性Advisor，那么我们可以进行以下的调整，拆分成2个表：</p><p>学生导师表：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707132344634.png" alt="image-20220707132344634"></p><p>导师表：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707132355841.png" alt="image-20220707132355841"></p><h2 id="4-第四范式">4. 第四范式</h2><p>多值依赖的概念：</p><p>*<code>多值依赖</code>即属性之间的一对多关系，记为K—&gt;—&gt;A。<br>*<code>函数依赖</code>事实上是单值依赖，所以不能表达属性值之间的一对多关系。<br>*<code>平凡的多值依赖</code>：全集U=K+A，一个K可以对应于多个A，即K—&gt;—&gt;A。此时整个表就是一组一对多关系。<br>*<code>非平凡的多值依赖</code>：全集U=K+A+B，一个K可以对应于多个A，也可以对应于多个B，A与B相互独立，即K—&gt;—&gt;A，K—&gt;—&gt;B。整个表有多组一对多关系，且有：&quot;一&quot;部分是相同的属性集合，“多”部分是相互独立的属性集合。</p><p>第四范式即在满足巴斯 - 科德范式（BCNF）的基础上，消除非平凡且非函数依赖的多值依赖（即把同一表的多对多关系删除）。</p><p>**举例1：**职工表(职工编号，职工孩子姓名，职工选修课程)。</p><p>在这个表中，同一个职工可能会有多个职工孩子姓名。同样，同一个职工也可能会有多个职工选修课程，即这里存在着多值事实，不符合第四范式。</p><p>如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实，例如：<code>职工表一</code>(职工编 号，职工孩子姓名)，<code>职工表二</code>(职工编号，职工选修课程)，两个表都只有一个多值事实，所以符合第四范式。</p><p><strong>举例2：</strong></p><p>比如我们建立课程、教师、教材的模型。我们规定，每门课程有对应的一组教师，每门课程也有对应的一组教材，一门课程使用的教材和教师没有关系。我们建立的关系表如下：</p><p>课程ID，教师ID，教材ID；这三列作为联合主键。</p><p>为了表述方便，我们用Name代替ID，这样更容易看懂：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707133830721.png" alt="image-20220707133830721"></p><p>这个表除了主键，就没有其他字段了，所以肯定满足BC范式，但是却存在<code>多值依赖</code>导致的异常。</p><p>假如我们下学期想采用一本新的英版高数教材，但是还没确定具体哪个老师来教，那么我们就无法在这 个表中维护Course高数和Book英版高数教材的的关系。</p><p>解决办法是我们把这个多值依赖的表拆解成2个表，分别建立关系。这是我们拆分后的表：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707134028730.png" alt="image-20220707134028730"></p><p>以及</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707134220820.png" alt="image-20220707134220820"></p><h2 id="5-第五范式、域键范式">5. 第五范式、域键范式</h2><p>除了第四范式外，我们还有更高级的第五范式（又称完美范式）和域键范式（DKNF）。</p><p>在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。<strong>如果关系模式R中的每一个连 接依赖均由R的候选键所隐含</strong>，则称此关系模式符合第五范式。</p><p>函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不 像函数依赖和多值依赖可以由<code>语义直接导出</code>，而是在<code>关系连接运算</code>时才反映出来。存在连接依赖的关系 模式仍可能遇到数据冗余及插入、修改、删除异常等问题。</p><p>第五范式处理的是<code>无损连接问题</code>，这个范式基本<code>没有实际意义</code>，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个<code>终极范式</code>，该范式考虑所有的依赖和约束类型，但是实用价值也是最小的，只存在理论研究中。</p><h2 id="6-实战案例">6. 实战案例</h2><p>商超进货系统中的<code>进货单表</code>进行剖析：</p><p>进货单表：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707134636225.png" alt="image-20220707134636225"></p><p>这个表中的字段很多，表里的数据量也很惊人。大量重复导致表变得庞大，效率极低。如何改造？</p><blockquote><p>在实际工作场景中，这种由于数据表结构设计不合理，而导致的数据重复的现象并不少见。往往是系统虽然能够运行，承载能力却很差，稍微有点流量，就会出现内存不足、CPU使用率飙升的情况，甚至会导致整个项目失败。</p></blockquote><h3 id="6-1-迭代1次：考虑1NF">6.1 迭代1次：考虑1NF</h3><p>第一范式要求：<span class='p red'>所有的字段都是基本数据类型，不可进行拆分。</span>这里需要确认，所有的列中，每个字段只包含一种数据。</p><p>这张表里，我们把“property&quot;这一字段，拆分成”specification (规格)&quot; 和 “unit (单位)”，这两个字段如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707154400580.png" alt="image-20220707154400580"></p><h3 id="6-2-迭代2次：考虑2NF">6.2 迭代2次：考虑2NF</h3><p>第二范式要求，在满足第一范式的基础上，<span class='p red'>还要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有字段，都必须完全依赖主键，不能只依赖主键的一部分。</span></p><p>第1步，就是要确定这个表的主键。通过观察发现，字段“listnumber（单号）&quot;+&quot;barcode（条码）&quot;可以唯一标识每一条记录，可以作为主键。</p><p>第2步，确定好了主键以后，判断哪些字段完全依赖主键，哪些字段只依赖于主键的一部分。把只依赖于主键一部分的字段拆出去，形成新的数据表。</p><p>首先，进货单明细表里面的&quot;goodsname(名称)““specification(规格)”“unit(单位)“这些信息是商品的属性，只依赖于&quot;batcode(条码)”，不完全依赖主键，可以拆分出去。我们把这3个字段加上它们所依赖的字段&quot;barcode(条码)”，拆分形成新的数据表&quot;商品信息表”。</p><p>这样一来，原来的数据表就被拆分成了两个表。</p><p>商品信息表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707163807205.png" alt="image-20220707163807205"  /><p>进货单表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707163828614.png" alt="image-20220707163828614"  /><p>此外，字段&quot;supplierid(供应商编号)““suppliername(供应商名称)”“stock(仓库)“只依赖于&quot;listnumber(单号)”，不完全依赖于主键，所以，我们可以把&quot;supplierid”“suppliername”“stock&quot;这3个字段拆出去，再加上它们依赖的字段&quot;listnumber(单号)”，就形成了一个新的表&quot;进货单头表&quot;。剩下的字段，会组成新的表，我们叫它&quot;进货单明细表&quot;。</p><p>原来的数据表就拆分成了3个表。</p><p>进货单头表：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707164128704.png" alt="image-20220707164128704"></p><p>进货单明细表：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707164146216.png" alt="image-20220707164146216"></p><p>商品信息表：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707164227845.png" alt="image-20220707164227845"></p><p>现在，我们再来分析一下拆分后的3个表，保证这3个表都满足第二范式的要求。</p><p>第3步，在“商品信息表”中，字段“barcode&quot;是有<code>可能存在重复</code>的，比如，用户门店可能有散装称重商品和自产商品，会存在条码共用的情况。所以，所有的字段都不能唯一标识表里的记录。这个时候，我们必须给这个表加上一个主键，比如说是<code>自增字段&quot;itemnumber&quot;</code>。</p><h3 id="6-3-迭代3次：考虑3NF">6.3 迭代3次：考虑3NF</h3><p>我们的进货单头表，还有数据冗余的可能。因为&quot;suppliername&quot;依赖&quot;supplierid&quot;，那么就可以按照第三范式的原则进行拆分了。我们就进一步拆分进货单头表，把它拆解陈供货商表和进货单头表。</p><p>供货商表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707165011050.png" alt="image-20220707165011050"  /><p>进货单头表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707165038108.png" alt="image-20220707165038108"  /><p>这2个表都满足第三范式的要求了。</p><h3 id="6-4-反范式化：业务优先的原则">6.4 反范式化：业务优先的原则</h3><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707165459547.png" alt="image-20220707165459547" style="zoom:80%;float:right" /><p>因此，最后我们可以把进货单表拆分成下面的4个表：</p><p>供货商表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707165011050.png" alt="image-20220707165011050"  /><p>进货单头表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707165038108.png" alt="image-20220707165038108"  /><p>进货单明细表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707164146216.png" alt="image-20220707164146216" style="zoom:80%;" /><p>商品信息表：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707164227845.png" alt="image-20220707164227845" style="zoom:80%;" /><p>这样一来，我们就避免了冗余数据，而且还能够满足业务的需求，这样的数据库设计，才是合格的设计。</p><hr><h2 id="7-ER模型">7. ER模型</h2><p>数据库设计是牵一发而动全身的。那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表、数据表中应该有哪些字段，数据表与数据表之间有什么关系、通过什么字段进行连接，等等。这样我们才能进行整体的梳理和设计。</p><p>其实，ER 模型就是一个这样的工具。ER模型也叫作<code>实体关系模型</code>，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。<span class='p red'>在开发基于数据库的信息系统的设计阶段，通常使用 ER 模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。</span></p><span class='p green'>ER 模型中有三个要素，分别是实体、属性和关系。</span><p><code>实体</code>，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用 矩形 来表 示。实体分为两类，分别是 强实体 和 弱实体 。强实体是指不依赖于其他实体的实体；弱实体是指对另 一个实体有很强的依赖关系的实体。</p><p><code>属性</code>，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用 椭圆形 来表示。</p><p><code>关系</code>，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模 型中用 菱形 来表示。</p><p>注意：实体和属性不容易区分。这里提供一个原则：我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。也就是说，属性不能包含其他属性。</p><span class='p blue'>在 ER 模型的 3 个要素中，关系又可以分为 3 种类型，分别是 一对一、一对多、多对多。</span><p><code>一对一</code>：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是一对一的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</p><p><code>一对多</code>：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如说，我们新建一个班级表，而每个班级都有多个学生，每个学 生则对应一个班级，班级对学生就是一对多的关系。</p><p><code>多对多</code>：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之 间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购 商品。再比如一个选课表，有许多科目，每个科目有很多学生选，而每个学生又可以选择多个科目，这 就是多对多的关系。</p><h3 id="7-1-建模分析">7.1 建模分析</h3><p>ER 模型看起来比较麻烦，但是对我们把控项目整体非常重要。如果你只是开发一个小应用，或许简单设 计几个表够用了，一旦要设计有一定规模的应用，在项目的初始阶段，建立完整的 ER 模型就非常关键 了。开发应用项目的实质，其实就是 建模 。</p><p>我们设计的案例是 电商业务 ，由于电商业务太过庞大且复杂，所以我们做了业务简化，比如针对 SKU（StockKeepingUnit，库存量单位）和SPU（Standard Product Unit，标准化产品单元）的含义上，我 们直接使用了SKU，并没有提及SPU的概念。本次电商业务设计总共有8个实体，如下所示。</p><ul><li>地址实体</li><li>用户实体</li><li>购物车实体</li><li>评论实体</li><li>商品实体</li><li>商品分类实体</li><li>订单实体</li><li>订单详情实体</li></ul><p>其中， 用户 和 商品分类 是强实体，因为它们不需要依赖其他任何实体。而其他属于弱实体，因为它们 虽然都可以独立存在，但是它们都依赖用户这个实体，因此都是弱实体。知道了这些要素，我们就可以 给电商业务创建 ER 模型了，如图：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707170608782.png" alt="image-20220707170608782"></p><p>在这个图中，地址和用户之间的添加关系，是一对多的关系，而商品和商品详情示一对1的关系，商品和 订单是多对多的关系。 这个 ER 模型，包括了 8个实体之间的 8种关系。</p><p>（1）用户可以在电商平台添加多个地址；</p><p>（2）用户只能拥有一个购物车；</p><p>（3）用户可以生成多个订单；</p><p>（4）用户可以发表多条评论；</p><p>（5）一件商品可以有多条评论；</p><p>（6）每一个商品分类包含多种商品；</p><p>（7）一个订单可以包含多个商品，一个商品可以在多个订单里。</p><p>（8）订单中又包含多个订单详情，因为一个订单中可能包含不同种类的商品</p><h3 id="7-2-ER-模型的细化">7.2 ER 模型的细化</h3><p>有了这个 ER 模型，我们就可以从整体上 理解 电商的业务了。刚刚的 ER 模型展示了电商业务的框架， 但是只包括了订单，地址，用户，购物车，评论，商品，商品分类和订单详情这八个实体，以及它们之 间的关系，还不能对应到具体的表，以及表与表之间的关联。我们需要把 属性加上 ，用 椭圆 来表示， 这样我们得到的 ER 模型就更加完整了。</p><p>因此，我们需要进一步去设计一下这个 ER 模型的各个局部，也就是细化下电商的具体业务流程，然后把 它们综合到一起，形成一个完整的 ER 模型。这样可以帮助我们理清数据库的设计思路。</p><p>接下来，我们再分析一下各个实体都有哪些属性，如下所示。</p><p>（1）<code>地址实体</code>包括用户编号、省、市、地区、收件人、联系电话、是否是默认地址。</p><p>（2）<code>用户实体</code>包括用户编号、用户名称、昵称、用户密码、手机号、邮箱、头像、用户级别。</p><p>（3）<code>购物车实体</code>包括购物车编号、用户编号、商品编号、商品数量、图片文件url。</p><p>（4）<code>订单实体</code>包括订单编号、收货人、收件人电话、总金额、用户编号、付款方式、送货地址、下单 时间。</p><p>（5）<code>订单详情实体</code>包括订单详情编号、订单编号、商品名称、商品编号、商品数量。</p><p>（6）<code>商品实体</code>包括商品编号、价格、商品名称、分类编号、是否销售，规格、颜色。</p><p>（7）<code>评论实体</code>包括评论id、评论内容、评论时间、用户编号、商品编号</p><p>（8）<code>商品分类实体</code>包括类别编号、类别名称、父类别编号</p><p>这样细分之后，我们就可以重新设计电商业务了，ER 模型如图：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707171022246.png" alt="image-20220707171022246"></p><h3 id="7-3-ER-模型图转换成数据表">7.3 ER 模型图转换成数据表</h3><p>通过绘制 ER 模型，我们已经理清了业务逻辑，现在，我们就要进行非常重要的一步了：把绘制好的 ER 模型，转换成具体的数据表，下面介绍下转换的原则：</p><p>（1）一个 实体通常转换成一个数据表 ；</p><p>（2）一个 多对多的关系 ，通常也转换成一个数据表 ；</p><p>（3）一个 1 对 1 ，或者 1 对多 的关系，往往通过表的外键 来表达，而不是设计一个新的数据表；</p><p>（4）属性转换成表的字段 。</p><p>下面结合前面的ER模型，具体讲解一下怎么运用这些转换的原则，把 ER 模型转换成具体的数据表，从而把抽象出来的数据模型，落实到具体的数据库设计当中。</p><div class="tabs" id="cf8e7d91-4e7d-43b9-8e90-47521cc91ee1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#cf8e7d91-4e7d-43b9-8e90-47521cc91ee1-1"><i class="fas fa-award"></i>一个实体转换成一个数据库</button></li><li class="tab"><button type="button" data-href="#cf8e7d91-4e7d-43b9-8e90-47521cc91ee1-2"><i class="fas fa-baseball-ball"></i>一个多对多的关系转换成一个数据表</button></li><li class="tab"><button type="button" data-href="#cf8e7d91-4e7d-43b9-8e90-47521cc91ee1-3"><i class="fas fa-bone"></i>通过外键来表达一对多的关系</button></li><li class="tab"><button type="button" data-href="#cf8e7d91-4e7d-43b9-8e90-47521cc91ee1-4"><i class="fas fa-anchor"></i>把属性转换成表的字段</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="cf8e7d91-4e7d-43b9-8e90-47521cc91ee1-1"><p><strong>先来看一下强实体转换成数据表:</strong></p><p><code>用户实体</code>转换成用户表(user_info)的代码如下所示。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707171335255.png" alt="image-20220707171335255"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707171412363.png" alt="image-20220707171412363"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707171915637.png" alt="image-20220707171915637"  /><p><strong>下面我们再把弱实体转换成数据表：</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172033399.png" alt="image-20220707172033399"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172052236.png" alt="image-20220707172052236"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172143793.png" alt="image-20220707172143793"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172217772.png" alt="image-20220707172217772"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172236606.png" alt="image-20220707172236606"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172259143.png" alt="image-20220707172259143"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cf8e7d91-4e7d-43b9-8e90-47521cc91ee1-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172350226.png" alt="image-20220707172350226"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cf8e7d91-4e7d-43b9-8e90-47521cc91ee1-3"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172609833.png" alt="image-20220707172609833"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cf8e7d91-4e7d-43b9-8e90-47521cc91ee1-4"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172819174.png" alt="image-20220707172819174"  /><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707172918017.png" alt="image-20220707172918017"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h2 id="8-数据表的设计原则">8. 数据表的设计原则</h2><p>综合以上内容，总结出数据表设计的一般原则：“三少一多”</p><p><strong>1. 数据表的个数越少越好</strong></p><p>RDBMS 的核心在于对实体和联系的定义，也就是E-R图（Entity Relationship Diagram)，数据表越少，证明实体和联系设计得越简洁，既方便理解又方便操作。</p><p><strong>2. 数据表中的字段个数越少越好</strong></p><p>字段个数越多，数据冗余的可能性越大。设置字段个数少的前提是各个字段相互独立，而不是某个字段的取值可以由其他字段计算出来。当然字段个数少是相对的，我们通常会在数据冗余和检索效率,中进行平衡。</p><p><strong>3. 数据表中联合主键的字段个数越少越好</strong></p><p>设置主键是为了确定唯一性，当一个字段无法确定唯一性的时候，就需要采用联合主键的方式（也就是用多个字段来定义一个主键）。联合主键中的字段越多，占用的崇引空间越大，不仅会加大理解难度，还会增加运行时间和索引空间，因此联合主键的字段个数越少越好。</p><p><strong>4. 使用主键和外键越多越好</strong></p><p>数据库的设计实际上就是定义各种表，以及各种字段之间的关系。这些关系越多，证明这些实体之间的几余度越低，利用度越商。这样做的好处在于不仅保证了数据表之间的独立性，还能提升相互之间的关联使用率。</p><p>“三少一多”原则的核心就是简单可复用。简单指的是用更少的表、更少的字段、更少的联合主健字段来完成数据表的设计。可复用则是通过主键、外键的使用来增强数据表之间的复用率。因为一个主键可以理解是一张表的代表。键设计得越多，证明它们之间的利用率越高。</p><p>注意：这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。</p><hr><h2 id="9-数据库对象编写建议">9. 数据库对象编写建议</h2><h3 id="9-1-关于库">9.1 关于库</h3><ol><li>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字 母开头。</li><li>【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。</li><li>【强制】库的名称格式：业务系统名称_子系统名。</li><li>【强制】库名禁止使用关键字（如type,order等）。</li><li>【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。 创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ;</li><li>【建议】对于程序连接数据库账号，遵循 权限最小原则 使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限 。</li><li>【建议】临时库以 tmp_ 为前缀，并以日期为后缀； 备份库以 bak_ 为前缀，并以日期为后缀。</li></ol><h3 id="9-2-关于表、列">9.2 关于表、列</h3><ol><li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议 以 英文字母开头 。</p></li><li><p>【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。</p></li><li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item</p></li><li><p>【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。</p></li><li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p></li><li><p>【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。</p></li><li><p>【强制】建表必须有comment。</p></li><li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用 corporation_id, 而用corp_id 即可。</p></li><li><p>【强制】布尔值类型的字段命名为 is_描述 。如member表上表示是否为enabled的会员的字段命 名为 is_enabled。</p></li><li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据 通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随 机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p></li><li><p>【建议】建表时关于主键： 表必须有主键</p><p>(1)强制要求主键为id，类型为int或bigint，且为 auto_increment 建议使用unsigned无符号型。</p><p>(2)标识表里每一行主体的字段不要设为主键，建议 设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机 插入，则会导致innodb内部页分裂和大量随机I/O，性能下降。</p></li><li><p>【建议】核心表（如用户表）必须有行数据的 创建时间字段 （create_time）和 最后更新时间字段 （update_time），便于查问题。</p></li><li><p>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用 NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问 题。</p></li><li><p>【建议】所有存储相同数据的 列名和列类型必须一致 （一般作为关联列，如果查询时关联列类型 不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p></li><li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以 tmp_ 开头。 备份表用于备份或抓取源表快照，名称以 bak_ 开头。中间表和备份表定期清理。 1</p></li><li><p>【示范】一个较为规范的建表语句：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_info (</span><br><span class="line">`id`<span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增主键&#x27;</span>,</span><br><span class="line">`user_id`<span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">`username`<span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;真实姓名&#x27;</span>,</span><br><span class="line">`email`<span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户邮箱&#x27;</span>,</span><br><span class="line">`nickname`<span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">`birthday`<span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">`sex`tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">`short_introduce`<span class="type">varchar</span>(<span class="number">150</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;一句话介绍自己，最多50个汉字&#x27;</span>,</span><br><span class="line">`user_resume`<span class="type">varchar</span>(<span class="number">300</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户提交的简历存放地址&#x27;</span>,</span><br><span class="line">`user_register_ip`<span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户注册时的源ip&#x27;</span>,</span><br><span class="line">`create_time`<span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">`update_time`<span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">`user_review_status`tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户资料审核状态，1为通过，2为审核中，3为未</span></span><br><span class="line"><span class="string">通过，4为还未提交审核&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY`uniq_user_id`(`user_id`),</span><br><span class="line">KEY`idx_username`(`username`),</span><br><span class="line">KEY`idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;网站用户基本信息</span></span><br></pre></td></tr></table></figure><ol start="17"><li>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。</li></ol><p>实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。</p><p>可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</p><h3 id="9-3-关于索引">9.3 关于索引</h3><ol><li>【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值 禁止被更新 。</li><li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。</li><li>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</li><li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如: sample 表 member_id 上的索引：idx_sample_mid。</li><li>【建议】单个表上的索引个数 不能超过6个 。</li><li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。</li><li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</li><li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)， 则key(a)为冗余索引，需要删除。</li></ol><h3 id="9-4-SQL编写">9.4 SQL编写</h3><ol><li><p>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</p></li><li><p>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</p></li><li><p>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</p></li><li><p>【建议】INSERT INTO…VALUES(XX),(XX),(XX)… 这里XX的值不要超过5000个。 值过多虽然上线很 快，但会引起主从同步延迟。</p></li><li><p>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以 内。</p></li><li><p>【建议】线上环境，多表 JOIN 不要超过5个表。</p></li><li><p>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</p></li><li><p>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果 集请保持在1000行以内，否则SQL会很慢。</p></li><li><p>【建议】对单表的多次alter操作必须合并为一次 对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生表锁 ，期间阻塞对于该表的所有写入，对于业务可能会产生极 大影响。</p></li><li><p>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</p></li><li><p>【建议】事务里包含SQL不超过5个。 因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</p></li><li><p>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</p></li></ol><hr><h2 id="10-PowerDesigner的使用">10. PowerDesigner的使用</h2><p>PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作<code>数据流程图</code>、<code>概念数据模型</code>、<code>物理数据模型</code>，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设 计提供的一套完整的集成化企业级建模解决方案。</p><h3 id="10-1-开始界面">10.1 开始界面</h3><p>当前使用的PowerDesigner版本是16.5的。打开软件即是此页面，可选择Create Model,也可以选择Do Not Show page Again,自行在打开软件后创建也可以！完全看个人的喜好，在此我在后面的学习中不在显示此页面。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707175250944.png" alt="image-20220707175250944" style="zoom:80%;" /><p>“Create Model”的作用类似于普通的一个文件，该文件可以单独存放也可以归类存放。</p><p>“Create Project”的作用类似于文件夹，负责把有关联关系的文件集中归类存放。</p><h3 id="10-2-概念数据模型">10.2 概念数据模型</h3><p>常用的模型有4种，分别是<code>概念模型(CDM Conceptual Data Model)</code>，<code>物理模型（PDM,Physical Data Model）</code>，<code>面向对象的模型（OOM Objcet Oriented Model）</code>和<code>业务模型（BPM Business Process Model）</code>，我们先创建概念数据模型。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707175350250.png" alt="image-20220707175350250"  /><p>点击上面的ok，即可出现下图左边的概念模型1，可以自定义概念模型的名字，在概念模型中使用最多的 就是如图所示的Entity(实体),Relationship(关系)</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707175604026.png" alt="image-20220707175604026"  /><p><strong>Entity实体</strong></p><p>选中右边框中Entity这个功能，即可出现下面这个方框，需要注意的是书写name的时候，code自行补全，name可以是英文的也可以是中文的，但是code必须是英文的。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707175653689.png" alt="image-20220707175653689"  /><p><strong>填充实体字段</strong></p><p>General中的name和code填好后，就可以点击Attributes（属性）来设置name（名字），code(在数据库中 的字段名)，Data Type(数据类型) ，length(数据类型的长度)</p><ul><li>Name: 实体名字一般为中文，如论坛用户</li><li>Code: 实体代号，一般用英文，如XXXUser</li><li>Comment:注释，对此实体详细说明</li><li>Code属性：代号，一般用英文UID DataType</li><li>Domain域，表示属性取值范围如可以创建10个字符的地址域</li><li>M:Mandatory强制属性，表示该属性必填。不能为空</li><li>P:Primary Identifer是否是主标识符，表示实体唯一标识符</li><li>D:Displayed显示出来，默认全部勾选</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707175805226.png" alt="image-20220707175805226"  /><p>在此上图说明name和code的起名方法</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707175827417.png" alt="image-20220707175827417"  /><p><strong>设置主标识符</strong></p><p>如果不希望系统自动生成标识符而是手动设置的话，那么切换到Identifiers选项卡，添加一行Identifier， 然后单击左上角的“属性”按钮，然后弹出的标识属性设置对话框中单击“添加行”按钮，选择该标识中使用的属性。例如将学号设置为学生实体的标识。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707175858031.png" alt="image-20220707175858031"  /><p><strong>放大模型</strong></p><p>创建好概念数据模型如图所示，但是创建好的字体很小，读者可以按着ctrl键同时滑动鼠标的可滑动按钮 即可放大缩写字体，同时也可以看到主标识符有一个*号的标志，同时也显示出来了，name,Data type和 length这些可见的属性</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707175925155.png" alt="image-20220707175925155"  /><p><strong>实体关系</strong></p><p>同理创建一个班级的实体（需要特别注意的是，点击完右边功能的按钮后需要点击鼠标指针状态的按钮 或者右击鼠标即可，不然很容易乱操作，这点注意一下就可以了），然后使用Relationship（关系）这个 按钮可以连接学生和班级之间的关系，发生一对多（班级对学生）或者多对一（学生对班级）的关系。</p><p>如图所示</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707175954634.png" alt="image-20220707175954634"  /><p>需要注意的是点击Relationship这个按钮，就把班级和学生联系起来了，就是一条线，然后双击这条线进 行编辑，在General这块起name和code</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180021612.png" alt="image-20220707180021612"  /><p>上面的name和code起好后就可以在Cardinalities这块查看班级和学生的关系，可以看到班级的一端是一 条线，学生的一端是三条，代表班级对学生是一对多的关系即one对many的关系，点击应用，然后确定 即可</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180044291.png" alt="image-20220707180044291"  /><p>一对多和多对一练习完还有多对多的练习，如下图操作所示，老师实体和上面介绍的一样，自己将 name，data type等等修改成自己需要的即可，满足项目开发需求即可。（comment是解释说明，自己可以写相关的介绍和说明）</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180113532.png" alt="image-20220707180113532"  /><p>多对多需要注意的是自己可以手动点击按钮将关系调整称为多对多的关系many对many的关系，然后点击应用和确定即可</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180159184.png" alt="image-20220707180159184"  /><p>综上即可完成最简单的学生，班级，教师这种概念数据模型的设计，需要考虑数据的类型和主标识码， 是否为空。关系是一对一还是一对多还是多对多的关系，自己需要先规划好再设计，然后就ok了。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180254510.png" alt="image-20220707180254510"></p><h3 id="10-3-物理数据模型">10.3 物理数据模型</h3><p>上面是概念数据模型，下面介绍一下物理数据模型，以后 经常使用 的就是物理数据模型。打开 PowerDesigner，然后点击File–&gt;New Model然后选择如下图所示的物理数据模型，物理数据模型的名字自己起，然后选择自己所使用的数据库即可。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180327712.png" alt="image-20220707180327712"  /><p>创建好主页面如图所示，但是右边的按钮和概念模型略有差别，物理模型最常用的三个是<code>table(表)</code>，<code>view(视图)</code>，<code>reference(关系)</code>；</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180418090.png" alt="image-20220707180418090"  /><p>鼠标先点击右边table这个按钮然后在新建的物理模型点一下，即可新建一个表，然后双击新建如下图所示，在General的name和code填上自己需要的，点击应用即可），如下图：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180449212.png" alt="image-20220707180449212"  /><p>然后点击Columns,如下图设置，非常简单，需要注意的就是P（primary主键） , F （foreign key外键） , M（mandatory强制性的，代表不可为空） 这三个。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180537251.png" alt="image-20220707180537251"  /><p>在此设置学号的自增（MYSQL里面的自增是这个AUTO_INCREMENT），班级编号同理，不多赘述！</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180556645.png" alt="image-20220707180556645"  /><p>在下面的这个点上对号即可，就设置好了自增</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180619440.png" alt="image-20220707180619440"  /><p>全部完成后如下图所示。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180643107.png" alt="image-20220707180643107"  /><p>班级物理模型同理如下图所示创建即可</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180723698.png" alt="image-20220707180723698"  /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180744600.png" alt="image-20220707180744600"  /><p>完成后如下图所示</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180806150.png" alt="image-20220707180806150"  /><p>上面的设置好如上图所示，然后下面是关键的地方，点击右边按钮Reference这个按钮，因为是班级对学 生是一对多的，所以鼠标从学生拉到班级如下图所示，学生表将发生变化，学生表里面增加了一行，这 行是班级表的主键作为学生表的外键，将班级表和学生表联系起来。（仔细观察即可看到区别。）</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707180828164.png" alt="image-20220707180828164"  /><p>做完上面的操作，就可以双击中间的一条线，显示如下图，修改name和code即可</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707183743297.png" alt="image-20220707183743297"  /><p>但是需要注意的是，修改完毕后显示的结果却如下图所示，并没有办法直接像概念模型那样，修改过后 显示在中间的那条线上面，自己明白即可。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707193816176.png" alt="image-20220707193816176"  /><p>学习了多对一或者一对多的关系，接下来学习多对对的关系，同理自己建好老师表，这里不在叙述，记得老师编号自增，建好如下图所示</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707193932694.png" alt="image-20220707193932694"  /><p>下面是多对多关系的关键，由于物理模型多对多的关系需要一个中间表来连接，如下图，只设置一个字 段，主键，自增</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707193957629.png" alt="image-20220707193957629"  /><p>点击应用，然后设置Columns，只添加一个字段</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194048843.png" alt="image-20220707194048843"  /><p>这是设置字段递增，前面已经叙述过好几次</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194111885.png" alt="image-20220707194111885"  /><p>设置好后如下图所示，需要注意的是有箭头的一方是一，无箭头的一方是多，即一对多的多对一的关系 需要搞清楚，学生也可以有很多老师，老师也可以有很多学生，所以学生和老师都可以是主体；</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194138137.png" alt="image-20220707194138137"  /><p>可以看到添加关系以后学生和教师的关系表前后发生的变化</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194158936.png" alt="image-20220707194158936"  /><h3 id="10-4-概念模型转为物理模型">10.4 概念模型转为物理模型</h3><p>1：如下图所示先打开概念模型图，然后点击Tool,如下图所示</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194228064.png" alt="image-20220707194228064"></p><p>点开的页面如下所示，name和code已经从概念模型1改成物理模型1了</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194248236.png" alt="image-20220707194248236"></p><p>完成后如下图所示，将自行打开修改的物理模型，需要注意的是这些表的数据类型已经自行改变了，而 且中间表出现两个主键，即双主键</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194308595.png" alt="image-20220707194308595"></p><h3 id="10-5-物理模型转为概念模型">10.5 物理模型转为概念模型</h3><p>上面介绍了概念模型转物理模型，下面介绍一下物理模型转概念模型（如下图点击操作即可）</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194405358.png" alt="image-20220707194405358"></p><p>然后出现如下图所示界面，然后将物理修改为概念 ，点击应用确认即可</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194419360.png" alt="image-20220707194419360"></p><p>点击确认后将自行打开如下图所示的页面，自己观察有何变化，如果转换为oracle的，数据类型会发生变 化，比如Varchar2等等）；</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194433407.png" alt="image-20220707194433407"></p><h3 id="10-6-物理模型导出SQL语句">10.6 物理模型导出SQL语句</h3><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194544714.png" alt="image-20220707194544714"></p><p>打开之后如图所示，修改好存在sql语句的位置和生成文件的名称即可</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194557554.png" alt="image-20220707194557554"></p><p>在Selection中选择需要导出的表，然后点击应用和确认即可</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194637242.png" alt="image-20220707194637242"></p><p>完成以后出现如下图所示，可以点击Edit或者close按钮</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220707194727849.png" alt="image-20220707194727849"></p><p>自此，就完成了导出sql语句，就可以到自己指定的位置查看导出的sql语句了；PowerDesigner在以后在 项目开发过程中用来做需求分析和数据库的设计非常的方便和快捷。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引失效与查询优化</title>
      <link href="/posts/ec3a9a87.html"/>
      <url>/posts/ec3a9a87.html</url>
      
        <content type="html"><![CDATA[<p>都有哪些维度可以进行数据库调优？简言之：</p><ul><li>索引失效、没有充分利用到索引——建立索引</li><li>关联查询太多JOIN（设计缺陷或不得已的需求）——SQL优化</li><li>服务器调优及各个参数设置（缓冲、线程数等）——调整my.cnf</li><li>数据过多——分库分表</li></ul><p>关于数据库调优的知识非常分散。不同的DBMS，不同的公司，不同的职位，不同的项目遇到的问题都不尽相同。这里我们分为三个章节进行细致讲解。</p><p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分成<code>物理查询优化</code>和<code>逻辑查询优化</code>两大块。</p><ul><li>物理查询优化是通过<code>索引</code>和<code>表连接方式</code>等技术来进行优化，这里重点需要掌握索引的使用。</li><li>逻辑查询优化就是通过SQL<code>等价变换</code>提升查询效率，直白一点就是说，换一种查询写法效率可能更高。</li></ul><hr><h2 id="1-数据准备">1. 数据准备</h2><div class="tabs" id="06aba016-1b98-4fdf-aa5a-0362d8823a19"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#06aba016-1b98-4fdf-aa5a-0362d8823a19-1"><i class="fas fa-bug"></i>步骤1</button></li><li class="tab"><button type="button" data-href="#06aba016-1b98-4fdf-aa5a-0362d8823a19-2"><i class="fas fa-cannabis"></i>步骤2</button></li><li class="tab"><button type="button" data-href="#06aba016-1b98-4fdf-aa5a-0362d8823a19-3"><i class="fas fa-candy-cane"></i>步骤3</button></li><li class="tab"><button type="button" data-href="#06aba016-1b98-4fdf-aa5a-0362d8823a19-4"><i class="fas fa-child"></i>步骤4</button></li><li class="tab"><button type="button" data-href="#06aba016-1b98-4fdf-aa5a-0362d8823a19-5"><i class="fas fa-cat"></i>步骤5</button></li><li class="tab"><button type="button" data-href="#06aba016-1b98-4fdf-aa5a-0362d8823a19-6"><i class="fas fa-horse"></i>步骤6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="06aba016-1b98-4fdf-aa5a-0362d8823a19-1"><blockquote><p>建表</p></blockquote><p><code>学员表</code>插<code>50万</code>条，<code>班级表</code>插<code>1万</code>条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE atguigudb2;</span><br><span class="line">USE atguigudb2;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`class`(</span><br><span class="line">  `id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `className`<span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `address`<span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `monitor`<span class="type">INT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`student`(</span><br><span class="line">  `id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stuno`<span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  `name`<span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age`<span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `classId`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">    #<span class="keyword">CONSTRAINT</span>`fk_class_id`<span class="keyword">FOREIGN</span> KEY (`classId`) <span class="keyword">REFERENCES</span>`t_class`(`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="06aba016-1b98-4fdf-aa5a-0362d8823a19-2"><blockquote><p>设置参数</p></blockquote><ul><li>命令开启：允许创建函数设置：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; # 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="06aba016-1b98-4fdf-aa5a-0362d8823a19-3"><blockquote><p>创建函数</p></blockquote><p>保证每条数据都不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#随机产生字符串</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line"><span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">function</span> rand_string;</span><br></pre></td></tr></table></figure><p>随机产生班级编号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#用于随机产生多少到多少的编号</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">function</span> rand_num;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="06aba016-1b98-4fdf-aa5a-0362d8823a19-4"><blockquote><p>创建存储过程</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#创建往stu表中插入数据的存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu( <span class="keyword">START</span> <span class="type">INT</span> , max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, name ,age ,classId ) <span class="keyword">VALUES</span></span><br><span class="line">((<span class="keyword">START</span><span class="operator">+</span>i),rand_string(<span class="number">6</span>),rand_num(<span class="number">1</span>,<span class="number">50</span>),rand_num(<span class="number">1</span>,<span class="number">1000</span>));</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_stu;</span><br></pre></td></tr></table></figure><p>创建往class表中插入数据的存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往class表添加随机数据</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>`insert_class`( max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">REPEAT</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> class ( classname,address,monitor ) <span class="keyword">VALUES</span></span><br><span class="line">(rand_string(<span class="number">8</span>),rand_string(<span class="number">10</span>),rand_num(<span class="number">1</span>,<span class="number">100000</span>));</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line">#假如要删除</span><br><span class="line">#<span class="keyword">drop</span> <span class="keyword">PROCEDURE</span> insert_class;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="06aba016-1b98-4fdf-aa5a-0362d8823a19-5"><blockquote><p>调用存储过程</p></blockquote><p>class</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往class表添加<span class="number">1</span>万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_class(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>stu</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往stu表添加<span class="number">50</span>万条数据</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">100000</span>,<span class="number">500000</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="06aba016-1b98-4fdf-aa5a-0362d8823a19-6"><blockquote><p>删除某表上的索引 后续演示过程中可能会频繁删除索引 所以定义此函数</p></blockquote><p>创建存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>`proc_drop_index`(dbname <span class="type">VARCHAR</span>(<span class="number">200</span>),tablename <span class="type">VARCHAR</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">        <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">DECLARE</span> ct <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">DECLARE</span> _index <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> index_name <span class="keyword">FROM</span></span><br><span class="line">information_schema.STATISTICS <span class="keyword">WHERE</span> table_schema<span class="operator">=</span>dbname <span class="keyword">AND</span> table_name<span class="operator">=</span>tablename <span class="keyword">AND</span></span><br><span class="line">seq_in_index<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> index_name <span class="operator">&lt;&gt;</span><span class="string">&#x27;PRIMARY&#x27;</span> ;</span><br><span class="line">#每个游标必须使用不同的<span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">set</span> done<span class="operator">=</span><span class="number">1</span>来控制游标的结束</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">set</span> done<span class="operator">=</span><span class="number">2</span> ;</span><br><span class="line">#若没有数据返回,程序继续,并将变量done设为<span class="number">2</span></span><br><span class="line">        <span class="keyword">OPEN</span> _cur;</span><br><span class="line">        <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">        WHILE _index<span class="operator">&lt;&gt;</span><span class="string">&#x27;&#x27;</span> DO</span><br><span class="line">            <span class="keyword">SET</span> <span class="variable">@str</span> <span class="operator">=</span> CONCAT(&quot;drop index &quot; , _index , &quot; on &quot; , tablename );</span><br><span class="line">            <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> <span class="variable">@str</span> ;</span><br><span class="line">            <span class="keyword">EXECUTE</span> sql_str;</span><br><span class="line">            <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str;</span><br><span class="line">            <span class="keyword">SET</span> _index<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="keyword">FETCH</span> _cur <span class="keyword">INTO</span> _index;</span><br><span class="line">        <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">CLOSE</span> _cur;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>执行存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> proc_drop_index(&quot;dbname&quot;,&quot;tablename&quot;);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="2-索引失效案例">2. 索引失效案例</h2><p>MySQL中<code>提高性能</code>的一个最有效的方式是对数据表<code>设计合理的索引</code>。索引提供了高效访问数据的方法，并且加快查询的速度，因此索引对查询的速度有着至关重要的影响。</p><ul><li><p>使用索引可以<code>快速地定位</code>表中的某条记录，从而提高数据库查询的速度，提高数据库的性能。</p></li><li><p>如果查询时没有使用索引，查询语句就会<code>扫描表中的所有记录</code>。在数据量大的情况下，这样查询的速度会很慢。</p></li></ul><p>大多数情况下都（默认）采用<code>B+树</code>来构建索引。只是空间列类型的索引使用<code>R-</code>树，并且MEMORY表还支持<code>hash 索引</code>。</p><p>其实，用不用索引，最终都是优化器说了算。优化器是基于什么的优化器？基于<code>cost开销 (CostBaseOptimizer)</code>，它不是基于<code>规则(Rule-Basedoptimizer）</code>，也不是基于<code>语义</code>。怎么样开销小就怎么来。另外，<span class='p red'>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。</span></p><div class="tabs" id="e9211a91-00fa-43d6-9499-a527e5d5888d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-1"><i class="fas fa-atom"></i>1.全值匹配我最爱</button></li><li class="tab"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-2"><i class="far fa-sun"></i>2.最佳左前缀法则</button></li><li class="tab"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-3"><i class="fas fa-wind"></i>3.主键插入顺序</button></li><li class="tab"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-4"><i class="fas fa-fire-alt"></i>计算、函数、类型转换导致索引失效</button></li><li class="tab"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-5"><i class="fas fa-award"></i>类型转换导致索引失效</button></li><li class="tab"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-6"><i class="fas fa-baseball-ball"></i>范围条件右边的列索引失效</button></li><li class="tab"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-7"><i class="fas fa-bone"></i>不等于索引失效</button></li><li class="tab"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-8"><i class="fas fa-dragon"></i>is null可以使用索引，is not null无法使用索引</button></li><li class="tab"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-9"><i class="fas fa-dove"></i>like以通配符%开头索引失效</button></li><li class="tab"><button type="button" data-href="#e9211a91-00fa-43d6-9499-a527e5d5888d-10"><i class="fas fa-horse"></i>OR前后存在非索引的列索引失效</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e9211a91-00fa-43d6-9499-a527e5d5888d-1"><p>系统中经常出现的sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p>建立索引前执行：（关注执行时间）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.28</span> sec)</span><br></pre></td></tr></table></figure><p><strong>建立索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> student(age);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid <span class="keyword">ON</span> student(age,classId);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student(age,classId,name);</span><br></pre></td></tr></table></figure><p>建立索引后执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到，创建索引前的查询时间是 0.28秒，创建索引后的查询时间是0.01 秒，索引帮助我们极大的提高了查询效率。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9211a91-00fa-43d6-9499-a527e5d5888d-2"><p>在MySQL建立联合索引时会遵守最佳左前缀原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p><p>举例1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p>举例3：索引<code>idx_age_classid_name</code>还能否正常使用？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">4</span> <span class="keyword">AND</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。<span class='p green'>与SQL中AND顺序无关，优化器会优化。</span></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704211116351.png" alt="image-20220704211116351"></p><p>虽然可以正常使用，但是只有部分被使用到了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.classId<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abcd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704211254581.png" alt="image-20220704211254581"></p><p>完全没有使用上索引。</p><p>结论：MySQL可以为多个字段创建索引，一个索引可以包含16个字段。对于多列索引，<span class='p red'>过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。</span>如果查询条件中没有用这些字段中第一个字段时，多列（或联合）索引不会被使用。</p><blockquote><p>拓展：Alibaba《Java开发手册》</p><p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9211a91-00fa-43d6-9499-a527e5d5888d-3"><p>对于一个使用<code>InnoDB</code>存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在<code>聚簇索引</code>的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录<code>主键值从小到大</code>的顺序进行排序， 所以如果我们插入的记录的<code>主键值是依次增大</code>的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在 1~100之间：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230411123722529.png" alt="image-20230411123722529"></p><p>如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704212428607.png" alt="image-20220704212428607"></p><p>可这个数据页已经满了，再插进来咋办呢？我们需要把当前<code>页面分裂</code>成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：<code>性能损耗</code>！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的<code>主键值依次递增</code>，这样就不会发生这样的性能损耗了。 所以我们建议：让主键具有<code>AUTO_INCREMENT</code>，让存储引擎自己为表生成主键，而不是我们手动插入 ， 比如：<code>person_info</code>表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(<span class="number">10</span>), birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们自定义的主键列<code>id</code>拥有<code>AUTO_INCREMENT</code>属性，在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9211a91-00fa-43d6-9499-a527e5d5888d-4"><ol><li>这两条sql哪种写法更好</li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建索引</li></ol>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure><div class="tabs" id="5f71e3f3-b819-4070-a29c-d6d9664e2d12"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5f71e3f3-b819-4070-a29c-d6d9664e2d12-1"><i class="fas fa-seedling"></i>第一种：索引优化生效</button></li><li class="tab"><button type="button" data-href="#5f71e3f3-b819-4070-a29c-d6d9664e2d12-2"><i class="fas fa-leaf"></i>第二种：索引优化失效</button></li><li class="tab"><button type="button" data-href="#5f71e3f3-b819-4070-a29c-d6d9664e2d12-3"><i class="fab fa-apple"></i>再举例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5f71e3f3-b819-4070-a29c-d6d9664e2d12-1"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> id      <span class="operator">|</span> stuno   <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> classId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5301379</span> <span class="operator">|</span> <span class="number">1233401</span> <span class="operator">|</span> AbCHEa <span class="operator">|</span> <span class="number">164</span>  <span class="operator">|</span> <span class="number">259</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7170042</span> <span class="operator">|</span> <span class="number">3102064</span> <span class="operator">|</span> ABcHeB <span class="operator">|</span> <span class="number">199</span>  <span class="operator">|</span> <span class="number">161</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1901614</span> <span class="operator">|</span> <span class="number">1833636</span> <span class="operator">|</span> ABcHeC <span class="operator">|</span> <span class="number">226</span>  <span class="operator">|</span> <span class="number">275</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5195021</span> <span class="operator">|</span> <span class="number">1127043</span> <span class="operator">|</span> abchEC <span class="operator">|</span> <span class="number">486</span>  <span class="operator">|</span> <span class="number">72</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4047089</span> <span class="operator">|</span> <span class="number">3810031</span> <span class="operator">|</span> AbCHFd <span class="operator">|</span> <span class="number">268</span>  <span class="operator">|</span> <span class="number">210</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4917074</span> <span class="operator">|</span> <span class="number">849096</span>  <span class="operator">|</span> ABcHfD <span class="operator">|</span> <span class="number">264</span>  <span class="operator">|</span> <span class="number">442</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1540859</span> <span class="operator">|</span> <span class="number">141979</span>  <span class="operator">|</span> abchFF <span class="operator">|</span> <span class="number">119</span>  <span class="operator">|</span> <span class="number">140</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5121801</span> <span class="operator">|</span> <span class="number">1053823</span> <span class="operator">|</span> AbCHFg <span class="operator">|</span> <span class="number">412</span>  <span class="operator">|</span> <span class="number">327</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2441254</span> <span class="operator">|</span> <span class="number">2373276</span> <span class="operator">|</span> abchFJ <span class="operator">|</span> <span class="number">170</span>  <span class="operator">|</span> <span class="number">362</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7039146</span> <span class="operator">|</span> <span class="number">2971168</span> <span class="operator">|</span> ABcHgI <span class="operator">|</span> <span class="number">502</span>  <span class="operator">|</span> <span class="number">465</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1636826</span> <span class="operator">|</span> <span class="number">1580286</span> <span class="operator">|</span> ABcHgK <span class="operator">|</span> <span class="number">71</span>   <span class="operator">|</span> <span class="number">262</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">374344</span>  <span class="operator">|</span> <span class="number">474345</span>  <span class="operator">|</span> abchHL <span class="operator">|</span> <span class="number">367</span>  <span class="operator">|</span> <span class="number">212</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1596534</span> <span class="operator">|</span> <span class="number">169191</span>  <span class="operator">|</span> AbCHHl <span class="operator">|</span> <span class="number">102</span>  <span class="operator">|</span> <span class="number">146</span> <span class="operator">|</span></span><br><span class="line">...</span><br><span class="line"><span class="operator">|</span> <span class="number">5266837</span> <span class="operator">|</span> <span class="number">1198859</span> <span class="operator">|</span> abclXe <span class="operator">|</span> <span class="number">292</span> <span class="operator">|</span> <span class="number">298</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8126968</span> <span class="operator">|</span> <span class="number">4058990</span> <span class="operator">|</span> aBClxE <span class="operator">|</span> <span class="number">316</span> <span class="operator">|</span> <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4298305</span> <span class="operator">|</span> <span class="number">399962</span>  <span class="operator">|</span> AbCLXF <span class="operator">|</span> <span class="number">72</span>  <span class="operator">|</span> <span class="number">423</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5813628</span> <span class="operator">|</span> <span class="number">1745650</span> <span class="operator">|</span> aBClxF <span class="operator">|</span> <span class="number">356</span> <span class="operator">|</span> <span class="number">323</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6980448</span> <span class="operator">|</span> <span class="number">2912470</span> <span class="operator">|</span> AbCLXF <span class="operator">|</span> <span class="number">107</span> <span class="operator">|</span> <span class="number">78</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7881979</span> <span class="operator">|</span> <span class="number">3814001</span> <span class="operator">|</span> AbCLXF <span class="operator">|</span> <span class="number">89</span>  <span class="operator">|</span> <span class="number">497</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4955576</span> <span class="operator">|</span> <span class="number">887598</span>  <span class="operator">|</span> ABcLxg <span class="operator">|</span> <span class="number">121</span> <span class="operator">|</span> <span class="number">385</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3653460</span> <span class="operator">|</span> <span class="number">3585482</span> <span class="operator">|</span> AbCLXJ <span class="operator">|</span> <span class="number">130</span> <span class="operator">|</span> <span class="number">174</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1231990</span> <span class="operator">|</span> <span class="number">1283439</span> <span class="operator">|</span> AbCLYH <span class="operator">|</span> <span class="number">189</span> <span class="operator">|</span> <span class="number">429</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6110615</span> <span class="operator">|</span> <span class="number">2042637</span> <span class="operator">|</span> ABcLyh <span class="operator">|</span> <span class="number">157</span> <span class="operator">|</span> <span class="number">40</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="number">401</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5f71e3f3-b819-4070-a29c-d6d9664e2d12-2"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704214905412.png" alt="image-20220704214905412"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(student.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> id      <span class="operator">|</span> stuno   <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> classId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5301379</span> <span class="operator">|</span> <span class="number">1233401</span> <span class="operator">|</span> AbCHEa <span class="operator">|</span> <span class="number">164</span> <span class="operator">|</span> <span class="number">259</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7170042</span> <span class="operator">|</span> <span class="number">3102064</span> <span class="operator">|</span> ABcHeB <span class="operator">|</span> <span class="number">199</span> <span class="operator">|</span> <span class="number">161</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1901614</span> <span class="operator">|</span> <span class="number">1833636</span> <span class="operator">|</span> ABcHeC <span class="operator">|</span> <span class="number">226</span> <span class="operator">|</span> <span class="number">275</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5195021</span> <span class="operator">|</span> <span class="number">1127043</span> <span class="operator">|</span> abchEC <span class="operator">|</span> <span class="number">486</span> <span class="operator">|</span> <span class="number">72</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4047089</span> <span class="operator">|</span> <span class="number">3810031</span> <span class="operator">|</span> AbCHFd <span class="operator">|</span> <span class="number">268</span> <span class="operator">|</span> <span class="number">210</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4917074</span> <span class="operator">|</span> <span class="number">849096</span>  <span class="operator">|</span> ABcHfD <span class="operator">|</span> <span class="number">264</span> <span class="operator">|</span> <span class="number">442</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1540859</span> <span class="operator">|</span> <span class="number">141979</span>  <span class="operator">|</span> abchFF <span class="operator">|</span> <span class="number">119</span> <span class="operator">|</span> <span class="number">140</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5121801</span> <span class="operator">|</span> <span class="number">1053823</span> <span class="operator">|</span> AbCHFg <span class="operator">|</span> <span class="number">412</span> <span class="operator">|</span> <span class="number">327</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2441254</span> <span class="operator">|</span> <span class="number">2373276</span> <span class="operator">|</span> abchFJ <span class="operator">|</span> <span class="number">170</span> <span class="operator">|</span> <span class="number">362</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7039146</span> <span class="operator">|</span> <span class="number">2971168</span> <span class="operator">|</span> ABcHgI <span class="operator">|</span> <span class="number">502</span> <span class="operator">|</span> <span class="number">465</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1636826</span> <span class="operator">|</span> <span class="number">1580286</span> <span class="operator">|</span> ABcHgK <span class="operator">|</span> <span class="number">71</span>  <span class="operator">|</span> <span class="number">262</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">374344</span>  <span class="operator">|</span> <span class="number">474345</span>  <span class="operator">|</span> abchHL <span class="operator">|</span> <span class="number">367</span> <span class="operator">|</span> <span class="number">212</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1596534</span> <span class="operator">|</span> <span class="number">169191</span>  <span class="operator">|</span> AbCHHl <span class="operator">|</span> <span class="number">102</span> <span class="operator">|</span> <span class="number">146</span> <span class="operator">|</span></span><br><span class="line">...</span><br><span class="line"><span class="operator">|</span> <span class="number">5266837</span> <span class="operator">|</span> <span class="number">1198859</span> <span class="operator">|</span> abclXe <span class="operator">|</span> <span class="number">292</span> <span class="operator">|</span> <span class="number">298</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8126968</span> <span class="operator">|</span> <span class="number">4058990</span> <span class="operator">|</span> aBClxE <span class="operator">|</span> <span class="number">316</span> <span class="operator">|</span> <span class="number">150</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4298305</span> <span class="operator">|</span> <span class="number">399962</span>  <span class="operator">|</span> AbCLXF <span class="operator">|</span> <span class="number">72</span>  <span class="operator">|</span> <span class="number">423</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5813628</span> <span class="operator">|</span> <span class="number">1745650</span> <span class="operator">|</span> aBClxF <span class="operator">|</span> <span class="number">356</span> <span class="operator">|</span> <span class="number">323</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6980448</span> <span class="operator">|</span> <span class="number">2912470</span> <span class="operator">|</span> AbCLXF <span class="operator">|</span> <span class="number">107</span> <span class="operator">|</span> <span class="number">78</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7881979</span> <span class="operator">|</span> <span class="number">3814001</span> <span class="operator">|</span> AbCLXF <span class="operator">|</span> <span class="number">89</span>  <span class="operator">|</span> <span class="number">497</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4955576</span> <span class="operator">|</span> <span class="number">887598</span>  <span class="operator">|</span> ABcLxg <span class="operator">|</span> <span class="number">121</span> <span class="operator">|</span> <span class="number">385</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3653460</span> <span class="operator">|</span> <span class="number">3585482</span> <span class="operator">|</span> AbCLXJ <span class="operator">|</span> <span class="number">130</span> <span class="operator">|</span> <span class="number">174</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1231990</span> <span class="operator">|</span> <span class="number">1283439</span> <span class="operator">|</span> AbCLYH <span class="operator">|</span> <span class="number">189</span> <span class="operator">|</span> <span class="number">429</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6110615</span> <span class="operator">|</span> <span class="number">2042637</span> <span class="operator">|</span> ABcLyh <span class="operator">|</span> <span class="number">157</span> <span class="operator">|</span> <span class="number">40</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="number">401</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">3.62</span> sec)</span><br></pre></td></tr></table></figure><p>type为“ALL”，表示没有使用到索引，查询时间为 3.62 秒，查询效率较之前低很多。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5f71e3f3-b819-4070-a29c-d6d9664e2d12-3"><ul><li>student表的字段stuno上设置有索引</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_sno <span class="keyword">ON</span> student(stuno);</span><br></pre></td></tr></table></figure><ul><li>索引优化失效：（假设：student表的字段stuno上设置有索引）</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno<span class="operator">+</span><span class="number">1</span> <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704215159768.png" alt="image-20220704215159768"></p><ul><li>索引优化生效：</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">900000</span>;</span><br></pre></td></tr></table></figure><p><strong>再举例：</strong></p><ul><li>student表的字段name上设置有索引</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, stuno, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="built_in">SUBSTRING</span>(name, <span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704215533871.png" alt="image-20220704215533871"></p><ul><li>索引优化生效</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, stuno, NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704215600507.png" alt="image-20220704215600507"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9211a91-00fa-43d6-9499-a527e5d5888d-5"><p>下列哪个sql语句可以用到索引。（假设name字段上设置有索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="number">123</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704215658526.png" alt="image-20220704215658526"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704215721216.png" alt="image-20220704215721216"></p><p>name=123发生类型转换，索引失效。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9211a91-00fa-43d6-9499-a527e5d5888d-6"><ol><li>系统经常出现的sql如下：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_name;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_age;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_age_classid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student (age, classId, NAME);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20190704220123647.png" alt="image-20220704220123647"></p><p>key_len=10 只用上了两个int+2NULL  age和classid，name失效</p><blockquote><p>解释一下为什么范围查询会导致索引失效：</p><p>例如：a_b_c这个索引，你根据b范围查找&gt;2的</p><p>因为根据范围查找筛选后的数据，无法保证范围查找后面的字段是有序的</p></blockquote><ol start="2"><li>那么索引 idx_age_classId_name 这个索引还能正常使用么？</li></ol><ul><li>不能，范围右边的列不能使用。比如：(&lt;) (&lt;=) (&gt;) (&gt;=) 和 between 等</li><li>如果这种sql出现较多，应该建立：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_age_name_classId <span class="keyword">on</span> student(age,name,classId);</span><br></pre></td></tr></table></figure><ul><li>将范围查询条件放置语句最后：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.age<span class="operator">=</span><span class="number">30</span> <span class="keyword">AND</span> student.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">AND</span> student.classId<span class="operator">&gt;</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p></blockquote><ol start="3"><li>效果</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704223211981.png" alt="image-20220704223211981"></p><p>name varchar(20)   60+2+1</p><p>int  4+1</p><p>int  4+1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9211a91-00fa-43d6-9499-a527e5d5888d-7"><ul><li>为name字段创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> student(NAME);</span><br></pre></td></tr></table></figure><ul><li>查看索引是否失效</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704224552374.png" alt="image-20220704224552374"></p><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> student.name <span class="operator">!=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704224916117.png" alt="image-20220704224916117"></p><p>场景举例：用户提出需求，将财务数据，产品利润金额不等于0的都统计出来。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9211a91-00fa-43d6-9499-a527e5d5888d-8"><ul><li>IS NULL: 可以触发索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><ul><li>IS NOT NULL: 无法触发索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704225333199.png" alt="image-20220704225333199"></p><blockquote><p>结论：最好在设计数据库的时候就将<code>字段设置为 NOT NULL 约束</code>，比如你可以将 INT 类型的字段，默认值设置为0。将字符类型的默认值设置为空字符串(‘’)。</p><p>扩展：同理，在查询中使用<code>not like</code>也无法使用索引，导致全表扫描。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9211a91-00fa-43d6-9499-a527e5d5888d-9"><p>在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为’%‘，索引就不会起作用。只有’%'不在第一个位置，索引才会起作用。</p><ul><li>使用到索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;ab%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705131643304.png" alt="image-20220705131643304"></p><ul><li>未使用到索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%ab%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705131717329.png" alt="image-20220705131717329"></p><blockquote><p>拓展：Alibaba《Java开发手册》</p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9211a91-00fa-43d6-9499-a527e5d5888d-10"><p>在WHERE子句中，如果在OR前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引会失效。也就是说，<strong>OR前后的两个条件中的列都是索引时，查询中才使用索引。</strong></p><p>因为OR的含义就是两个只要满足一个即可，因此<code>只有一个条件列进行了索引是没有意义的</code>，只要有条件列没有进行索引，就会进行<code>全表扫描</code>，因此所以的条件列也会失效。</p><p>查询语句使用OR关键字的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 未使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> classid <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705132221045.png" alt="image-20220705132221045"></p><p>因为classId字段上没有索引，所以上述查询语句没有使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使用到索引</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">OR</span> name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705132239232.png" alt="image-20220705132239232"></p><p>因为age字段和name字段上都有索引，所以查询中使用了索引。你能看到这里使用到了<code>index_merge</code>，简单来说index_merge就是对age和name分别进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是<code>避免了全表扫描</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <blockquote><p>注意：数据库和表的字符集统一使用utf8mb4</p><p>统一使用utf8mb4( 5.5.3版本以上支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不 同的<code>字符集</code>进行比较前需要进行<code>转换</code>会造成索引失效。</p></blockquote><p>练习：假设存在索引index(a,b,c)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705145225852.png" alt="image-20220705145225852"></p><p><strong>一般性建议</strong></p><ul><li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择能够当前query中where子句中更多的索引。</li><li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。</li></ul><p><strong>总之，书写SQL语句时，尽量避免造成索引失效的情况</strong></p><hr><h2 id="3-关联查询优化">3. 关联查询优化</h2><h3 id="1-数据准备-2">1 数据准备</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># 分类</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>`type`(</span><br><span class="line">`id`<span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card`<span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line">#图书</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>`book`(</span><br><span class="line">`bookid`<span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`card`<span class="type">INT</span>(<span class="number">10</span>) UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`bookid`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#向分类表中添加<span class="number">20</span>条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`type`(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"></span><br><span class="line">#向图书表中添加<span class="number">20</span>条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-采用左外连接">3.2 采用左外连接</h3><p>下面开始 EXPLAIN 分析</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span>`type`<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705160504018.png" alt="image-20220705160504018"></p><p>结论：type 有All</p><p>添加索引优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX Y (card); #【被驱动表】，可以避免全表扫描</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span>`type`<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705160935109.png" alt="image-20220705160935109"></p><p>可以看到第二行的 type 变为了 ref，rows 也变成了优化比较明显。这是由左连接特性决定的。LEFT JOIN 条件用于确定如何从右表搜索行，左边一定都有，所以<code>右边是我们的关键点,一定需要建立索引</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>`type`<span class="keyword">ADD</span> INDEX X (card); #【驱动表】，无法避免全表扫描</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span>`type`<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705161243838.png" alt="image-20220705161243838"></p><p>接着：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX Y <span class="keyword">ON</span> book;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span>`type`<span class="keyword">LEFT</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705161515545.png" alt="image-20220705161515545"></p><hr><h3 id="3-3-采用内连接">3.3 采用内连接</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index X <span class="keyword">on</span> type;</span><br><span class="line"><span class="keyword">drop</span> index Y <span class="keyword">on</span> book;（如果已经删除了可以不用再执行该操作）</span><br></pre></td></tr></table></figure><p>换成 inner join（MySQL自动选择驱动表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> type <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705161602362.png" alt="image-20220705161602362"></p><p>添加索引优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX Y (card);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> type <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705161746184.png" alt="image-20220705161746184"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> type <span class="keyword">ADD</span> INDEX X (card);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> type <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705161843558.png" alt="image-20220705161843558"></p><p>对于内连接来说，</p><ol><li><p>查询优化器可以决定谁作为驱动表，谁作为被驱动表出现的</p></li><li><span class='p green'>如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表。</span></li><li><p>在两个表的链接条件都存在索引的情况下，会选择小表作为驱动表。 “小表驱动大表”</p></li></ol><p>演示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX X <span class="keyword">ON</span>`type`;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> TYPE <span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p>交换了位置</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705161929544.png" alt="image-20220705161929544"></p><p>接着：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>`type`<span class="keyword">ADD</span> INDEX X (card);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span>`type`<span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span> type.card<span class="operator">=</span>book.card;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705162009145.png" alt="image-20220705162009145"></p><p>接着：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#向图书表中添加<span class="number">20</span>条记录</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(card) <span class="keyword">VALUES</span>(<span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> (RAND() <span class="operator">*</span> <span class="number">20</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book <span class="keyword">ADD</span> INDEX Y (card);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span>`type`<span class="keyword">INNER</span> <span class="keyword">JOIN</span> book <span class="keyword">ON</span>`type`.card <span class="operator">=</span> book.card;</span><br></pre></td></tr></table></figure><p>发现，由于book表数据大于type表数据，MySQL选择将book作为被驱动表。</p><hr><h3 id="3-4-join语句原理">3.4 join语句原理</h3><p>join方式连接多个表，本质就是各个表之间数据的循环匹配。MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会很长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p><div class="tabs" id="9fba7784-d8d4-46ae-8707-b7612bc1d72f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#9fba7784-d8d4-46ae-8707-b7612bc1d72f-1"><i class="fas fa-cat"></i>驱动表和被驱动表</button></li><li class="tab"><button type="button" data-href="#9fba7784-d8d4-46ae-8707-b7612bc1d72f-2"><i class="fas fa-horse"></i>简单嵌套循环连接</button></li><li class="tab"><button type="button" data-href="#9fba7784-d8d4-46ae-8707-b7612bc1d72f-3"><i class="fas fa-dove"></i>索引嵌套循环连接</button></li><li class="tab"><button type="button" data-href="#9fba7784-d8d4-46ae-8707-b7612bc1d72f-4"><i class="fas fa-dragon"></i>块嵌套循环连接</button></li><li class="tab"><button type="button" data-href="#9fba7784-d8d4-46ae-8707-b7612bc1d72f-5"><i class="fas fa-tree"></i>Join小结</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="9fba7784-d8d4-46ae-8707-b7612bc1d72f-1"><p>驱动表就是主表，被驱动表就是从表、非驱动表。</p><ul><li>对于内连接来说：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br></pre></td></tr></table></figure><p>A一定是驱动表吗？不一定，优化器会根据你查询语句做优化，决定先查哪张表。先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。</p><ul><li>对于外连接来说：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> ...</span><br><span class="line"># 或</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> A <span class="keyword">ON</span> ... </span><br></pre></td></tr></table></figure><p>通常，大家会认为A就是驱动表，B就是被驱动表。但也未必。测试如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> a(f1 <span class="type">INT</span>, f2 <span class="type">INT</span>, INDEX(f1)) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> b(f1 <span class="type">INT</span>, f2 <span class="type">INT</span>) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> a <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> b <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> b;</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> b <span class="keyword">ON</span>(a.f1<span class="operator">=</span>b.f1) <span class="keyword">WHERE</span> (a.f2<span class="operator">=</span>b.f2);</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230412102452266.png" alt="image-20230412102452266"></p><p>优化器把外连接优化成为内连接，之后就优化器帮你选择哪个。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9fba7784-d8d4-46ae-8707-b7612bc1d72f-2"><p><span class='p green'>Simple Nested-Loop Join</span></p><p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result… 以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705165559127.png" alt="image-20220705165559127"></p><p>可以看到这种方式效率是非常低的，以上述表A数据100条，表B数据1000条计算，则A*B=10万次。开销统计如下:</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705165646252.png" alt="image-20220705165646252"></p><p>当然mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join优化算法。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9fba7784-d8d4-46ae-8707-b7612bc1d72f-3"><p><span class='p green'>Index Nested-Loop Join</span></p><p>Index Nested-Loop Join其优化的思路主要是为了<code>减少内存表数据的匹配次数</code>，所以要求被驱动表上必须<code>有索引</code>才行。通过外层表匹配条件直接与内层表索引进行匹配，避免和内存表的每条记录去进行比较，这样极大的减少了对内存表的匹配次数。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705172315554.png" alt="image-20220705172315554"></p><p>驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的，故mysql优化器都倾向于使用记录数少的表作为驱动表（外表）。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705172650749.png" alt="image-20220705172650749"></p><p>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9fba7784-d8d4-46ae-8707-b7612bc1d72f-4"><p><span class='p green'>Block Nested-Loop Join</span></p><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，大大增加了10的次数。为了减少被驱动表的10次数，就出现了Block Nested-Loop Join的方式。</p><p>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了<code>join buffer缓冲区</code>，将驱动表join相关的部分数据列(大小受join buffer的限制缓存到join bufer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。</p><blockquote><p>注意：</p><p>这里缓存的不只是关联表的列，select后面的列也会缓存起来。</p><p>在一个有N个join关联的sql中会分配N-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。</p></blockquote><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705174005280.png" alt="image-20220705174005280"></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705174250551.png" alt="image-20220705174250551"></p><p>参数设置：</p><ul><li>block_nested_loop</li></ul><p>通过<code>show variables like '%optimizer_switch%</code>查看<code>block_nested_loop</code>状态。默认是开启的。</p><ul><li>join_buffer_size</li></ul><p>驱动表能不能一次加载完，要看join buffer能不能存储所有的数据，默认情况下<code>join_buffer_size=256k</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%join_buffer%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>join_buffer_size的最大值在32位操作系统可以申请4G，而在64位操作系统下可以申请大于4G的Join Buffer空间（64位Windows除外，其大值会被截断为4GB并发出警告）。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9fba7784-d8d4-46ae-8707-b7612bc1d72f-5"><p>1、<strong>整体效率比较：INLJ &gt; BNLJ &gt; SNLJ</strong></p><p>2、永远用小结果集驱动大结果集（其本质就是减少外层循环的数据数量）（小的度量单位指的是表行数 * 每行大小）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.b,t2.<span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">100</span>; # 推荐</span><br><span class="line"><span class="keyword">select</span> t1.b,t2.<span class="operator">*</span> <span class="keyword">from</span> t2 straight_join t1 <span class="keyword">on</span> (t1.b<span class="operator">=</span>t2.b) <span class="keyword">where</span> t2.id<span class="operator">&lt;=</span><span class="number">100</span>; # 不推荐</span><br></pre></td></tr></table></figure><p>3、为被驱动表匹配的条件增加索引(减少内存表的循环匹配次数)</p><p>4、增大join buffer size的大小（一次索引的数据越多，那么内层包的扫描次数就越少）</p><p>5、减少驱动表不必要的字段查询（字段越少，join buffer所缓存的数据就越多）</p><blockquote><p>Hash Join</p></blockquote><p><strong>从MySQL的8.0.20版本开始将废弃BNLJ，因为从MySQL8.0.18版本开始就加入了hash join默认都会使用hash join</strong></p><ul><li><p>Nested Loop:</p><p>对于被连接的数据子集较小的情况，Nested Loop是个较好的选择。</p></li><li><p>Hash Join是做<code>大数据集连接</code>时的常用方式，优化器使用两个表中较小（相对较小）的表利用Join Key在内存中建立<code>散列表</code>，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p><ul><li>这种方式适合于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成<code>若干不同的分区</code>，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/O的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。Hash Join只能应用于等值连接（如WHERE A.COL1 = B.COL2），这是由Hash的特点决定的。</li></ul></li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705205050280.png" alt="image-20220705205050280"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="3-5-小结">3.5 小结</h3><ul><li>保证被驱动表的JOIN字段已经创建了索引</li><li>需要JOIN 的字段，数据类型保持绝对一致。</li><li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li><li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li><li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li><li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li><li>衍生表建不了索引</li></ul><hr><h2 id="4-子查询优化">4. 子查询优化</h2><p>MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，即一个SELECT查询的结 果作为另一个SELECT语句的条件。<code>子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作</code>。</p><span class='p red'>子查询是 MySQL 的一项重要的功能，可以帮助我们通过一个 SQL 语句实现比较复杂的查询。但是，子查询的执行效率不高。</span>原因：<p>① 执行子查询时，MySQL需要为内层查询语句的查询结果<code>建立一个临时表</code>，然后外层查询语句从临时表 中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗过多的CPU和IO资源，产生大量的慢查询。</p><p>② 子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都<code>不会存在索引</code>，所以查询性能会受到一定的影响。</p><p>③ 对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</p><span class='p red'>在MySQL中，可以使用连接（JOIN）查询来替代子查询。</span> 连接查询不需要建立临时，其速度比子查询要快 ，如果查询中使用索引的话，性能就会更好。<p>举例1：查询学生表中是班长的学生信息</p><ul><li>使用子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建班级表中班长的索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_monitor <span class="keyword">ON</span> class(monitor);</span><br><span class="line"># 查询班长信息</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student stu1</span><br><span class="line"><span class="keyword">WHERE</span> stu1.`stuno`<span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> monitor</span><br><span class="line"><span class="keyword">FROM</span> class c</span><br><span class="line"><span class="keyword">WHERE</span> monitor <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230412113820338.png" alt="image-20230412113820338"></p><ul><li>推荐使用多表查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> stu1.<span class="operator">*</span> <span class="keyword">FROM</span> student stu1 <span class="keyword">JOIN</span> class c</span><br><span class="line"><span class="keyword">ON</span> stu1.`stuno`<span class="operator">=</span> c.`monitor`</span><br><span class="line"><span class="keyword">WHERE</span> c.`monitor`<span class="keyword">is</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230412113950052.png" alt="image-20230412113950052"></p><p>举例2：取所有不为班长的同学</p><ul><li>不推荐</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student a</span><br><span class="line"><span class="keyword">WHERE</span> a.stuno <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> monitor <span class="keyword">FROM</span> class b</span><br><span class="line">    <span class="keyword">WHERE</span> monitor <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705210708343.png" alt="image-20220705210708343"></p><ul><li>推荐：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE a.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student a <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> class b</span><br><span class="line"><span class="keyword">ON</span> a.stuno <span class="operator">=</span> b.monitor</span><br><span class="line"><span class="keyword">WHERE</span> b.monitor <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705210839437.png" alt="image-20220705210839437"></p><blockquote><p>结论：尽量不要使用NOT IN或者NOT EXISTS，用LEFT JOIN xxx ON xx WHERE xx IS NULL替代</p></blockquote><hr><h2 id="5-排序优化">5. 排序优化</h2><h3 id="5-1-排序优化">5.1 排序优化</h3><p><strong>问题</strong>：在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？</p><p><strong>回答：</strong></p><p>在MySQL中，支持两种排序方式，分别是<code>FileSort</code>和<code>Index</code>排序。</p><ul><li>Index 排序中，索引可以保证数据的有序性，不需要再进行排序，<code>效率更高</code>。</li><li>FileSort 排序则一般在<code>内存中</code>进行排序，占用<code>CPU较多</code>。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低。</li></ul><p><strong>优化建议：</strong></p><ol><li>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中<code>避免全表扫描</code>，在 ORDER BY 子句<code>避免使用 FileSort 排序</code>。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</li><li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列； 如果不同就使用联合索引。</li><li>无法使用 Index 时，需要对 FileSort 方式进行调优。</li></ol><h3 id="5-2-测试">5.2 测试</h3><p>删除student表和class表中已创建的索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 方式<span class="number">1</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_monitor <span class="keyword">ON</span> class;</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_cid <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_name <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_name_classId <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_classId_name <span class="keyword">ON</span> student;</span><br><span class="line"></span><br><span class="line"># 方式<span class="number">2</span></span><br><span class="line"><span class="keyword">call</span> proc_drop_index(<span class="string">&#x27;atguigudb2&#x27;</span>,<span class="string">&#x27;student&#x27;</span>;)</span><br></pre></td></tr></table></figure><p>以下是否能使用到索引，<code>能否去掉using filesort</code></p><p><strong>过程一：</strong></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705215436102.png" alt="image-20220705215436102"></p><p><strong>过程二： order by 时不limit,索引失效</strong></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705215909350.png" alt="image-20220705215909350"></p><p><strong>过程三：order by 时顺序错误，索引失效</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705220033520.png" alt="image-20220705220033520" style="zoom:80%;" /><p><strong>过程四：order by 时规则不一致，索引失效（顺序错，不索引；方向反，不索引）</strong></p><p>第四个反而能索引都倒了</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705220404802.png" alt="image-20220705220404802" style="zoom:80%;" /><blockquote><p>结论：ORDER BY 子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p></blockquote><p><strong>过程五：无过滤，不索引</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705221212879.png" alt="image-20220705221212879" style="zoom:80%;" /><p><strong>小结</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">INDEX a_b_c(a,b,c)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 能使用索引最左前缀</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a,b</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a,b,c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">DESC</span>,b <span class="keyword">DESC</span>,c <span class="keyword">DESC</span></span><br><span class="line">如果<span class="keyword">WHERE</span>使用索引的最左前缀定义为常量，则<span class="keyword">order</span> <span class="keyword">by</span> 能使用索引</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c</span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">AND</span> b <span class="operator">&gt;</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c</span><br><span class="line">不能使用索引进行排序</span><br><span class="line"><span class="operator">-</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">ASC</span>,b <span class="keyword">DESC</span>,c <span class="keyword">DESC</span> <span class="comment">/* 排序不一致 */</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> g <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c <span class="comment">/*丢失a索引*/</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="comment">/*丢失b索引*/</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="operator">=</span> const <span class="keyword">ORDER</span> <span class="keyword">BY</span> a,d <span class="comment">/*d不是索引的一部分*/</span></span><br><span class="line"><span class="operator">-</span> <span class="keyword">WHERE</span> a <span class="keyword">in</span> (...) <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c <span class="comment">/*对于排序来说，多个相等条件也是范围查询*/</span></span><br></pre></td></tr></table></figure><h3 id="5-3-案例实战">5.3 案例实战</h3><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。</p><p>执行案例前先清除student上的索引，只留主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX idx_age <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_classid_stuno <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_classid_name <span class="keyword">ON</span> student;</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">call</span> proc_drop_index(<span class="string">&#x27;atguigudb2&#x27;</span>,<span class="string">&#x27;student&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>场景:查询年龄为30岁的，且学生编号小于101000的学生，按用户名称排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME ;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705222027812.png" alt="image-20220705222027812"></p><p>查询结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> id      <span class="operator">|</span> stuno  <span class="operator">|</span>  name  <span class="operator">|</span> age  <span class="operator">|</span> classId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">922</span>     <span class="operator">|</span> <span class="number">100923</span> <span class="operator">|</span> elTLXD <span class="operator">|</span> <span class="number">30</span>   <span class="operator">|</span> <span class="number">249</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3723263</span> <span class="operator">|</span> <span class="number">100412</span> <span class="operator">|</span> hKcjLb <span class="operator">|</span> <span class="number">30</span>   <span class="operator">|</span> <span class="number">59</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3724152</span> <span class="operator">|</span> <span class="number">100827</span> <span class="operator">|</span> iHLJmh <span class="operator">|</span> <span class="number">30</span>   <span class="operator">|</span> <span class="number">387</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3724030</span> <span class="operator">|</span> <span class="number">100776</span> <span class="operator">|</span> LgxWoD <span class="operator">|</span> <span class="number">30</span>   <span class="operator">|</span> <span class="number">253</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">30</span>      <span class="operator">|</span> <span class="number">100031</span> <span class="operator">|</span> LZMOIa <span class="operator">|</span> <span class="number">30</span>   <span class="operator">|</span> <span class="number">97</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3722887</span> <span class="operator">|</span> <span class="number">100237</span> <span class="operator">|</span> QzbJdx <span class="operator">|</span> <span class="number">30</span>   <span class="operator">|</span> <span class="number">440</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">609</span>     <span class="operator">|</span> <span class="number">100610</span> <span class="operator">|</span> vbRimN <span class="operator">|</span> <span class="number">30</span>   <span class="operator">|</span> <span class="number">481</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">139</span>     <span class="operator">|</span> <span class="number">100140</span> <span class="operator">|</span> ZqFbuR <span class="operator">|</span> <span class="number">30</span>   <span class="operator">|</span> <span class="number">351</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+--------+--------+------+---------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">3.16</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>结论：type 是 ALL，即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。优化是必须的。</p></blockquote><p><strong>方案一: 为了去掉filesort我们可以把索引建成</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建新索引</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age,NAME);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705222912521.png" alt="image-20220705222912521"></p><p>这样我们优化掉了 using filesort</p><p>查询结果如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705222954971.png" alt="image-20220705222954971"  /><p><strong>方案二：尽量让where的过滤条件和排序使用上索引</strong></p><p>建一个三个字段的组合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX idx_age_name <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_stuno_name <span class="keyword">ON</span> student (age,stuno,NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705223111883.png" alt="image-20220705223111883"></p><p>我们发现using filesort依然存在，所以name并没有用到索引，而且type还是range光看名字其实并不美好。原因是，因为<code>stuno是一个范围过滤</code>，所以索引后面的字段不会在使用索引了 。</p><p>结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> student</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> stuno <span class="operator">&lt;</span><span class="number">101000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> NAME ;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+--------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> stuno <span class="operator">|</span> name <span class="operator">|</span> age <span class="operator">|</span> classId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+--------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">167</span> <span class="operator">|</span> <span class="number">100168</span> <span class="operator">|</span> AClxEF <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">319</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">323</span> <span class="operator">|</span> <span class="number">100324</span> <span class="operator">|</span> bwbTpQ <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">654</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">651</span> <span class="operator">|</span> <span class="number">100652</span> <span class="operator">|</span> DRwIac <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">997</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">517</span> <span class="operator">|</span> <span class="number">100518</span> <span class="operator">|</span> HNSYqJ <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">256</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">344</span> <span class="operator">|</span> <span class="number">100345</span> <span class="operator">|</span> JuepiX <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">329</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">905</span> <span class="operator">|</span> <span class="number">100906</span> <span class="operator">|</span> JuWALd <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">892</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">574</span> <span class="operator">|</span> <span class="number">100575</span> <span class="operator">|</span> kbyqjX <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">260</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">703</span> <span class="operator">|</span> <span class="number">100704</span> <span class="operator">|</span> KJbprS <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">594</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">723</span> <span class="operator">|</span> <span class="number">100724</span> <span class="operator">|</span> OTdJkY <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">236</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">656</span> <span class="operator">|</span> <span class="number">100657</span> <span class="operator">|</span> Pfgqmj <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">600</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">982</span> <span class="operator">|</span> <span class="number">100983</span> <span class="operator">|</span> qywLqw <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">837</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">468</span> <span class="operator">|</span> <span class="number">100469</span> <span class="operator">|</span> sLEKQW <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">346</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">988</span> <span class="operator">|</span> <span class="number">100989</span> <span class="operator">|</span> UBYqJl <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">457</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">173</span> <span class="operator">|</span> <span class="number">100174</span> <span class="operator">|</span> UltkTN <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">830</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">332</span> <span class="operator">|</span> <span class="number">100333</span> <span class="operator">|</span> YjWiZw <span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> <span class="number">824</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+--------+--------+------+---------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>结果竟然有 filesort的 sql 运行速度， 超过了已经优化掉 filesort的 sql ，而且快了很多，几乎一瞬间就出现了结果。</p><p>原因：</p><p>所有的排序都是在条件过滤之后才执行的。所以，如果条件过滤掉大部分数据的话，剩下几百几干条数据进行排序其实并不是很消耗性能，即使索引优化了排序，但实际提升性能很有限。相对的 stuno&lt;101000 这个条件，如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的，所以索引放在这个字段上性价比最高，是最优选择。</p><blockquote><p>结论：</p><ol><li>两个索引同时存在，mysql自动选择最优的方案。（对于这个例子，mysql选择 idx_age_stuno_name）。但是，<code>随着数据量的变化，选择的索引也会随之变化的</code>。</li><li><strong>当【范围条件】和【group by 或者 order by】的字段出现二选一时，优先观察条件字段的过 滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</strong></li></ol></blockquote><p>思考：这里我们使用如下索引，是否可行？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX idx_age_stuno_name <span class="keyword">ON</span> student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_stuno <span class="keyword">ON</span> student(age,stuno);</span><br></pre></td></tr></table></figure><p>当然可以。</p><h3 id="5-4-filesort算法：双路排序和单路排序">5.4 filesort算法：双路排序和单路排序</h3><p>排序的字段若不在索引列上，则filesort会有两种算法：双路排序和单路排序</p><p><strong>双路排序 （慢）</strong></p><ul><li>MySQL 4.1之前是使用双路排序 ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和 order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段 。</li></ul><p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种 改进的算法，就是单路排序。</p><p><strong>单路排序 （快）</strong></p><p>从磁盘读取查询需要的 所有列 ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>结论及引申出的问题</strong></p><ul><li>由于单路是后出的，总体而言好过双路</li><li>但是用单路有问题<ul><li>在sort_buffer中，单路要比多路多占用很多空间，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了<code>sort_buffer</code>的容量，导致每次只能取<code>sort_buffer</code>容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排…从而多次I/O。</li><li>单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</li></ul></li></ul><p><strong>优化策略</strong></p><p><strong>1. 尝试提高 sort_buffer_size</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705224410340.png" alt="image-20220705224410340" style="zoom:80%;" /><p><strong>2. 尝试提高 max_length_for_sort_data</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705224505668.png" alt="image-20220705224505668" style="zoom:80%;" /><p><strong>3. Order by 时select * 是一个大忌。最好只Query需要的字段。</strong></p><ul><li><p>当Query的字段大小总和小于<code>max_length_for-sort_data</code>，而且排序字段不是TEXT | BLOB 类型时，会用改进后的算法一一单路排序，否则用老算法一一多路排序。</p></li><li><p>两种算法的数据都有可能超出sort_buffer_size的容量，超出之后，会创建tmp文件进行合并排序，导致多次 I/O，但是用单路排序算法的风险会更大一些，所以要提高<code>sort_buffer-size</code>。</p></li></ul><hr><h2 id="6-GROUP-BY优化">6. GROUP BY优化</h2><ul><li>group by 使用索引的原则几乎跟order by一致 ，group by 即使没有过滤条件用到索引，也可以直接使用索引。</li><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>当无法使用索引列，增大 max_length_for_sort_data 和 sort_buffer_size 参数的设置</li><li>where效率高于having，能写在where限定的条件就不要写在having中了</li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行 以内，否则SQL会很慢。</li></ul><hr><h2 id="7-优化分页查询">7. 优化分页查询</h2><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 此时需要MySQL排序前2000010记录，仅仅返回2000000-2000010的记录，其他记录丢弃，查询排序的代价非常大。</p><p><code>EXPLAIN SELECT * FROM student LIMIT 2000000,10</code>;</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230411140225812.png" alt="image-20230411140225812"></p><p><strong>优化思路一</strong></p><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student t,(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">WHERE</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705225625166.png" alt="image-20220705225625166"></p><p><strong>优化思路二</strong></p><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2000000</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220705225654124.png" alt="image-20220705225654124"></p><hr><h2 id="8-优先考虑覆盖索引">8. 优先考虑覆盖索引</h2><h3 id="8-1-什么是覆盖索引？">8.1 什么是覆盖索引？</h3><p><strong>理解方式一</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。<strong>一个索引包含了满足查询结果的数据就叫做覆盖索引</strong>。</p><p><strong>理解方式二</strong>：非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列 （即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p><p>简单说就是，<code>索引列+主键</code>包含<code>SELECT 到 FROM之间查询的列</code>。</p><p><strong>举例一：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除之前的索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX idx_age_stuno <span class="keyword">ON</span> student;</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age, NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> age,name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706124528680.png" alt="image-20220706124528680"></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230412144559891.png" alt="image-20230412144559891"></p><p>本来由于不等号索引失效 ，但是覆盖索引</p><p><strong>举例二：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706124612180.png" alt="image-20220706124612180"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> student(age, NAME);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> id,age,NAME <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706125113658.png" alt="image-20220706125113658"></p><p>使用上了索引，即使是左模糊查询</p><p>加上了索引不在的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id,age,NAME,classId <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706125351116.png" alt="image-20220706125351116"></p><h3 id="8-2-覆盖索引的利弊">8.2 覆盖索引的利弊</h3><p>好处：</p><ol><li><p>避免Innodb表进行索引的二次查询（回表）</p><p>Innodb是以聚集索引的顺序来存储的，对于Innodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。</p><p>在覆盖索引中，二级索引的键值中可以获取所要的数据，<code>避免了对主键的二次查询，减少了I0操作</code>，提升了查询效率。</p></li><li><p>可以把随机IO变成顺序IO加快查询效率</p><p>由于覆盖索引是按键值的顺序存储的，对于I0密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的<code>随机读取的IO</code>转变成索引查找的<code>顺序IO</code>。</p><span class='p green'>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</span></li></ol><p>弊端：</p><p><code>索引字段的维护</code>总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</p><hr><h2 id="9-如何给字符串添加索引">9. 如何给字符串添加索引</h2><p>有一张教师表，表定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(</span><br><span class="line">ID <span class="type">bigint</span> unsigned <span class="keyword">primary</span> key,</span><br><span class="line">email <span class="type">varchar</span>(<span class="number">64</span>),</span><br><span class="line">...</span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure><p>讲师要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> col1, col2 <span class="keyword">from</span> teacher <span class="keyword">where</span> email<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果email这个字段上没有索引，那么这个语句就只能做<code>全表扫描</code>。</p><h3 id="9-1-前缀索引">9.1 前缀索引</h3><p>MySQL是支持前缀索引的。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字 符串。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index1(email);</span><br><span class="line">#或</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> teacher <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>这两种不同的定义在数据结构和存储上有什么区别呢？下图就是这两个索引的示意图。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706130901307.png" alt="image-20220706130901307" style="zoom:50%;" /><p>以及</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706130921934.png" alt="image-20220706130921934" style="zoom: 50%;" /><p><strong>如果使用的是index1</strong>（即email整个字符串的索引结构），执行顺序是这样的：</p><ol><li>从index1索引树找到满足索引值是’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a>’的这条记录，取得ID2的值；</li><li>到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；</li><li>取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足email=’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’的 条件了，循环结束。</li></ol><p>这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</p><p><strong>如果使用的是index2</strong>（即email(6)索引结构），执行顺序是这样的：</p><ol><li>从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；</li><li>到主键上查到主键值是ID1的行，判断出email的值不是’ <a href="mailto:zhangssxyz@xxx.com">zhangssxyz@xxx.com</a> ’，这行记录丢弃；</li><li>取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然 后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。</li></ol><p>也就是说**使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。**前面 已经讲过区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p><h3 id="9-2-前缀索引对覆盖索引的影响">9.2 前缀索引对覆盖索引的影响</h3><blockquote><p>结论： 使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。</p></blockquote><hr><h2 id="10-索引下推">10. 索引下推</h2><h3 id="10-1-使用前后对比">10.1 使用前后对比</h3><p>Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。把本应该在 server 层进行筛选的条件，下推到存储引擎层来进行筛选判断，这样能有效减少回表IO次数。</p><ul><li><p>如果没有ICP，存储引擎会遍历索引以定位基表中的行，并将它们返回给 MySQL服务器，由 MysQL服务器评估<code>WHERE</code>后面的条件是否保留行。</p></li><li><p>启用ICP 后，如果部分<code>WHERE</code>条件可以仅使用索引中的列进行筛选，则 MySQL服务器会把这部分<code>WHERE</code>条件放到存储引擎筛选。然后，存储引擎通过使用索引条目来筛选数据，并且只有在满足这一条件时才从表中读取行。</p><ul><li>好处：ICP可以减少存储引擎必须访问基表的次数和MySQL服务器必须访问存储引擎的次数。</li><li>但是，ICP的<code>加速效果</code>取决于在存储引擎内通过<code>ICP筛选</code>掉的数据的比例。</li></ul></li></ul><h3 id="10-2-ICP的开启-关闭">10.2 ICP的开启/关闭</h3><ul><li>默认情况下启动索引条件下推。可以通过设置系统变量<code>optimizer_switch</code>控制：<code>index_condition_pushdown</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 打开索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=on&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 关闭索引下推</span><br><span class="line"><span class="keyword">SET</span> optimizer_switch <span class="operator">=</span> <span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>当使用索引条件下推是，<code>EXPLAIN</code>语句输出结果中<code>Extra</code>列内容显示为<code>Using index condition</code>。</li></ul><hr><h3 id="10-3-ICP使用案例">10.3 ICP使用案例</h3><p>假设一个表包含有关人员及其地址的信息，并且该表的索引定义为<code>INDEX (zipcode, lastname, firstname)</code>。如果我们知道一个人的<code>zipcode</code>但不确定姓氏，我们可以这样搜索：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> people</span><br><span class="line">  <span class="keyword">WHERE</span> zipcode<span class="operator">=</span><span class="string">&#x27;95054&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> lastname <span class="keyword">LIKE</span> <span class="string">&#x27;%etrunia%&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> address <span class="keyword">LIKE</span> <span class="string">&#x27;%Main Street%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>MySQL可以使用索引扫描zipcode='95054’的用户，第二部分姓氏不能使用索引。因此如果没有索引条件下推，则此查询必须为所有邮政编码为“95054”的人检索完整的行。</p><p>使用索引条件下推，MySQL在读取整个表行之前，在索引中检查姓氏LIKE“%etrunia%”部分。这样可以避免读取与zipcode条件匹配但与lastname条件不匹配的索引元组对应的完整行。</p><h3 id="10-4-IP的使用条件">10.4 IP的使用条件</h3><ol><li>如果表的访问类型为 range 、 ref 、 eq_ref 或者 ref_or_null 可以使用ICP。</li><li>ICP可以使用<code>InnDB</code>和<code>MyISAM</code>表，包括分区表<code>InnoDB</code>和<code>MyISAM</code>表</li><li>对于<code>InnoDB</code>表，ICP仅用于<code>二级索引</code>。ICP的目标是减少全行读取次数，从而减少I/O操作。</li><li>当SQL使用覆盖索引时，不支持ICP优化方法。因为这种情况下使用ICP不会减少I/O。</li><li>相关子查询的条件不能使用ICP</li></ol><hr><h2 id="11-普通索引-vs-唯一索引">11. 普通索引 vs 唯一索引</h2><p>从性能的角度考虑，你选择唯一索引还是普通索引呢？选择的依据是什么呢？</p><p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引，假设字段 k 上的值都不重复。</p><p>这个表的建表语句是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">index (k)</span><br><span class="line">)engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)。</p><h3 id="11-1-查询过程">11.1 查询过程</h3><p>假设，执行查询的语句是 select id from test where k=5。</p><ul><li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一 个不满足k=5条件的记录。</li><li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检 索。</li></ul><p>那么，这个不同带来的性能差距会有多少呢？答案是， 微乎其微 。</p><h3 id="11-2-更新过程">11.2 更新过程</h3><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话， 在不影响数据一致性的前提下，<code>InooDB会将这些更新操作缓存在change buffer中</code>，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了<code>访问这个数据页</code>会触 发merge外，系统有<code>后台线程会定期</code>merge。在<code>数据库正常关闭（shutdown）</code>的过程中，也会执行merge 操作。</p><p>如果能够将更新操作先记录在change buffer，<code>减少读磁盘</code>，语句的执行速度会得到明显的提升。而且， 数据读入内存是需要占用 buffer pool 的，所以这种方式还能够<code>避免占用内存</code>，提高内存利用率。</p><p><code>唯一索引的更新就不能使用change buffer</code>，实际上也只有普通索引可以使用。</p><p>如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的？</p><h3 id="11-3-change-buffer的使用场景">11.3 change buffer的使用场景</h3><ol><li>普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是 对 更新性能 的影响。所以，建议你 尽量选择普通索引 。</li><li>在实际使用中会发现， 普通索引 和 change buffer 的配合使用，对于 数据量大 的表的更新优化 还是很明显的。</li><li>如果所有的更新后面，都马上 伴随着对这个记录的查询 ，那么你应该 关闭change buffer 。而在 其他情况下，change buffer都能提升更新性能。</li><li>由于唯一索引用不上change buffer的优化机制，因此如果 业务可以接受 ，从性能角度出发建议优 先考虑非唯一索引。但是如果&quot;业务可能无法确保&quot;的情况下，怎么处理呢？<ul><li>首先， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能 问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。 这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一 个排查思路。</li><li>然后，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年， 然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率， 可以考虑把表里面的唯一索引改成普通索引。</li></ul></li></ol><hr><h2 id="12-其它查询优化策略">12. 其它查询优化策略</h2><h3 id="1-EXISTS-和-IN-的区分">.1 EXISTS 和 IN 的区分</h3><p><strong>问题：</strong></p><p>不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？</p><p><strong>回答：</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706141957185.png" alt="image-20220706141957185" style="zoom:80%;float:right" /><h3 id="12-2-COUNT-与COUNT-具体字段-效率">12.2 COUNT(*)与COUNT(具体字段)效率</h3><p>问：在 MySQL 中统计数据表的行数，可以使用三种方式： SELECT COUNT(*) 、 SELECT COUNT(1) 和 SELECT COUNT(具体字段) ，使用这三者之间的查询效率是怎样的？</p><p>答：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706142648452.png" alt="image-20220706142648452" style="zoom:80%;float:right" /><h3 id="12-3-关于SELECT">12.3 关于SELECT(*)</h3><p>在表查询中，建议明确字段，不要使用 * 作为查询的字段列表，推荐使用SELECT &lt;字段列表&gt; 查询。原因：</p><p>① MySQL 在解析的过程中，会通过查询数据字典 将&quot;*&quot;按序转换成所有列名，这会大大的耗费资源和时间。</p><p>② 无法使用 覆盖索引</p><h3 id="12-4-LIMIT-1-对优化的影响">12.4 LIMIT 1 对优化的影响</h3><p>针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上 LIMIT 1 了。</p><h3 id="12-5-多使用COMMIT">12.5 多使用COMMIT</h3><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放 的资源而减少。</p><p>COMMIT 所释放的资源：</p><ul><li>回滚段上用于恢复数据的信息</li><li>被程序语句获得的锁</li><li>redo / undo log buffer 中的空间</li><li>管理上述 3 种资源中的内部花费</li></ul><hr><h2 id="13-淘宝数据库主键如何设计？">13. 淘宝数据库主键如何设计？</h2><p>聊一个实际问题：淘宝的数据库，主键是如何设计的？</p><p>某些错的离谱的答案还在网上年复一年的流传着，甚至还成为了所谓的MySQL军规。其中，一个最明显的错误就是关于MySQL的主键设计。</p><p>大部分人的回答如此自信：用8字节的 BIGINT 做主键，而不要用INT。<code>错</code>！</p><p>这样的回答，只站在了数据库这一层，而没有<code>从业务的角度</code>思考主键。主键就是一个自增ID吗？站在 2022年的新年档口，用自增做主键，架构设计上可能<code>连及格都拿不到</code>。</p><h3 id="13-1-自增ID的问题">13.1 自增ID的问题</h3><p>自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自有所不同而已。自增ID除 了简单，其他都是缺点，总体来看存在以下几方面的问题：</p><ol><li><p><strong>可靠性不高</strong></p><p>存在自增ID回溯的问题，这个问题直到最新版本的MySQL 8.0才修复。</p></li><li><p>**安全性不高 **</p><p>对外暴露的接口可以非常容易猜测对应的信息。比如：/User/1/这样的接口，可以非常容易猜测用户ID的 值为多少，总用户数量有多少，也可以非常容易地通过接口进行数据的爬取。</p></li><li><p><strong>性能差</strong></p><p>自增ID的性能较差，需要在数据库服务器端生成。</p></li><li><p><strong>交互多</strong></p><p>业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的 网络交互。在海量并发的系统中，多1条SQL，就多一次性能上的开销。</p></li><li><p>**局部唯一性 **</p><p>最重要的一点，自增ID是局部唯一，只在当前数据库实例中唯一，而不是全局唯一，在任意服务器间都 是唯一的。对于目前分布式系统来说，这简直就是噩梦。</p></li></ol><h3 id="13-2-业务字段做主键">13.2 业务字段做主键</h3><p>为了能够唯一地标识一个会员的信息，需要为 会员信息表 设置一个主键。那么，怎么为这个表设置主 键，才能达到我们理想的目标呢？ 这里我们考虑业务字段做主键。</p><p>表数据如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706151506580.png" alt="image-20220706151506580"></p><p>在这个表里，哪个字段比较合适呢？</p><ul><li><strong>选择卡号（cardno）</strong></li></ul><p>会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员 记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> demo.membermaster</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> (</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> cardno <span class="type">CHAR</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY, <span class="comment">-- 会员卡号为主键</span></span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> membername TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberphone TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberpid TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> memberaddress TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> sex TEXT,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> birthday DATETIME</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure><p>不同的会员卡号对应不同的会员，字段“cardno”唯一地标识某一个会员。如果都是这样，会员卡号与会员一一对应，系统是可以正常运行的。</p><p>但实际情况是， 会员卡号可能存在重复使用的情况。比如，张三因为工作变动搬离了原来的地址，不再 到商家的门店消费了 （退还了会员卡），于是张三就不再是这个商家门店的会员了。但是，商家不想让 这个会 员卡空着，就把卡号是“10000001”的会员卡发给了王五。</p><p>从系统设计的角度看，这个变化只是修改了会员信息表中的卡号是“10000001”这个会员 信息，并不会影 响到数据一致性。也就是说，修改会员卡号是“10000001”的会员信息， 系统的各个模块，都会获取到修 改后的会员信息，不会出现“有的模块获取到修改之前的会员信息，有的模块获取到修改后的会员信息， 而导致系统内部数据不一致”的情况。因此，从 信息系统层面 上看是没问题的。</p><p>但是从使用 系统的业务层面 来看，就有很大的问题 了，会对商家造成影响。</p><p>比如，我们有一个销售流水表（trans），记录了所有的销售流水明细。2020 年 12 月 01 日，张三在门店 购买了一本书，消费了 89 元。那么，系统中就有了张三买书的流水记录，如下所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706151715106.png" alt="image-20220706151715106"></p><p>接着，我们查询一下 2020 年 12 月 01 日的会员销售记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber<span class="operator">=</span>c.itemnumber);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> membername <span class="operator">|</span> goodsname <span class="operator">|</span> quantity <span class="operator">|</span> salesvalue <span class="operator">|</span> transdate <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span>     张三   <span class="operator">|</span> 书         <span class="operator">|</span> <span class="number">1.000</span>    <span class="operator">|</span> <span class="number">89.00</span>      <span class="operator">|</span> <span class="number">2020</span><span class="number">-12</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>如果会员卡“10000001”又发给了王五，我们会更改会员信息表。导致查询时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> b.membername,c.goodsname,a.quantity,a.salesvalue,a.transdate</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> demo.trans <span class="keyword">AS</span> a</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.membermaster <span class="keyword">AS</span> b</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">JOIN</span> demo.goodsmaster <span class="keyword">AS</span> c</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> (a.cardno <span class="operator">=</span> b.cardno <span class="keyword">AND</span> a.itemnumber<span class="operator">=</span>c.itemnumber);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> membername <span class="operator">|</span> goodsname <span class="operator">|</span> quantity <span class="operator">|</span> salesvalue <span class="operator">|</span> transdate <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="operator">|</span> 王五        <span class="operator">|</span> 书        <span class="operator">|</span> <span class="number">1.000</span>    <span class="operator">|</span> <span class="number">89.00</span>      <span class="operator">|</span> <span class="number">2020</span><span class="number">-12</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+-----------+----------+------------+---------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>这次得到的结果是：王五在 2020 年 12 月 01 日，买了一本书，消费 89 元。显然是错误的！结论：千万 不能把会员卡号当做主键。</p><ul><li><strong>选择会员电话 或 身份证号</strong></li></ul><p>会员电话可以做主键吗？不行的。在实际操作中，手机号也存在 被运营商收回 ，重新发给别人用的情况。</p><p>那身份证号行不行呢？好像可以。因为身份证决不会重复，身份证号与一个人存在一一对 应的关系。可 问题是，身份证号属于 个人隐私 ，顾客不一定愿意给你。要是强制要求会员必须登记身份证号，会把很 多客人赶跑的。其实，客户电话也有这个问题，这也是我们在设计会员信息表的时候，允许身份证号和 电话都为空的原因。</p><p><strong>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测 在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</strong></p><blockquote><p>经验： 刚开始使用 MySQL 时，很多人都很容易犯的错误是喜欢用业务字段做主键，想当然地认为了解业 务需求，但实际情况往往出乎意料，而更改主键设置的成本非常高。</p></blockquote><h3 id="13-3-淘宝的主键设计">13.3 淘宝的主键设计</h3><p>在淘宝的电商业务中，订单服务是一个核心业务。请问，订单表的主键淘宝是如何设计的呢？是自增ID 吗？</p><p>打开淘宝，看一下订单信息：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706161436920.png" alt="image-20220706161436920"></p><p>从上图可以发现，订单号不是自增ID！我们详细看下上述4个订单号：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1550672064762308113</span></span><br><span class="line"><span class="number">1481195847180308113</span></span><br><span class="line"><span class="number">1431156171142308113</span></span><br><span class="line"><span class="number">1431146631521308113</span></span><br></pre></td></tr></table></figure><p>订单号是19位的长度，且订单的最后5位都是一样的，都是08113。且订单号的前面14位部分是单调递增的。</p><p>大胆猜测，淘宝的订单ID设计应该是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">订单ID <span class="operator">=</span> 时间 <span class="operator">+</span> 去重字段 <span class="operator">+</span> 用户ID后<span class="number">6</span>位尾号</span><br></pre></td></tr></table></figure><p>这样的设计能做到全局唯一，且对分布式系统查询及其友好。</p><h3 id="13-4-推荐的主键设计">13.4 推荐的主键设计</h3><p><strong>非核心业务</strong> ：对应表的主键自增ID，如告警、日志、监控等信息。</p><p><strong>核心业务</strong> ：<code>主键设计至少应该是全局唯一且是单调递增</code>。全局唯一保证在各系统之间都是唯一的，单调 递增是希望插入时不影响数据库性能。</p><p>这里推荐最简单的一种主键设计：UUID。</p><p><strong>UUID的特点：</strong></p><p>全局唯一，占用36字节，数据无序，插入性能差。</p><p><strong>认识UUID：</strong></p><ul><li>为什么UUID是全局唯一的？</li><li>为什么UUID占用36个字节？</li><li>为什么UUID是无序的？</li></ul><p>MySQL数据库的UUID组成如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID <span class="operator">=</span> 时间<span class="operator">+</span>UUID版本（<span class="number">16</span>字节）<span class="operator">-</span> 时钟序列（<span class="number">4</span>字节） <span class="operator">-</span> MAC地址（<span class="number">12</span>字节）</span><br></pre></td></tr></table></figure><p>我们以UUID值e0ea12d4-6473-11eb-943c-00155dbaa39d举例：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706162131362.png" alt="image-20220706162131362"></p><p><code>为什么UUID是全局唯一的？</code></p><p>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00 到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降 低到1/100ns。</p><p>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。</p><p><code>为什么UUID占用36个字节？</code></p><p>UUID根据字符串进行存储，设计时还带有无用&quot;-&quot;字符串，因此总共需要36个字节。</p><p><code>为什么UUID是随机无序的呢？</code></p><p>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p><p><strong>改造UUID</strong></p><p>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。</p><p>MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的&quot;-&quot;字符串，并且将字符串用二进制类型保存，这样存储空间降低为了16字节。</p><p>可以通过MySQL8.0提供的uuid_to_bin函数实现上述功能，同样的，MySQL也提供了bin_to_uuid函数进行转化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@uuid</span> <span class="operator">=</span> UUID();</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@uuid</span>,uuid_to_bin(<span class="variable">@uuid</span>),uuid_to_bin(<span class="variable">@uuid</span>,<span class="literal">TRUE</span>);</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706162657448.png" alt="image-20220706162657448"></p><p><strong>通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID了</strong>。全局唯一 + 单调递增，这不就是我们想要的主键！</p><p><strong>有序UUID性能测试</strong></p><p>16字节的有序UUID，相比之前8字节的自增ID，性能和存储空间对比究竟如何呢？</p><p>我们来做一个测试，插入1亿条数据，每条数据占用500字节，含有3个二级索引，最终的结果如下所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220706162947613.png" alt="image-20220706162947613" style="zoom:67%;" /><p>从上图可以看到插入1亿条数据有序UUID是最快的，而且在实际业务使用中有序UUID在<code>业务端就可以生成</code>。还可以进一步减少SQL的交互次数。</p><p>另外，虽然有序UUID相比自增ID多了8个字节，但实际只增大了3G的存储空间，还可以接受。</p><blockquote><p>在当今的互联网环境中，非常不推荐自增ID作为主键的数据库设计。更推荐类似有序UUID的全局 唯一的实现。</p><p>另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样 的主键设计就更为考验架构师的水平了。</p></blockquote><p><strong>如果不是MySQL8.0 肿么办？</strong></p><p>手动赋值字段做主键！</p><p>比如，设计各个分店的会员表的主键，因为如果每台机器各自产生的数据需要合并，就可能会出现主键重复的问题。</p><p>可以在总部 MySQL 数据库中，有一个管理信息表，在这个表中添加一个字段，专门用来记录当前会员编号的最大值。</p><p>门店在添加会员的时候，先到总部 MySQL 数据库中获取这个最大值，在这个基础上加1，然后用这个值作为新会员的“id”，同时，更新总部 MySQL 数据库管理信息表中的当前会员编号的最大值。</p><p>这样一来，各个门店添加会员的时候，都对同一个总部 MySQL 数据库中的数据表字段进行操作，就解决了各门店添加会员时会员编号冲突的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找指定位置-二分法</title>
      <link href="/posts/c1110203.html"/>
      <url>/posts/c1110203.html</url>
      
        <content type="html"><![CDATA[<h2 id="704-二分查找">704. 二分查找</h2><div class="tag link"><a class="link-card" title="704. 二分查找" href="https://leetcode.cn/problems/binary-search/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">704. 二分查找</p><p class="url">https://leetcode.cn/problems/binary-search/</p></div></a></div><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9     </span><br><span class="line">输出: 4       </span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4     </span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2     </span><br><span class="line">输出: -1        </span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1        </span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><hr><h3 id="思路">思路</h3><p>这道题目的前提是数组为<span class='p blue'>有序数组</span>，同时题目还强调数组中<span class='p blue'>无重复元素</span>，<span class='p red'>因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的</span>，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是<code>while(left &lt; right)</code>还是<code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，<code>区间的定义就是不变量</code>。要在二分查找的过程中，<span class='p green'>保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。</span></p><p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>下面我用这两种区间的定义分别讲解两种不同的二分写法。</p><hr><h3 id="两种写法">两种写法</h3><div class="tabs" id="062a674c-72e9-4da3-a22b-0dedcc400f23"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#062a674c-72e9-4da3-a22b-0dedcc400f23-1"><i class="fas fa-cat"></i>左闭右闭</button></li><li class="tab"><button type="button" data-href="#062a674c-72e9-4da3-a22b-0dedcc400f23-2"><i class="fas fa-horse"></i>左闭右开</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="062a674c-72e9-4da3-a22b-0dedcc400f23-1"><blockquote><p>left：0</p><p>right：nums.length - 1</p></blockquote><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，也就是[left, right] （这个很重要非常重要）。</p><p>区间的定义这就决定了二分法的代码应该如何写，因为定义target在[left, right]区间，所以有如下两点：</p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left,right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;     <span class="comment">//当left==right，区间[left,right]依然有效，所以用&lt;=</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;         <span class="comment">//数组中找到目标值，直接返回下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;     <span class="comment">//target 在右区间，所以[mid+1,right]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;   <span class="comment">//target 在左区间，所以[left,mid-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="062a674c-72e9-4da3-a22b-0dedcc400f23-2"><blockquote><p>left：0</p><p>right：nums.length</p></blockquote><p>如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;   <span class="comment">// 定义target在左闭右开的区间里，即[left,right)</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;     <span class="comment">// 因为left == right的时候，在[left,right)是无效的区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;        <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;    <span class="comment">// target 在右区间，在[mid+1, right)中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid;       <span class="comment">// target 在左区间，在[left，mid)中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能分析工具的使用</title>
      <link href="/posts/2678f2d3.html"/>
      <url>/posts/2678f2d3.html</url>
      
        <content type="html"><![CDATA[<p>在数据库调优中，我们的目标是<code>响应时间更快, 吞吐量更大</code>。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。</p><h2 id="1-数据库服务器的优化步骤">1. 数据库服务器的优化步骤</h2><p>当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。</p><p>整个流程划分成了<code>观察（Show status）</code>和<code>行动（Action）</code>两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</p><div class="tabs" id="791ab877-575f-4606-8648-c45807e777a1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#791ab877-575f-4606-8648-c45807e777a1-1"><i class="fas fa-cat"></i>流程图</button></li><li class="tab"><button type="button" data-href="#791ab877-575f-4606-8648-c45807e777a1-2"><i class="fas fa-horse"></i>解析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="791ab877-575f-4606-8648-c45807e777a1-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%B5%81%E7%A8%8B%E5%9B%BE%20(2).jpg" alt="流程图 (2)" style="zoom:45%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="791ab877-575f-4606-8648-c45807e777a1-2"><p>首先在 S1 部分，我们需要观察服务器的状态是否<code>存在周期性的波动</code>。如果存在周期性波动，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过A1 这一步骤解决，也就是加缓存，或者更改缓存失效策略。</p><p>如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步<code>分析查询延迟和卡顿的原因</code>。接下来进入 s2这一步，我们需要开启慢查询。慢查询可以帮我们定位执行慢的 SQL语句。我们可以通过设置<code>long_query-time</code>参数定义“慢”的阈值，如果 SQL执行时间超过了 long_query_time，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p><p>在S3 这一步骤中，我们就知道了执行慢的 SQL，这样就可以针对性地用<code>EXPLAIN</code>查看对应 SQL语句的执行计划，或者使用<code>show profile</code>查看 SQL中每一个步骤的时间成本。这样我们就可以了解 SQL 查询慢是因为执行时间长，还是等待时间长。</p><p>如果是 SQL等待时间长，我们进入A2 步骤。在这一步骤中，我们可以<code>调优服务器的参数</code>，比如适当增加数据库缓冲池等。如果是SQL执行时间长，就进入A3 步骤，这一步中我们需要考虑是索引设计的问题？还是查询关联的数据表过多？还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。</p><p>如果 A2 和 A3 都不能解决问题，我们需要考虑数据库自身的 SQL 查询性能是否已经达到了瓶颈，如果确认没有达到性能瓶颈，就需要重新检查，重复以上的步骤。如果已经达到了<code>性能瓶颈</code>，进入A4 阶段，需要考虑<code>增加服务器</code>，采用<code>读写分离</code>的架构，或者考虑对数据库进行<code>分库分表</code>，比如垂直分库、垂直分表和水平分表等，</p><p>以上就是数据库调优的流程思路。如果我们发现执行 SQL时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的 SQL，这三种分析工具你可以理解是 SQL 调优的三个步骤：<code>慢查询</code>、<code>EXPLAIN</code>和<code>SHOW PROFILING</code>。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230410153919452.png" alt="image-20230410153919452" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p><hr><h2 id="2-查看系统性能参数">2. 查看系统性能参数</h2><p>在MySQL中，可以使用<code>SHOW STATUS</code>语句查询一些MySQL数据库服务器的<code>性能参数、执行频率</code>。</p><p>SHOW STATUS语句语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span>;</span><br></pre></td></tr></table></figure><p>一些常用的性能参数如下：</p><ul><li>Connections：连接MySQL服务器的次数。</li><li>Uptime：MySQL服务器的上线时间。</li><li>Slow_queries：慢查询的次数。</li><li>Innodb_rows_read：Select查询返回的行数</li><li>Innodb_rows_inserted：执行INSERT操作插入的行数</li><li>Innodb_rows_updated：执行UPDATE操作更新的 行数</li><li>Innodb_rows_deleted：执行DELETE操作删除的行数</li><li>Com_select：查询操作的次数。</li><li>Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。</li><li>Com_update：更新操作 的次数。</li><li>Com_delete：删除操作的次数。</li></ul><p>若查询MySQL服务器的连接次数，则可以执行如下语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Connections&#x27;</span>;</span><br></pre></td></tr></table></figure><p>若查询服务器工作时间，则可以执行如下语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Uptime&#x27;</span>;</span><br></pre></td></tr></table></figure><p>若查询MySQL服务器的慢查询次数，则可以执行如下语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Slow_queries&#x27;</span>;</span><br></pre></td></tr></table></figure><p>慢查询次数参数可以结合慢查询日志找出慢查询语句，然后针对慢查询语句进行<code>表结构优化</code>或者<code>查询语句优化</code>。</p><p>再比如，如下的指令可以查看相关的指令情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="3-统计SQL的查询成本">3. 统计SQL的查询成本</h2><p>一条SQL查询语句在执行前需要查询执行计划，如果存在多种执行计划的话，MySQL会计算每个执行计划所需要的成本，从中选择<code>成本最小</code>的一个作为最终执行的执行计划。</p><p>如果我们想要查看某条SQL语句的查询成本，可以在执行完这条SQL语句之后，通过查看当前会话中的<code>last_query_cost</code>变量值来得到当前查询的成本。它通常也是我们<code>评价一个查询的执行效率</code>的一个常用指标。这个查询成本对应的是<code>SQL语句所需要读取的读页的数量</code>。</p><p>我们依然使用第8章的 student_info 表为例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`student_info`(</span><br><span class="line">  `id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `student_id`<span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  `name`<span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `course_id`<span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  `class_id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time`DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>如果我们想要查询 id=900001 的记录，然后看下查询成本，我们可以直接在聚簇索引上进行查找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">900001</span>;</span><br></pre></td></tr></table></figure><p>运行结果（1 条记录，运行时间为 0.042s ）</p><p>然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span>   <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">1.000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+----------+</span></span><br></pre></td></tr></table></figure><p>如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student_id, class_id, NAME, create_time <span class="keyword">FROM</span> student_info <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">900001</span> <span class="keyword">AND</span> <span class="number">900100</span>;</span><br></pre></td></tr></table></figure><p>运行结果（100 条记录，运行时间为 0.046s ）：</p><p>然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span>   <span class="keyword">Value</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Last_query_cost <span class="operator">|</span> <span class="number">21.134453</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-----------+</span></span><br></pre></td></tr></table></figure><p>你能看到页的数量是刚才的 20 倍，但是查询的效率并没有明显的变化，实际上这两个 SQL 查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然页数量（last_query_cost）增加了不少 ，但是通过缓冲池的机制，并没有增加多少查询时间 。</p><p>使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。</p><blockquote><p>SQL查询时一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p><p>1.<code>位置决定效率</code>。如果页就在数据库<code>缓冲池</code>中，那么效率是最高的，否则还需要从<code>内存</code>或者<code>磁盘</code>中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。<br>2.<code>批量决定效率</code>。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</p><p>所以说，遇到I/O并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是进程使用的数据就要尽量放到<code>缓冲池</code>中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p></blockquote><hr><h2 id="4-定位执行慢的SQL-慢查询日志">4. 定位执行慢的SQL:慢查询日志</h2><p>MySQL的慢查询日志，用来记录在MysQL中<code>响应时间超过阀值</code>的语句，具体指运行时间超过<code>long_query_time</code>值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上（不含10秒）的语句，认为是超出了我们的最大忍耐时间值。</p><p>它的主要作用是，帮助我们发现那些执行时间特别长的 SQL 查询，并且有针对性地进行优化，从而提高系统的整体效率，当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。</p><p>默认情况下，MysQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<span class='p red'>如果不是调优需要的话，一般不建议启动该参数</span>，因为开启慢查询日志会或多或少带来一定的性能影响。</p><p>慢查询日志支持将日志记录写入文件。</p><h3 id="4-1-开启慢查询日志参数">4.1 开启慢查询日志参数</h3><div class="tabs" id="32e2ffd3-dd35-4b1d-b933-c314ce9033f8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#32e2ffd3-dd35-4b1d-b933-c314ce9033f8-1"><i class="fas fa-award"></i>1. 开启 slow_query_log</button></li><li class="tab"><button type="button" data-href="#32e2ffd3-dd35-4b1d-b933-c314ce9033f8-2"><i class="fas fa-baseball-ball"></i>2. 修改 long_query_time 阈值</button></li><li class="tab"><button type="button" data-href="#32e2ffd3-dd35-4b1d-b933-c314ce9033f8-3"><i class="fas fa-bone"></i>补充：配置文件中一并设置参数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="32e2ffd3-dd35-4b1d-b933-c314ce9033f8-1"><p>在使用前，我们需要先查下慢查询是否已经开启，使用下面这条命令即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628173525966.png" alt="image-20220628173525966" style="zoom:67%;" /><p>我们可以看到<code>slow_query_log=OFF</code>，我们可以把慢查询日志打开，注意设置变量值的时候需要使用 global，否则会报错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628175226812.png" alt="image-20220628175226812" style="zoom:67%;" /><p>你能看到这时慢查询分析已经开启，同时文件保存在<code>/var/lib/mysql/atguigu02-slow.log</code>文件 中。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="32e2ffd3-dd35-4b1d-b933-c314ce9033f8-2"><p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628175353233.png" alt="image-20220628175353233" /><p>这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#测试发现：设置<span class="keyword">global</span>的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> long_query_time<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628175425922.png" alt="image-20220628175425922"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="32e2ffd3-dd35-4b1d-b933-c314ce9033f8-3"><p>如下的方式相较于前面的命令行方式，可以看做是永久设置的方式。</p><p>修改<code>my.cnf</code>文件，[mysqld] 下增加或修改参数<code>long_query_time、slow_query_log</code>和<code>slow_query_log_file</code>后，然后重启 MySQL 服务器。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">ON  # 开启慢查询日志开关</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">/var/lib/mysql/atguigu-low.log  # 慢查询日志的目录和文件名信息</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">3  # 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">FILE</span></span><br></pre></td></tr></table></figure><p>如果不指定存储路径，慢查询日志默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname_slow.log。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="4-2-查看慢查询数目">4.2 查看慢查询数目</h3><p>查询当前系统中有多少条慢查询记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-3-数据准备">4.3 数据准备</h3><div class="tabs" id="2a49e976-417f-4a18-9661-b7964a9e92a9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2a49e976-417f-4a18-9661-b7964a9e92a9-1"><i class="fas fa-bug"></i>步骤1</button></li><li class="tab"><button type="button" data-href="#2a49e976-417f-4a18-9661-b7964a9e92a9-2"><i class="fas fa-cannabis"></i>步骤2</button></li><li class="tab"><button type="button" data-href="#2a49e976-417f-4a18-9661-b7964a9e92a9-3"><i class="fas fa-candy-cane"></i>步骤3</button></li><li class="tab"><button type="button" data-href="#2a49e976-417f-4a18-9661-b7964a9e92a9-4"><i class="fas fa-child"></i>步骤4</button></li><li class="tab"><button type="button" data-href="#2a49e976-417f-4a18-9661-b7964a9e92a9-5"><i class="fab fa-apple"></i>步骤5</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2a49e976-417f-4a18-9661-b7964a9e92a9-1"><blockquote><p>建表</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`student`(</span><br><span class="line">  `id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `stuno`<span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">  `name`<span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age`<span class="type">INT</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `classId`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2a49e976-417f-4a18-9661-b7964a9e92a9-2"><blockquote><p>设置参数 log_bin_trust_function_creators</p></blockquote><p>创建函数，假如报错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> DETERMINISTIC......</span><br></pre></td></tr></table></figure><ul><li>命令开启：允许创建函数设置：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; # 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2a49e976-417f-4a18-9661-b7964a9e92a9-3"><blockquote><p>创建函数</p></blockquote><p>随机产生字符串：（同上一章）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">    <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line"><span class="keyword">SELECT</span> rand_string(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>产生随机数值：（同上一章）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#测试：</span><br><span class="line"><span class="keyword">SELECT</span> rand_num(<span class="number">10</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2a49e976-417f-4a18-9661-b7964a9e92a9-4"><blockquote><p>创建存储过程</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu1( <span class="keyword">START</span> <span class="type">INT</span> , max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student (stuno, NAME ,age ,classId ) <span class="keyword">VALUES</span></span><br><span class="line">    ((<span class="keyword">START</span><span class="operator">+</span>i),rand_string(<span class="number">6</span>),rand_num(<span class="number">10</span>,<span class="number">100</span>),rand_num(<span class="number">10</span>,<span class="number">1000</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2a49e976-417f-4a18-9661-b7964a9e92a9-5"><blockquote><p>调用存储过程</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#调用刚刚写好的函数, <span class="number">4000000</span>条记录,从<span class="number">100001</span>号开始</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> insert_stu1(<span class="number">100001</span>,<span class="number">4000000</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="4-4-测试及分析">4.4 测试及分析</h3><div class="tabs" id="95731a00-674d-47b5-8c8e-b1b83e31e576"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#95731a00-674d-47b5-8c8e-b1b83e31e576-1"><i class="fas fa-seedling"></i>测试</button></li><li class="tab"><button type="button" data-href="#95731a00-674d-47b5-8c8e-b1b83e31e576-2"><i class="fas fa-leaf"></i>分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="95731a00-674d-47b5-8c8e-b1b83e31e576-1"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stuno <span class="operator">=</span> <span class="number">3455655</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span>   id    <span class="operator">|</span>  stuno  <span class="operator">|</span>  name  <span class="operator">|</span> age  <span class="operator">|</span> classId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3523633</span> <span class="operator">|</span> <span class="number">3455655</span> <span class="operator">|</span> oQmLUr <span class="operator">|</span>  <span class="number">19</span>  <span class="operator">|</span>    <span class="number">39</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">2.09</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;oQmLUr&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span>   id    <span class="operator">|</span>  stuno  <span class="operator">|</span>  name  <span class="operator">|</span>  age <span class="operator">|</span> classId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1154002</span> <span class="operator">|</span> <span class="number">1243200</span> <span class="operator">|</span> OQMlUR <span class="operator">|</span> <span class="number">266</span>  <span class="operator">|</span>   <span class="number">28</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1405708</span> <span class="operator">|</span> <span class="number">1437740</span> <span class="operator">|</span> OQMlUR <span class="operator">|</span> <span class="number">245</span>  <span class="operator">|</span>   <span class="number">439</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1748070</span> <span class="operator">|</span> <span class="number">1680092</span> <span class="operator">|</span> OQMlUR <span class="operator">|</span> <span class="number">240</span>  <span class="operator">|</span>   <span class="number">414</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2119892</span> <span class="operator">|</span> <span class="number">2051914</span> <span class="operator">|</span> oQmLUr <span class="operator">|</span> <span class="number">17</span>   <span class="operator">|</span>   <span class="number">32</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2893154</span> <span class="operator">|</span> <span class="number">2825176</span> <span class="operator">|</span> OQMlUR <span class="operator">|</span> <span class="number">245</span>  <span class="operator">|</span>   <span class="number">435</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3523633</span> <span class="operator">|</span> <span class="number">3455655</span> <span class="operator">|</span> oQmLUr <span class="operator">|</span> <span class="number">19</span>   <span class="operator">|</span>   <span class="number">39</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+---------+--------+------+---------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">2.39</span> sec)</span><br></pre></td></tr></table></figure><p>从上面的结果可以看出来，查询学生编号为“3455655”的学生信息花费时间为2.09秒。查询学生姓名为 “oQmLUr”的学生信息花费时间为2.39秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面的小节我们分析一下原因。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="95731a00-674d-47b5-8c8e-b1b83e31e576-2"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;slow_queries&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628195650079.png" alt="image-20220628195650079" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="4-5-慢查询日志分析工具">4.5 慢查询日志分析工具</h3><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具<code>mysqldumpslow</code>。</p><p>查看mysqldumpslow的帮助信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">--help</span></span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628195821440.png" alt="image-20220628195821440"  /><p>mysqldumpslow 命令的具体参数如下：</p><ul><li>-a: 不将数字抽象成N，字符串抽象成S</li><li>-s: 是表示按照何种方式排序：<ul><li>c: 访问次数</li><li>l: 锁定时间</li><li>r: 返回记录</li><li>t: 查询时间</li><li>al:平均锁定时间</li><li>ar:平均返回记录数</li><li>at:平均查询时间 （默认方式）</li><li>ac:平均查询次数</li></ul></li><li>-t: 即为返回前面多少条的数据；</li><li>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</li></ul><p>举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s t -t 5 /var/lib/mysql/atguigu01-slow.log</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[root@bogon</span> <span class="string">~]# mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Reading</span> <span class="string">mysql slow query log from /var/lib/mysql/atguigu01-slow.log</span></span><br><span class="line"><span class="attr">Count</span>: <span class="string">1 Time=2.39s (2s) Lock=0.00s (0s) Rows=13.0 (13), root[root]@localhost</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM student WHERE name = &#x27;S&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Count</span>: <span class="string">1 Time=2.09s (2s) Lock=0.00s (0s) Rows=2.0 (2), root[root]@localhost</span></span><br><span class="line"><span class="attr">SELECT</span> <span class="string">* FROM student WHERE stuno = N</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Died</span> <span class="string">at /usr/bin/mysqldumpslow line 162, &lt;&gt; chunk 2.</span></span><br></pre></td></tr></table></figure><p><strong>工作常用参考：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#得到返回记录集最多的10个SQL</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s r -t 10 /var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s c -t 10 /var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s t -t 10 -g &quot;right join&quot; /var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line"><span class="attr">mysqldumpslow</span> <span class="string">-s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span></span><br></pre></td></tr></table></figure><h3 id="4-6-关闭慢查询日志">4.6 关闭慢查询日志</h3><p>MySQL服务器停止慢查询日志功能有两种方法：</p><p><strong>方式1：永久性方式</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">OFF</span></span><br></pre></td></tr></table></figure><p>或者，把slow_query_log一项注释掉 或 删除</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment">#slow_query_log =OFF</span></span><br></pre></td></tr></table></figure><p>重启MySQL服务，执行如下语句查询慢日志功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>; #查询慢查询日志所在目录</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>; #查询超时时长</span><br></pre></td></tr></table></figure><p><strong>方式2：临时性方式</strong></p><p>使用SET语句来设置。</p><p>（1）停止MySQL慢查询日志功能，具体SQL语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log<span class="operator">=</span>off;</span><br></pre></td></tr></table></figure><p>（2）<strong>重启MySQL服务</strong>，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow%&#x27;</span>;</span><br><span class="line">#以及</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="4-7-删除慢查询日志">4.7 删除慢查询日志</h3><p>使用SHOW语句显示慢查询日志信息，具体SQL语句如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span>`slow_query_log<span class="operator">%</span>`;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628203545536.png" alt="image-20220628203545536" /><p>从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下<code>手动删除慢查询日志文件</code>即可。</p><p>使用命令<code>mysqladmin flush-logs</code>来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mysqladmin</span> <span class="string">-uroot -p flush-logs slow</span></span><br></pre></td></tr></table></figure><blockquote><p>提示</p><p>慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p></blockquote><hr><h2 id="5-查看SQL执行成本-PROFILE">5. 查看SQL执行成本:PROFILE</h2><p>show profile 是 MySQL 提供的可以用来分析当前会话中 SQL 都做了什么、执行的资源消耗工具的情况，可用于 sql 调优的测量。<code>默认情况下处于关闭状态</code>，并保存最近15次的运行结果。</p><p>我们可以在会话级别开启这个功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628204922556.png" alt="image-20220628204922556"  /><p>通过设置 profiling=‘ON’ 来开启 show profile:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628205029208.png" alt="image-20220628205029208" style="zoom:80%;" /><p>然后执行相关的查询语句。接着看下当前会话都有哪些 profiles，使用下面这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628205243769.png" alt="image-20220628205243769" style="zoom:80%;" /><p>你能看到当前会话一共有 2 个查询。如果我们想要查看最近一次查询的开销，可以使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">show</span> profile;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628205317257.png" alt="image-20220628205317257"  /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">2</span></span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628205354230.png" alt="image-20220628205354230"  /><p>show profile的常用查询参数：</p><p>① ALL：显示所有的开销信息。</p><p>② BLOCK IO：显示块IO开销。</p><p>③ CONTEXT SWITCHES：上下文切换开销。</p><p>④ CPU：显示CPU开销信息。</p><p>⑤ IPC：显示发送和接收开销信息。</p><p>⑥ MEMORY：显示内存开销信 息。</p><p>⑦ PAGE FAULTS：显示页面错误开销信息。</p><p>⑧ SOURCE：显示和Source_function，Source_file， Source_line相关的开销信息。</p><p>⑨ SWAPS：显示交换次数开销信息。</p><p><strong>日常开发需注意的结论：</strong></p><p>①<code>converting HEAP to MyISAM</code>: 查询结果太大，内存不够，数据往磁盘上搬了。</p><p>②<code>Creating tmp table</code>：创建临时表。先拷贝数据到临时表，用完后再删除临时表。</p><p>③<code>Copying to tmp table on disk</code>：把内存中临时表复制到磁盘上，警惕！</p><p>④<code>locked</code>。</p><p>如果在show profile诊断结果中出现了以上4条结果中的任何一条，则sql语句需要优化。</p><p><strong>注意：</strong></p><p>不过SHOW PROFILE命令将被弃用，我们可以从 information_schema 中的 profiling 数据表进行查看。</p><hr><h2 id="6-分析查询语句-EXPLAIN">6. 分析查询语句:EXPLAIN</h2><span class='p red'>定位了查询慢的 SQL之后，我们就可以使用 EXPLAIN 或 DESCRIBE 工具做针对性的分析查询语句</span>。DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。<p>MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的<code>执行计划</code>（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间）。</p><p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了<code>EXPLAIN</code>语句来帮助我们查看某个查询语句的具体执行计划，大家看懂<code>EXPLAIN</code>语句的各个输出项，可以有针对性的提升我们查询语句的性能。</p><span class='p red'>能做什么？</span><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li><span class='p green'>哪些索引被实际使用</span></li><li>表之间的引用</li><li><span class='p green'>每张表有多少行被优化器查询</span></li></ul><blockquote><span class='p blue'>只是查看执行计划，并没有实际执行</span></blockquote><h3 id="6-1-基本语法">6.1 基本语法</h3><p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_options</span><br></pre></td></tr></table></figure><p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 EXPLAIN ，就像这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>EXPLAIN 语句输出的各个列的作用如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628212049096.png" alt="image-20220628212049096" style="zoom:67%;" /><p>在这里把它们都列出来知识为了描述一个轮廓，让大家有一个大致的印象。</p><hr><h3 id="6-2-数据准备">6.2 数据准备</h3><div class="tabs" id="278ee7fa-8801-4ba2-9168-68be67cc58fe"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#278ee7fa-8801-4ba2-9168-68be67cc58fe-1"><i class="fas fa-atom"></i>步骤1</button></li><li class="tab"><button type="button" data-href="#278ee7fa-8801-4ba2-9168-68be67cc58fe-2"><i class="far fa-sun"></i>步骤2</button></li><li class="tab"><button type="button" data-href="#278ee7fa-8801-4ba2-9168-68be67cc58fe-3"><i class="fas fa-wind"></i>步骤3</button></li><li class="tab"><button type="button" data-href="#278ee7fa-8801-4ba2-9168-68be67cc58fe-4"><i class="fas fa-fire-alt"></i>步骤4</button></li><li class="tab"><button type="button" data-href="#278ee7fa-8801-4ba2-9168-68be67cc58fe-5"><i class="fas fa-dragon"></i>步骤5</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="278ee7fa-8801-4ba2-9168-68be67cc58fe-1"><blockquote><p>建表</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s2 (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">    INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="278ee7fa-8801-4ba2-9168-68be67cc58fe-2"><blockquote><p>设置参数 log_bin_trust_function_creators</p></blockquote><p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; # 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="278ee7fa-8801-4ba2-9168-68be67cc58fe-3"><blockquote><p>创建函数</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string1(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">        <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="278ee7fa-8801-4ba2-9168-68be67cc58fe-4"><blockquote><p>创建存储过程</p></blockquote><p>创建往s1表中插入数据的存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s1 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> s1 <span class="keyword">VALUES</span>(</span><br><span class="line">        (min_num <span class="operator">+</span> i),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建往s2表中插入数据的存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_s2 (<span class="keyword">IN</span> min_num <span class="type">INT</span> (<span class="number">10</span>),<span class="keyword">IN</span> max_num <span class="type">INT</span> (<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    REPEAT</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> s2 <span class="keyword">VALUES</span>(</span><br><span class="line">        (min_num <span class="operator">+</span> i),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        (min_num <span class="operator">+</span> <span class="number">30</span> <span class="operator">*</span> i <span class="operator">+</span> <span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">6</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">5</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>),</span><br><span class="line">        rand_string1(<span class="number">10</span>));</span><br><span class="line">    UNTIL i <span class="operator">=</span> max_num</span><br><span class="line">    <span class="keyword">END</span> REPEAT;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="278ee7fa-8801-4ba2-9168-68be67cc58fe-5"><blockquote><p>调用存储过程</p></blockquote><p>s1表数据的添加：加入1万条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_s1(<span class="number">10001</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>s2表数据的添加：加入1万条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_s2(<span class="number">10001</span>,<span class="number">10000</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="6-3-EXPLAIN各列作用">6.3 EXPLAIN各列作用</h3><p>为了让大家有比较好的体验，我们调整了下<code>EXPLAIN</code>输出列的顺序。</p><div class="tabs" id="3d8c80d0-e512-487e-8c93-0506e90c7af1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-1"><i class="fas fa-bug"></i>table</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-2"><i class="fas fa-cannabis"></i>id</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-3"><i class="fas fa-candy-cane"></i>select_type</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-4"><i class="fas fa-child"></i>partitions</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-5"><i class="fas fa-award"></i>type☆</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-6"><i class="fas fa-baseball-ball"></i>possible_keys和key</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-7"><i class="fas fa-bone"></i>key_len☆</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-8"><i class="fas fa-anchor"></i>ref</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-9"><i class="fas fa-atom"></i>rows☆</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-10"><i class="far fa-sun"></i>filtered</button></li><li class="tab"><button type="button" data-href="#3d8c80d0-e512-487e-8c93-0506e90c7af1-11"><i class="fas fa-wind"></i>Extra☆</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-1"><p>不论我们的查询语句有多复杂，里边儿包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所 以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该 表的表名（有时不是真实的表名字，可能是简称）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628221143339.png" alt="image-20220628221143339"></p><p>这个查询语句只涉及对s1表的单表查询，所以<code>EXPLAIN</code>输出中只有一条记录，其中的table列的值为s1，表明这条记录是用来说明对s1表的单表访问方法的。</p><p>下边我们看一个连接查询的执行计划</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628221414097.png" alt="image-20220628221414097"></p><p>可以看出这个连接查询的执行计划中有两条记录，这两条记录的table列分别是s1和s2，这两条记录用来分别说明对s1表和s2表的访问方法是什么。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-2"><p>我们写的查询语句一般都以 SELECT 关键字开头，比较简单的查询语句里只有一个 SELECT 关键字，比 如下边这个查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line"><span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line"><span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p>但是下边两种情况下在一条查询语句中会出现多个SELECT关键字：</p><ul><li><p><span class='p red'>查询中包含子查询的情况</span></p><p>比如下边这个查询语句就包含两个<code>SELECT</code>关键字:</p></li></ul><p><code>SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2)</code></p><ul><li><p><span class='p red'>查询中包含<code>UNION</code>语句的情况</span></p><p>比如下边这个查询语句中也包含2个<code>SELECT</code>关键字：</p></li></ul><p><code>SELECT * FROM s1 UNION SELECT * FROM s2;</code></p><p><span class='p red'>查询语句中每出现一个<code>SELECT</code>关键字</span>，<span class='p red'>MySQL就会为它分配一个唯一的<code>id</code>值。</span>这个<code>id</code>值就是<code>EXPLAIN</code>语句的第一个列，比如下边这个查询中只有一个 SELECT 关键字，所以<code>EXPLAIN</code>的结果中也就只有一条<code>id</code>列为<code>1</code>的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628222055716.png" alt="image-20220628222055716"></p><p>对于连接查询来说，一个SELECT关键字后边的FROM字句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220628222251309.png" alt="image-20220628222251309"></p><p>可以看到，上述连接查询中参与连接的s1和s2表分别对应一条记录，但是这两条记录对应的<code>id</code>都是1。这里需要大家记住的是，<strong>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的</strong>，出现在前边的表表示<code>驱动表</code>，出现在后面的表表示<code>被驱动表</code>。所以从上边的EXPLAIN输出中我们可以看到，查询优化器准备让s1表作为驱动表，让s2表作为被驱动表来执行查询。</p><p>对于包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的id值，比如这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629165122837.png" alt="image-20220629165122837"></p><p>从输出结果中我们可以看到，s1表在外层查询中，外层查询有一个独立的<code>SELECT</code>关键字，所以第一条记录的<code>id</code>值就是1，s2表在子查询中，子查询有一个<code>独立的SELECT</code>关键字，所以第二条记录的<code>id</code>值就是<code>2</code>。</p><p>但是这里大家需要特别注意，<span class='p red'>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。</span>所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作。  </span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629165603072.png" alt="image-20220629165603072"></p><p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中s1和s2表对应的记录的<code>id</code>值全部是1，这就表明<code>查询优化器将子查询转换为了连接查询</code>。</p><p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值也是没错的，不过还是有点儿特别的东西，比方说下边的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Union</span>去重</span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629165909340.png" alt="image-20220629165909340"></p><p>这个语句的执行计划的第三条记录是什么？为何<code>id</code>值是<code>NULL</code>，而且table列也很奇怪？<code>UNTON</code>！它会把多个查询的结果集合并起来并对结果集中的记录<code>进行去重</code>，怎么去重呢？MySQL使用的是内部的<code>临时表</code>。正如上边的查询计划中所示，UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为<code>&lt;union1,2&gt;</code>的临时表（就是执行计划第三条记录的table列的名称），id为<code>NULL</code>表明这个临时表是为了合并两个查询的结果集而创建的。</p><p>跟UNION对比起来，<code>UNION ALL</code>就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含<code>UNION ALL</code>子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629171138065.png" alt="image-20220629171138065"></p><p><strong>小结:</strong></p><ul><li>id如果相同，可以认为是一组，从上往下顺序执行</li><li>在所有组中，id值越大，优先级越高，越先执行</li><li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-3"><p>一条大的查询语句里边可以包含若干个SELECT关键字，<code>每个SELECT关键字代表着一个小的查询语句</code>，而每个 SELECT关键字的FROM子句中都可以包含若干张表（这些表用来做连接查询），<code>每一张表都对应者执行计划输出中的一条记录</code>，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。</p><p>MySQL为每—个SELECT关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type</code>属性，就知道了这个小查询在整个大查询中扮演了一个什么角色，我们看一下 select_type都能取哪些值，请看官方文档：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230410163311883.png" alt="image-20230410163311883"></p><p>具体分析如下：</p><ul><li><p>SIMPLE</p><p>查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型，比方说下边这个单表查询<code>select_type</code>的值就是<code>SIMPLE</code>:</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629171840300.png" alt="image-20220629171840300"></p><p>​        当然，连接查询也算是 SIMPLE 类型，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629171904912.png" alt="image-20220629171904912"></p><ul><li><p>PRIMARY</p><p>对于包含<code>UNION、UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>的值就是<code>PRIMARY</code>,比方说：</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629171929924.png" alt="image-20220629171929924"></p><p>从结果中可以看到，最左边的小查询<code>SELECT * FROM s1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>的值就是<code>PRIMARY</code>。</p><ul><li><p>UNION</p><p>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询意外，其余的小查询的<code>select_type</code>值就是UNION，可以对比上一个例子的效果。</p></li><li><p>UNION RESULT</p><p>MySQL 选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>, 例子上边有。</p></li><li><p>SUBQUERY</p><p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629172449267.png" alt="image-20220629172449267"></p><ul><li>DEPENDENT SUBQUERY</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key2 <span class="operator">=</span> s2.key2) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629172525236.png" alt="image-20220629172525236"></p><ul><li>DEPENDENT UNION</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629172555603.png" alt="image-20220629172555603"></p><ul><li>DERIVED</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> key1, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1) <span class="keyword">AS</span> derived_s1 <span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629172622893.png" alt="image-20220629172622893"></p><p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的select_type是DERIVED, 说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是derived2，表示该查询时针对将派生表物化之后的表进行查询的。</p><ul><li><p>MATERIALIZED</p><p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后的外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是DERIVED，比如下边这个查询：</p></li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2);</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629172646367.png" alt="image-20220629172646367"></p><ul><li><p>UNCACHEABLE SUBQUERY</p><p>不常用，就不多说了。</p></li><li><p>UNCACHEABLE UNION</p><p>不常用，就不多说了。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-4"><blockquote><p>(可略)</p></blockquote><ul><li>代表分区表中的命中情况，非分区表，该项为<code>NULL</code>。一般情况下我们的额查询语句的执行计划的<code>partitions</code>列的值为<code>NULL</code>。</li><li><a>https://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html</a></li><li>如果想详细了解，可以如下方式测试。创建分区表：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建分区表，</span></span><br><span class="line"><span class="comment">-- 按照id分区，id&lt;100 p0分区，其他p1分区</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_partitions (id <span class="type">INT</span> auto_increment,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">12</span>),<span class="keyword">PRIMARY</span> KEY(id))</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(id)(</span><br><span class="line"><span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> less than(<span class="number">100</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> less than MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629190304966.png" alt="image-20220629190304966"  /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_partitions <span class="keyword">WHERE</span> id<span class="operator">&gt;</span><span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>查询id大于200（200&gt;100，p1分区）的记录，查看执行计划，partitions是p1，符合我们的分区规则</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220629190335371.png" alt="image-20220629190335371"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-5"><p>执行计划的一条记录就代表着MySQL对某个表的<code>执行查询时的访问方法</code>, 又称“访问类型”，其中的<code>type</code>列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到<code>type</code>列的值是<code>ref</code>，表明<code>MySQL</code>即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。</p><p>完整的访问方法如下：<code>system，const，eq_ref，ref，fulltext，ref_or_null，index_merge，unique_subquery，index_subquery，range，index ，ALL</code>。</p><p>我们详细解释一下：</p><p>*<code>system</code></p><p>当表中<code>只有一条记录</code>并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t(i <span class="type">int</span>) Engine<span class="operator">=</span>MyISAM;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>然后我们看一下查询这个表的执行计划：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure>  <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220630164434315.png" alt="image-20220630164434315"  /><p>可以看到<code>type</code>列的值就是<code>system</code>了，</p><blockquote><p>测试，可以把表改成使用InnoDB存储引擎，试试看执行计划的<code>type</code>列是什么。ALL</p></blockquote><p>*<code>const</code></p><p>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>, 比如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>  <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220630164724548.png" alt="image-20220630164724548"  /><p>*<code>eq_ref</code></p><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较）。则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure>  <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220630164802559.png" alt="image-20220630164802559"  /><p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问 方法是<code>eq_ref</code>，表明在访问s1表的时候可以<code>通过主键的等值匹配</code>来进行访问。</p><p>*<code>ref</code></p><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是<code>ref</code>，比方说下边这个查询：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>  <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220630164930020.png" alt="image-20220630164930020"  /><p>*<code>fulltext</code></p><p>全文索引</p><p>*<code>ref_or_null</code></p><p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code>，比如说：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key1 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>  <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220630175133920.png" alt="image-20220630175133920"  /><p>*<code>index_merge</code></p><p>一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用<code>Interseation、union、Sort-Union</code>这三种索引合并的方式来执行查询。我们看一下执行计划中是怎么体现MySQL使用索引合并的方式来对某个表执行查询的：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>  <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220630175511644.png" alt="image-20220630175511644"  /><p>从执行计划的<code>type</code>列的值是<code>index_merge</code>就可以看出，MySQL 打算使用索引合并的方式来执行 对 s1 表的查询。</p><p>*<code>unique_subquery</code></p><p>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>  <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220630180123913.png" alt="image-20220630180123913"  /><p>+<code>index_subquery</code></p><p><code>index_subquery</code>与<code>unique_subquery</code>类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key3 <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.key1 <span class="operator">=</span> s2.key1) <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220703214407225.png" alt="image-20220703214407225"></p><p>*<code>range</code></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220703214633338.png" alt="image-20220703214633338"></p><p>或者：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220703214657251.png" alt="image-20220703214657251"></p><p>*<code>index</code></p><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>，比如这样：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> key_part2 <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220703214844885.png" alt="image-20220703214844885"></p><p>上述查询中的所有列表中只有key_part2 一个列，而且搜索条件中也只有 key_part3 一个列，这两个列又恰好包含在idx_key_part这个索引中，可是搜索条件key_part3不能直接使用该索引进行<code>ref</code>和<code>range</code>方式的访问，只能扫描整个<code>idx_key_part</code>索引的记录，所以查询计划的<code>type</code>列的值就是<code>index</code>。</p><blockquote><p>再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。</p></blockquote><p>*<code>ALL</code></p><p>最熟悉的全表扫描，就不多说了，直接看例子：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220703215958374.png" alt="image-20220703215958374"></p><p>小结:</p><p>结果值从最好到最坏依次是：</p><p><span class='p green'>system &gt; const &gt; eq_ref &gt; ref</span>&gt;fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <span class='p green'>range &gt; index &gt; ALL</span></p><p>其中比较重要的几个提取出来（见上图中的绿色）。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴 开发手册要求）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-6"><p>在EXPLAIN语句输出的执行计划中，<code>possible_keys</code>列表示在某个查询语句中，对某个列执行<code>单表查询时可能用到的索引</code>有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。<code>key</code>列表示<code>实际用到的索引</code>有哪些，如果为NULL，则没有使用索引。比方说下面这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220703220724964.png" alt="image-20220703220724964"></p><p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1, idx_key3</code>，表示该查询可能使用到<code>idx_key1, idx_key3</code>两个索引，然后<code>key</code>列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定采用<code>idx_key3</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-7"><p>实际使用到的索引长度 (即：字节数)</p><p>帮你检查<code>是否充分的利用了索引</code>，<code>值越大越好</code>，主要针对于联合索引，有一定的参考意义。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704130030692.png" alt="image-20220704130030692"></p><blockquote><p>int 占用 4 个字节 主键非空</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key2 <span class="operator">=</span> <span class="number">10126</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704130138204.png" alt="image-20220704130138204"></p><blockquote><p>key2上有一个唯一性约束，是否为NULL占用一个字节，那么就是5个字节</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704130214482.png" alt="image-20220704130214482"></p><blockquote><p>key1 VARCHAR(100) 一个字符占3个字节，100*3，是否为NULL占用一个字节，varchar的长度信息占两个字节。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704130442095.png" alt="image-20220704130442095"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key_part2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704130515031.png" alt="image-20220704130515031"></p><blockquote><p>联合索引中可以比较，key_len=606的好于key_len=303</p></blockquote><p>练习：</p><p>key_len的长度计算公式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">varchar</span>(<span class="number">10</span>)变长字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">2</span>(变长字段)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>(<span class="keyword">NULL</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>(<span class="number">10</span>)固定字段且不允许<span class="keyword">NULL</span> <span class="operator">=</span> <span class="number">10</span> <span class="operator">*</span> ( <span class="type">character</span> <span class="keyword">set</span>：utf8<span class="operator">=</span><span class="number">3</span>,gbk<span class="operator">=</span><span class="number">2</span>,latin1<span class="operator">=</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-8"><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p><p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<code>const</code>、<code>eq-ref</code>、<code>ref</code>、<code>ref_or-null</code>、<code>unique_subquery</code>、<code>index_subquery</code>其中之一时，<code>ref</code>列展示的就是与索引列作等值匹配的结构是什么，比如只是一个常数或者是某个列。大家看下边这个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704130837498.png" alt="image-20220704130837498"></p><p>可以看到<code>ref</code>列的值是<code>const</code>，表明在使用<code>idx_key1</code>索引执行查询时，与<code>key1</code>列作等值匹配的对象是一个常数，当然有时候更复杂一点:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704130925426.png" alt="image-20220704130925426"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s2.key1 <span class="operator">=</span> <span class="built_in">UPPER</span>(s1.key1);</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704130957359.png" alt="image-20220704130957359"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-9"><p>预估的需要读取的记录条数，<code>值越小越好</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704131050496.png" alt="image-20220704131050496"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-10"><p>某个表经过搜索条件过滤后剩余记录条数的百分比</p><p>如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704131323242.png" alt="image-20220704131323242"></p><p>对于单表查询来说，这个filtered的值没有什么意义，我们<code>更关注在连接查询中驱动表对应的执行计划记录的filtered值</code>，它决定了被驱动表要执行的次数 (即: rows * filtered)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704131644615.png" alt="image-20220704131644615"></p><p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>作为驱动表，<code>s2</code>当做被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为<code>9688</code>，filtered列为<code>10.00</code>，这意味着驱动表<code>s1</code>的扇出值就是<code>9688 x 10.00% = 968.8</code>，这说明还要对被驱动表执行大约<code>968</code>次查询。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3d8c80d0-e512-487e-8c93-0506e90c7af1-11"><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来<code>更准确的理解MySQL到底将如何执行给定的查询语句</code>。MySQL提供的额外信息有好几十个，我们就不一个一个介绍了，所以我们只挑选比较重要的额外信息介绍给大家。</p><p>*<code>No tables used</code></p><p>当查询语句没有<code>FROM</code>子句时将会提示该额外信息，比如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704132345383.png" alt="image-20220704132345383"></p><p>*<code>Impossible WHERE</code></p><p>当查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704132458978.png" alt="image-20220704132458978"></p><p>-<code>Using where</code></p><p>不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤。表明使用了where过滤。</p><p>当我们使用全表扫描来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有针对该表的搜索条件时，在<code>Extra</code>列中会提示上述额外信息。比如下边这个查询：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704132655342.png" alt="image-20220704132655342"></p><p>当使用索引访问来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有除了该索引包含的列之外的其他搜索条件时，在<code>Extra</code>列中也会提示上述额外信息。比如下边这个查询虽然使用<code>idx_key1</code>索引执行查询，但是搜索条件中除了包含<code>key1</code>的搜索条件<code>key1='a'</code>，还包含<code>common_field</code>的搜索条件，所以<code>Extra</code>列会显示<code>Using where</code>的提示：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704133130515.png" alt="image-20220704133130515"></p><p>*<code>No matching min/max row</code></p><p>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚合函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key1) <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;abcdefg&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704134324354.png" alt="image-20220704134324354"></p><p>*<code>Using index</code></p><p>当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在<code>Extra</code>列将会提示该额外信息。比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作:</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> key1,id <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704134931220.png" alt="image-20220704134931220"></p><p>*<code>Using index condition</code></p><p>有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure>  <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704140344015.png" alt="image-20220704140344015"  />  <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704140411033.png" alt="image-20220704140411033"  /> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">&#x27;%b&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704140441702.png" alt="image-20220704140441702"></p><p>*<code>Using join buffer (Block Nested Loop)</code></p><p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code>。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.common_field <span class="operator">=</span> s2.common_field;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704140815955.png" alt="image-20220704140815955"></p><p>*<code>Not exists</code></p><p>当我们使用左(外)连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列是不允许存储<code>NULL</code>值的，那么在该表的执行计划的Extra列就会提示这个信息：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704142059555.png" alt="image-20220704142059555"></p><p>*<code>Using intersect(...) 、 Using union(...) 和 Using sort_union(...)</code></p><p>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；</p><p>如果出现<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询;</p><p>如果出现<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704142552890.png" alt="image-20220704142552890"></p><p>*<code>Zero limit</code></p><p>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示压根儿不打算从表中读取任何记录，将会提示该额外信息</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 LIMIT <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704142754394.png" alt="image-20220704142754394"></p><p>*<code>Using filesort</code></p><p>有一些情况下对结果集中的记录进行排序是可以使用到索引的。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> key1 LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704142901857.png" alt="image-20220704142901857"></p><p>这个查询语句可以利用<code>idx_key1</code>索引直接取出<code>key1</code>列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，MysQL把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的<code>Extra</code>列中显示<code>Using filesort</code>提示，比如这样：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> common_field LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704143518857.png" alt="image-20220704143518857"></p><p>需要注意的是，如果查询中需要使用<code>filesort</code>的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法<code>将使用文件排序的执行方式改为索引进行排序</code>。</p><p>*<code>Using temporary</code></p><p>在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询， MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示，比方说这样：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> common_field <span class="keyword">FROM</span> s1;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704150030005.png" alt="image-20220704150030005"></p><p>再比如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> common_field, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> common_field;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704150156416.png" alt="image-20220704150156416"></p><p>执行计划中出现<code>Using temporary</code>并不是一个好的征兆，因为建立与维护临时表要付出很大的成本的，所以我们<code>最好能使用索引来替代掉使用临时表</code>，比方说下边这个包含<code>GROUP BY</code>子句的查询就不需要使用临时表：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> key1, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704150308189.png" alt="image-20220704150308189"></p><p>从<code>Extra</code>的<code>Using index</code>的提示里我们可以看出，上述查询只需要扫描<code>idx_key1</code>索引就可以搞 定了，不再需要临时表了。</p><ul><li><p>其他</p><p>其它特殊情况这里省略。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>小结</p></blockquote><ul><li>EXPLAIN不考虑各种Cache</li><li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li><li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li><li>部分统计信息是估算的，并非精确值</li></ul><hr><h2 id="7-EXPLAIN的进一步使用">7. EXPLAIN的进一步使用</h2><h3 id="7-1-EXPLAIN四种输出格式">7.1 EXPLAIN四种输出格式</h3><p>这里谈谈EXPLAIN的输出格式。EXPLAIN可以输出四种格式：<code>传统格式</code>，<code>JSON格式</code>，<code>TREE格式</code>以及<code>可视化输出</code>。用户可以根据需要选择适用于自己的格式。</p><div class="tabs" id="b05238d9-59e2-47e4-81c0-98086ae4e45a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b05238d9-59e2-47e4-81c0-98086ae4e45a-1"><i class="fas fa-award"></i>传统格式</button></li><li class="tab"><button type="button" data-href="#b05238d9-59e2-47e4-81c0-98086ae4e45a-2"><i class="fas fa-baseball-ball"></i>JSON格式</button></li><li class="tab"><button type="button" data-href="#b05238d9-59e2-47e4-81c0-98086ae4e45a-3"><i class="fas fa-bone"></i>TREE格式</button></li><li class="tab"><button type="button" data-href="#b05238d9-59e2-47e4-81c0-98086ae4e45a-4"><i class="fas fa-anchor"></i>可视化输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b05238d9-59e2-47e4-81c0-98086ae4e45a-1"><p>传统格式简单明了，输出是一个表格形式，概要说明查询计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704161702384.png" alt="image-20220704161702384"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b05238d9-59e2-47e4-81c0-98086ae4e45a-2"><p>第1种格式中介绍的<code>EXPLAIN</code>语句输出中缺少了一个衡量执行好坏的重要属性 ——<code>成本</code>。而JSON格式是四种格式里面输出<code>信息最详尽</code>的格式，里面包含了执行的成本信息。</p><ul><li>JSON格式：在EXPLAIN单词和真正的查询语句中间加上 FORMAT=JSON 。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> ....</span><br></pre></td></tr></table></figure><ul><li>EXPLAIN的Column与JSON的对应关系：(来源于MySQL 5.7文档)</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704164236909.png" alt="image-20220704164236909"></p><p>这样我们就可以得到一个json格式的执行计划，里面包含该计划花费的成本。比如这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN FORMAT<span class="operator">=</span>JSON <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704172833362.png" alt="image-20220704172833362"></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704172920158.png" alt="image-20220704172920158"></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704173012413.png" alt="image-20220704173012413"></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704173045190.png" alt="image-20220704173045190"></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704173108888.png" alt="image-20220704173108888"></p><p>我们使用 # 后边跟随注释的形式为大家解释了<code>EXPLAIN FORMAT=JSON</code>语句的输出内容，但是大家可能 有疑问 “<code>cost_info</code>” 里边的成本看着怪怪的，它们是怎么计算出来的？先看 s1 表的 “<code>cost_info</code>” 部 分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1840.84&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;193.76&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2034.60&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1M&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>*<code>read_cost</code>是由下边这两部分组成的：</p><ul><li>IO 成本</li><li>检测 rows × (1 - filter) 条记录的 CPU 成本</li></ul><blockquote><p>小贴士： rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows 相当于rows_examined_per_scan，filtered名称不变。</p></blockquote><p>+<code>eval_cost</code>是这样计算的：</p><p>检测 rows × filter 条记录的成本。</p><p>+<code>prefix_cost</code>就是单独查询 s1 表的成本，也就是：</p><p><code>read_cost + eval_cost</code></p><p>+<code>data_read_per_join</code>表示在此次查询中需要读取的数据量。</p><p>对于<code>s2</code>表的 “<code>cost_info</code>” 部分是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;cost_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;read_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;968.80&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eval_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;193.76&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prefix_cost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3197.16&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data_read_per_join&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1M&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>由于<code>s2</code>表是被驱动表，所以可能被读取多次，这里的<code>read_cost</code>和<code>eval_cost</code>是访问多次<code>s2</code>表后累加起来的值，大家主要关注里边儿的<code>prefix_cost</code>的值代表的是整个连接查询预计的成本，也就是单次查询<code>s1</code>表和多次查询<code>s2</code>表后的成本的和，也就是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">968</span>.<span class="number">80</span> + <span class="number">193</span>.<span class="number">76</span> + <span class="number">2034</span>.<span class="number">60</span> = <span class="number">3197</span>.<span class="number">16</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b05238d9-59e2-47e4-81c0-98086ae4e45a-3"><p>TREE格式是8.0.16版本之后引入的新格式，主要根据查询的<code>各个部分之间的关系</code>和<code>各部分的执行顺序</code>来描述如何查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN FORMAT<span class="operator">=</span>tree <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key2 <span class="keyword">WHERE</span></span><br><span class="line">s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">EXPLAIN: <span class="operator">-</span><span class="operator">&gt;</span> Nested loop <span class="keyword">inner</span> <span class="keyword">join</span> (cost<span class="operator">=</span><span class="number">1360.08</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>: ((s1.common_field <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) <span class="keyword">and</span> (s1.key1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>)) (cost<span class="operator">=</span><span class="number">1013.75</span></span><br><span class="line"><span class="keyword">rows</span><span class="operator">=</span><span class="number">990</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Table</span> scan <span class="keyword">on</span> s1 (cost<span class="operator">=</span><span class="number">1013.75</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">9895</span>)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> Single<span class="operator">-</span><span class="type">row</span> index lookup <span class="keyword">on</span> s2 <span class="keyword">using</span> idx_key2 (key2<span class="operator">=</span>s1.key1), <span class="keyword">with</span> index</span><br><span class="line"><span class="keyword">condition</span>: (<span class="built_in">cast</span>(s1.key1 <span class="keyword">as</span> <span class="keyword">double</span>) <span class="operator">=</span> <span class="built_in">cast</span>(s2.key2 <span class="keyword">as</span> <span class="keyword">double</span>)) (cost<span class="operator">=</span><span class="number">0.25</span> <span class="keyword">rows</span><span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b05238d9-59e2-47e4-81c0-98086ae4e45a-4"><p>可视化输出，可以通过MySQL Workbench可视化查看MySQL的执行计划。通过点击Workbench的放大镜图标，即可生成可视化的查询计划。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704174401970.png" alt="image-20220704174401970"></p><p>上图按从左到右的连接顺序显示表。红色框表示<code>全表扫描</code>，而绿色框表示使用<code>索引查找</code>。对于每个表， 显示使用的索引。还要注意的是，每个表格的框上方是每个表访问所发现的行数的估计值以及访问该表的成本。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="7-2-SHOW-WARNINGS的使用">7.2 SHOW WARNINGS的使用</h3><p>在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> s1.key1, s2.key1 <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1 <span class="keyword">WHERE</span> s2.common_field <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220704174543663.png" alt="image-20220704174543663"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> WARNINGS\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">    Level: Note</span><br><span class="line">     Code: <span class="number">1003</span></span><br><span class="line">Message: <span class="comment">/* select#1 */</span> <span class="keyword">select</span>`atguigu`.`s1`.`key1`<span class="keyword">AS</span>`key1`,`atguigu`.`s2`.`key1`</span><br><span class="line"><span class="keyword">AS</span>`key1`<span class="keyword">from</span>`atguigu`.`s1`<span class="keyword">join</span>`atguigu`.`s2`<span class="keyword">where</span> ((`atguigu`.`s1`.`key1`<span class="operator">=</span></span><br><span class="line">`atguigu`.`s2`.`key1`) <span class="keyword">and</span> (`atguigu`.`s2`.`common_field`<span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>))</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>大家可以看到<code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level、Code、Message</code>。我们最常见的就是Code为1003的信息，当Code值为1003时，<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左(外)连接查询，但是有一个s2.common_field IS NOT NULL的条件，这就会导致查询优化器把左(外)连接查询优化为内连接查询，从<code>SHOW WARNINGS</code>的<code>Message</code>字段也可以看出来，原本的LEFE JOIN已经变成了JOIN。</p><p>但是大家一定要注意，我们说<code>Message</code>字段展示的信息类似于查询优化器将我们的查询语句<code>重写后的语句</code>，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解MySQL将如何执行查询语句的一个参考依据而已。</p><hr><h2 id="8-分析优化器执行计划-trace">8. 分析优化器执行计划:trace</h2><p><code>OPTIMIZER_TRACE</code>是MysQL5.6引入的一项跟踪功能，它可以跟踪优化器做出的各种决策（比如访问表的方法、 各种开销计算、各种转换等），并将跟踪结果记录到<code>INFORMATION_ SCHEMA.OPTIMIZER_TRACE</code>表中。</p><p>此功能默认关闭。开启trace，并设置格式为 JSON，同时设置trace最大能够使用的内存大小，避免解析过程中因为默认內存过小而不能够完整展示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p>开启后，可分析如下语句：</p><ul><li>SELECT</li><li>INSERT</li><li>REPLACE</li><li>UPDATE</li><li>DELETE</li><li>EXPLAIN</li><li>SET</li><li>DECLARE</li><li>CASE</li><li>IF</li><li>RETURN</li><li>CALL</li></ul><p>测试：执行如下SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>最后， 查询 information_schema.optimizer_trace 就可以知道MySQL是如何执行SQL的 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#第<span class="number">1</span>部分：查询语句</span><br><span class="line">QUERY: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">10</span></span><br><span class="line">#第<span class="number">2</span>部分：QUERY字段对应语句的跟踪信息</span><br><span class="line">TRACE: &#123;</span><br><span class="line">&quot;steps&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">    &quot;join_preparation&quot;: &#123; #预备工作</span><br><span class="line">        &quot;select#&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">            &quot;expanded_query&quot;: &quot;/* select#1 */ select`student`.`id`AS</span><br><span class="line">          `id`,`student`.`stuno`AS`stuno`,`student`.`name`AS`name`,`student`.`age`AS</span><br><span class="line">          `age`,`student`.`classId`AS`classId`from`student`where (`student`.`id`&lt; 10)&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">    &#125; <span class="comment">/* join_preparation */</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;join_optimization&quot;: &#123; #进行优化</span><br><span class="line">    &quot;select#&quot;: <span class="number">1</span>,</span><br><span class="line">    &quot;steps&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">        &quot;condition_processing&quot;: &#123; #条件处理</span><br><span class="line">        &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">        &quot;original_condition&quot;: &quot;(`student`.`id`&lt; 10)&quot;,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">            &quot;resulting_condition&quot;: &quot;(`student`.`id`&lt; 10)&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">            &quot;resulting_condition&quot;: &quot;(`student`.`id`&lt; 10)&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">            &quot;resulting_condition&quot;: &quot;(`student`.`id`&lt; 10)&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">    &#125; <span class="comment">/* condition_processing */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;substitute_generated_columns&quot;: &#123; #替换生成的列</span><br><span class="line">        &#125; <span class="comment">/* substitute_generated_columns */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;table_dependencies&quot;: [ #表的依赖关系</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">            &quot;row_may_be_null&quot;: <span class="literal">false</span>,</span><br><span class="line">            &quot;map_bit&quot;: <span class="number">0</span>,</span><br><span class="line">            &quot;depends_on_map_bits&quot;: [</span><br><span class="line">            ] <span class="comment">/* depends_on_map_bits */</span></span><br><span class="line">        &#125;</span><br><span class="line">    ] <span class="comment">/* table_dependencies */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;ref_optimizer_key_uses&quot;: [ #使用键</span><br><span class="line">        ] <span class="comment">/* ref_optimizer_key_uses */</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;rows_estimation&quot;: [ #行判断</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">            &quot;range_analysis&quot;: &#123;</span><br><span class="line">                &quot;table_scan&quot;: &#123;</span><br><span class="line">                    &quot;rows&quot;: <span class="number">3973767</span>,</span><br><span class="line">                    &quot;cost&quot;: <span class="number">408558</span></span><br><span class="line">            &#125; <span class="comment">/* table_scan */</span>, #扫描表</span><br><span class="line">            &quot;potential_range_indexes&quot;: [ #潜在的范围索引</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                    &quot;usable&quot;: <span class="literal">true</span>,</span><br><span class="line">                    &quot;key_parts&quot;: [</span><br><span class="line">                    &quot;id&quot;</span><br><span class="line">                    ] <span class="comment">/* key_parts */</span></span><br><span class="line">                &#125;</span><br><span class="line">            ] <span class="comment">/* potential_range_indexes */</span>,</span><br><span class="line">        &quot;setup_range_conditions&quot;: [ #设置范围条件</span><br><span class="line">        ] <span class="comment">/* setup_range_conditions */</span>,</span><br><span class="line">        &quot;group_index_range&quot;: &#123;</span><br><span class="line">            &quot;chosen&quot;: <span class="literal">false</span>,</span><br><span class="line">            &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;</span><br><span class="line">        &#125; <span class="comment">/* group_index_range */</span>,</span><br><span class="line">            &quot;skip_scan_range&quot;: &#123;</span><br><span class="line">                &quot;potential_skip_scan_indexes&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                        &quot;usable&quot;: <span class="literal">false</span>,</span><br><span class="line">                        &quot;cause&quot;: &quot;query_references_nonkey_column&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                ] <span class="comment">/* potential_skip_scan_indexes */</span></span><br><span class="line">            &#125; <span class="comment">/* skip_scan_range */</span>,</span><br><span class="line">        &quot;analyzing_range_alternatives&quot;: &#123; #分析范围选项</span><br><span class="line">            &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                    &quot;ranges&quot;: [</span><br><span class="line">                        &quot;id &lt; 10&quot;</span><br><span class="line">                    ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                &quot;index_dives_for_eq_ranges&quot;: <span class="literal">true</span>,</span><br><span class="line">                &quot;rowid_ordered&quot;: <span class="literal">true</span>,</span><br><span class="line">                &quot;using_mrr&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;index_only&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;rows&quot;: <span class="number">9</span>,</span><br><span class="line">                &quot;cost&quot;: <span class="number">1.91986</span>,</span><br><span class="line">                &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ] <span class="comment">/* range_scan_alternatives */</span>,</span><br><span class="line">        &quot;analyzing_roworder_intersect&quot;: &#123;</span><br><span class="line">            &quot;usable&quot;: <span class="literal">false</span>,</span><br><span class="line">            &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">        &#125; <span class="comment">/* analyzing_roworder_intersect */</span></span><br><span class="line">        &#125; <span class="comment">/* analyzing_range_alternatives */</span>,</span><br><span class="line">        &quot;chosen_range_access_summary&quot;: &#123; #选择范围访问摘要</span><br><span class="line">            &quot;range_access_plan&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                &quot;rows&quot;: <span class="number">9</span>,</span><br><span class="line">                &quot;ranges&quot;: [</span><br><span class="line">                &quot;id &lt; 10&quot;</span><br><span class="line">                ] <span class="comment">/* ranges */</span></span><br><span class="line">                &#125; <span class="comment">/* range_access_plan */</span>,</span><br><span class="line">                &quot;rows_for_plan&quot;: <span class="number">9</span>,</span><br><span class="line">                &quot;cost_for_plan&quot;: <span class="number">1.91986</span>,</span><br><span class="line">                &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                &#125; <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">                &#125; <span class="comment">/* range_analysis */</span></span><br><span class="line">            &#125;</span><br><span class="line">        ] <span class="comment">/* rows_estimation */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;considered_execution_plans&quot;: [ #考虑执行计划</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;plan_prefix&quot;: [</span><br><span class="line">    ] <span class="comment">/* plan_prefix */</span>,</span><br><span class="line">        &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">        &quot;best_access_path&quot;: &#123; #最佳访问路径</span><br><span class="line">        &quot;considered_access_paths&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;rows_to_scan&quot;: <span class="number">9</span>,</span><br><span class="line">            &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">            &quot;range_details&quot;: &#123;</span><br><span class="line">            &quot;used_index&quot;: &quot;PRIMARY&quot;</span><br><span class="line">        &#125; <span class="comment">/* range_details */</span>,</span><br><span class="line">        &quot;resulting_rows&quot;: <span class="number">9</span>,</span><br><span class="line">        &quot;cost&quot;: <span class="number">2.81986</span>,</span><br><span class="line">        &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ] <span class="comment">/* considered_access_paths */</span></span><br><span class="line">    &#125; <span class="comment">/* best_access_path */</span>,</span><br><span class="line">        &quot;condition_filtering_pct&quot;: <span class="number">100</span>, #行过滤百分比</span><br><span class="line">        &quot;rows_for_plan&quot;: <span class="number">9</span>,</span><br><span class="line">        &quot;cost_for_plan&quot;: <span class="number">2.81986</span>,</span><br><span class="line">        &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ] <span class="comment">/* considered_execution_plans */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;attaching_conditions_to_tables&quot;: &#123; #将条件附加到表上</span><br><span class="line">        &quot;original_condition&quot;: &quot;(`student`.`id`&lt; 10)&quot;,</span><br><span class="line">        &quot;attached_conditions_computation&quot;: [</span><br><span class="line">        ] <span class="comment">/* attached_conditions_computation */</span>,</span><br><span class="line">        &quot;attached_conditions_summary&quot;: [ #附加条件概要</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">        &quot;attached&quot;: &quot;(`student`.`id`&lt; 10)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ] <span class="comment">/* attached_conditions_summary */</span></span><br><span class="line">    &#125; <span class="comment">/* attaching_conditions_to_tables */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;finalizing_table_conditions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;table&quot;: &quot;`student`&quot;,</span><br><span class="line">        &quot;original_table_condition&quot;: &quot;(`student`.`id`&lt; 10)&quot;,</span><br><span class="line">        &quot;final_table_condition &quot;: &quot;(`student`.`id`&lt; 10)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ] <span class="comment">/* finalizing_table_conditions */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;refine_plan&quot;: [ #精简计划</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;table&quot;: &quot;`student`&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ] <span class="comment">/* refine_plan */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ] <span class="comment">/* steps */</span></span><br><span class="line">    &#125; <span class="comment">/* join_optimization */</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">        &quot;join_execution&quot;: &#123; #执行</span><br><span class="line">            &quot;select#&quot;: <span class="number">1</span>,</span><br><span class="line">            &quot;steps&quot;: [</span><br><span class="line">            ] <span class="comment">/* steps */</span></span><br><span class="line">        &#125; <span class="comment">/* join_execution */</span></span><br><span class="line">        &#125;</span><br><span class="line">    ] <span class="comment">/* steps */</span></span><br><span class="line">&#125;</span><br><span class="line">#第<span class="number">3</span>部分：跟踪信息过长时，被截断的跟踪信息的字节数。</span><br><span class="line">MISSING_BYTES_BEYOND_MAX_MEM_SIZE: <span class="number">0</span> #丢失的超出最大容量的字节</span><br><span class="line">#第<span class="number">4</span>部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为<span class="number">1</span>且TRACE字段为空，一般在</span><br><span class="line">#调用带有<span class="keyword">SQL</span> SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。</span><br><span class="line">INSUFFICIENT_PRIVILEGES: <span class="number">0</span> #缺失权限</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><hr><h2 id="9-监控分析视图-sys-schema">9. 监控分析视图:sys schema</h2><p>关于MySQL的性能监控和问题诊断，我们一般都从performance_schema中去获取想要的数据，在MySQL5.7.7版本中新增sys schema，它将performance_schema和linformation_schema中的数据以更容易理解的方式总结归纳为”视图&quot;，其目的就是为了<code>降低查询performance_schema的复杂度</code>，让DBA能够快速的定位问题。下面看看这些库中都有哪些监控表和视图，掌握了这些，在我们开发和运维的过程中就起到了事半功倍的效果。</p><h3 id="9-1-Sys-schema视图摘要">9.1 Sys schema视图摘要</h3><ol><li><strong>主机相关</strong>：以host_summary开头，主要汇总了IO延迟的信息。</li><li><strong>Innodb相关</strong>：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。</li><li><strong>I/O相关</strong>：以io开头，汇总了等待I/O、I/O使用量情况。</li><li><strong>内存使用情况</strong>：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li><li><strong>连接与会话信息</strong>：processlist和session相关视图，总结了会话相关信息。</li><li><strong>表相关</strong>：以schema_table开头的视图，展示了表的统计信息。</li><li><strong>索引信息</strong>：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li><li><strong>语句相关</strong>：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li><li><strong>用户相关</strong>：以user开头的视图，统计了用户使用的文件I/O、执行语句统计信息。</li><li><strong>等待事件相关信息</strong>：以wait开头，展示等待事件的延迟情况。</li></ol><h3 id="9-2-Sys-schema视图使用场景">9.2 Sys schema视图使用场景</h3><p>索引情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span> 查询冗余索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_redundant_indexes;</span><br><span class="line">#<span class="number">2.</span> 查询未使用过的索引</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.schema_unused_indexes;</span><br><span class="line">#<span class="number">3.</span> 查询索引的使用情况</span><br><span class="line"><span class="keyword">select</span> index_name,rows_selected,rows_inserted,rows_updated,rows_deleted</span><br><span class="line"><span class="keyword">from</span> sys.schema_index_statistics <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure><p>表相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查询表的访问量</span><br><span class="line"><span class="keyword">select</span> table_schema,table_name,<span class="built_in">sum</span>(io_read_requests<span class="operator">+</span>io_write_requests) <span class="keyword">as</span> io <span class="keyword">from</span></span><br><span class="line">sys.schema_table_statistics <span class="keyword">group</span> <span class="keyword">by</span> table_schema,table_name <span class="keyword">order</span> <span class="keyword">by</span> io <span class="keyword">desc</span>;</span><br><span class="line"># <span class="number">2.</span> 查询占用bufferpool较多的表</span><br><span class="line"><span class="keyword">select</span> object_schema,object_name,allocated,data</span><br><span class="line"><span class="keyword">from</span> sys.innodb_buffer_stats_by_table <span class="keyword">order</span> <span class="keyword">by</span> allocated limit <span class="number">10</span>;</span><br><span class="line"># <span class="number">3.</span> 查看表的全表扫描情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.statements_with_full_table_scans <span class="keyword">where</span> db<span class="operator">=</span><span class="string">&#x27;dbname&#x27;</span>;</span><br></pre></td></tr></table></figure><p>语句相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span> 监控<span class="keyword">SQL</span>执行的频率</span><br><span class="line"><span class="keyword">select</span> db,exec_count,query <span class="keyword">from</span> sys.statement_analysis</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> exec_count <span class="keyword">desc</span>;</span><br><span class="line">#<span class="number">2.</span> 监控使用了排序的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,first_seen,last_seen,query</span><br><span class="line"><span class="keyword">from</span> sys.statements_with_sorting limit <span class="number">1</span>;</span><br><span class="line">#<span class="number">3.</span> 监控使用了临时表或者磁盘临时表的<span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">select</span> db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line"><span class="keyword">from</span> sys.statement_analysis <span class="keyword">where</span> tmp_tables<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">or</span> tmp_disk_tables <span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (tmp_tables<span class="operator">+</span>tmp_disk_tables) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>IO相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span> 查看消耗磁盘IO的文件</span><br><span class="line"><span class="keyword">select</span> file,avg_read,avg_write,avg_read<span class="operator">+</span>avg_write <span class="keyword">as</span> avg_io</span><br><span class="line"><span class="keyword">from</span> sys.io_global_by_file_by_bytes <span class="keyword">order</span> <span class="keyword">by</span> avg_read limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>Innodb 相关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span> 行锁阻塞情况</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure><p>风险提示：</p><p>通过sys库去查询时，MySQL会<code>消耗大量资源</code>去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上<code>不要频繁</code>的去查询sys或者performance_schema、 information_schema来完成监控、巡检等工作。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引的创建与设计原则</title>
      <link href="/posts/d227e38d.html"/>
      <url>/posts/d227e38d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-索引的分类">1. 索引的分类</h2><p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p><p>从 功能逻辑 上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。</p><p>按照 物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。</p><p>按照 作用字段个数 进行划分，分成单列索引和联合索引。</p><div class="tabs" id="36c85279-7f3e-4bc9-a05b-a310a56c263d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#36c85279-7f3e-4bc9-a05b-a310a56c263d-1"><i class="fas fa-atom"></i>普通索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc9-a05b-a310a56c263d-2"><i class="far fa-sun"></i>唯一性索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc9-a05b-a310a56c263d-3"><i class="fas fa-wind"></i>主键索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc9-a05b-a310a56c263d-4"><i class="fas fa-fire-alt"></i>单列索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc9-a05b-a310a56c263d-5"><i class="fas fa-award"></i>联合索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc9-a05b-a310a56c263d-6"><i class="fas fa-baseball-ball"></i>全文索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc9-a05b-a310a56c263d-7"><i class="fas fa-bone"></i>空间索引</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="36c85279-7f3e-4bc9-a05b-a310a56c263d-1"><p>在创建普通素引时，不附加任何限制条件，只是用于提高查询效率，这类索引可以创建在<code>任何数据类型</code>中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索事以后，可以通过索引进行查询。例如，在表 student 的字段name 上建立一个普通索引，查询记录时就可以根据该索引进行查询。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc9-a05b-a310a56c263d-2"><p>使用 UNIQUE参数可以设置索引为<code>唯一性索引</code>，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里<code>可以有多个</code>唯一索引。</p><p>例如，在表 student 的字段 email 中创建唯一性索引，那么字段email的值就必须是唯一的。通过唯一性索引， 可以更快速地确定某条记录。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc9-a05b-a310a56c263d-3"><p>主键索引就是一种<code>特殊的唯一性索引</code>，在唯一索引的基础上增加了不为空的约束，也就是<code>NOT NULL+UNIQUE</code>, 一张表里<code>最多只有一个</code>主键索引。</p><p>Why?这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc9-a05b-a310a56c263d-4"><p>在表中的单个字段上创建索引。单列索引只根据该字段进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表<code>可以有多个</code>单列索引。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc9-a05b-a310a56c263d-5"><p>多列索引是在表的<code>多个字段组合上</code>创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段id、 name和 gender上建立一个多列索引<code>idx_id_name_gender</code>，只有在查询条件中使用了字段id时该索引|才会被使用。使用组合索引时遵循<code>最左前缀集合</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc9-a05b-a310a56c263d-6"><p>全文索引（也称全文检索）是目前<code>搜索引擎</code>使用的一种关键技术。它能够利用【<code>分词技术</code>】 等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。</p><p>使用参数<code>FULLTEXT</code>可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在<code>CHAR</code>、<code>VARCHAR</code>或<code>TEXT</code>类型及其系列类型的字段上，<span class='p red'>查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。</span>例如，表 student 的字段 information 是 TEXT 类型， 该字段包含了很多文字信息。在字段information上建立全文索引后，可以提高查询字段information的速度。</p><p>全文索引典型的有两种类型：自然语言的全文索引和布尔全文索引。</p><p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。<span class='p red'>在整个索引中出现次数越少的词语，匹配时的相关度就越高。</span>相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50%的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。</p><p>MysQL数据库从3.23.23版开始支持全文索引|，但MySQL5.6.4以前只有Myisam支持，5.6.4版本以后 innodb才支持，但是官方版本不支持中文分词，需要第三方分词插件。在5.7.6版本，MySQL内置了 ngram全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的 MySQL版本、存储引擎和数据类型是否支持全文索引。</p><p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被<code>solr</code>、<code>Elasticsearch</code>等专门的搜索引擎所替代。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc9-a05b-a310a56c263d-7"><p>使用<code>参数SPATIAL</code>可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MysQL中的空间数据类型包括<code>GEOMETRY</code>、<code>POINT</code>、<code>LINESTRING</code>和<code>POLYGON</code>等。目前只有MyISAM 存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>小结：不同的存储引擎支持的索引类型也不一样</p><p>InnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash 索引；</p><p>MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引；</p><p>Memory ：支持 B-tree、Hash 等 索引，不支持 Full-text 索引；</p><p>NDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引；</p><p>Archive ：不支持 B-tree、Hash、Full-text 等索引；</p><hr><h2 id="2-创建索引">2. 创建索引</h2><p>MySQL支持多种方法在单个或多个列上创建索引：在创建表的定义语句<code>CREATE TABLE</code>中指定索引列，使用<code>ALTER TABLE</code>语句在存在的表上创建索引，或者使用<code>CREATE INDEX</code>语句在已存在的表上添加索引。</p><h3 id="2-1-创建表的时候创建索引">2.1 创建表的时候创建索引</h3><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">dept_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"># 隐式的方式创建索引。在声明有主键约束、唯一性约束、外键约束的字段上，会自动的添加相关的索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">emp_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">emp_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">dept_id <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">CONSTRAINT</span> emp_dept_id_fk <span class="keyword">FOREIGN</span> KEY(dept_id) <span class="keyword">REFERENCES</span> dept(dept_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>但是，如果显式创建表时创建索引的话，基本语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line">[col_name data_type]  [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL]  [INDEX <span class="operator">|</span> KEY] [index_name] </span><br><span class="line">(col_name [length]) [<span class="keyword">ASC</span> <span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p>*<code>UNIQUE</code>、<code>FULLTEXT</code>和<code>SPATIAL</code>为可选参数，分别表示唯一索引、全文索引和空间索引；<br>*<code>INDEX</code>与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引；<br>*<code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名；<br>*<code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；<br>*<code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；<br>*<code>ASC</code>或<code>DESC</code>指定升序或者降序的索引值存储。</p><div class="tabs" id="36c85279-7f3e-4bc8-a05b-a310a56c263d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#36c85279-7f3e-4bc8-a05b-a310a56c263d-1"><i class="fas fa-atom"></i>普通索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc8-a05b-a310a56c263d-2"><i class="far fa-sun"></i>唯一性索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc8-a05b-a310a56c263d-3"><i class="fas fa-wind"></i>主键索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc8-a05b-a310a56c263d-4"><i class="fas fa-fire-alt"></i>单列索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc8-a05b-a310a56c263d-5"><i class="fas fa-award"></i>联合索引</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc8-a05b-a310a56c263d-6"><i class="fas fa-baseball-ball"></i>全文检索</button></li><li class="tab"><button type="button" data-href="#36c85279-7f3e-4bc8-a05b-a310a56c263d-7"><i class="fas fa-bone"></i>空间索引</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="36c85279-7f3e-4bc8-a05b-a310a56c263d-1"><p>在book表中的year_publication字段上建立普通索引，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">  book_id <span class="type">INT</span> ,</span><br><span class="line">  book_name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  authors <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  info <span class="type">VARCHAR</span>(<span class="number">100</span>) ,</span><br><span class="line">  comment <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">  year_publication <span class="keyword">YEAR</span>,</span><br><span class="line">  INDEX idx_bname(book_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可通过以下命令查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#方式一</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book;</span><br><span class="line">#方式二</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> book;</span><br><span class="line">#方式三 性能分析工具EXPLAIN</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book_name<span class="operator">=</span><span class="string">&#x27;Mysql高级&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc8-a05b-a310a56c263d-2"><p>声明有唯一索引的字段，在添加数据时，要保证唯一性，但是可以添加null</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX uk_idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc8-a05b-a310a56c263d-3"><p>通过定义主键约束的方式定义主键索引，innodb为聚簇索引，语法：</p><ul><li>随表一起建索引：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) UNSIGNED AUTO_INCREMENT ,</span><br><span class="line">student_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">student_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>通过删除主键约束的方式删除主键索引：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc8-a05b-a310a56c263d-4"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test2(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">name <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span>,</span><br><span class="line">INDEX single_idx_name(name(<span class="number">20</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc8-a05b-a310a56c263d-5"><p>举例：创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test3(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">INDEX multi_idx(id,name,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在test3表中，查询id和name字段，使用EXPLAIN语句查看索引的使用情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test3 <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> name<span class="operator">=</span><span class="string">&#x27;songhongkang&#x27;</span> \G</span><br></pre></td></tr></table></figure><p>可以看到，查询id和name字段时，使用了名称为MultiIdx的索引，如果查询 (name, age) 组合或者单独查询name和age字段，会发现结果中possible_keys和key值为NULL, 并没有使用在t3表中创建的索引进行查询。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc8-a05b-a310a56c263d-6"><p>FULLTEXT全文索引可以用于全文检索，并且只为<code>CHAR</code>、<code>VARCHAR</code>和<code>TEXT</code>列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引。</p><p>举例1：创建表test4，在表中的info字段上建立全文索引，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test4(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">name <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><blockquote><p>在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。</p></blockquote><p>语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test4 \G</span><br></pre></td></tr></table></figure><p>由结果可以看到，info字段上已经成功建立了一个名为futxt_idx_info的FULLTEXT索引。</p><p>举例2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</span><br><span class="line">id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">title <span class="type">VARCHAR</span> (<span class="number">200</span>),</span><br><span class="line">body TEXT,</span><br><span class="line">FULLTEXT index (title, body)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB;</span><br></pre></td></tr></table></figure><p>创建了一个给title和body字段添加全文索引的表。</p><p>举例3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`papers`(</span><br><span class="line">`id`<span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`title`<span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`content`text,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">FULLTEXT KEY`title`(`title`,`content`)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>不同于like方式的的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> content <span class="keyword">LIKE</span> ‘<span class="operator">%</span>查询字符串<span class="operator">%</span>’;</span><br></pre></td></tr></table></figure><p>全文索引用match+against方式查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> papers <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure><p>明显的提高查询效率。</p><blockquote><p>注意点</p><ol><li>使用全文索引前，搞清楚版本支持情况；</li><li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li><li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引。</li></ol></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="36c85279-7f3e-4bc8-a05b-a310a56c263d-7"><p>空间索引创建中，要求空间类型的字段必须为 非空 。</p><p>举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test5(</span><br><span class="line">geo GEOMETRY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> test5 \G</span><br></pre></td></tr></table></figure><p>可以看到，test5表的geo字段上创建了名称为spa_idx_geo的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储引擎为MyISAM。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="2-2-在已经存在的表上创建索引">2.2 在已经存在的表上创建索引</h3><p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p><p><strong>1. 使用ALTER TABLE语句创建索引</strong><code>ALTER TABLE</code>语句创建索引的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 使用CREATE INDEX创建索引</strong><code>CREATE INDEX</code>语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="3-删除索引">3. 删除索引</h2><p><strong>1. 使用ALTER TABLE删除索引</strong><code>ALTER TABLE</code>删除索引的基本语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure><p><strong>2. 使用DROP INDEX语句删除索引</strong><code>DROP INDEX</code>删除索引的基本语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><blockquote><p>提示: 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。</p></blockquote><hr><h2 id="4-MySQL8-0索引新特性">4. MySQL8.0索引新特性</h2><h3 id="4-1-支持降序索引">4.1 支持降序索引</h3><p>降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引 (仅限于InnoDBc存储引擎)。</p><p>MySQL在<span class='p red'>8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。</span>在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。</p><p>举例：分别在MySQL 5.7版本和MySQL 8.0版本中创建数据表ts1，结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts1(a <span class="type">int</span>,b <span class="type">int</span>,index idx_a_b(a,b <span class="keyword">desc</span>));</span><br></pre></td></tr></table></figure><p>在MySQL 5.7版本中查看数据表ts1的结构，结果如下:</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220622224124267.png" alt="image-20220622224124267" style="zoom:50%;" /><p>从结果可以看出，索引仍然是默认的升序</p><p>在MySQL 8.0版本中查看数据表ts1的结构，结果如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220622224205048.png" alt="image-20220622224205048" style="zoom:50%;" /><p>从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本的数据表ts1中插入800条随机数据，执行语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ts_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">WHILE i <span class="operator">&lt;</span> <span class="number">800</span></span><br><span class="line">DO</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ts1 <span class="keyword">select</span> rand()<span class="operator">*</span><span class="number">80000</span>, rand()<span class="operator">*</span><span class="number">80000</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER;</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">CALL</span> ts_insert();</span><br></pre></td></tr></table></figure><p>在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ts1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> a, b <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>在MySQL 8.0版本中查看数据表 ts1 的执行计划。</p><p>从结果可以看出，修改后MySQL 5.7 的执行计划要明显好于MySQL 8.0。</p><hr><h3 id="4-2-隐藏索引">4.2 隐藏索引</h3><p>在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发展删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。</p><p>从MySQL 8.x开始支持<code>隐藏索引（invisible indexes）</code>，只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引）， 确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。 <span class='p green'>这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。</span></p><p>同时，如果你想验证某个索引删除之后的<code>查询性能影响</code>，就可以暂时先隐藏该索引。</p><blockquote><p>注意：</p><p>主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。</p></blockquote><p>索引默认是可见的，在使用CREATE TABLE, CREATE INDEX 或者 ALTER TABLE 等语句时可以通过<code>VISIBLE</code>或者<code>INVISIBLE</code>关键词设置索引的可见性。</p><div class="tabs" id="24d3db91-5b3b-48e6-badc-00cd6bf05142"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#24d3db91-5b3b-48e6-badc-00cd6bf05142-1"><i class="fas fa-bug"></i>创建表时创建</button></li><li class="tab"><button type="button" data-href="#24d3db91-5b3b-48e6-badc-00cd6bf05142-2"><i class="fas fa-cannabis"></i>在存在的表上创建</button></li><li class="tab"><button type="button" data-href="#24d3db91-5b3b-48e6-badc-00cd6bf05142-3"><i class="fas fa-candy-cane"></i>通过ALTER TABLE语句创建</button></li><li class="tab"><button type="button" data-href="#24d3db91-5b3b-48e6-badc-00cd6bf05142-4"><i class="fas fa-child"></i>切换索引可见状态</button></li><li class="tab"><button type="button" data-href="#24d3db91-5b3b-48e6-badc-00cd6bf05142-5"><i class="fas fa-dragon"></i>了解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="24d3db91-5b3b-48e6-badc-00cd6bf05142-1"><p>在MySQL中创建隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename(</span><br><span class="line">propname1 type1[CONSTRAINT1],</span><br><span class="line">propname2 type2[CONSTRAINT2],</span><br><span class="line">……</span><br><span class="line">propnamen typen,</span><br><span class="line">INDEX [indexname](propname1 [(length)]) INVISIBLE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="24d3db91-5b3b-48e6-badc-00cd6bf05142-2"><p>可以为已经存在的表设置隐藏索引，其语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX indexname</span><br><span class="line"><span class="keyword">ON</span> tablename(propname[(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="24d3db91-5b3b-48e6-badc-00cd6bf05142-3"><p>语法形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename</span><br><span class="line"><span class="keyword">ADD</span> INDEX indexname (propname [(length)]) INVISIBLE;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="24d3db91-5b3b-48e6-badc-00cd6bf05142-4"><p>已存在的索引可通过如下语句切换可见状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name INVISIBLE; #切换成隐藏索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename <span class="keyword">ALTER</span> INDEX index_name VISIBLE; #切换成非隐藏索引</span><br></pre></td></tr></table></figure><p>如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了index_cname索引。</p><blockquote><p>注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。</p></blockquote><p>通过设置隐藏索引的可见性可以查看索引对调优的帮助。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="24d3db91-5b3b-48e6-badc-00cd6bf05142-5"><blockquote><p><span class='p blue'>使隐藏索引对查询优化器可见(了解)</span></p></blockquote><p>在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关 (use_invisible_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果use_invisible_indexes 设置为off (默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计 划时仍会考虑使用隐藏索引。</p><p>（1）在MySQL命令行执行如下命令查看查询优化器的开关设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@optimizer</span>_switch \G</span><br></pre></td></tr></table></figure><p>在输出的结果信息中找到如下属性配置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes<span class="operator">=</span>off</span><br></pre></td></tr></table></figure><p>此属性配置值为off，说明隐藏索引默认对查询优化器不可见。</p><p>（2）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> session optimizer_switch<span class="operator">=</span>&quot;use_invisible_indexes=on&quot;;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>SQL语句执行成功，再次查看查询优化器的开关设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@optimizer</span>_switch \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">@<span class="variable">@optimizer</span>_switch:</span><br><span class="line">index_merge<span class="operator">=</span><span class="keyword">on</span>,index_merge_union<span class="operator">=</span><span class="keyword">on</span>,index_merge_sort_union<span class="operator">=</span><span class="keyword">on</span>,index_merge_</span><br><span class="line"><span class="keyword">intersection</span><span class="operator">=</span><span class="keyword">on</span>,engine_condition_pushdown<span class="operator">=</span><span class="keyword">on</span>,index_condition_pushdown<span class="operator">=</span><span class="keyword">on</span>,mrr<span class="operator">=</span><span class="keyword">on</span>,mrr_co</span><br><span class="line">st_based<span class="operator">=</span><span class="keyword">on</span>,block_nested_loop<span class="operator">=</span><span class="keyword">on</span>,batched_key_access<span class="operator">=</span>off,materialization<span class="operator">=</span><span class="keyword">on</span>,semijoin<span class="operator">=</span><span class="keyword">on</span></span><br><span class="line">,loosescan<span class="operator">=</span><span class="keyword">on</span>,firstmatch<span class="operator">=</span><span class="keyword">on</span>,duplicateweedout<span class="operator">=</span><span class="keyword">on</span>,subquery_materialization_cost_based<span class="operator">=</span><span class="keyword">on</span></span><br><span class="line">,use_index_extensions<span class="operator">=</span><span class="keyword">on</span>,condition_fanout_filter<span class="operator">=</span><span class="keyword">on</span>,derived_merge<span class="operator">=</span><span class="keyword">on</span>,use_invisible_ind</span><br><span class="line">exes<span class="operator">=</span><span class="keyword">on</span>,skip_scan<span class="operator">=</span><span class="keyword">on</span>,hash_join<span class="operator">=</span><span class="keyword">on</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>此时，在输出结果中可以看到如下属性配置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use_invisible_indexes<span class="operator">=</span><span class="keyword">on</span></span><br></pre></td></tr></table></figure><p>use_invisible_indexes属性的值为on，说明此时隐藏索引对查询优化器可见。</p><p>（3）使用EXPLAIN查看以字段invisible_column作为查询条件时的索引使用情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> classes <span class="keyword">where</span> cname <span class="operator">=</span> <span class="string">&#x27;高一2班&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查询优化器会使用隐藏索引来查询数据。</p><p>（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> session optimizer_switch<span class="operator">=</span>&quot;use_invisible_indexes=off&quot;;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>再次查看查询优化器的开关设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@optimizer</span>_switch \G</span><br></pre></td></tr></table></figure><p>此时，use_invisible_indexes属性的值已经被设置为“off”。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="5-索引的设计原则">5. 索引的设计原则</h2><p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。**索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。**高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。</p><h3 id="5-1-数据准备">5.1 数据准备</h3><div class="tabs" id="c29b67e3-fde9-4ad0-8300-aaf63d359cc9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c29b67e3-fde9-4ad0-8300-aaf63d359cc9-1"><i class="fas fa-award"></i>创建数据库、创建表</button></li><li class="tab"><button type="button" data-href="#c29b67e3-fde9-4ad0-8300-aaf63d359cc9-2"><i class="fas fa-baseball-ball"></i>创建模拟数据必需的存储函数</button></li><li class="tab"><button type="button" data-href="#c29b67e3-fde9-4ad0-8300-aaf63d359cc9-3"><i class="fas fa-bone"></i>创建插入模拟数据的存储过程</button></li><li class="tab"><button type="button" data-href="#c29b67e3-fde9-4ad0-8300-aaf63d359cc9-4"><i class="fas fa-anchor"></i>调用存储过程</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c29b67e3-fde9-4ad0-8300-aaf63d359cc9-1"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE atguigudb1;</span><br><span class="line">USE atguigudb1;</span><br><span class="line">#<span class="number">1.</span>创建学生表和课程表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`student_info`(</span><br><span class="line">`id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`student_id`<span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">`name`<span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`course_id`<span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">`class_id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`create_time`DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>`course`(</span><br><span class="line">`id`<span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`course_id`<span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">`course_name`<span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c29b67e3-fde9-4ad0-8300-aaf63d359cc9-2"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#函数<span class="number">1</span>：创建随机产生字符串函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_string(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">255</span>) #该函数会返回一个字符串</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span></span><br><span class="line"><span class="string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;</span> n DO</span><br><span class="line">    <span class="keyword">SET</span> return_str <span class="operator">=</span>CONCAT(return_str,<span class="built_in">SUBSTRING</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">52</span>),<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#函数<span class="number">2</span>：创建随机数函数</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> rand_num (from_num <span class="type">INT</span> ,to_num <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span>(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> <span class="built_in">FLOOR</span>(from_num <span class="operator">+</span>RAND()<span class="operator">*</span>(to_num <span class="operator">-</span> from_num<span class="operator">+</span><span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">RETURN</span> i;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>创建函数，假如报错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> DETERMINISTIC......</span><br></pre></td></tr></table></figure><p>由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。</p><p>主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使 用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。</p><ul><li>查看mysql是否允许创建函数：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin_trust_function_creators&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>命令开启：允许创建函数设置：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>; # 不加<span class="keyword">global</span>只是当前窗口有效。</span><br></pre></td></tr></table></figure><ul><li><p>mysqld重启，上述参数又会消失。永久方法：</p><ul><li>windows下：my.ini[mysqld]加上：</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>linux下：/etc/my.cnf下my.cnf[mysqld]加上：</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c29b67e3-fde9-4ad0-8300-aaf63d359cc9-3"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程<span class="number">1</span>：创建插入课程表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_course( max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course (course_id, course_name ) <span class="keyword">VALUES</span> (rand_num(<span class="number">10000</span>,<span class="number">10100</span>),rand_string(<span class="number">6</span>));</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 存储过程<span class="number">2</span>：创建插入学生信息表存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_stu( max_num <span class="type">INT</span> )</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>; #设置手动提交事务</span><br><span class="line">REPEAT #循环</span><br><span class="line"><span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>; #赋值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_info (course_id, class_id ,student_id ,NAME ) <span class="keyword">VALUES</span></span><br><span class="line">(rand_num(<span class="number">10000</span>,<span class="number">10100</span>),rand_num(<span class="number">10000</span>,<span class="number">10200</span>),rand_num(<span class="number">1</span>,<span class="number">200000</span>),rand_string(<span class="number">6</span>));</span><br><span class="line">UNTIL i <span class="operator">=</span> max_num</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">COMMIT</span>; #提交事务</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c29b67e3-fde9-4ad0-8300-aaf63d359cc9-4"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> insert_course(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">CALL</span> insert_stu(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="5-2-哪些情况适合创建索引">5.2 哪些情况适合创建索引</h3><div class="tabs" id="001b5ebd-73a5-4b51-9870-47614b415977"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-4"><i class="fas fa-tree"></i>4</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-5"><i class="fas fa-cat"></i>5</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-6"><i class="fas fa-horse"></i>6</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-7"><i class="fas fa-dove"></i>7</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-8"><i class="fas fa-dragon"></i>8</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-9"><i class="fas fa-atom"></i>9</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-10"><i class="far fa-sun"></i>10</button></li><li class="tab"><button type="button" data-href="#001b5ebd-73a5-4b51-9870-47614b415977-11"><i class="fas fa-wind"></i>11</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="001b5ebd-73a5-4b51-9870-47614b415977-1"><p><span class='p blue'>字段的数值有唯一性的限制</span></p><p>索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中， 如果<code>某个字段是唯一性的</code>，就可以直接创建<code>唯一性索引</code>，或者<code>主键索引</code>。这样可以更快速地通过该索引来确定某条记录。</p><p>例如，学生表中学号是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><blockquote><p>业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba） 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-2"><p><span class='p green'>频繁作为 WHERE 查询条件的字段</span></p><p>某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在 数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。</p><p>比如student_info数据表（含100万条数据），假设我们想要查询 student_id=123110 的用户信息。</p><p>如果我们没有对student_id字段创建索引，进行如下查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  course_id,class_id,name,create_time,student_id</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">  student_info</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  student_id <span class="operator">=</span> <span class="number">123110</span>;</span><br></pre></td></tr></table></figure><p>花费276ms</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#给student_id 索引后查询</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info <span class="keyword">ADD</span> INDEX idx_sid(student_id);</span><br></pre></td></tr></table></figure><p>花费40ms</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-3"><p><span class='p red'>经常 GROUP BY 和 ORDER BY 的列</span></p><p>索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要<code>对分组或者排序的字段进行索引</code>。如果待排序的列有多个，那么可以在这些列上建立<code>组合索引</code>。</p><p>比如，按照 student_id 对学生选修的课程进行分组，显示不同的 student_id 和课程数量，显示 100 个即可。</p><p>如果我们不对 student_id 创建索引，执行下面的 SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  student_id,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  student_info</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  student_id</span><br><span class="line">LIMIT</span><br><span class="line">  <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>花费 866ms</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#给student_id 索引后查询</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info <span class="keyword">ADD</span> INDEX idx_sid(student_id);</span><br></pre></td></tr></table></figure><p>花费 40ms</p><p>同样，如果是 ORDER BY，也需要对字段创建索引。</p><p>如果同时有 GROUP BY 和 ORDER BY 的情况：比如我们按照 student_id 进行分组，同时按照创建时间降序的方式进行排序，这时我们就需要同时进行 GROUP BY 和 ORDER BY，那么是不是需要单独创建 student_id 的索引和 create_time 的索引呢？</p><p>当我们对 student_id 和 create_time 分别都<code>创建索引</code>，执行下面的 SQL 查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  student_id,<span class="built_in">count</span>(<span class="operator">*</span>）<span class="keyword">as</span> num </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">  student_info </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> </span><br><span class="line">  student_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> </span><br><span class="line">  create_time <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">100</span>；</span><br></pre></td></tr></table></figure><p>发现只走了student_id 的索引 执行时间 5.212s</p><p>添加联合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info <span class="keyword">ADD</span> INDEX idx_sid_cre_time(student_id,create_time <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure><p>再执行查询  花费 0.257s</p><p>如果我们创建联合索引的顺序为(create_time, student_id) 呢？运行时间为 2.164s，因为在进行 SELECT 查询的时候，先进行 GROUP BY，再对数据进行 ORDER BY 的操作，所以按照 (student_id, create_time) 这个联合索引的顺序效率是最高的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-4"><p><span class='p blue'>UPDATE、DELETE 的 WHERE 条件列</span></p><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<span class='p red'>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</span></p><p>我们先看一下对数据进行 UPDATE 的情况：我们想要把 name 为ZDUPpf 对应的 student_id 修改为 10002，当我们没有对name 进行索引的时候，执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> </span><br><span class="line">  student_info </span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">  student_id <span class="operator">=</span> <span class="number">10002</span></span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  name <span class="operator">=</span><span class="string">&#x27;ZDUPpf&#x27;</span></span><br></pre></td></tr></table></figure><p>运行时间 0.84s</p><p>添加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#给name 索引后查询</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student_info <span class="keyword">ADD</span> INDEX idx_name(name);</span><br></pre></td></tr></table></figure><p>运行时间 0.036s</p><p>对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。<span class='p red'>如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-5"><p><span class='p green'>DISTINCT 字段需要创建索引</span></p><p>有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。</p><p>比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span>`student_info`;</span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间 0.683s ）</p><p>如果我们对 student_id 创建索引，再执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(student_id) <span class="keyword">FROM</span>`student_info`;</span><br></pre></td></tr></table></figure><p>运行结果（600637 条记录，运行时间 0.010s ）</p><p>你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照递增的顺序 进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-6"><p><span class='p red'>多表 JOIN 连接操作时，创建索引注意事项</span></p><p>首先，<code>连接表的数量尽量不要超过 3 张</code>，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。</p><p>其次，<code>对 WHERE 条件创建索引</code>，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。</p><p>最后，<code>对用于连接的字段创建索引</code>，并且该字段在多张表中的 类型必须一致 。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。</p><p>举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.course_id, name, s.student_id, c.course_name</span><br><span class="line"><span class="keyword">FROM</span> student_info s <span class="keyword">JOIN</span> course c</span><br><span class="line"><span class="keyword">ON</span> s.course_id <span class="operator">=</span> c.course_id</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;462eed7ac6e791292a79&#x27;</span>;</span><br></pre></td></tr></table></figure><p>运行结果（1 条数据，运行时间 0.189s ）</p><p>这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-7"><p><span class='p blue'>使用列的类型小的创建索引</span></p><p>我们这里所说的<code>类型大小</code>指的就是该类型表示的数据范围的大小。</p><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有<code>TINYINT</code>、<code>MEDTUMIN</code>T、<code>INT</code>、<code>BIGINT</code>等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT，能使用 MEDIUMINT 就不要使用 INT。这是因为：</p><ul><li><p>数据类型越小，在查询时进行的比较操作越快</p></li><li><p>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以<code>放下更多的记录</code>，从而减少磁盘I/0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</p></li></ul><p>这个建议对于表的<code>主键来说更加适用</code>，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/0。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-8"><p><span class='p green'>使用字符串前缀创建索引</span></p><p>假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题：</p><ul><li><p>B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，<code>在索引中占用的存储空间越大</code>。</p></li><li><p>如果B+树索引中索引列存储的字符串很长，那在做字符串<code>比较时会占用更多的时间</code>。</p></li></ul><p>我们可以通过截取字段的前面一部分内容建立索引，这个就叫<code>前缀索引</code>。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既<code>节约空间</code>，又<code>减少了字符串的比较时间</code>，还大体能解决排序的问题。</p><p>例如，TEXT和BL0G类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。</p><p>创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="type">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> shop <span class="keyword">add</span> index(address(<span class="number">12</span>));</span><br></pre></td></tr></table></figure><p>问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？</p><p>先看一下字段在全部数据中的选择度：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> address) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> shop</span><br></pre></td></tr></table></figure><p>通过不同长度去计算，与全表的选择性对比：</p><p>公式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(列名, 索引长度))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">10</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub10, <span class="comment">-- 截取前10个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">15</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub11, <span class="comment">-- 截取前15个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">20</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub12, <span class="comment">-- 截取前20个字符的选择度</span></span><br><span class="line"><span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">25</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub13 <span class="comment">-- 截取前25个字符的选择度</span></span><br><span class="line"><span class="keyword">from</span> shop;</span><br></pre></td></tr></table></figure><blockquote><p>越接近于1越好，说明越有区分度</p></blockquote><p><strong>引申另一个问题：索引列前缀对排序的影响</strong></p><p>如果使用了索引列前缀，比方说前边只把address列的<code>前12个字符</code>放到了二级索引中，下边这个查询可能就有点尴尬了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> shop</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> address</span><br><span class="line">LIMIT <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式<code>无法支持使用索引排序</code>，只能使用文件排序。</p><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【 强制 】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上 ，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-9"><p><span class='p red'>区分度高(散列性高)的列适合作为索引</span></p><p><code>列的基数</code>指的是某一列中不重复数据的个数，比方说某个列包含值<code>2, 5, 8, 2, 5, 8, 2, 5, 8</code>，虽然有<code>9</code>条记录，但该列的基数却是3。也就是说<code>在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。</code>这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列简历索引，为基数太小的列的简历索引效果可能不好。</p><p>可以使用公式<code>select count(distinct a) / count(*) from t1</code>计算区分度，越接近1越好，一般超过33%就算比较高效的索引了。</p><p>扩展：联合索引把区分度搞(散列性高)的列放在前面。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-10"><p><span class='p blue'>使用最频繁的列放到联合索引的左侧</span></p><p>这样也可以较少的建立一些索引。同时，由于&quot;最左前缀原则&quot;，可以增加联合索引的使用率。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="001b5ebd-73a5-4b51-9870-47614b415977-11"><p><span class='p green'>在多个字段都要创建索引的情况下，联合索引优于单值索引</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="5-3-限制索引的数目">5.3 限制索引的数目</h3><p>在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量<code>不超过6个</code>。原因：</p><p>◎ 每个索引都需要占用<code>磁盘空间</code>，索引越多，需要的磁盘空间就越大。</p><p>② 索引会影响<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。</p><p>③ 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的<code>索引來进行评估</code>，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。</p><hr><h3 id="5-4-哪些情况不适合创建索引">5.4 哪些情况不适合创建索引</h3><div class="tabs" id="854de219-f278-4797-adb3-a38373cae1e9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#854de219-f278-4797-adb3-a38373cae1e9-1"><i class="fas fa-baseball-ball"></i>2</button></li><li class="tab"><button type="button" data-href="#854de219-f278-4797-adb3-a38373cae1e9-2"><i class="fas fa-bone"></i>3</button></li><li class="tab"><button type="button" data-href="#854de219-f278-4797-adb3-a38373cae1e9-3"><i class="fas fa-anchor"></i>4</button></li><li class="tab"><button type="button" data-href="#854de219-f278-4797-adb3-a38373cae1e9-4"><i class="fas fa-fire-alt"></i>5</button></li><li class="tab"><button type="button" data-href="#854de219-f278-4797-adb3-a38373cae1e9-5"><i class="fas fa-bug"></i>6</button></li><li class="tab"><button type="button" data-href="#854de219-f278-4797-adb3-a38373cae1e9-6"><i class="fas fa-cannabis"></i>7</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="854de219-f278-4797-adb3-a38373cae1e9-1"><p><span class='p green'>数据量小的表最好不要使用索引</span></p><p>如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引<code>对查询效率的影响并不大</code>。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</p><p>举例：创建表1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_without_index(</span><br><span class="line">a <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">b <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>提供存储过程1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#创建存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> t_wout_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;=</span> <span class="number">900</span></span><br><span class="line">    DO</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_without_index(b) <span class="keyword">SELECT</span> RAND()<span class="operator">*</span><span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line"><span class="keyword">CALL</span> t_wout_insert()</span><br></pre></td></tr></table></figure><p>创建表2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_with_index(</span><br><span class="line">a <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">b <span class="type">INT</span>,</span><br><span class="line">INDEX idx_b(b)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建存储过程2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#创建存储过程</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> t_with_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> i <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">    WHILE i <span class="operator">&lt;=</span> <span class="number">900</span></span><br><span class="line">    DO</span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_with_index(b) <span class="keyword">SELECT</span> RAND()<span class="operator">*</span><span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line"><span class="keyword">CALL</span> t_with_insert();</span><br></pre></td></tr></table></figure><p>查询对比：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_without_index <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">9879</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> a    <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1242</span> <span class="operator">|</span> <span class="number">9879</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_with_index <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">9879</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span> a   <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">112</span> <span class="operator">|</span> <span class="number">9879</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>你能看到运行结果相同，但是在数据量不大的情况下，索引就发挥不出作用了。</p><blockquote><p>结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="854de219-f278-4797-adb3-a38373cae1e9-2"><p><span class='p red'>有大量重复数据的列上不要建立索引</span></p><p>在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的&quot;性别&quot;字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会<code>严重降低数据更新速度</code>。</p><p>举例1：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。</p><p>举例2：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。</p><p>学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student_gender(</span><br><span class="line">    student_id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    student_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    student_gender TINYINT(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(student_id)</span><br><span class="line">)ENGINE <span class="operator">=</span> INNODB;</span><br></pre></td></tr></table></figure><p>如果我们要筛选出这个学生表中的男性，可以使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student_gender <span class="keyword">WHERE</span> student_gender <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>结论：当数据重复度大，比如 高于 10% 的时候，也不需要对这个字段使用索引。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="854de219-f278-4797-adb3-a38373cae1e9-3"><p><span class='p blue'>避免对经常更新的表创建过多的索引</span></p><p>第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。</p><p>第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却降低更新表的速度。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="854de219-f278-4797-adb3-a38373cae1e9-4"><p><span class='p green'>不建议用无序的值作为索引</span></p><p>例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="854de219-f278-4797-adb3-a38373cae1e9-5"><p><span class='p red'>删除不再使用或者很少使用的索引</span></p><p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="854de219-f278-4797-adb3-a38373cae1e9-6"><p><span class='p blue'>不要定义夯余或重复的索引</span></p><p>① 冗余索引</p><p>举例：建表语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    birthday <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    phone_number <span class="type">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_name_birthday_phone_number (name(<span class="number">10</span>), birthday, phone_number),</span><br><span class="line">    KEY idx_name (name(<span class="number">10</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一 个专门针对 name 列的索引就算是一个冗余索引 ，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p><p>② 重复索引</p><p>另一种情况，我们可能会对某个列 重复建立索引 ，比方说这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> repeat_index_demo (</span><br><span class="line">col1 <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">col2 <span class="type">INT</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> uk_idx_c1 (col1),</span><br><span class="line">INDEX idx_c1 (col1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <blockquote><p>小结</p></blockquote><p>索引是一把<code>双刃剑</code>，可提高查询效率，但也会降低插入扣更新的速度并占用磁盘空间。</p><p>选择索引的最终目的是为了使查询的速度变快，上面给出的原则是最基本的准则，但不能拘泥于上面的准则，大家要在以后的学习和工作中进行不断的实践，根据应用的实际情况进行分析和判断，选择最合适的索引方式。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB数据存储结构</title>
      <link href="/posts/de6e5e9c.html"/>
      <url>/posts/de6e5e9c.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据库的存储结构-页">1. 数据库的存储结构:页</h2><p>索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的<code>存储引擎</code>负责对表中数据的读取和写入工作。</p><p>不同存储引擎中<code>存放的格式</code>一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。</p><p>由于<code>InnoDB</code>是MySQL的<code>默认存储引擎</code>，所以本章剖析InnoDB存储引擎的数据存储结构。</p><blockquote><span class='p green'>磁盘与内存交互基本单位:页</span></blockquote><p>InnoDB 将数据划分为若干个页，InnoDB中页的大小默认为<code>16KB</code>。</p><p>以<code>页</code>作为磁盘和内存之间交互的<code>基本单位</code>，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，<span class='p red'>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/0操作的最小单位是页。</span>一个页中可以存储多个行记录。</p><blockquote><p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次 I0 操作）只能处理一行数据，效率会非常低。</p></blockquote><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409152821598.png" alt="image-20230409152821598" style="zoom: 67%;" /><div class="tabs" id="9c4d584f-fd53-4896-a2da-0e2d42e4d72f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#9c4d584f-fd53-4896-a2da-0e2d42e4d72f-1"><i class="fas fa-cat"></i>页结构概述</button></li><li class="tab"><button type="button" data-href="#9c4d584f-fd53-4896-a2da-0e2d42e4d72f-2"><i class="fas fa-horse"></i>页的大小</button></li><li class="tab"><button type="button" data-href="#9c4d584f-fd53-4896-a2da-0e2d42e4d72f-3"><i class="fas fa-dove"></i>页的上层结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="9c4d584f-fd53-4896-a2da-0e2d42e4d72f-1"><p>页a、页b、页c…页n 这些页可以<code>不在物理结构上相连</code>，只要通过<code>双向链表</code>相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个<code>单向链表</code>，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中<code>使用二分法</code>快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9c4d584f-fd53-4896-a2da-0e2d42e4d72f-2"><p>不同的数据库管理系统（简称DBMS）的页大小不同。比如在 MySQL 的 InnoDB 存储引擎中，默认页的大小是<code>16KB</code>，我们可以通过下面的命令来进行查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span></span><br></pre></td></tr></table></figure><p>SQL Server 中页的大小为<code>8KB</code>，而在 Oracle 中我们用术语 “<code>块</code>” （Block）来表示 “页”，Oracle 支持的块大小为2KB, 4KB, 8KB, 16KB, 32KB 和 64KB。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9c4d584f-fd53-4896-a2da-0e2d42e4d72f-3"><p>另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409151428168.png" alt="image-20230409151428168" style="zoom:50%;" /><p>区（Extent）是比页大一级的存储结构，在 InnoDB 存储引擎中，一个区会分配<code>64 个连续的页</code>。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是64*16KB=<code>1MB</code>。</p><p>段(Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB 中是连续的 64个页）， 不过在段中不要求区与区之间是相邻的。<code>段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在</code>。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。</p><p>表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>、<code>用户表空间</code>、<code>撤销表空间</code>、<code>临时表空间</code>等。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-页的内部结构">2. 页的内部结构</h2><p>页如果按类型划分的话，常见的有<code>数据页（保存B+树节点）、系统表、Undo 页 和 事务数据页</code>等。数据页是我们最常使用的页。</p><p>数据页的<code>16KB</code>大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page Header）、最大最小记录（Infimum + supremum）、用户记录（User Records）、空闲空间（Free Space）、页目录（Page Directory）和文件尾（File Tailer）。</p><p>页结构的示意图如下所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617195012446.png" alt="image-20220617195012446" style="float: right; zoom: 75%;margin-top:85px;" /> <table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">占用大小</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">File Header</td><td style="text-align:center">38字节</td><td style="text-align:center">文件头，描述页的信息</td></tr><tr><td style="text-align:center">Page Header</td><td style="text-align:center">56字节</td><td style="text-align:center">页头，页的状态信息</td></tr><tr><td style="text-align:center">Infimum + Supremum</td><td style="text-align:center">26字节</td><td style="text-align:center">最大和最小记录，这是两个虚拟的行记录</td></tr><tr><td style="text-align:center">User Records</td><td style="text-align:center">不确定</td><td style="text-align:center">用户记录，存储行记录内容</td></tr><tr><td style="text-align:center">Free Space</td><td style="text-align:center">不确定</td><td style="text-align:center">空闲记录，页中还没有被使用的空间</td></tr><tr><td style="text-align:center">Page Directory</td><td style="text-align:center">不确定</td><td style="text-align:center">页目录，存储用户记录的相对位置</td></tr><tr><td style="text-align:center">File Trailer</td><td style="text-align:center">8字节</td><td style="text-align:center">文件尾，校验页是否完整</td></tr></tbody></table><p>我们可以把这7个结构分为3个部分。</p><h3 id="2-1-第一部分">2.1 第一部分</h3><p>首先是文件通用部分，也就是File Header (文件头) 和 File Trailer (文件尾)。<div class="tabs" id="49833921-320e-41f6-8b41-d7d62c2cd0e3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#49833921-320e-41f6-8b41-d7d62c2cd0e3-1"><i class="fas fa-seedling"></i>File Header</button></li><li class="tab"><button type="button" data-href="#49833921-320e-41f6-8b41-d7d62c2cd0e3-2"><i class="fas fa-cannabis"></i>几个比较重要的属性</button></li><li class="tab"><button type="button" data-href="#49833921-320e-41f6-8b41-d7d62c2cd0e3-3"><i class="fas fa-leaf"></i>File Trailer</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="49833921-320e-41f6-8b41-d7d62c2cd0e3-1"><p>作用：</p><p>描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）</p><p>大小：38字节</p><p>构成：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">占用空间大小</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">FIL_PAGE_SPACE_OR_CHKSUM</td><td style="text-align:center">4字节</td><td style="text-align:center">页的校验和 (checksum值）</td></tr><tr><td style="text-align:center">FIL_PAGE_OFFSET</td><td style="text-align:center">4字节</td><td style="text-align:center">页号</td></tr><tr><td style="text-align:center">FIL_PAGE_ PREV</td><td style="text-align:center">4字节</td><td style="text-align:center">上一个页的页号</td></tr><tr><td style="text-align:center">FIL_PAGE_NEXT</td><td style="text-align:center">4字节</td><td style="text-align:center">下一个页的页号</td></tr><tr><td style="text-align:center">FIL_ PAGE_ LSN</td><td style="text-align:center">8字节</td><td style="text-align:center">页面被最后修改时对应的日志序列位置</td></tr><tr><td style="text-align:center">FIL_PAGE_TYPE</td><td style="text-align:center">2字节</td><td style="text-align:center">该页的类型</td></tr><tr><td style="text-align:center">FIL_ PAGE_FILE_ FLUSH_LSN</td><td style="text-align:center">8字节</td><td style="text-align:center">仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td style="text-align:center">FIL_PAGE_ARCH_LOG_ NO_OR_SPACE_ID</td><td style="text-align:center">4字节</td><td style="text-align:center">页属于哪个表空间</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="49833921-320e-41f6-8b41-d7d62c2cd0e3-2"><blockquote><p>FIL_PAGE_SPACE_OR_CHKSUM</p></blockquote><p>校验和（checksum）。 什么是校验和？就是对于一个很长的字节串来说，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。在比较两个很长的字节串之前，先比较这两个长字节串的校验和，如果校验和都不一样，则两个长字节串肯定是不同的，所以省去了直接比较两个比较长的字节串的时间损耗。 文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM 作用：InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum 值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。</p><p>具体的：每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，二者不同则意味着同步中间出了错。这里，校验方式就是采用 Hash 算法进行校验。</p><blockquote><p>FIL_PAGE_TYPE</p></blockquote><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409163530049.png" alt="image-20230409163530049"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="49833921-320e-41f6-8b41-d7d62c2cd0e3-3"><p>8个字节</p><ul><li><p>前4个字节代表页的校验和：</p><p>这个部分是和File Header中的校验和相对应的。</p></li><li><p>后4个字节代表页面被最后修改时对应的日志序列位置（LSN)：</p><p>这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h3 id="2-2-第二部分">2.2 第二部分</h3><p>第二个部分是记录部分，页的主要作用是存储记录，所以“最大和最小记录”和“用户记录”部分占了页结构的主要空间。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409163754316.png" alt="image-20230409163754316" style="zoom:50%;" /><div class="tabs" id="81a654d0-8167-4513-81b1-bb54eb07e29c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#81a654d0-8167-4513-81b1-bb54eb07e29c-1"><i class="fas fa-bug"></i>空闲空间</button></li><li class="tab"><button type="button" data-href="#81a654d0-8167-4513-81b1-bb54eb07e29c-2"><i class="fas fa-cannabis"></i>用户记录</button></li><li class="tab"><button type="button" data-href="#81a654d0-8167-4513-81b1-bb54eb07e29c-3"><i class="fas fa-candy-cane"></i>最大最小记录</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="81a654d0-8167-4513-81b1-bb54eb07e29c-1"><p>我们自己存储的记录会按照指定的<code>行格式</code>存储到<code>User Records</code>部分。但是在一开始生成页的时候，其实并没有User Records这个部分，<span class='p green'>每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分</span>，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409164404762.png" alt="image-20230409164404762"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="81a654d0-8167-4513-81b1-bb54eb07e29c-2"><p>User Records中的这些记录按照<code>指定的行格式</code>一条一条摆在User Records部分，相互之间形成<code>单链表</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="81a654d0-8167-4513-81b1-bb54eb07e29c-3"><p><span class='p red'>记录可以比较大小吗？</span></p><p>是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。</p><p>InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的，如图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409171901669.png" alt="image-20230409171901669"></p><p>这两条记录不是我们自己定义的记录，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-3-第三部分">2.3 第三部分</h3><h4 id="2-3-1-Page-Directory-页目录">2.3.1 Page Directory 页目录</h4><p>为什么需要页目录？</p><p>在页中，记录是以<code>单向链表</code>的形式进行存储的。单向链表的特点就是插入、删除非常方便 ，但是<code>检索效率不高</code>，最差的情记下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，<span class='p red'>专门给记录做一个目录</span>，通过<code>二分查找法</code>的方式进行检索，提升效率。</p><p>页目录如何实现快速查找呢？</p><p><code>SELECT * FROM page_demo WHERE c1 = 3;</code></p><ol><li><p>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</p></li><li><p>第1组，也就是最小记录所在的分组只有 1个记录；<br>最后一组，就是最大记录所在的分组，会有1-8 条记录：<br>其余的组记录数量在 4-8 条之间。</p><p>这样做的好处是，除了第 1组（最小记录所在组）以外，其余组的记录数会<span class='p blue'>尽量平分</span>。</p></li><li><p>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</p></li><li><span class='p blue'>页目录用来存储每组最后一条记录的地址偏移量</span>，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为<span class='p blue'>槽（slot）</span>，每个槽相当于指针指向了不同组的最后一个记录。</li></ol><p>现在向page_demo表中添加更多的数据。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">5</span>, <span class="number">500</span>, <span class="string">&#x27;zhou&#x27;</span>), (<span class="number">6</span>, <span class="number">600</span>, <span class="string">&#x27;chen&#x27;</span>), (<span class="number">7</span>, <span class="number">700</span>, <span class="string">&#x27;deng&#x27;</span>), (<span class="number">8</span>, <span class="number">800</span>, <span class="string">&#x27;yang&#x27;</span>), (<span class="number">9</span>, <span class="number">900</span>, <span class="string">&#x27;wang&#x27;</span>), (<span class="number">10</span>, <span class="number">1000</span>, <span class="string">&#x27;zhao&#x27;</span>), (<span class="number">11</span>, <span class="number">1100</span>, <span class="string">&#x27;qian&#x27;</span>), (<span class="number">12</span>, <span class="number">1200</span>, <span class="string">&#x27;feng&#x27;</span>), (<span class="number">13</span>, <span class="number">1300</span>, <span class="string">&#x27;tang&#x27;</span>), (<span class="number">14</span>, <span class="number">1400</span>, <span class="string">&#x27;ding&#x27;</span>), (<span class="number">15</span>, <span class="number">1500</span>, <span class="string">&#x27;jing&#x27;</span>), (<span class="number">16</span>, <span class="number">1600</span>, <span class="string">&#x27;quan&#x27;</span>);</span><br></pre></td></tr></table></figure><p>添加了12条记录，现在页里一共有18条记录了（包括最小和最大记录），这些记录被分成了5个组，如图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409175556862.png" alt="image-20230409175556862" style="zoom:67%;" /><p>这里只保留了16条记录的记录头信息中的n_owned和next_record属性，省略了各个记录之间的箭头。现在看怎么从这个页目录中查找记录。</p><p>因为各个槽代表的记录的主键值都是从小到大排序的，所以我们可以使用二分法来进行快速查找。5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。</p><p>比方说我们想找主键值为6的记录，过程是这样的：</p><ol><li>计算中间槽的位置：(0+4)/2=2，所以查看槽2对应记录的主键值为8，又因为8 &gt; 6，所以设置high=2，low保持不变。</li><li>重新计算中间槽的位置：(0+2)/2=1，所以查看槽1对应的主键值为4，又因为4 &lt; 6，所以设置low=1，high保持不变。</li><li>因为high - low的值为1，所以确定主键值为6的记录在槽2对应的组中。此刻我们需要找到槽2中主键值最小的那条记录，然后沿着单向链表遍历槽2中的记录。</li></ol><p>但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽2对应的记录是主键值为8的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到槽1对应的记录（主键值为4），该条记录的下一条记录就是槽2中主键值最小的记录，该记录的主键值为5。所以我们可以从这条主键值为5的记录出发，遍历槽2中的各条记录，直到找到主键值为6的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以遍历一个组中的记录的代价是很小的。</p><p>小结：在一个数据页中查找指定主键值的记录的过程分为两步：1. 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。2. 通过记录的next_record属性遍历该槽所在的组中的各个记录。</p><hr><h4 id="2-3-2-Page-Header-页面头部">2.3.2 Page Header 页面头部</h4><p>为了能得到一个数据页中存储的记录的状态信息，比如本页中己经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409180014674.png" alt="image-20230409180014674" style="zoom:67%;" /><hr><h2 id="3-从数据库页角度看B-树如何查询">3. 从数据库页角度看B+树如何查询</h2><p>一颗B+树按照字节类型可以分为两部分：</p><ol><li>叶子节点，B+ 树最底层的节点，节点的高度为0，存储行记录。</li><li>非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220620221112635.png" alt="image-20220620221112635"></p><p>当我们从页结构来理解 B+ 树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：</p><span class='p red'>1. B+ 树是如何进行记录检索的？</span><p>如果通过 B+ 树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽（slot）采用<code>二分查找</code>的方式先找到一个粗略的记录分组， 然后再在分组中通过<code>链表遍历</code>的方式查找记录。</p><span class='p red'>2.普通索引和唯一索引在查询效率上有什么不同？</span><p>我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？</p><p>唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB 存储引|擎的页大小为 16KB，在一个页中可能存储着上干个记录，因此在普通索引的字段上进行查找也就是在内存中多几次&quot;判断下一条记录”的操作， 对于 CPU 来说，这些操作所消耗的时间是可以忽路不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。</p><hr><h2 id="4-InnoDB行格式">4. InnoDB行格式</h2><p>我们平时的数据以行为单位来向表中插入数据，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。</p><p>InnoDB存储引擎设计了4种不同类型的行格式，分别是<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>和<code>Compressed</code>行格式。</p><p>查看MySQL8的默认行格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@innodb</span>_default_row_format;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@innodb</span>_default_row_format         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">dynamic</span>                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec) </span><br></pre></td></tr></table></figure><p>也可以使用如下语法查看具体表使用的行格式：<code>SHOW TABLE STATUS like '表名'\G </code></p><p><span id="jump"></span></p><hr><h3 id="4-1-记录头信息">4.1 记录头信息</h3><blockquote><span class='p blue'>先来看看四种不同类型的行格式中都含有的-记录头信息</span></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_demo( </span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span>     c1 <span class="type">INT</span>,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span>     c2 <span class="type">INT</span>,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span>     c3 <span class="type">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">PRIMARY</span> KEY (c1))</span><br><span class="line">CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>Compact;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec) </span><br></pre></td></tr></table></figure><p>这个表中记录的行格式示意图：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409165644134.png" alt="image-20230409165644134" style="zoom:50%;" /><span class='p green'>简化后的行格式示意图：</span><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409165817074.png" alt="image-20230409165817074" style="zoom:50%;" /><p>插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">100</span>, &quot;song&quot;),</span><br><span class="line">(<span class="number">2</span>, <span class="number">200</span>, &quot;tong&quot;),</span><br><span class="line">(<span class="number">3</span>, <span class="number">300</span>, &quot;zhan&quot;),</span><br><span class="line">(<span class="number">4</span>, <span class="number">400</span>, &quot;isi&quot;);</span><br></pre></td></tr></table></figure><p>图示如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409170119841.png" alt="image-20230409170119841" style="zoom:67%;" /><p>这些记录头信息中各个属性如下：</p><div class="tabs" id="ce6e463d-7384-4053-be86-c9941aac665b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ce6e463d-7384-4053-be86-c9941aac665b-1"><i class="fas fa-award"></i>属性</button></li><li class="tab"><button type="button" data-href="#ce6e463d-7384-4053-be86-c9941aac665b-2"><i class="fas fa-baseball-ball"></i>delete_mask</button></li><li class="tab"><button type="button" data-href="#ce6e463d-7384-4053-be86-c9941aac665b-3"><i class="fas fa-bone"></i>min-rec_mask</button></li><li class="tab"><button type="button" data-href="#ce6e463d-7384-4053-be86-c9941aac665b-4"><i class="fas fa-anchor"></i>record_type</button></li><li class="tab"><button type="button" data-href="#ce6e463d-7384-4053-be86-c9941aac665b-5"><i class="fas fa-bug"></i>heap_no</button></li><li class="tab"><button type="button" data-href="#ce6e463d-7384-4053-be86-c9941aac665b-6"><i class="fas fa-cannabis"></i>next_record</button></li><li class="tab"><button type="button" data-href="#ce6e463d-7384-4053-be86-c9941aac665b-7"><i class="fas fa-seedling"></i>添加删除</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ce6e463d-7384-4053-be86-c9941aac665b-1"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">大小</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">预留位1</td><td style="text-align:center">1bit</td><td style="text-align:center">没有使用</td></tr><tr><td style="text-align:center">预留位2</td><td style="text-align:center">1bit</td><td style="text-align:center">没有使用</td></tr><tr><td style="text-align:center">delete_mask</td><td style="text-align:center">1bit</td><td style="text-align:center">标记该记录是否被删除</td></tr><tr><td style="text-align:center">min-rec_mask</td><td style="text-align:center">1bit</td><td style="text-align:center">B+树的每层非叶子节点中的最小记录都会添加该标记</td></tr><tr><td style="text-align:center">n_owned</td><td style="text-align:center">4bits</td><td style="text-align:center">表示当前记录拥有的记录数</td></tr><tr><td style="text-align:center">heap_no</td><td style="text-align:center">13bits</td><td style="text-align:center">表示当前记录在记录堆的位置信息</td></tr><tr><td style="text-align:center">record_type</td><td style="text-align:center">3bits</td><td style="text-align:center">表示当前记录的类型</td></tr><tr><td style="text-align:center">next_record</td><td style="text-align:center">16bits</td><td style="text-align:center">表示下一条记录的相对位置</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ce6e463d-7384-4053-be86-c9941aac665b-2"><p>这个属性标记着当前记录是否被删除，占用1个二进制位。</p><ul><li><p>值为0：代表记录并没有被删除</p></li><li><p>值为1：代表记录被删除掉了</p></li></ul><p><span class='p red'>被删除的记录为什么还在页中存储呢？</span></p><p>你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除是因为移除它们之后其他的记录在磁盘上需要<code>重新排列，导致性能消耗</code>。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的<code>垃圾链表</code>，在这个链表中的记录占用的空间称之为<code>可重用空间</code>，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ce6e463d-7384-4053-be86-c9941aac665b-3"><p>B+树的每层非叶子节点中的最小记录都会添加该标记，min_rec_mask值为1。</p><p>我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ce6e463d-7384-4053-be86-c9941aac665b-4"><p>这个属性表示当前记录的类型，一共有4种类型的记录：</p><p>0：表示普通记录</p><p>1：表示B+树非叶节点记录</p><p>2：表示最小记录</p><p>3：表示最大记录</p><p>从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的record_type值都是0，而最小记录和最大记录的record_type值分别为2和3。至于record_type为1的情況，我们在索引的数据结构章节讲过。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ce6e463d-7384-4053-be86-c9941aac665b-5"><p>这个属性表示当前记录在本页中的位置。</p><p>从图中可以看出来，我们插入的4条记录在本页中的位置分别是：2、3、4、5。</p><p><span class='p red'>怎么不见heap_no值为0和1的记录呢？</span></p><p>MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录 ，最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409172134138.png" alt="image-20230409172134138"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ce6e463d-7384-4053-be86-c9941aac665b-6"><p>记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的<span class='p red'>地址偏移量</span>。</p><p>比如：第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。</p><p>注意，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定Infimum记录（也就是最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）。下图用箭头代替偏移量表示next_record。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409172406642.png" alt="image-20230409172406642"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ce6e463d-7384-4053-be86-c9941aac665b-7"><div class="tabs" id="70d723f3-2c00-4b25-a70b-7a274858ff57"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#70d723f3-2c00-4b25-a70b-7a274858ff57-1"><i class="fas fa-cat"></i>删除操作</button></li><li class="tab"><button type="button" data-href="#70d723f3-2c00-4b25-a70b-7a274858ff57-2"><i class="fas fa-horse"></i>添加操作</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="70d723f3-2c00-4b25-a70b-7a274858ff57-1"><p>从表中删除掉一条记录，这个链表也是会跟着变化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> page_demo <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec) </span><br></pre></td></tr></table></figure><p>删掉第2条记录后的示意图就是：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409172641654.png" alt="image-20230409172641654" style="zoom:67%;" /><p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p><ul><li><p>第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask值设置为1。</p></li><li><p>第2条记录的next_record值变为了0，意味着该记录没有下一条记录了。</p></li><li><p>第1条记录的next_record指向了第3条记录。</p></li><li><p>最大记录的n_owned值从5 变成了 4。</p></li></ul><p>所以，不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表链表中的各个节点是按照主键值由小到大的顺序连接起来的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="70d723f3-2c00-4b25-a70b-7a274858ff57-2"><p>主键值为2的记录被我们删掉了，但是存储空间却没有回收，如果我们再次把这条记录插入到表中，会发生什么事呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">200</span>, <span class="string">&#x27;tong&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>我们看一下记录的存储情况：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409173114316.png" alt="image-20230409173114316" style="zoom:67%;" /><p>直接复用了原来被删除记录的存储空间。</p><p>说明：</p><p>当数据页中存在多条被删除掉的记录时，这些记录的next_record属性将会把这些被删除掉的记录组成一个垃圾链表，以备之后重用这部分存储空间。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="4-2-Compact">4.2 Compact</h3><div class="tabs" id="12e24f34-fb99-424f-88d2-97607ea35cc0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#12e24f34-fb99-424f-88d2-97607ea35cc0-1"><i class="fas fa-award"></i>Compact</button></li><li class="tab"><button type="button" data-href="#12e24f34-fb99-424f-88d2-97607ea35cc0-2"><i class="fas fa-baseball-ball"></i>变成字段长度列表</button></li><li class="tab"><button type="button" data-href="#12e24f34-fb99-424f-88d2-97607ea35cc0-3"><i class="fas fa-bone"></i>NULL值列表</button></li><li class="tab"><button type="button" data-href="#12e24f34-fb99-424f-88d2-97607ea35cc0-4"><i class="fas fa-anchor"></i>记录头信息</button></li><li class="tab"><button type="button" data-href="#12e24f34-fb99-424f-88d2-97607ea35cc0-5"><i class="fas fa-candy-cane"></i>真实数据</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="12e24f34-fb99-424f-88d2-97607ea35cc0-1"><p>在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409192626770.png" alt="image-20230409192626770" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="12e24f34-fb99-424f-88d2-97607ea35cc0-2"><p>MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型， BLOB类型，这些数据类型修饰列称为<span class='p red'>变长字段</span>，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。<span class='p red'>在 Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位从而形成一个变长字段长度列表。</span></p><p>注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。</p><p>以record_test_table表中的第一条记录举例：因为record_test_table表的col1、 col2、col4列都是VARCHAR(8)类型的，所以这三个列的值的长度都需要保存在记录开头处，注意record_test_table表中的各个列都使用的是asci字符集（每个字符只需要 1个字节来进行编码）。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409194639922.png" alt="image-20230409194639922" style="zoom:50%;float: right;margin-top:30px;" /><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">存储内容</th><th style="text-align:center">内容长度(十进制表示)</th><th style="text-align:center">内容长度(十六进制表示)</th></tr></thead><tbody><tr><td style="text-align:center">col1</td><td style="text-align:center">‘zhangsan’</td><td style="text-align:center">8</td><td style="text-align:center">0x08</td></tr><tr><td style="text-align:center">col2</td><td style="text-align:center">‘lisi’</td><td style="text-align:center">4</td><td style="text-align:center">ox04</td></tr><tr><td style="text-align:center">col4</td><td style="text-align:center">‘songhk’</td><td style="text-align:center">6</td><td style="text-align:center">0x06</td></tr></tbody></table><p>又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：</p><p>06 04 08</p><p>把这个字节串组成的变长字段长度列表填入上边的示意图中的效果就是：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409194924706.png" alt="image-20230409194924706"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="12e24f34-fb99-424f-88d2-97607ea35cc0-3"><p>Compact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。</p><p>如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。</p><p><span class='p red'>为什么定义NULL值列表？</span></p><p>之所以要存储NULL是因为数据都是需要对齐的，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：</p><ol><li><p>二进制位的值为1时，代表该列的值为NULL。</p></li><li><p>二进制位的值为0时，代表该列的值不为NULL。</p></li></ol><p>例如：字段 a、b、c，其中a是主键，在某一行中存储的数依次是 a=1、 b=null、 c=2。</p><p>那么Compact行格式中的NULL值列表中存储：01。第一个0表示c不为null，第二个1表示b是null。这里之所以没有a是因为数据库会自动跳过主键，因为主键肯定是非NULL且唯一的，在NULL值列表的数据中就会自动跳过主键。</p><p>record_test_table的两条记录的NULL值列表就如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409195734964.png" alt="image-20230409195734964" style="zoom: 50%;" /><blockquote><p>注意：InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，不足 8 位，要在高位补 0。</p><p>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。</p><p>「NULL 值列表」的空间不是固定 1 字节的。当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="12e24f34-fb99-424f-88d2-97607ea35cc0-4"><p><a href="#jump">点击跳转↑↑↑↑</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="12e24f34-fb99-424f-88d2-97607ea35cc0-5"><p>记录的真实数据除了我们自己定义的列的数据以外，还会有三个隐藏列：</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>transaction _id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>rollpointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>实际上这几个列的真正名称其实是：<code>DB_ROW_ID</code>、<code>DB_TRX_ID</code>、<code>DB_ROLL_PTR</code>。</p><ul><li><p>一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。</p></li><li><p>事务ID和回滚指针在后面的《MySQL事务日志》章节中讲解。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="4-3-行溢出">4.3 行溢出</h3><p>大体与Compact格式相同</p><blockquote><p>行溢出</p></blockquote><span class='p red'>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</span><p>很多DBA喜欢MySQL数据库提供的VARCHAR(M)类型，认为可以存放65535字节。这是真的吗？如果我们使用 ascii字符集的话，一个字符就代表一个字节，我们看看VARCHAR(65535)是否可用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo</span><br><span class="line">( c <span class="type">VARCHAR</span>(<span class="number">65535</span>) ) </span><br><span class="line">CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>Compact;</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1118</span> (<span class="number">42000</span>): <span class="type">Row</span> size too large. The maximum <span class="type">row</span> size <span class="keyword">for</span> the used <span class="keyword">table</span> type, <span class="keyword">not</span> counting BLOBs, <span class="keyword">is</span> <span class="number">65535.</span> This includes storage overhead, <span class="keyword">check</span> the manual. You have <span class="keyword">to</span> change <span class="keyword">some</span> columns <span class="keyword">to</span> TEXT <span class="keyword">or</span> BLOBs </span><br></pre></td></tr></table></figure><p>报错信息表达的意思是：MySQL对一条记录占用的最大存储空间是有限制的，除BLOB或者TEXT类型的列之外， 其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。</p><p>这个65535个字节除了列本身的数据之外，还包括一些其他的数据，以Compact行格式为例，比如说我们为了存储一个VARCHAR(M)类型的列，除了真实数据占有空间以外，还需要记录的额外信息。</p><p>如果该VARCHAR类型的列没有NOT NULL属性，那最多只能存储65532个字节的数据，因为变长字段的长度占用 2个字节，NULL值标识需要占用1个字节。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> varchar_size_demo( </span><br><span class="line">  c <span class="type">VARCHAR</span>(<span class="number">65532</span>)) </span><br><span class="line">  CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>Compact; </span><br></pre></td></tr></table></figure><p>通过上面的案例，我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为<span class='p red'>行溢出</span>。</p><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行<span class='p red'>分页存储</span>，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为页的扩展，举例如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409205048398.png" alt="image-20230409205048398" style="zoom:50%;" /><hr><h3 id="4-4-Dynamic和Compressed">4.4 Dynamic和Compressed</h3><p>在MySQL 8.0中，默认行格式就是Dynamic, Dynamic、Compressed行格式和 Compact行格式挺像，只不过在处理行溢出数据时有分歧：</p><ul><li><p>Compressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中。</p></li><li><p>Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放 768个前缀字节）。</p></li></ul><p>Compressed行记录格式的另一个功能就是，存储在其中的行数据会以zlib的算法进行压缩，因此对于BLOB、 TEXT、VARCHAR这类大长度类型的数据能够进行非常有效的存储。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409205517998.png" alt="image-20230409205517998"></p><hr><h3 id="4-5-Redundant">4.5 Redundant</h3><p>Redundant是MySQL 5.0版本之前InnoDB的行记录存储方式，MySQL 5.0支持 Redundant是为了兼容之前版本的页格式。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409205743540.png" alt="image-20230409205743540" style="zoom: 50%;" /><p>从上图可以看到，不同于Compact行记录格式，Redundant行格式的首部是一个字段长度偏移列表，同样是按照列的顺序<span class='p red'>逆序放置</span>的。</p><p>下边我们从各个方面看一下Redundant行格式有什么不同的地方。</p><p>注意Compact行格式的开头是变长字段长度列表，而Redundant行格式的开头是字段长度偏移列表，与变长字段长度列表有两处不同：</p><ul><li><p>少了“变长”两个字：Redundaht行格式会把该条记录中所有列（包括隐藏列）的长度信息都按照逆序存储到字段长度偏移列表。</p></li><li><p>多了“偏移”两个字：这意味着计算列值长度的方式不像Compact行格式那么直观 ，它是采用两个相邻数值的差值来计算各个列值的长度。</p></li></ul><hr><h2 id="5-区、段与碎片区">5. 区、段与碎片区</h2><div class="tabs" id="e91a6832-e47d-42ac-a2f5-db18557a06f9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e91a6832-e47d-42ac-a2f5-db18557a06f9-1"><i class="fas fa-atom"></i>为什么要有区？</button></li><li class="tab"><button type="button" data-href="#e91a6832-e47d-42ac-a2f5-db18557a06f9-2"><i class="far fa-sun"></i>为什么要有段？</button></li><li class="tab"><button type="button" data-href="#e91a6832-e47d-42ac-a2f5-db18557a06f9-3"><i class="fas fa-wind"></i>为什么要有碎片区？</button></li><li class="tab"><button type="button" data-href="#e91a6832-e47d-42ac-a2f5-db18557a06f9-4"><i class="fas fa-fire-alt"></i>区的分类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e91a6832-e47d-42ac-a2f5-db18557a06f9-1"><p><code>B+</code>树的每一层中的页都会形成一个双向链表，如果是<code>以页为单位</code>来分配存储空间的话，双向链表相邻的两个页之问的<code>物理位置可能离得非常远</code>。我们介绍B+树泰引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远， 就是所谓的<code>随机I/0</code>。再一次强调，磁盘的速度和内存的速度差了好几个数量级，<code>随机I/0是非常慢</code>的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I/0。</p><p>引入<code>区</code>的概念，一个区就是在物理位置上连续的<code>64个页</code>。因为 InnoDB 中的页大小默认是 16KB， 所以一个区的大小是 64 16KB=<code>1MB</code>。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/0，功大于过！</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e91a6832-e47d-42ac-a2f5-db18557a06f9-2"><p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分<code>叶子节点</code>和<code>非叶子节点</code>，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以 InnoDB 对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个<code>段（segment）</code>，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个<code>叶子节点段</code>，一个<code>非叶子节点段</code>。</p><p>除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有<code>数据段</code>、<code>索引段</code>、<code>回滚段</code>。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。</p><p>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。</p><p>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e91a6832-e47d-42ac-a2f5-db18557a06f9-3"><p>默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M(64* 16Kb =1024Kb）存储空间，所以<span class='p red'>默认情况下一个只存了几条记录的小表也需要2M的存储空间么？</span>以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常<code>纯粹</code>的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。</p><p>为了考虑以完整的区为单位分配给某个段对于<code>数据量较小</code>的表太浪费存储空间的这种情况，InnoDB提出了一个<code>碎片（fragment）区</code>的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。</p><p>所以此后为某个段分配存储空间的策略是这样的：</p><ul><li><p>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</p></li><li><p>当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。</p></li></ul><p>所以现在段不能仅定义为是某些区的集合，更精确的应该是<code>某些零散的页面</code>以及<code>一些完整的区</code>的集合。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e91a6832-e47d-42ac-a2f5-db18557a06f9-4"><p>区大体上可以分为4种类型：</p><ul><li>空闲的区 (FREE) : 现在还没有用到这个区中的任何页面。</li><li>有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。</li><li>没有剩余空间的碎片区 (FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。</li><li>附属于某个段的区 (FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。</li></ul><p>处于FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，直属于表空间。而处于 FSEG 状态的区是附属于某个段的。</p><blockquote><p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于 FSEG 的区全部隶属于某个段，而处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h2 id="6-表空间">6. 表空间</h2><p>表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。</p><p>表空间是一个<code>逻辑容器</code>，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为<code>系统表空间</code>(System tablespace)、<code>独立表空间</code>(File-per-table tablespace)、<code>撤销表空间</code>(Undo Tablespace）和<code>临时表空间</code>(Temporary Tablespace) 等。</p><div class="tabs" id="2b23fb45-4f28-461f-a1f8-c4694ddcc12d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2b23fb45-4f28-461f-a1f8-c4694ddcc12d-1"><i class="fas fa-bug"></i>独立表空间</button></li><li class="tab"><button type="button" data-href="#2b23fb45-4f28-461f-a1f8-c4694ddcc12d-2"><i class="fas fa-cannabis"></i>系统表空间</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2b23fb45-4f28-461f-a1f8-c4694ddcc12d-1"><p>独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间 (即：单表) 可以在不同的数据库之间进行<code>迁移</code>。</p><p>空间可以回收 (DROP TABLE 操作可自动回收表空间；其他情况，表空间不能自己回收) 。如果对于统计分析或是日志表，删除大量数据后可以通过：alter table TableName engine=innodb; 回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。</p><p><strong>独立表空间结构</strong></p><p>独立表空间由段、区、页组成。</p><p><strong>真实表空间对应的文件大小</strong></p><p>我们到数据目录里看，会发现一个新建的表对应的 .ibd 文件只占用了 96K，才6个页面大小 (MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些 .ibd 文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。</p><p><strong>查看 InnoDB 的表空间类型：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span></span><br></pre></td></tr></table></figure><p>你能看到 innodb_file_per_table=ON, 这就意味着每张表都会单词保存一个 .ibd 文件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b23fb45-4f28-461f-a1f8-c4694ddcc12d-2"><p>系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。</p><p><strong>InnoDB数据字典</strong></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220621150648770.png" alt="image-20220621150648770"  /><p>删除这些数据并不是我们使用 INSERT 语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得以引入的一些额外数据，这些数据页称为 元数据。InnoDB 存储引擎特意定义了一些列的 内部系统表 (internal system table) 来记录这些元数据：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220621150924922.png" alt="image-20220621150924922"  /><p>这些系统表也称为<code>数据字典</code>，它们都是以 B+ 树的形式保存在系统表空间的某个页面中。其中<code>SYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS</code>这四个表尤其重要，称之为基本系统表 (basic system tables) ，我们先看看这4个表的结构：</p><div class="tabs" id="5c77cd88-9420-4be4-9487-202f2f71c4b3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5c77cd88-9420-4be4-9487-202f2f71c4b3-1"><i class="fas fa-seedling"></i>SYS_TABLES</button></li><li class="tab"><button type="button" data-href="#5c77cd88-9420-4be4-9487-202f2f71c4b3-2"><i class="fas fa-leaf"></i>SYS_COLUMNS</button></li><li class="tab"><button type="button" data-href="#5c77cd88-9420-4be4-9487-202f2f71c4b3-3"><i class="fab fa-apple"></i>SYS_INDEXES</button></li><li class="tab"><button type="button" data-href="#5c77cd88-9420-4be4-9487-202f2f71c4b3-4"><i class="fas fa-tree"></i>SYS_FIELDS</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5c77cd88-9420-4be4-9487-202f2f71c4b3-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220621151139759.png" alt="image-20220621151139759"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5c77cd88-9420-4be4-9487-202f2f71c4b3-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220621151158361.png" alt="image-20220621151158361"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5c77cd88-9420-4be4-9487-202f2f71c4b3-3"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220621151215274.png" alt="image-20220621151215274"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5c77cd88-9420-4be4-9487-202f2f71c4b3-4"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220621151238157.png" alt="image-20220621151238157"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>注意：用户不能直接访问 InnoDB 的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库<code>information_schema</code>中提供了一些以<code>innodb_sys</code>开头的表:</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409224721791.png" alt="image-20230409224721791" style="zoom:50%;float: right" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE information_schema;</span><br><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_sys%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在<code>information_scheme</code>数据库中的这些以<code>INNODB_SYS</code>开头的表并不是真正的内部系统表 (内部系统表就是我们上边以<code>SYS</code>开头的那些表)，而是在存储引擎启动时读取这些以<code>SYS</code>开头的系统表，然后填充到这些以<code>INNODB_SYS</code>开头的表中。以<code>INNODB_SYS</code>开头的表和以<code>SYS</code>开头的表中的字段并不完全一样，但仅供大家参考已经足矣。</p><hr><h2 id="附录：数据页加载的三种方式">附录：数据页加载的三种方式</h2><p>InnoDB从磁盘中读取数据<code>最小单位</code>是数据页。而你想得到的 id = xxx 的数据，就是这个数据页众多行中的一行。</p><p>对于MySQL存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按<code>数据页</code>形式进行存放的，当其加载到 MySQL 中我们称之为<code>缓存页</code>。</p><p>如果缓冲池没有该页数据，那么缓冲池有以下三种读取数据的方式，每种方式的读取速率是不同的：</p><div class="tabs" id="d1e131f6-5cb4-4dbf-8cae-9d380d3d2be5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d1e131f6-5cb4-4dbf-8cae-9d380d3d2be5-1"><i class="fas fa-award"></i>1.内存读取</button></li><li class="tab"><button type="button" data-href="#d1e131f6-5cb4-4dbf-8cae-9d380d3d2be5-2"><i class="fas fa-baseball-ball"></i>2.随机读取</button></li><li class="tab"><button type="button" data-href="#d1e131f6-5cb4-4dbf-8cae-9d380d3d2be5-3"><i class="fas fa-bone"></i>3.顺序读取</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d1e131f6-5cb4-4dbf-8cae-9d380d3d2be5-1"><p>如果该数据存在于内存中，基本上执行时间在 1ms 左右，效率还是很高的。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220621135638283.png" alt="image-20220621135638283"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d1e131f6-5cb4-4dbf-8cae-9d380d3d2be5-2"><p>如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在<code>10ms</code>左右，这 10ms 中有 6ms 是磁盘的实际繁忙时间（包括了<code>寻道和半圈旋转时间</code>），有3ms 是对可能发生的排队时间的估计值，另外还有 1ms 的传输时间，将页从磁密服务器缓冲区传输到数据库缓冲区中。这 10ms 看起来很快，但实际上对于数据库来说消耗的时间已经非常长了，因为这还只是一个页的读取时间。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409221031496.png" alt="image-20230409221031496"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d1e131f6-5cb4-4dbf-8cae-9d380d3d2be5-3"><p>顺序读取其实是一种批量读取的方式，因为我们请求的<code>数据在磁盘上往往都是相邻存储的</code>，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘1/0操作了。如果一个磁盘的吞吐量是 40MB/S，那么对于一个 16KB 大小的页来说，一次可以顺序读取 2560 (40MB/16KB) 个页，相当于一个页的读取时间为 0.4ms。采用批量读取的方式，即使是从磁盘上进行读取，效率也比从内存中只单独读取一个页的效率要高。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> ]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引数据结构</title>
      <link href="/posts/d81d61c1.html"/>
      <url>/posts/d81d61c1.html</url>
      
        <content type="html"><![CDATA[<blockquote><span class='p red'>为什么使用索引?</span></blockquote><p>​索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则<code>通过索引查找</code>相关数据，如果不符合则需要<code>全表扫描</code>，即需要一条一条地查找记录，直到找到与条件符合的记录。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616141351236.png" alt="image-20220616141351236" style="zoom:80%;" /><p>​如上图所示，数据库没有索引的情况下，数据<code>分布在硬盘不同的位置上面</code>，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果<code>数据顺序摆放</code>，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，<code>依旧非常耗时</code>。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 = 89 这条记录，就要逐行去查找、去比较。从Col 2 = 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有<code>上千万条数据</code>，就意味着要做<code>很多很多次硬盘I/0</code>才能找到。现在要查找 Col 2 = 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I/O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）</p><p>假如给数据使用<code>二叉树</code>这样的数据结构进行存储，如下图所示</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616142723266.png" alt="image-20220616142723266" style="zoom: 50%;" /><p>对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个<code>二叉搜索树</code>。二叉搜索树的每个结点存储的是<code>(K, V) 结构</code>，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：<code>(34, 0x07)</code>。现在对 Col 2 添加了索引，这时再去查找 Col 2 = 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34 到内存，89 &gt; 34; 继续右侧数据，读 89 到内存，89==89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要<code>查找两次</code>就可以定位到记录的地址，查询速度就提高了。</p><p>这就是我们为什么要建索引，目的就是为了<code>减少磁盘I/O的次数</code>，加快查询速率。</p><hr><h2 id="1-索引及其优缺点">1. 索引及其优缺点</h2><p>MySQL官方对索引的定义为：<span class='p red'>索引（Index）是帮助MySQL高效获取数据的数据结构。</span></p><span class='p green'>索引的本质</span>：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法 。<br/><p>索引是在存储引擎中实现，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 最大索引和 最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。</p><div class="tabs" id="6b6452ca-3179-4180-9a5f-03a5089a65c3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6b6452ca-3179-4180-9a5f-03a5089a65c3-1"><i class="fas fa-award"></i>优点</button></li><li class="tab"><button type="button" data-href="#6b6452ca-3179-4180-9a5f-03a5089a65c3-2"><i class="fas fa-baseball-ball"></i>缺点</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6b6452ca-3179-4180-9a5f-03a5089a65c3-1"><p>（1）类似大学图书馆建书目索引，提高数据检索的效率，降低<code>数据库的IO成本</code>，这也是创建索引最主要的原因。</p><p>（2）通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。</p><p>（3）在实现数据的 参考完整性方面，可以<code>加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。</p><p>（4）在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6b6452ca-3179-4180-9a5f-03a5089a65c3-2"><p>增加索引也有许多不利的方面，主要表现在如下几个方面：</p><p>（1）创建索引和维护索引要<code>耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。</p><p>（2）索引需要占<code>磁盘空间</code>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</p><p>（3）虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p><p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p><blockquote><p>提示：</p><p>索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><blockquote><span class='p green'>InnoDB中索引的推演-递进的方式</span></blockquote><h2 id="2-无索引下的查找">2. 无索引下的查找</h2><p>先来看一个精确匹配的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [列名列表] <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure><div class="tabs" id="482166e2-fc75-42e4-9c3f-2da254c45bc1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#482166e2-fc75-42e4-9c3f-2da254c45bc1-1"><i class="fas fa-bug"></i>在一个页中的查找</button></li><li class="tab"><button type="button" data-href="#482166e2-fc75-42e4-9c3f-2da254c45bc1-2"><i class="fas fa-cannabis"></i>在很多页中查找</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="482166e2-fc75-42e4-9c3f-2da254c45bc1-1"><p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：</p><ul><li><p>以主键为搜索条件</p><p>可以在页目录中使用<code>二分法</code>快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。</p></li><li><p>以其他列作为搜索条件</p><p>因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从<code>最小记录</code>开始<code>依次遍历单链表中的每条记录</code>， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="482166e2-fc75-42e4-9c3f-2da254c45bc1-2"><p>在很多页中查找记录的活动可以分为两个步骤：</p><ol><li>定位到记录所在的页。</li><li>从所在的页内中查找相应的记录。</li></ol><p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从<code>第一个页</code>沿着<code>双向链表</code>一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时<code>索引</code>应运而生。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="3-设计索引">3. 设计索引</h2><div class="tabs" id="cba09c0a-f57e-4b13-ac4b-18f08dac81a7"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#cba09c0a-f57e-4b13-ac4b-18f08dac81a7-1"><i class="fas fa-bug"></i>1</button></li><li class="tab"><button type="button" data-href="#cba09c0a-f57e-4b13-ac4b-18f08dac81a7-2"><i class="fas fa-cannabis"></i>2</button></li><li class="tab"><button type="button" data-href="#cba09c0a-f57e-4b13-ac4b-18f08dac81a7-3"><i class="fas fa-candy-cane"></i>3</button></li><li class="tab"><button type="button" data-href="#cba09c0a-f57e-4b13-ac4b-18f08dac81a7-4"><i class="fas fa-child"></i>4</button></li><li class="tab"><button type="button" data-href="#cba09c0a-f57e-4b13-ac4b-18f08dac81a7-5"><i class="fas fa-fire-alt"></i>5</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="cba09c0a-f57e-4b13-ac4b-18f08dac81a7-1"><p>建一个表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> index_demo(</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> c1 <span class="type">INT</span>,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> c2 <span class="type">INT</span>,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> c3 <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">PRIMARY</span> KEY(c1)</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> ) ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p>这个新建的<code>index_demo</code>表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用<code>Compact</code>行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616152453203.png" alt="image-20220616152453203" style="zoom:50%;" /><p>我们只在示意图里展示记录的这几个部分：</p><ul><li>record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。</li><li>mysql&gt; CREATE TABLE index_demo( -&gt; c1 INT, -&gt; c2 INT, -&gt; c3 CHAR(1), -&gt; PRIMARY KEY(c1) -&gt; ) ROW_FORMAT = Compact; next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。</li><li>各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、c2 和 c3 。</li><li>其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cba09c0a-f57e-4b13-ac4b-18f08dac81a7-2"><p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样 和 把一些记录放到页里的示意图就是：</p><div class="fj-gallery"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616152727234.png" alt="image-20220616152727234" style="zoom: 50%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616152651878.png" alt="image-20220616152651878" style="zoom:50%;" />          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cba09c0a-f57e-4b13-ac4b-18f08dac81a7-3"><p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们<code>想快速的定位到需要查找的记录在哪些数据页</code>中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录 ，建这个目录必须完成下边这些事：</p><p>*<code>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</code></p><p>假设：每页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&#x27;u&#x27;</span>), (<span class="number">3</span>, <span class="number">9</span>, <span class="string">&#x27;d&#x27;</span>), (<span class="number">5</span>, <span class="number">3</span>, <span class="string">&#x27;y&#x27;</span>);</span><br></pre></td></tr></table></figure><p>​      那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616153518456.png" alt="image-20220616153518456" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cba09c0a-f57e-4b13-ac4b-18f08dac81a7-4"><p>从图中可以看出来， index_demo 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> index_demo <span class="keyword">VALUES</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>因为<code>页10</code>最多只能放3条记录，所以我们不得不再分配一个新页：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616155306705.png" alt="image-20220616155306705" style="zoom:50%;" /><p>注意：新分配的<code>数据页编号可能并不是连续的</code>。它们只是通过维护者上一个页和下一个页的编号而建立了<code>链表</code>关系。另外，<code>页10</code>中用户记录最大的主键值是5，而<code>页28</code>中有一条记录的主键值是4，因为5&gt;4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次<code>记录移动</code>，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616160216525.png" alt="image-20220616160216525" style="zoom:50%;" /><p>这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如<code>记录移动</code>的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为<code>页分裂</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cba09c0a-f57e-4b13-ac4b-18f08dac81a7-5"><p>给所有的页建立一个目录项。</p><p>由于数据页的<code>编号可能是不连续</code>的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616160619525.png" alt="image-20220616160619525" style="zoom:50%;" /><p>我们需要给它们做个<code>目录</code>，每个页对应一个目录项，每个目录项包括下边两个部分：</p><p>1）页的用户记录中最小的主键值，我们用<code>key</code>来表示。</p><p>2）页号，我们用<code>page_on</code>表示。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616160857381.png" alt="image-20220616160857381" style="zoom:50%;" /><p>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：</p><ol><li>先从目录项中根据 二分法快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是页9 。</li><li>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><blockquote><span class='p green'>基于上面设计出的索引我们进行迭代</span></blockquote><h2 id="4-InnoDB中的索引方案">4. InnoDB中的索引方案</h2><div class="tabs" id="1c9644dd-b3c9-48ae-8bc2-1d34214b03d0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1c9644dd-b3c9-48ae-8bc2-1d34214b03d0-1"><i class="fas fa-atom"></i>① 迭代1次</button></li><li class="tab"><button type="button" data-href="#1c9644dd-b3c9-48ae-8bc2-1d34214b03d0-2"><i class="far fa-sun"></i>② 迭代2次</button></li><li class="tab"><button type="button" data-href="#1c9644dd-b3c9-48ae-8bc2-1d34214b03d0-3"><i class="fas fa-wind"></i>③ 迭代3次</button></li><li class="tab"><button type="button" data-href="#1c9644dd-b3c9-48ae-8bc2-1d34214b03d0-4"><i class="fas fa-fire-alt"></i>B+Tree</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1c9644dd-b3c9-48ae-8bc2-1d34214b03d0-1"><blockquote><p><span class='p green'>目录项纪录的页</span></p></blockquote><p>上边称为一个简易的索引方案，是因为我们为了在根据主键值进行查找时使用<code>二分法</code>快速定位具体的目录项而<code>假设</code>所有目录项都可以在物理存储器上<code>连续存储</code>，但是这样做有几个问题：</p><ul><li><p>InnoDB是使用页来作为管理存储空间的基本单位，最多能保证<code>16KB</code>的连续存储空间，而随着表中记录数量的增多，需要<code>非常大的连续的存储空间</code>才能把所有的目录项都放下，这对记录数量非常多的表是不现实的。</p></li><li><p>我们时常会对<code>记录进行增删</code>，假设我们把<code>页28</code>中的记录都州除了，那意味着<code>目录项2</code>也就没有存在的必要了，这就需要把目录项2后的目录项都向前移动一下，这样牵一发而动全身的操作效率很差。</p></li></ul><p>所以，我们需要一种可以<code>灵活管理所有目录项</code>的方式。我们发现目录项其实长得跟我们的用户记录差不多，只不过目录项中的两个列是<code>主键</code>和<code>页号</code>而已，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为<code>目录项记录</code>。那InnoDB怎么区分一条记录是普通的<code>用户记录</code>还是<code>目录项记录</code>呢？使用记录头信息里的 record_type 属性，它的各个取值代表的意思如下：</p><ul><li>0：普通的用户记录</li><li>1：目录项记录</li><li>2：最小记录</li><li>3：最大记录</li></ul><p>我们把前边使用到的目录项放到数据页中的样子就是这样：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616162944404.png" alt="image-20220616162944404" style="zoom:67%;" /><p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调<code>目录项记录</code>和普通的<code>用户记录</code>的<span class='p red'>不同点</span>：</p><p>*<code>目录项记录</code>的 record_type 值是1，而<code>普通用户记录</code>的 record_type 值是0。</p><ul><li>目录项记录只有<code>主键值和页的编号</code>两个列，而普通的用户记录的列是用户自己定义的，可能包含<code>很多列</code>，另外还有InnoDB自己添加的隐藏列。</li><li>了解：记录头信息里还有一个叫<code>min_rec_mask</code>的属性，只有在存储<code>目录项记录</code>的页中的主键值最小的<code>目录项记录</code>的<code>min_rec_mask</code>值为<code>1</code>，其他别的记录的<code>min_rec_mask</code>值都是<code>0</code>。</li></ul><p><span class='p red'>相同点</span>：两者用的是一样的数据页，都会为主键值生成<code>Page Directory （页目录）</code>，从而在按照主键值进行查找时可以使用<code>二分法</code>来加快查询速度。</p><p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：</p><ol><li>先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</li><li>再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1c9644dd-b3c9-48ae-8bc2-1d34214b03d0-2"><p><span class='p green'>多个目录项纪录的页</span></p><p>虽然说<code>目录项记录</code>中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有<code>16KB</code>大小，能存放的<code>目录项记录</code>也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，如何处理呢？</p><p>这里我们假设一个存储目录项记录的页<code>最多只能存放4条目录项记录</code>，所以如果此时我们再向上图中插入一条主键值为320 的用户记录的话，那就需要分配一个新的存储<code>目录项记录</code>的页：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616171135082.png" alt="image-20220616171135082" style="zoom: 67%;" /><p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：</p><ul><li>为存储该用户记录而新生成了 页31 。</li><li>因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。</li></ul><p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例：</p><ol><li>确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。</li><li>通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。</li><li>在真实存储用户记录的页中定位到具体的记录。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1c9644dd-b3c9-48ae-8bc2-1d34214b03d0-3"><p><code>目录项记录页的目录页</code></p><p>问题来了，在这个查询步骤的第1步中我们需要定位存储目录项记录的页，但是这些<code>页是不连续的</code>，如果我们表中的数据非常多则会<code>产生很多存储目录项记录的页</code>，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个<code>更高级的目录</code>，就像是一个多级目录一样，<code>大目录里嵌套小目录</code>，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616173512780.png" alt="image-20220616173512780" style="zoom:67%;" /><p>如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。</p><p>我们可以用下边这个图来描述它：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616173717538.png" alt="image-20220616173717538"></p><p>这个数据结构，它的名称是 B+树 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1c9644dd-b3c9-48ae-8bc2-1d34214b03d0-4"><p>不论是存放<code>用户记录</code>的数据页，还是存放<code>目录项记录</code>的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为<code>节点</code>。从图中可以看出，我们的实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为<code>叶子节点</code>，其余用来存放<code>目录项</code>的节点称为<code>非叶子节点</code>或者<code>内节点</code>，其中B+树最上边的那个节点也称为<code>根节点</code>。</p><p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么：</p><ul><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li><li>如果B+树有2层，最多能存放 1000×100=10,0000 条记录。</li><li>如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。</li><li>如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！</li></ul><p>你的表里能存放<code>100000000000</code>条记录吗？所以一般情况下，我们用到的<code>B+树都不会超过4层</code>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的<code>Page Directory</code>（页目录），所以在页面内也可以通过<code>二分法</code>实现快速 定位记录。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h2 id="5-常见索引">5. 常见索引</h2><p>索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。</p><h3 id="5-1-聚簇索引">5.1 聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是<code>一种数据存储方式</code>（所有的用户记录都存储在了叶子结点），也就是所谓的<code>索引即数据，数据即索引</code>。</p><blockquote><p>术语&quot;聚簇&quot;表示当前数据行和相邻的键值聚簇的存储在一起</p></blockquote><div class="tabs" id="4e502af4-b25a-4711-9b33-2e8c93a36db4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4e502af4-b25a-4711-9b33-2e8c93a36db4-1"><i class="fas fa-atom"></i>特点</button></li><li class="tab"><button type="button" data-href="#4e502af4-b25a-4711-9b33-2e8c93a36db4-2"><i class="far fa-sun"></i>优点</button></li><li class="tab"><button type="button" data-href="#4e502af4-b25a-4711-9b33-2e8c93a36db4-3"><i class="fas fa-wind"></i>缺点</button></li><li class="tab"><button type="button" data-href="#4e502af4-b25a-4711-9b33-2e8c93a36db4-4"><i class="fas fa-fire-alt"></i>限制</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4e502af4-b25a-4711-9b33-2e8c93a36db4-1"><ul><li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p><p>*<code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code>。</p><ul><li>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</li><li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</li></ul></li><li><p>B+树的 叶子节点 存储的是完整的用户记录。</p><p>所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p></li></ul><p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个<code>聚簇索引</code>的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用<code>INDEX</code>语句去创建，<code>InnDB</code>存储引擎会<code>自动</code>的为我们创建聚簇索引。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4e502af4-b25a-4711-9b33-2e8c93a36db4-2"><p>*<code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</p><ul><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4e502af4-b25a-4711-9b33-2e8c93a36db4-3"><p>*<code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code><br>*<code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<strong>主键为不可更新</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4e502af4-b25a-4711-9b33-2e8c93a36db4-4"><ul><li><p>对于MysQL数据库目前只有InnoDB数据引擎支持聚簇索列，而MyISAM并不支持聚簇索引。</p></li><li><p>由于数据物理存储排序方式只能有一种，所以每个MySQL的表只能有一个<code>聚簇索引</code>。一般情况下就是该表的主键。</p></li><li><p>如果没有定义主键，Innodb会选择<code>非空的唯一索引</code>代替。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。</p></li><li><p>为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用<code>有序的顺序id</code>，而不建议用无序的id， 比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="5-2-二级索引">5.2 二级索引</h3><p>上边介绍的<code>聚簇索引</code>只能在搜索条件是<code>主键值</code>时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该怎么办呢？肯定不能是从头到尾沿着链表依次遍历记录一遍。</p><p>答案：我们可以<code>多建几颗B+树</code>，不同的B+树中的数据采用不同的排列规则。比方说我们用<code>c2</code>列的大小作为数据页、页中记录的排序规则，再建一颗B+树，效果如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616203852043.png" alt="image-20220616203852043" style="zoom: 50%;" /><ul><li><p>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：</p><ul><li>页内的记录是按照c2列的大小顺序排成一个<code>单向链表</code>。</li><li>各个存放<code>用户记录的页</code>也是根据页中记录的c2列大小顺序排成一个<code>双向链表</code>。</li><li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个<code>双向链表</code>。</li></ul></li><li><p>B+树的叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。</p></li><li><p>目录项记录中不再是<code>主键+页号</code>的搭配，而变成了<code>c2列+页号</code>的搭配。</p></li></ul><p>所以如果我们现在想通过c2列的值查找某些记录的话就可以使用我们刚刚建好的这个B+树了。以查找c2列的值为<code>4</code>的记录为例，查找过程如下：</p><ol><li><p>确定<code>目录项记录页</code></p><p>根据<code>根页面</code>，也就是<code>页44</code>，可以快速定位到<code>目录项记录</code>所在的页为<code>页42</code>(因为2≤ 4≤9）。</p></li><li><p>通过<code>目录项记录页</code>确定用户记录真实所在的页。</p><p>在<code>页42</code>中可以快速定位到实际存储用户记录的页，但是由于 c2 列并没有唯一性约束，所以c2 列值为4的记录可能分布在多个数据页中，又因为2＜4≤4，所以确定实际存储用户记录的页在页34和页35中。</p></li><li><p>在真实存储用户记录的页中定位到具体的记录。</p><p>到页34和页35 中定位到具体的记录。</p></li><li><p>但是这个B+树的叶子节点中的记录只存储了 c2和c1（也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录。</p></li></ol><blockquote><p>概念：<span class='p red'>回表</span></p></blockquote><p>我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！</p><blockquote><p><strong>问题</strong>：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？</p></blockquote><p><strong>回答</strong>：</p><p>如果把完整的用户记录放到叶子结点是可以不用回表。但是<code>太占地方</code>了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。</p><p>因为这种按照<code>非主键列</code>建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为<code>二级索引</code>，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列简历的索引。</p><p>非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616213109383.png" alt="image-20220616213109383" style="zoom:50%;" /><p>小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：</p><ol><li>聚簇索引的<code>叶子节点</code>存储的就是我们的<code>数据记录</code>, 非聚簇索引的叶子节点存储的是<code>数据位置</code>。非聚簇索引不会影响数据表的物理存储顺序。</li><li>一个表<code>只能有一个聚簇索引</code>，因为只能有一种排序存储的方式，但可以有<code>多个非聚簇索引</code>，也就是多个索引目录提供数据检索。</li><li>使用聚簇索引的时候，数据的<code>查询效率高</code>，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</li></ol><hr><h3 id="5-3-联合索引">5.3 联合索引</h3><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照c2列进行排序。</li><li>在记录的c2列相同的情况下，采用c3列进行排序</li></ul><p>为c2和c3建立的索引的示意图如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220616215251172.png" alt="image-20220616215251172" style="zoom:50%;" /><p>如图所示，我们需要注意以下几点：</p><ul><li>每条目录项都有c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序</li><li>B+树叶子节点处的用户记录由c2、c3和主键c1列组成</li></ul><p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p><ul><li>建立 联合索引 只会建立如上图一样的1棵B+树。</li><li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li></ul><hr><h2 id="6-InnoDB的B-树索引注意事项">6. InnoDB的B+树索引注意事项</h2><div class="tabs" id="4f022a31-b74b-4ef2-b25f-3cf21e66465d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4f022a31-b74b-4ef2-b25f-3cf21e66465d-1"><i class="fas fa-award"></i>1.根页面位置万年不动</button></li><li class="tab"><button type="button" data-href="#4f022a31-b74b-4ef2-b25f-3cf21e66465d-2"><i class="fas fa-baseball-ball"></i>2.一个页面最少存储2条记录</button></li><li class="tab"><button type="button" data-href="#4f022a31-b74b-4ef2-b25f-3cf21e66465d-3"><i class="fas fa-bone"></i>3.内节点中目录项记录的唯一性</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4f022a31-b74b-4ef2-b25f-3cf21e66465d-1"><p>我们前边介绍B+树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画存储目录项记录的内节点，实际上B+树的形成过程是这样的：</p><p>实际上B+树的形成过程是这样的：</p><ul><li>每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根结点</code>页面。最开始表中没有数据的时候，每个B+树索引对应的<code>根结点</code>中即没有用户记录，也没有目录项记录。</li><li>随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。</li><li>当根节点中的可用<code>空间用完时</code>继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li></ul><p>这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是<code>InnoDB</code>存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4f022a31-b74b-4ef2-b25f-3cf21e66465d-2"><p>一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 <strong>InnoDB 的一个数据页至少可以存放两条记录</strong>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4f022a31-b74b-4ef2-b25f-3cf21e66465d-3"><p>内节点：用来存目录项的节点</p><p>我们知道B+树索引的内节点中目录项记录的内容是<code>索引列 + 页号</code>的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index_demo 表为例，假设这个表中的数据是这样的：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617151918786.png" alt="image-20220617151918786"></p><p>如果二级索引中目录项记录的内容只是<code>索引列 + 页号</code>的搭配的话，那么为<code>c2</code>列简历索引后的B+树应该长这样：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617152906690.png" alt="image-20220617152906690"></p><p>如果我们想新插入一行记录，其中<code>c1</code>、<code>c2</code>、<code>c3</code>的值分别是:<code>9</code>、<code>1</code>、<code>c</code>, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 页号</code>的值构成的，<code>页3</code>中的两条目录项记录对应的 c2 列的值都是1，而我们<code>新插入的这条记录</code>的 c2 列的值也是<code>1</code>，那我们这条新插入的记录到底应该放在<code>页4</code>中，还是应该放在<code>页5</code>中？答案：对不起，懵了</p><p>为了让新插入记录找到自己在那个页面，我们需要<strong>保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617154135258.png" alt="image-20220617154135258"></p><p>这样我们再插入记录<code>(9, 1, 'c')</code>时，由于<code>页3</code>中存储的目录项记录是由<code>c2列 + 主键 + 页号</code>的值构成的，可以先把新纪录的<code>c2</code>列的值和<code>页3</code>中各目录项记录的<code>c2</code>列的值作比较，如果<code>c2</code>列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的<code>c2列 + 主键</code>的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到<code>页5</code>中。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h2 id="7-MyISAM中的索引方案">7. MyISAM中的索引方案</h2><p>B树索引使用存储引擎如表所示：</p><table><thead><tr><th style="text-align:center">索引 / 存储引擎</th><th style="text-align:center">MyISAM</th><th style="text-align:center">InnoDB</th><th style="text-align:center">Memory</th></tr></thead><tbody><tr><td style="text-align:center">B-Tree索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr></tbody></table><p>即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索引是Btree索引；而Memory默认的索引是Hash索引。</p><p>MyISAM引擎使用<code>B+Tree</code>作为索引结构，叶子节点的data域存放的是<code>数据记录的地址</code>。</p><h3 id="7-1-MyISAM索引的原理">7.1 MyISAM索引的原理</h3><p>我们知道<code>InnoDB中索引即数据</code>，也就是聚簇索引的那棵B+树的叶子节点中己经把所有完整的用户记录都包含了， 而<code>MyISAM</code>的索引方案虽然也使用树形结构，但是却<code>将索引和数据分开存储</code>：</p><ul><li><p>将表中的记录<code>按照记录的插入顺序</code>单独存储在一个文件中，称之为<code>数据文件</code>。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</p></li><li><p>使用<code>MyISAM</code>存储引擎的表会把索引信息另外存储到一个称为<code>索引文件</code>的另一个文件中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是<code>主键值 +数据记录地址</code>的组合。</p></li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409133104671.png" alt="image-20230409133104671" style="zoom:50%;" /><p>这里设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引(Primary key) 示意。可以看出 MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主键索引和二级索引(Secondary key)在结构上没有任何区别，只是主键索引要求key是唯一的，而二级索引的key可以重复。如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230409133213129.png" alt="image-20230409133213129" style="zoom:50%;" /><p>同样也是一棵B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为：首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><h3 id="7-2-MyISAM-与-InnoDB对比">7.2 MyISAM 与 InnoDB对比</h3><span class='p red'>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。</span>小结两种引擎中索引的区别：<p>① 在InnoDB存储引擎中，我们只需要根据主键值对<code>聚簇索引</code>进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次<code>回表</code>操作，意味着MyISAM中建立的索引相当于全部都是<code>二级索引</code>。</p><p>② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是<code>分离的</code>，索引文件仅保存数 据记录的地址。</p><p>③ InnoDB的非聚簇索引data域存储相应记录<code>主键的值</code>，而MyISAM索引记录的是<code>地址</code>。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。</p><p>④ MyISAM的回表操作是十分<code>快速</code>的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</p><p>⑤ InnoDB要求表<code>必须有主键</code>（ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。</p><p>⑥ MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。</p><p><strong>小结：</strong></p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助。比如：</p><p>举例1：知道了InnoDB的索引实现后，就很容易明白<code>为什么不建议使用过长的字段作为主键</code>，因为所有二级索引都引用主键索引，过长的主键索引会令二级索引变得过大。</p><p>举例2：用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时，数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用<code>自增字段作为主键则是一个很好的选择</code>。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230408165518725.png" alt="image-20230408165518725" style="zoom: 33%;" /><h2 id="8-索引的代价">8. 索引的代价</h2><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><p>空间上的代价</p><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p></li><li><p>时间上的代价</p><p>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ，页面分裂 、页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p></li></ul><blockquote><p>一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。</p></blockquote><h2 id="9-索引数据结构选择的合理性">9. 索引数据结构选择的合理性</h2><p>从MySQL的角度讲，不得不考虑一个现实问题就是磁盘IO。如果我们能让索引的数据结构尽量减少硬盘的V/0操作，所消耗的时间也就越小。可以说，<code>磁盘的I/0</code>操作次数对索引的使用效率至关重要。</p><p>查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存的占用，<span class='p red'>数据库索引是存储在外部磁盘上的。</span>当我们利用索引查询的时候， 不可能把整个索引全部加载到内存，只能<code>逐一加载</code>，那么MySQL衡量查询效率的标准就是磁盘IO次数。</p><h3 id="9-1-全表查询">9.1 全表查询</h3><p>相当于顺序查找。</p><p>这里都懒得说了。</p><h3 id="9-2-Hash查询">9.2 Hash查询</h3><p>Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率。</p><p>Hash 算法是通过某种确定性的算法（比如 MD5、 SHA1、 SHA2、 SHA3) 将输入转变为输出。<code>相同的输入永远可以得到相同的输出</code>，假设输入内容有微小偏差，在输出中通常会有不同的结果。</p><p>举例：如果你想要验证两个文件是否相同，那么你不需要把两份文件直接拿来比对，只需要让对方把 Hash 函数计算得到的结果告诉你即可，然后在本地同样对文件进行 Hash 函数的运算，最后通过比较这两个 Hash 函数的结果是否相同，就可以知道这两个文件是否相同。</p><p>加快查找速度的数据结构，常见的有两类：</p><p>(1) 树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是<code>O(log2N)</code>;</p><p>(2)哈希，例如HashMap，查询/插入/修改/删除的平均时间复杂度都是<code>O(1)</code>; (key, value)</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617162153587.png" alt="image-20220617162153587" style="zoom:67%;" /><p>采用 Hash 进行检素效率非常高，基本上一次检索就可以找到数据，而 B+树需要自顶向下依次查找，多次访问节点才能找到数据，中间需要多次IO 操作，<code>从效率来说 Hash 比 B+ 树更快</code>。</p><p>在哈希的方式下，一个元素k处于h(k)中，即利用哈希函数h，根据关键字k计算出槽的位置。函数h将关键字域映射到哈希表T[0…m-1]的槽位上。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617162604272.png" alt="image-20220617162604272" style="zoom:67%;" /><p>上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做<code>碰撞</code>，在数据库中一般采用<code>链接法</code>来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617162703006.png" alt="image-20220617162703006" style="zoom:67%;" /><span class='p green'>实验：体会数组和hash表的查找方面的效率区别</span><div class="tabs" id="e62a39b3-0bfb-45cb-841a-341c07fdc320"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e62a39b3-0bfb-45cb-841a-341c07fdc320-1"><i class="fas fa-seedling"></i>数组查询</button></li><li class="tab"><button type="button" data-href="#e62a39b3-0bfb-45cb-841a-341c07fdc320-2"><i class="fas fa-leaf"></i>Hash查询</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e62a39b3-0bfb-45cb-841a-341c07fdc320-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(n)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=<span class="number">100000</span>;j++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp == arr[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time： &quot;</span> + (end - start)); </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//time： 823</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e62a39b3-0bfb-45cb-841a-341c07fdc320-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法复杂度为 O(1)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)&#123;</span><br><span class="line">    set.add(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=<span class="number">100000</span>;j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> set.contains(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;time： &quot;</span> + (end - start)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//time： 5</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><span class='p red'>Hash结构效率高，那为什么索引结构要设计成树型呢？</span><p>原因1：Hash 索引|仅能满足(=)(&lt;&gt;)和 IN 查询。如果进行<code>范围查询</code>，哈希型的索引，时间复杂度会退化为 o(n)；而树型的“有序”特性，依然能够保持O(log2N) 的高效率。</p><p>原因2：Hash 索引还有一个缺陷，数据的存储是<code>没有顺序的</code>，在 ORDER BY 的情况下，使用 Hash 索引还需要对数据重新排序。</p><p>原因3：对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</p><p>原因4：对于等值查询来说，通常 Hash 索引的效率更高，不过也存在一种情况，就是<code>索引列的重复值如果很多，效率就会降低</code>。这是因为遇到 Hash 冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash 索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。</p><span class='p green'>Hash索引适用存储引擎如表所示：</span><table><thead><tr><th style="text-align:center">索引 / 存储引擎</th><th style="text-align:center">MyISAM</th><th style="text-align:center">InnoDB</th><th style="text-align:center">Memory</th></tr></thead><tbody><tr><td style="text-align:center">HASH索引</td><td style="text-align:center">不支持</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr></tbody></table><span class='p green'>Hash索引的适用性：</span><p>Hash 索引存在着很多限制，相比之下在数据库中 B+ 树索引的使用面会更广，不过也有一些场景采用 Hash 索引效率更高，比如在键值型（Key-Value）数据库中，<code>Redis 存储的核心就是 Hash 表</code>。</p><p>MySQL 中的 Memory 存储引擎支持 Hash 存储，如果我们需要用到查询的临时表时，就可以选择 Memory 存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行<code>等值查询</code>的时候，采用 Hash 索引是个不错的选择。</p><p>另外，InnoDB 本身不支持 Hash 索引，但是提供<code>自适应 Hash 索引</code>(Adaptive Hash Index)。什么情况下才会使用自适应 Hash 索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到 Hash 表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让 B+ 树也具备了 Hash 索引的优点。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230408171742687.png" alt="image-20230408171742687" style="zoom:50%;" /><p>采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。</p><p>我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%adaptive_hash_index&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="9-3-二叉搜索树">9.3 二叉搜索树</h3><p>如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。</p><span class='p green'>1. 二叉搜索树的特点</span><ul><li>一个节点只能有两个子节点，也就是一个节点度不能超过2</li><li>左子节点 &lt; 本节点; 右子节点 &gt;= 本节点，比我大的向右，比我小的向左</li></ul><span class='p green'>2. 查找规则</span><div class="tabs" id="bb3fbfa4-cf47-4fee-a9e6-15bfe4762219"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#bb3fbfa4-cf47-4fee-a9e6-15bfe4762219-1"><i class="fas fa-award"></i>1</button></li><li class="tab"><button type="button" data-href="#bb3fbfa4-cf47-4fee-a9e6-15bfe4762219-2"><i class="fas fa-baseball-ball"></i>2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="bb3fbfa4-cf47-4fee-a9e6-15bfe4762219-1"><p>我们先来看下最基础的二叉搜索树 (Binary Search Tree），搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为 key:</p><ol><li>如果 key 大于根节点，则在右子树中进行查找；</li><li>如果 key 小于根节点，则在左子树中进行查找；</li><li>如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。</li></ol><p>举个例子，我们对数列 （34，22，89，5,23，77，91）创造出来的二分查找树如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617164022728.png" alt="image-20220617164022728" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bb3fbfa4-cf47-4fee-a9e6-15bfe4762219-2"><p>但是特殊情况，就是有时候二叉树的深度非常大，比如：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617164053134.png" alt="image-20220617164053134" style="zoom:50%;" /><p>为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘IO的次数，就需要尽量 降低树的高度 ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="9-4-AVL树">9.4 AVL树</h3><p>为了解决上面二叉查找树退化成链表的问题，人们提出了<code>平衡二叉搜索树</code>(Balanced Binary Tree)，又称为 AVL树（有别于AVL算法），它在二叉搜索树的基础上增加了约束，具有以下性质：</p><span class='p red'>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</span><p>这里说一下，常见的平衡二叉树有很多种，包括了平衡二叉搜索树、红黑树、数堆、伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上，第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是 0(log2n)。</p><p>数据查询的时间主要依赖于磁盘I/0 的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是 O(log2n)，当n比较大时，深度也是比较高的，比如下图的情况：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617165105005.png" alt="image-20220617165105005"></p><p>每访问一次节点就需要进行一次磁盘 I/O 操作，对于上面的树来说，我们需要进行 5次 I/O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率。</p><p>针对同样的数据，如果我们把二叉树改成 M 叉树 （M&gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面 的三叉树来进行存储：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617165124685.png" alt="image-20220617165124685"></p><p>你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉树 M 大的时候，M叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把`树从“瘦高” 变 “矮胖”。</p><h3 id="9-5-B-Tree">9.5 B-Tree</h3><p>B 树的英文是 Balance Tree，也就是<code>多路平衡查找树</code>。简写为 B-Tree。它的高度远小于平衡二叉树的高度。</p><p>B 树的结构如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230408172814225.png" alt="image-20230408172814225" style="zoom:67%;" /><p>B树作为多路平衡查找树，它的每一个节点最多可以包括M个子节点，<code>M 称为B 树的阶</code>。每个磁盘块中包括了<code>关键字</code>和<code>子节点的指针</code>。如果一个磁盘块中包括了×个关键字，那么指针数就是x+1。对于一个100阶的B树来说，如果有3层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用B树的结构是非常适合的，因为树的高度要远小于二叉树的高度。</p><div class="tabs" id="d93e2ac0-53b2-466b-b0ac-56143caf62d2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d93e2ac0-53b2-466b-b0ac-56143caf62d2-1"><i class="fas fa-award"></i>B树特性</button></li><li class="tab"><button type="button" data-href="#d93e2ac0-53b2-466b-b0ac-56143caf62d2-2"><i class="fas fa-baseball-ball"></i>B树的查找</button></li><li class="tab"><button type="button" data-href="#d93e2ac0-53b2-466b-b0ac-56143caf62d2-3"><i class="fas fa-bone"></i>小结</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d93e2ac0-53b2-466b-b0ac-56143caf62d2-1"><p>一个 M 阶的 B 树（M&gt;2）有以下的特性：</p><ol><li>根节点的儿子数的范围是 [2,M]。</li><li>每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 [ceil(M/2), M]。</li><li>叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。</li><li>假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。</li><li>所有叶子节点位于同一层。</li></ol><p>上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d93e2ac0-53b2-466b-b0ac-56143caf62d2-2"><p>然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：</p><ol><li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；</li><li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；</li><li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。</li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I/O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d93e2ac0-53b2-466b-b0ac-56143caf62d2-3"><p>小结：</p><ol><li><p>B树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。</p></li><li><p>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束</p></li><li><p>其搜索性能等价于在关键字全集内做一次二分查找。</p></li></ol><p><strong>再举例1：</strong></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617170526488.png" alt="image-20220617170526488"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="9-6-B-Tree">9.6 B+Tree</h3><p>B+树也是一种多路搜索树，<code>基于B树做出了改进</code>，主流的 DBMS 都支持B+树的素引方式，比如 MysQL。相比于B-Tree，<code>B+Tree适合文件索引系统</code>。</p><div class="tabs" id="1bffc484-0b50-4c32-87fa-96e851899c74"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1bffc484-0b50-4c32-87fa-96e851899c74-1"><i class="fas fa-bug"></i>与B树的差异</button></li><li class="tab"><button type="button" data-href="#1bffc484-0b50-4c32-87fa-96e851899c74-2"><i class="fas fa-cannabis"></i>查找</button></li><li class="tab"><button type="button" data-href="#1bffc484-0b50-4c32-87fa-96e851899c74-3"><i class="fas fa-candy-cane"></i>思考</button></li><li class="tab"><button type="button" data-href="#1bffc484-0b50-4c32-87fa-96e851899c74-4"><i class="fas fa-child"></i>思考</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1bffc484-0b50-4c32-87fa-96e851899c74-1"><ol><li>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。</li><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，<code>非叶子节点既保存索引，也保存数据记录</code>。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1bffc484-0b50-4c32-87fa-96e851899c74-2"><p>下图就是一棵 B+树，阶数为 3，根节点中的关键字1、18、35 分别是子节点(1，8, 14)，(18,24，31）和 (35， 41，53）中的最小值。每一层父节点的关键字都会出现在下一层的子节点的关键字中，因此在叶子节点中包括了所有的关键字信息，并且每一个叶子节点都有一个指向下一个节点的指针，这样就形成了一个链表。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230408183115135.png" alt="image-20230408183115135" style="zoom: 50%;" /><p>比如，我们想要查找关键字 16，B+ 树会自顶向下逐层进行查找：</p><ol><li>与根节点的关键字(1，18，35) 进行比较，16在1和18之间，得到指针 P1（指向磁盘块2）</li><li>找到磁盘块2，关键字为（1，8，14），因为 16大于14，所以得到指针 P3（指向磁盘块7）</li><li>找到磁盘块7，关键字为（14，16，17），然后我们找到了关键字 16，所以可以找到关键字16所对应的数据。</li></ol><p>整个过程一共进行了3次I/0操作，看起来 B+树和B树的查询过程差不多，但是 B+树和B树有个根本的差异在于，<span class='p red'>B+树的中间节点并不直接存储数据</span>。这样的好处都有什么呢？</p><p>首先，<span class='p red'>B+ 树查询效率更稳定</span>。因为 B+树每次只有访问到叶子节点才能找到对应的数据，而在B树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p><p>其次，<span class='p red'>B+树的查询效率更高</span>。这是因为通常B+树比B树更矮胖（阶数更大，深度更低），查询所需要的磁盘 V/0 也会更少。同样的磁盘页大小，B+ 树可以存储更多的节点关键字。</p><p>不仅是对单个关键字的查询上，<span class='p red'>在查询范围上，B+树的效率也比 B树高</span>。这是因为所有关键字都出现在 B+ 树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在B树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p><blockquote><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。</p><p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1bffc484-0b50-4c32-87fa-96e851899c74-3"><blockquote><p>思考题：为了减少IO，索引树会一次性加载吗？</p></blockquote><p>1、数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，超过几个G。<br>2、当我们利用索引查询时候，是不可能将全部几个G的索引都加载进内存的，我们能做的只能是：逐一加载每一个磁盘页，因为磁盘页对应着索引l树的节点。</p><blockquote><p>思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO</p></blockquote><p>InnoDB 存储引/擎中页的大小为 16KB，一般表的主键类型为INT（占用4个字节）或 BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree 中的一个节点)中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的K取值为 10^3。也就是说一个深度为3的 B+Tree 索引可以维护 10^3* 10^3* 10^3=10 亿条记录。（这里假定一个数据页也存储10^3条行记录数据了）</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，<code>B+Tree 的高度一般都在 2~4 层</code>。MySQL的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3 次磁益 I/O操作。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1bffc484-0b50-4c32-87fa-96e851899c74-4"><blockquote><p>思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</p></blockquote><ol><li><p>B+树的磁盘读写代价更低</p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p></li><li><p>B+树的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></li></ol><blockquote><p>思考题：Hash 索引与 B+ 树索引的区别</p></blockquote><ol><li><p>Hash 索引<code>不能进行范围查询</code>，而 B+ 树可以。这是因为 Hash 索引指向的数据是无序的，而 B+树的叶子节点是个有序的链表。</p></li><li><p>Hash 索引<code>不支持联合索引的最左侧原则</code>（即联合索引的部分索引无法使用），而B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将索引键合并后再一起计算 Hash 值，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。</p></li><li><p>Hash 泰引<code>不支持 ORDER BY 排序</code>，因为 Hash 索引指向的数据是无序的，因此无法起到排序优化的作用，而B+树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，我们也无法用 Hash 索引进行<code>模糊查询</code>，而 B+ 树使用 LIKE 进行模湖查询的时候，LIKE 后面后模糊查询（比如％结尾）的话就可以起到优化作用。</p></li><li><p>InnoDB<code>不支持哈希素引</code></p></li></ol><blockquote><p>思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</p></blockquote><p>你能看到，针对 InnoDB 和 MyISAM 存储引擎，都会默认采用 B+ 树索引，无法使用 Hash 索引。InnoDB 提供的自适应 Hash 是不需要手动指定的。如果是 Memory/Heap 和NDB 存储引擎，是可以进行选择 Hash 索引的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="9-7-R树">9.7 R树</h3><p>R-Tree在MySQL很少使用，仅支持<code>geometry</code>数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果 没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记 录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满 足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度 地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 解决了这种高维空间搜索问题 。它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree 的优势在于范围查找。</p><table><thead><tr><th style="text-align:center">索引 / 存储引擎</th><th style="text-align:center">MyISAM</th><th style="text-align:center">InnoDB</th><th style="text-align:center">Memory</th></tr></thead><tbody><tr><td style="text-align:center">R-Tree索引</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td><td style="text-align:center">不支持</td></tr></tbody></table><h3 id="9-8-小结">9.8 小结</h3><p>使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引|也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利（提升查询效率）和弊（维护索引所需的代价）。</p><p>在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管<code>索引不是万能的</code>，但<code>数据数据量大的时候不使用去引是不可想象的</code>，毕竟索引的本质，是帮助我们提升数据检表的效率。</p><h3 id="9-9-附录：算法的时间复杂度">9.9 附录：算法的时间复杂度</h3><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220617175516191.png" alt="image-20220617175516191"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL逻辑架构与存储引擎</title>
      <link href="/posts/13910bb8.html"/>
      <url>/posts/13910bb8.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-逻辑架构">1. 逻辑架构</h2><h3 id="1-1-逻辑架构剖析">1.1 逻辑架构剖析</h3><h4 id="1-1-1-服务器处理客户端请求">1.1.1 服务器处理客户端请求</h4><p>首先MySQL是典型的C/S架构，即<code>Clinet/Server 架构</code>，服务端程序使用的mysqld。</p><p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果是：<span class='p green'>客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。</span></p><p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615133227202.png" alt="image-20210615133227202" style="zoom: 67%;" /><hr><h4 id="1-1-2-Connectors">1.1.2 Connectors</h4><p>Connectors, 指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL Server<code>建立TCP连接</code>，之后按照其定义好的协议进行交互。或者比较方便的方法是调用SDK，比如Native C API、JDBC、PHP等各语言MySQL Connecotr,或者通过ODBC。但通过SDK来访问MySQL，本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230407101006728.png" alt="image-20230407101006728" style="zoom: 33%;" /><hr><h4 id="1-1-3-三层架构">1.1.3 三层架构</h4><span class='p blue'>MySQL Server结构可以分为如下三层：</span><div class="tabs" id="0fbe1939-61e3-4457-8c80-315887cf7bd1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0fbe1939-61e3-4457-8c80-315887cf7bd1-1"><i class="fas fa-award"></i>第一层:连接层</button></li><li class="tab"><button type="button" data-href="#0fbe1939-61e3-4457-8c80-315887cf7bd1-2"><i class="fas fa-baseball-ball"></i>第二层:服务层</button></li><li class="tab"><button type="button" data-href="#0fbe1939-61e3-4457-8c80-315887cf7bd1-3"><i class="fas fa-bone"></i>第三层:引擎层</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0fbe1939-61e3-4457-8c80-315887cf7bd1-1"><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立<code>TCP 连接</code>。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p><ul><li>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</li><li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li></ul><blockquote><p>如何查看 MySQL 服务被多少个客户端连接了？</p></blockquote><p>如果你想知道当前 MySQL 服务被多少个客户端连接了，你可以执行<code>show processlist</code>命令进行查看。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5.png" alt="img"></p><p>比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为<code>Sleep</code>，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。</p><blockquote><p>空闲连接会一直占用着吗？</p></blockquote><p>当然不是了，MySQL 定义了空闲连接的最大空闲时长，由<code>wait_timeout</code>参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> wait_timeout  <span class="operator">|</span> <span class="number">28800</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> kill connection <span class="operator">+</span><span class="number">6</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。</p><blockquote><p>MySQL 的连接数有限制吗？</p></blockquote><p>MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> max_connections <span class="operator">|</span> <span class="number">151</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 短连接</span></span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长连接</span></span><br><span class="line">连接 mysql 服务（TCP 三次握手）</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">执行sql</span><br><span class="line">....</span><br><span class="line">断开 mysql 服务（TCP 四次挥手）</span><br></pre></td></tr></table></figure><p>可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。</p><p>但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p><blockquote><p>怎么解决长连接占用内存的问题？</p></blockquote><p>有两种解决方式。</p><p>第一种，<span class='p blue'>定期断开长连接</span>。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。</p><p>第二种，<span class='p blue'>客户端主动重置连接</span>。MySQL 5.7 版本实现了<code>mysql_reset_connection()</code>函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><p>至此，连接器的工作做完了，简单总结一下：</p><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230407113921814.png" alt="image-20230407113921814"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0fbe1939-61e3-4457-8c80-315887cf7bd1-2"><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成<code>缓存的查询</code>，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p><p>在该层，服务器会<code>解析查询</code>并创建相应的内部<code>解析树</code>，并对其完成相应的<code>优化</code>：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p><p>如果是SELECT语句，服务器还会<code>查询内部的缓存</code>。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230407101606147.png" alt="image-20230407101606147" style="zoom:25%;" /><div class="tabs" id="68644226-2ebd-4896-90d5-8e8e1fac02c8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#68644226-2ebd-4896-90d5-8e8e1fac02c8-1"><i class="fas fa-award"></i>SQL Interface:SQL接口</button></li><li class="tab"><button type="button" data-href="#68644226-2ebd-4896-90d5-8e8e1fac02c8-2"><i class="fas fa-baseball-ball"></i>Parser:解析器</button></li><li class="tab"><button type="button" data-href="#68644226-2ebd-4896-90d5-8e8e1fac02c8-3"><i class="fas fa-bone"></i>Optimizer:查询优化器</button></li><li class="tab"><button type="button" data-href="#68644226-2ebd-4896-90d5-8e8e1fac02c8-4"><i class="fas fa-anchor"></i>Caches&Buffers:查询缓存组件</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="68644226-2ebd-4896-90d5-8e8e1fac02c8-1"><ul><li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface</li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定 义函数等多种SQL语言接口</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="68644226-2ebd-4896-90d5-8e8e1fac02c8-2"><ul><li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构 传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</li><li>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字 典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还 会对SQl查询进行语法上的优化，进行查询重写。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="68644226-2ebd-4896-90d5-8e8e1fac02c8-3"><ul><li>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 执行计划 。</li><li>这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连 接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将 查询结果返回给用户。</li><li>它使用“ 选取-投影-连接 ”策略进行查询。例如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过 滤，将这两个查询条件 连接 起来生成最终查询结果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="68644226-2ebd-4896-90d5-8e8e1fac02c8-4"><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结 果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过 程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在 不同客户端之间共享 。</li><li>从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0fbe1939-61e3-4457-8c80-315887cf7bd1-3"><p>插件式存储引擎层（ Storage Engines），<span class='p red'>真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作</span>，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样 我们可以根据自己的实际需要进行选取。</p><p>MySQL 8.0.25默认支持的存储引擎如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615140556893.png" alt="image-20210615140556893"></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230407102134972.png" alt="image-20230407102134972" style="zoom:33%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h4 id="1-1-4-存储层">1.1.4 存储层</h4><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统 上，以<code>文件</code>的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。</p><h4 id="1-1-5-小结">1.1.5 小结</h4><p>MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615140710351.png" alt="image-20210615140710351" style="zoom: 50%;" /><p>简化为三层结构：</p><ol><li><span class='p green'>连接层</span>：客户端和服务器端建立连接，客户端发送 SQL 至服务器端； </li><li><span class='p green'>SQL 层（服务层）</span>：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</li><li><span class='p green'>存储引擎层</span>：与数据库文件打交道，负责数据的存储和读取。</li></ol><hr><h3 id="1-2-SQL执行流程">1.2 SQL执行流程</h3><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615141934531.png" alt="image-20210615141934531" style="zoom: 67%;" /><span class='p red'>MySQL的查询流程：</span><div class="tabs" id="0cb8e838-e6d5-4c70-ad46-d60c36ceaeac"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0cb8e838-e6d5-4c70-ad46-d60c36ceaeac-1"><i class="fas fa-atom"></i>查询缓存</button></li><li class="tab"><button type="button" data-href="#0cb8e838-e6d5-4c70-ad46-d60c36ceaeac-2"><i class="far fa-sun"></i>解析器</button></li><li class="tab"><button type="button" data-href="#0cb8e838-e6d5-4c70-ad46-d60c36ceaeac-3"><i class="fas fa-wind"></i>优化器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0cb8e838-e6d5-4c70-ad46-d60c36ceaeac-1"><p>Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为<span class='p red'>查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃了这个功能。</span></p><p><span class='p red'>大多数情况查询缓存就是个鸡肋，为什么呢？</span></p><blockquote><p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，只有<code>相同的查询操作</code>才会命中查询缓存。两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。因此 MySQL 的查询缓存命中率不高。</p><p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数<code>NOW</code>，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！</p><p>此外，既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>TRUNCATE TABLE</code>、<code>ALTERTABLE</code>、<code>DROP TABLE</code>或<code>DROP DATABASE</code>语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除！对于更新压力大的数据库来说，查询缓存的命中率会非常低。</p></blockquote><p>总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁。</p><p>一般建议大家在静态表里使用查询缓存，什么叫<code>静态表</code>呢？就是一般我们极少更新的表。比如，一个系统配置表、字典表，这张表上的查询才适合使用查询缓存。MySQL也提供了这种“<code>按需使用</code>”的方式。你可以将 my.cnf 参数 query_cache_type 设置成 DEMAND，代表当 sql 语句中有 SQL_CACHE关键字时才缓存。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0cb8e838-e6d5-4c70-ad46-d60c36ceaeac-2"><p>在解析器中对 SQL 语句进行语法分析、语义分析。</p><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。SQL语句的分析分为词法分析与语法分析。</p><p>分析器先做“<code>词法分析</code>”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。</p><p>MySQL 从你输入的&quot;select&quot;这个关键字识别出来，这是一个查询语 句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p><p>接着，要做“<code>语法分析</code>”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否<code>满足 MySQL 语法</code>。</p><p>select department_id,job_id, avg(salary) from employees group by department_id;</p><p>如果SQL语句正确，则会生成一个这样的语法树：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615162031427.png" alt="image-20210615162031427"></p><p>下图是SQL分词分析的过程步骤:</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615163338495.png" alt="image-20210615163338495"></p><p>至此解析器的工作任务也基本圆满了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0cb8e838-e6d5-4c70-ad46-d60c36ceaeac-3"><p>在优化器中会确定 SQL 语句的执行路径，比如是根据<code>全表检索</code>，还是根据<code>索引检索</code>等。</p><p>经过解释器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。<strong>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划</strong>。</p><p>比如：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联 (join) 的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。</p><p>举例：如下语句是执行两个表的 join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test1 <span class="keyword">join</span> test2 <span class="keyword">using</span>(ID)</span><br><span class="line"><span class="keyword">where</span> test1.name<span class="operator">=</span><span class="string">&#x27;zhangwei&#x27;</span> <span class="keyword">and</span> test2.name<span class="operator">=</span><span class="string">&#x27;mysql高级课程&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>方案1：可以先从表 test1 里面取出 name='zhangwei’的记录的 ID 值，再根据 ID 值关联到表 test2，再判<br>断 test2 里面 name的值是否等于 ‘mysql高级课程’。</p><p>方案2：可以先从表 test2 里面取出 name=‘mysql高级课程’ 的记录的 ID 值，再根据 ID 值关联到 test1，<br>再判断 test1 里面 name的值是否等于 zhangwei。</p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化<br>器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。<br>如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</p></blockquote><p>在查询优化器中，可以分为<code>逻辑查询</code>优化阶段和<code>物理查询</code>优化阶段。</p><p>逻辑查询优化就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行<code>等价变换</code>，对查询进行<code>重写</code>，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。</p><p>物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地<code>使用索引</code>，提升查询效率。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。</p><p>SQL 语句在 MySQL 中的流程是：<code>SQL语句</code>→<code>查询缓存</code>→<code>解析器</code>→<code>优化器</code>→<code>执行器</code>。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615164722975.png" alt="image-20210615164722975"></p><!-- endtab --><hr><h3 id="1-3-数据库缓冲池-buffer-pool">1.3 数据库缓冲池(buffer pool)</h3><p><code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请占用内存来作为数据<code>缓冲池</code>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。</p><p>这样做的好处是可以让磁盘活动最小化，从而<code>减少与磁盘直接进行 I/O 的时间</code>。要知道，这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p><p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615175309751.png" alt="image-20210615175309751"></p><p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。</p><span class='p red'>缓存池的重要性：</span><p>对于使用<code>InnoDB</code>作为存储引擎的表来说，不管是用于存储用户数据的索引（包括聚簇索引和二级索引），还是各种系统数据，都是以<code>页</code>的形式存放在<code>表空间</code>中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的跟乌龟一样，怎么能配得上<code>“快如风，疾如电”的CPU</code>呢？这里，缓冲池可以帮助我们消除CPU和磁盘之间的<code>鸿沟</code>。所以 InnoDB存储引擎在处理客户端的请求时，当需要访问某个页的数据时，就会把<code>完整的页的数据全部加载到内存</code>中， 也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其<code>缓存</code>起来，这样将来有请求再次访问该页面时，就可以<code>省去磁盘IO</code>的开销了。</p><span class='p green'>缓存原则：</span><p>“<code>位置 * 频次</code>”这个原则，可以帮我们对 I/O 访问效率进行优化。</p><p>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。</p><p>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会<code>优先对使用频次高的热数据进行加载</code>。</p><span class='p green'>缓冲池的预读特性:</span><p>缓冲池的作用就是提升 I/O 效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，<strong>大概率还会使用它周围的一些数据</strong>，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘 I/O 操作。</p><blockquote><p>缓冲池和查询缓存是一个东西吗？ <span class='p red'>否</span></p></blockquote><p>查询缓存是提查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p><blockquote><span class='p blue'>缓冲池如何读取数据？</span></blockquote><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p><p>缓存在数据库中的结构和作用如下图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615193131719.png" alt="image-20210615193131719"></p><blockquote><span class='p green'>如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？</span></blockquote><p>实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会<code>以一定的频率刷新</code>到磁盘中。注意并不是每次发生更新操作，都会立即进行磁盘回写。缓冲池会采用一种叫做<code>checkpoint 的机制</code>将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。</p><p>比如，当<code>缓冲池不够用</code>时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，将不常用的脏页回写到磁盘上，然后再从缓存池中将这些页释放掉。这里的脏页 (dirty page) 指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。</p><blockquote><span class='p blue'>如何查看/设置缓冲池的大小、实例个数</span></blockquote><div class="tabs" id="c76b8aba-bf80-42f3-994e-f232c80ccf91"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c76b8aba-bf80-42f3-994e-f232c80ccf91-1"><i class="fas fa-atom"></i>设置大小</button></li><li class="tab"><button type="button" data-href="#c76b8aba-bf80-42f3-994e-f232c80ccf91-2"><i class="far fa-sun"></i>设置Buffer Pool实例数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c76b8aba-bf80-42f3-994e-f232c80ccf91-1"><p>如果你使用的是 MySQL MyISAM 存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为<code>key_buffer_size</code>，你可以用它进行查看。</p><p>如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大小。命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615214847480.png" alt="image-20210615214847480" style="zoom:80%;" /><p>你能看到此时 InnoDB 的缓冲池大小只有 134217728/1024/1024=128MB。我们可以修改缓冲池大小，比如改为256MB，方法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> <span class="number">268435456</span>;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size <span class="operator">=</span> <span class="number">268435456</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c76b8aba-bf80-42f3-994e-f232c80ccf91-2"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这样就表明我们要创建2个<code>Buffer Pool</code>实例。</p><p>我们看下如何查看缓冲池的个数，使用命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_instances&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230407190758971.png" alt="image-20230407190758971"></p><p>那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size<span class="operator">/</span>innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure><p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p><p>不过也不是说 Buffer Pool 实例创建的越多越好，分别管理各个 Buffer Pool 也是需要性能开销的，InnDB规定：当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances的值修改为1。而我们鼓励在 Buffer Pool 大于等于 1G 的时候设置多个 Buffer Pool 实例。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><blockquote><span class='p red'>引申问题：我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？</span></blockquote><p>Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。</p><p>黑盒下的更新数据流程</p><p>当我们查询数据的时候，会先去 Buffer Pool 中查询。如果 Buffer Pool 中不存在，存储引擎会先将数据从磁盘加载到 Buffer Pool 中，然后将数据返回给客户端；同理，当我们更新某个数据的时候，如果这个数据不存在于 Buffer Pool，同样会先数据加载进来，然后修改内存的数据。被修改的数据会在之后统一刷入磁盘。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615222455867.png" alt="image-20210615222455867" style="zoom:75%;" /><span class='p green'>答案：Redo Log & Undo Log</span><hr><h2 id="2-存储引擎">2. 存储引擎</h2><p>为了管理方便，人们把<code>连接管理、查询绶存、语法解析、查询优化</code>这些并不涉及真实数据存储的功能划分为<code>MySQL server</code>的功能，把真实存取数据的功能划分为<code>存储引擎</code>的功能。所以在<code>MySQL server</code>完成了查询优化后，只需按照生成的<code>执行计划</code>调用底层存储引擎提供的APl，获取到数据后返回给客户端就好了。</p><p>MySQL中提到了存储引擎的概念。简而言之，<code>存储引擎就是指表的类型。</code>其实存储引擎以前叫做<code>表处理器</code>，后来改名为<code>存储引擎</code>，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p><div class="tabs" id="dba4892e-9f59-4cb2-8845-6951a1a2cae8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dba4892e-9f59-4cb2-8845-6951a1a2cae8-1"><i class="fas fa-bug"></i>查看存储引擎</button></li><li class="tab"><button type="button" data-href="#dba4892e-9f59-4cb2-8845-6951a1a2cae8-2"><i class="fas fa-cannabis"></i>修改系统存储引擎</button></li><li class="tab"><button type="button" data-href="#dba4892e-9f59-4cb2-8845-6951a1a2cae8-3"><i class="fas fa-candy-cane"></i>设置表的存储引擎</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dba4892e-9f59-4cb2-8845-6951a1a2cae8-1"><p>查看mysql提供什么存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615223831995.png" alt="image-20210615223831995"></p><p>查看系统默认的存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br><span class="line">#或</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@default</span>_storage_engine;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210615224249491.png" alt="image-20210615224249491" style="zoom:60%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dba4892e-9f59-4cb2-8845-6951a1a2cae8-2"><p>修改默认的存储引擎</p><p>如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。 如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><p>或者修改 my.cnf 文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span><span class="operator">-</span>storage<span class="operator">-</span>engine<span class="operator">=</span>MyISAM</span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dba4892e-9f59-4cb2-8845-6951a1a2cae8-3"><p>我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB 。如果我们想显 式的指定一下表的存储引擎，那可以这么写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">建表语句;</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><p>如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><p>比如我们修改一下 engine_demo_table 表的存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> engine_demo_table ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="2-1-引擎介绍">2.1 引擎介绍</h3><div class="tabs" id="53809b56-a6af-4480-8840-c5311d4bd7af"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#53809b56-a6af-4480-8840-c5311d4bd7af-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#53809b56-a6af-4480-8840-c5311d4bd7af-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#53809b56-a6af-4480-8840-c5311d4bd7af-3"><i class="fas fa-dove"></i>3</button></li><li class="tab"><button type="button" data-href="#53809b56-a6af-4480-8840-c5311d4bd7af-4"><i class="fas fa-dragon"></i>4</button></li><li class="tab"><button type="button" data-href="#53809b56-a6af-4480-8840-c5311d4bd7af-5"><i class="fas fa-atom"></i>5</button></li><li class="tab"><button type="button" data-href="#53809b56-a6af-4480-8840-c5311d4bd7af-6"><i class="far fa-sun"></i>6</button></li><li class="tab"><button type="button" data-href="#53809b56-a6af-4480-8840-c5311d4bd7af-7"><i class="fas fa-wind"></i>7</button></li><li class="tab"><button type="button" data-href="#53809b56-a6af-4480-8840-c5311d4bd7af-8"><i class="fas fa-fire-alt"></i>8</button></li><li class="tab"><button type="button" data-href="#53809b56-a6af-4480-8840-c5311d4bd7af-9"><i class="fas fa-tree"></i>9</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="53809b56-a6af-4480-8840-c5311d4bd7af-1"><p><span class='p green'>InnoDB 引擎：具备外键支持功能的事务存储引擎</span></p><p>MySQL从3.23开始就包含InnoDB存储引擎。<code>大于等于5.5之后，默认采用InnoDB引擎</code>。</p><p>InnoDB是MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</p><p>除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 <span class='p red'>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</span></p><p>数据文件结构：</p><ul><li>表名.frm 存储表结构<span class='p red'>（MySQL8.0时，合并在表名.ibd中，即没有.frm）</span></li><li>表名.ibd 存储数据和索引</li></ul><p>InnoDB是为处理巨大数据量的最大性能设计 。</p><ul><li>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除 了。比如：<code>.frm , .par  , .trn, .isl , .db , .opt</code>等都在MySQL8.0中不存在了。</li></ul><p>对比MyISAM的存储引擎，<code>InnoDB写的处理效率差一些</code>，并且会占用更多的磁盘空间以保存数据和索引。</p><p>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，<code>对内存要求较高</code>，而且内存大小对性能有决定性的影响。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="53809b56-a6af-4480-8840-c5311d4bd7af-2"><p><span class='p green'>MyISAM 引擎：主要的非事务处理存储引擎</span></p><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级 锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。</p><p>5.5之前默认的存储引擎</p><p>优势是<code>访问的速度快</code>，对事务完整性没有要求或者以SELECT、INSERT为主的应用</p><p>针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高 数据文件结构：</p><ul><li>表名.frm 存储表结构</li><li>表名.MYD 存储数据 (MYData)</li><li>表名.MYI 存储索引 (MYIndex)</li></ul><p>应用场景：只读应用或者以读为主的业务</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="53809b56-a6af-4480-8840-c5311d4bd7af-3"><p>Archive 引擎：用于数据存档</p><p>archive 是归档的意思，仅仅支持插入和查询两种功能（行被插入后不能再修改）。</p><p>在MySQL5.5以后支持索引功能。</p><p>拥有很好的压缩机制，使用z1ib压缩库，在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。</p><p>创建ARCHIVE表时，存储引擎会创建名称以表名开头的文件。数据文件的扩展名为.ARZ。</p><p>根据英文的测试结论来看，同样数据量下，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</p><p>ARCHIVE存储引擎采用了<code>行级锁</code>。该ARCHIVE引擎支持 AUTO_ INCREMENT 列属性。AUTO_INCREMENT列可以具有唯一索引或非唯一索引。尝试在任何其他列上创建索引会导致错误。</p><p>Archive表适合<code>日志和数据采集（档案）类应用</code>；适合存储大量的独立的作为历史记录的数据。拥有很高的插入速度，但是对查询的支持较差。</p><p>下表展示了ARCHIVE 存储引擎功能</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210616124743732.png" alt="image-20210616124743732"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="53809b56-a6af-4480-8840-c5311d4bd7af-4"><p>Blackhole 引擎：丢弃写操作，读操作会返回空内容</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="53809b56-a6af-4480-8840-c5311d4bd7af-5"><p>CSV 引擎：存储数据时，以逗号分隔各个数据项</p><p>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。</p><p>CSV引擎可以作为一种数据交换的机制，非常有用。</p><p>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者exce读取。</p><p>对于数据的快速导入、导出是有明显优势的。</p><p>创建CSV表时，服务器会创建一个纯文本数据文件，其名称以表名开头并带有.CSV扩展名。当你将数据存储到表中时，存储引擎将其以逗号分隔值格式保存到数据文件中。</p><p>使用案例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (i <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, c <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>) ENGINE <span class="operator">=</span> CSV;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.06</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;record one&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;record two&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.05</span> sec)</span><br><span class="line">Records: <span class="number">2</span> Duplicates: <span class="number">0</span> Warnings: <span class="number">0</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+------------+</span></span><br><span class="line"><span class="operator">|</span> i <span class="operator">|</span>      c     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span> record <span class="keyword">one</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span> record two <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>创建CSV表还会创建相应的元文件 ，用于 存储表的状态 和 表中存在的行数 。此文件的名称与表的名称相 同，后缀为 CSM 。如图所示</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210616125342599.png" alt="image-20210616125342599"></p><p>如果检查 test.CSV 通过执行上述语句创建的数据库目录中的文件，其内容使用Notepad++打开如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;1&quot;,&quot;record one&quot;</span><br><span class="line">&quot;2&quot;,&quot;record two&quot;</span><br></pre></td></tr></table></figure><p>这种格式可以被 Microsoft Excel 等电子表格应用程序读取，甚至写入。使用Microsoft Excel打开如图所示</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210616125448555.png" alt="image-20210616125448555"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="53809b56-a6af-4480-8840-c5311d4bd7af-6"><p>Memory 引擎：置于内存的表</p><p><strong>概述：</strong></p><p>Memory采用的逻辑介质是内存 ，响应速度很快 ，但是当mysqld守护进程崩溃的时候数据会丢失 。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。</p><p><strong>主要特征：</strong></p><ul><li>Memory同时 支持哈希（HASH）索引 和 B+树索引 。</li><li>Memory表至少比MyISAM表要快一个数量级 。</li><li>MEMORY 表的大小是受到限制 的。表的大小主要取决于两个参数，分别是 max_rows 和 max_heap_table_size 。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默 认为16MB，可以按需要进行扩大。</li><li>数据文件与索引文件分开存储。</li><li>缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。</li></ul><p><strong>使用Memory存储引擎的场景：</strong></p><ol><li>目标数据比较小 ，而且非常频繁的进行访问 ，在内存中存放数据，如果太大的数据会造成内存溢出 。可以通过参数 max_heap_table_size 控制Memory表的大小，限制Memory表的最大的大小。</li><li>如果数据是临时的 ，而且必须立即可用得到，那么就可以放在内存中。</li><li>存储在Memory表中的数据如果突然间丢失的话也没有太大的关系 。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="53809b56-a6af-4480-8840-c5311d4bd7af-7"><p>Federated 引擎：访问远程表</p><p><strong>Federated引擎是访问其他MySQL服务器的一个 代理 ，尽管该引擎看起来提供了一种很好的 跨服务 器的灵活性 ，但也经常带来问题，因此 默认是禁用的 。</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="53809b56-a6af-4480-8840-c5311d4bd7af-8"><p>Merge引擎：管理多个MyISAM表构成的表集合</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="53809b56-a6af-4480-8840-c5311d4bd7af-9"><p>NDB引擎：MySQL集群专用存储引擎</p><p>也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群 环境，类似于 Oracle 的 RAC 集群。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-2-MyISAM和InnoDB对比">2.2 MyISAM和InnoDB对比</h3><table><thead><tr><th style="text-align:center">对比选项</th><th style="text-align:center">MyISAM</th><th style="text-align:center">InnoDB</th></tr></thead><tbody><tr><td style="text-align:center">外键</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">事务</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">行表锁</td><td style="text-align:center">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td style="text-align:center">行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td style="text-align:center">缓存</td><td style="text-align:center">只缓存索引，不缓存真实数据</td><td style="text-align:center">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td style="text-align:center">自带系统表使用</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">关注点</td><td style="text-align:center">性能：节省资源、消耗少、简单业务</td><td style="text-align:center">事务：并发写、事务、更大资源</td></tr><tr><td style="text-align:center">默认安装</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:center">默认使用</td><td style="text-align:center">N</td><td style="text-align:center">Y</td></tr></tbody></table><blockquote><p>补充：为什么InnoDB没有像MyISAM那样记录表的总行数？</p></blockquote><p>对于MyISAM：<br>因为MySQL对该引擎的count有对应优化，精确的行数会被储存在存储引擎中，因此此类没有where条件的单表总行数查询会迅速返回结果。<br>对于InnoDB：<br>因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引。<br>如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试SHOW TABLE STATUS</p><hr><h3 id="2-3-课外补充">2.3 课外补充</h3><blockquote><p>阿里巴巴、淘宝用哪个存储引擎？</p></blockquote><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230407200425135.png" alt="image-20230407200425135"></p><ul><li>Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。</li><li>该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外有更多的参数和命令来控制服务器行为。</li><li>该公司新建了一款存储引擎叫Xtradb 完全可以替代Innodb ，并且在性能和并发上做得更好</li><li>阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。</li></ul><blockquote><p>1、InnoDB的优势</p></blockquote><p>InnoDB存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。</p><p>InnoDB存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。</p><p>在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。<code>InnoDB不仅支持当前读写，也会缓冲改变的数据到数据流磁盘。</code></p><p>InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度。使用InnoDB可以压缩表和相关的索引，<code>可以在不影响性能和可用性的情况下创建或删除索引</code>。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。<code>当处理大数据量时，InnoDB兼顾CPU，以达到最大性能。</code></p><blockquote><p>2、InnoDB和ACID模型</p></blockquote><p>ACID模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应用非常重要。MySQL包含类似InnoDB存储引擎的组件，与ACID模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖ACID模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将MySQL设置调整为只依赖部分ACID特性，以达到更高的性能。下面讲解InnoDB存储引擎与ACID模型相同作用的四个方面。</p><div class="tabs" id="8e9b218f-011e-4c55-bc56-637a8c82aaeb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8e9b218f-011e-4c55-bc56-637a8c82aaeb-1"><i class="fas fa-seedling"></i>原子方面</button></li><li class="tab"><button type="button" data-href="#8e9b218f-011e-4c55-bc56-637a8c82aaeb-2"><i class="fas fa-leaf"></i>一致性方面</button></li><li class="tab"><button type="button" data-href="#8e9b218f-011e-4c55-bc56-637a8c82aaeb-3"><i class="fab fa-apple"></i>隔离方面</button></li><li class="tab"><button type="button" data-href="#8e9b218f-011e-4c55-bc56-637a8c82aaeb-4"><i class="fas fa-tree"></i>耐久性方面</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8e9b218f-011e-4c55-bc56-637a8c82aaeb-1"><p>ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括：</p><ul><li>自动提交设置。</li><li>COMMIT语句。</li><li>ROLLBACK语句。</li><li>操作INFORMATION_SCHEMA库中的表数据。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8e9b218f-011e-4c55-bc56-637a8c82aaeb-2"><p>ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性主要包括：</p><ul><li>InnoDB双写缓存。</li><li>InnoDB崩溃恢复。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8e9b218f-011e-4c55-bc56-637a8c82aaeb-3"><p>隔离是应用于事务的级别，与MySQL相关的特性主要包括：</p><ul><li>自动提交设置。</li><li>SET ISOLATION LEVEL语句。</li><li>InnoDB锁的低级别信息。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8e9b218f-011e-4c55-bc56-637a8c82aaeb-4"><p>ACID模型的耐久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循。与MySQL相关的特性有：</p><ul><li>InnoDB双写缓存，通过innodb_doublewrite配置项配置。</li><li>配置项innodb_flush_log_at_trx_commit。</li><li>配置项sync_binlog。</li><li>配置项innodb_file_per_table。</li><li>存储设备的写入缓存。</li><li>存储设备的备用电池缓存。</li><li>运行MySQL的操作系统。</li><li>持续的电力供应。</li><li>备份策略。</li><li>对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>3、InnoDB架构</p></blockquote><ol><li><p>缓冲池 缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。</p></li><li><p>更改缓存 更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管理。</p></li><li><p>自适应哈希索引 自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过–skip-innodb_adaptive_hash_index命令行在服务启动时关闭。</p></li><li><p>重做日志缓存 重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存使得大型事务能够正常运行而不需要写入磁盘。</p></li><li><p>系统表空间 系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。</p></li><li><p>双写缓存 双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB才会将数据页写入合适的位置。</p></li><li><p>撤销日志 撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。</p></li><li><p>每个表一个文件的表空间 每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数据文件代表，该文件默认被创建在数据库目录中。</p></li><li><p>通用表空间 使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数据目录之外能够管理多个表并支持所有行格式的表。</p></li><li><p>撤销表空间 撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由innodb_undo_tablespaces配置项配置。</p></li><li><p>临时表空间 用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。</p></li><li><p>重做日志 重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.ThreadLocal</title>
      <link href="/posts/5ce1.html"/>
      <url>/posts/5ce1.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-ThreadLocal简介">1. ThreadLocal简介</h2><h3 id="1-1-ThreadLocal是什么">1.1 ThreadLocal是什么</h3><p>ThreadLocal提供线程局部变量。这些变量与正常的变量不同，因为每一个线程在访问 ThreadLocal实例的时候（通过其get、set方法）都有自己的、独立初始化的变量剛本。ThreadLocal实例通常是类中的私有静态字段，使用它的目的是希望将状态（例如，用户ID或事务ID）与线程关联起来。</p><p>①. ThreadLocal本地线程变量,<span class='p green'>线程自带的变量副本</span>(实现了每一个线程副本都有一个专属的本地变量,主要解决的就是让每一个线程绑定自己的值,自己用自己的,不跟别人争抢。通过使用get()和set()方法,获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全的问题)</p><p>②. synchronized或者lock,有个管理员,好比,现在大家签到,多个同学(线程),但是只有一只笔,只能同一个时间,只有一个线程(同学)签到,加锁(同步机制是以时间换空间,执行时间不一样,类似于排队)</p><p>③. ThreadLocal,人人有份,每个同学手上都有一支笔,自己用自己的,不用再加锁来维持秩序(同步机制是以空间换时间,为每一个线程都提供了一份变量的副本,从而实现同时访问,互不干扰同时访问,肯定效率高啊)</p><hr><h3 id="1-2-api介绍">1.2 api介绍</h3><div class="tabs" id="8f937209-a42d-4813-b981-8b52eed9e500"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8f937209-a42d-4813-b981-8b52eed9e500-1"><i class="fas fa-bug"></i>API</button></li><li class="tab"><button type="button" data-href="#8f937209-a42d-4813-b981-8b52eed9e500-2"><i class="fas fa-cannabis"></i>withInitial源码分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8f937209-a42d-4813-b981-8b52eed9e500-1"><p>①.<code>protected T initialValue():initialValue()</code>:返回此线程局部变量的当前线程的&quot;初始值&quot;(对于initialValue()较为老旧,jdk1.8又加入了withInitial()方法)</p><p>②.<code>static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</code>:创建线程局部变量,变量的初始值是通过调用<code>get</code>方法来<code>Supplier</code>。</p><p>③.<code>T get()</code>:返回当前线程的此线程局部变量的副本中的值</p><p>④.<code>void set(T value)</code>:将当前线程的此线程局部变量的副本设置为指定的值</p><p>⑤.<code>void remove()</code>:删除此线程局部变量的当前线程的值</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230405195310770.png" alt="image-20230405195310770" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8f937209-a42d-4813-b981-8b52eed9e500-2"><p>调用<code>static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</code>创建ThreadLocal时</p><p>例如：<code>ThreadLocal&lt;Integer&gt; threadLocal= ThreadLocal.withInitial(()-&gt;0);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="title function_">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实则：返回了ThreadLocal的子类，ThreadLocal 的扩展，从指定的Supplier获取其初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="1-3-示例">1.3 示例</h3><p>需求：5个销售员卖房子(相当于五个线程)，各自独立销售，集团高层只关心每个销售员出售多少套房子。</p><div class="tabs" id="82428b19-8304-4700-bde9-f4ea56c0a683"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#82428b19-8304-4700-bde9-f4ea56c0a683-1"><i class="fas fa-award"></i>House类</button></li><li class="tab"><button type="button" data-href="#82428b19-8304-4700-bde9-f4ea56c0a683-2"><i class="fas fa-baseball-ball"></i>统计</button></li><li class="tab"><button type="button" data-href="#82428b19-8304-4700-bde9-f4ea56c0a683-3"><i class="fas fa-bone"></i>纠正</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="82428b19-8304-4700-bde9-f4ea56c0a683-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">House</span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Integer&gt; threadLocal= ThreadLocal.withInitial(()-&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saleHouse</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//T get():返回当前线程的此线程局部变量的副本中的值。</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        value++;</span><br><span class="line">        <span class="comment">//void set(T value):将当前线程的此线程局部变量的副本设置为指定的值。</span></span><br><span class="line">        threadLocal.set(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="82428b19-8304-4700-bde9-f4ea56c0a683-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">int</span> size=<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">5</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=size;j++)&#123;</span><br><span class="line">                house.saleHouse();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;共计卖出:&quot;</span>+house.threadLocal.get());</span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1共计卖出:2</span></span><br><span class="line"><span class="comment">//2共计卖出:3</span></span><br><span class="line"><span class="comment">//4共计卖出:2</span></span><br><span class="line"><span class="comment">//3共计卖出:1</span></span><br><span class="line"><span class="comment">//5共计卖出:5</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="82428b19-8304-4700-bde9-f4ea56c0a683-3"><p>阿里规范：必须回收自定义的ThreadLocal变量记录的当前线程的值，尤其在<code>线程池场景下，线程经常会被复用</code>，如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代码中使用try-finally块进行回收。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>总结</p><p>①. 因为每个Thread内有自己的实例副本且该副本只由当前线程自己使用</p><p>②. 既然其他Thread不可访问,那就不存在多线程共享的问题</p><p>③. 统一设置初始值,但是每个线程对这个值的修改都是各自线程互相独立的</p><p>④. 加入synchronized或者lock控制线程的访问顺序,而ThreadLocal人手一份,大家各自安好,没必要抢夺</p><hr><h2 id="2-ThreadLocal源码分析">2. ThreadLocal源码分析</h2><blockquote><p>Thread  |  ThreadLocal  |  ThreadLocalMap  关系</p></blockquote><div class="tabs" id="aa9edaf1-e423-4c3e-92c4-7709665abd12"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#aa9edaf1-e423-4c3e-92c4-7709665abd12-1"><i class="fas fa-seedling"></i>①. Thread和ThreadLocal</button></li><li class="tab"><button type="button" data-href="#aa9edaf1-e423-4c3e-92c4-7709665abd12-2"><i class="fas fa-leaf"></i>②. ThreadLocal和ThreadLocalMap</button></li><li class="tab"><button type="button" data-href="#aa9edaf1-e423-4c3e-92c4-7709665abd12-3"><i class="fab fa-apple"></i>总结</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="aa9edaf1-e423-4c3e-92c4-7709665abd12-1"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/20210406191343536.png" alt="在这里插入图片描述"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="aa9edaf1-e423-4c3e-92c4-7709665abd12-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230405210602560.png" alt="image-20230405210602560" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="aa9edaf1-e423-4c3e-92c4-7709665abd12-3"><ul><li>Thread类中有一个ThreadLocal.ThreadLocalMap threadLocals = null的变量,这个ThreadLocal相当于是Thread类和ThreadLocalMap的桥梁,在ThreadLocal中有静态内部类ThreadLocalMap,ThreadLocalMap中有Entry数组</li><li>当我们为threadLocal变量赋值,实际上就是以当前threadLocal实例为key,值为value的Entry往这个threadLocalMap中存放</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230405210717894.png" alt="image-20230405210717894" style="zoom:50%;" /><p>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以ThreadLocal为Key)，不过是经过了两层包装的ThreadLocal对象。</p><p>JVM内部维护了一个线程版的Map&lt;ThreadLocal,Value&gt;(通过ThreadLocal对象的set方法，结果把ThreadLocal对象自己当做key, 放进了 ThreadLoalMap中),每个线程要用到这个T的时候，用当前的线程去Map里面获取，通过这样让每个线程都拥有了自己独立的变量，人手一份，竞争条件被彻底消除，在并发模式下是绝对安全的变量。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-1-set方法详解">2.1 set方法详解</h3><ul><li>①. 首先获取当前线程,并根据当前线程获取一个Map</li><li>②. 如果获取的Map不为空,则将参数设置到Map中(当前ThreadLocal的引用作为key)</li><li>③. 如果Map为空,则给该线程创建 Map,并设置初始值</li></ul><div class="tabs" id="fbb5bde0-61cc-47e4-92de-1a5fc5a605ae"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-1"><i class="fas fa-bug"></i>set(T value)</button></li><li class="tab"><button type="button" data-href="#fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-2"><i class="fas fa-cannabis"></i>getMap(Thread t)</button></li><li class="tab"><button type="button" data-href="#fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-3"><i class="fas fa-candy-cane"></i>createMap(Thread t, T firstValue)</button></li><li class="tab"><button type="button" data-href="#fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-4"><i class="fas fa-child"></i>ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue)</button></li><li class="tab"><button type="button" data-href="#fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-5"><i class="fas fa-dragon"></i>set(ThreadLocal<?> key, Object value)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//初始化table</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">//计算索引(重点代码)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">////设置值</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fbb5bde0-61cc-47e4-92de-1a5fc5a605ae-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">//计算索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//找到key对应的Entry</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-2-get方法详解">2.2 get方法详解</h3><p>先获取当前线程的ThreadLocalMap变量,如果存在则返回值,不存在则创建并返回初始值</p><div class="tabs" id="f87e3815-791e-4062-bb4f-336b351895d4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#f87e3815-791e-4062-bb4f-336b351895d4-1"><i class="fas fa-atom"></i>get()</button></li><li class="tab"><button type="button" data-href="#f87e3815-791e-4062-bb4f-336b351895d4-2"><i class="far fa-sun"></i>setInitialValue()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="f87e3815-791e-4062-bb4f-336b351895d4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量,</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 以当前的ThreadLocal 为 key,调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 对e进行判空</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="comment">// 即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 : 有两种情况有执行当前代码</span></span><br><span class="line"><span class="comment">     * 第一种情况: map不存在,表示此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="comment">     * 第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f87e3815-791e-4062-bb4f-336b351895d4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value 初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用initialValue获取初始化的值</span></span><br><span class="line">    <span class="comment">// 此方法可以被子类重写, 如果不重写默认返回null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 判断map是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 1)当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2)则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3)并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="2-3-remove方法详解">2.3 remove方法详解</h3><ul><li>①. 首先获取当前线程,并根据当前线程获取一个Map</li><li>②. 如果获取的Map不为空,则移除当前ThreadLocal对象对应的entry</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">        <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-ThreadLocal内存泄漏问题">3. ThreadLocal内存泄漏问题</h2><blockquote><p>为什么Entry使用弱引用?</p></blockquote><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230405233131908.png" alt="image-20230405233131908" style="zoom:50%;" /><div class="tabs" id="82c55e9f-4744-4f2e-8b2e-2aeb23d58dc2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#82c55e9f-4744-4f2e-8b2e-2aeb23d58dc2-1"><i class="fas fa-award"></i>1</button></li><li class="tab"><button type="button" data-href="#82c55e9f-4744-4f2e-8b2e-2aeb23d58dc2-2"><i class="fas fa-baseball-ball"></i>2</button></li><li class="tab"><button type="button" data-href="#82c55e9f-4744-4f2e-8b2e-2aeb23d58dc2-3"><i class="fas fa-bone"></i>3</button></li><li class="tab"><button type="button" data-href="#82c55e9f-4744-4f2e-8b2e-2aeb23d58dc2-4"><i class="fas fa-anchor"></i>清除脏Entry</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="82c55e9f-4744-4f2e-8b2e-2aeb23d58dc2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function01</span><span class="params">()</span>&#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();  <span class="comment">//line1</span></span><br><span class="line">    tl.set(<span class="string">&quot;LuckyBoy&quot;</span>);                            <span class="comment">//line2</span></span><br><span class="line">    tl.get();                                      <span class="comment">//line3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>line1新建了一个ThreadLocal对象，tl是强引用指向这个对象；</p><p>line2调用set()方法后新建一个Entry，通过源码可知Entry对象里的k是弱引用指向这个对象。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230405230616586.png" alt="image-20230405230616586" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="82c55e9f-4744-4f2e-8b2e-2aeb23d58dc2-2"><p>当fumction1方法执行完毕后，栈帧销毁强引用tl也就没有了。但此时线程的 ThreadLocalMap里某个entry的key引用还指向这个对象</p><p>若这个key引用是强引用，断了一个强引用还一个强引用，就会导致key指向的ThreadLocal对象及v指向的对象不能被gc回收，造成内存泄漏；</p><p>若这个key引用是弱引用就大概率会减少内存泄漏的问题(还有一个key为nul的雷，第2个坑后面讲)。</p><p>使用弱引用， 就可以使<code>ThreadLocal对象</code>在方法执行完华后顺利被回收且Entry的key引用指向为null。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="82c55e9f-4744-4f2e-8b2e-2aeb23d58dc2-3"><p>①. ThreadLocalMap使用ThreadLocal的弱引用作为key,如果一个ThreadLocal没有外部强引用引用他,那么系统gc的时候,这个ThreadLocal势必会被回收,这样一来,ThreadLocalMap中就会出现key为null的Entry,就没有办法访问这些key为null的Entry的value,如果当前线程再迟迟不结束的话(比如正好用在线程池),这些key为null的Entry的value就会一直存在一条强引用链</p><p>②. 虽然弱引用,保证了key指向的ThreadLocal对象能被及时回收,但是v指向的value对象是需要ThreadLocalMap调用get、set时发现key为null时才会去回收整个entry、value</p><p>③. 因此弱引用不能100%保证内存不泄露。我们要在不使用某个ThreadLocal对象后,手动调用remoev方法来删除它,尤其是在线程池中,不仅仅是内存泄露的问题,因为线程池中的线程是重复使用的,意味着这个线程的ThreadLocalMap对象也是重复使用的,如果我们不手动调用remove方法,那么后面的线程就有可能获取到上个线程遗留下来的value值,造成bug</p><p>④. 如果当前thread运行结束,threadLocal,threadLocalMap, Entry没有引用链可达,在垃圾回收的时候都会被系统进行回收</p><p>⑤. 但在实际使用中我们有时候会用线程池去维护我们的线程,比如在Executors.newFixedThreadPool()时创建线程的时候,为了复用线程是不会结束的,所以threadLocal内存泄漏就值得我们小心</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="82c55e9f-4744-4f2e-8b2e-2aeb23d58dc2-4"><p>从前面的set,getEntry,remove 方法看出，在threadLocal的生命周期里，针对threadLocal存在的内存泄漏的问题， 都会通过expungeStaleEntry, cleanSomeSlots,replace StaleEntry这三个方法清理掉key为Ful的脏entry。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h2 id="4-ThreadLocal小总结">4. ThreadLocal小总结</h2><p>①. ThreadLocal 并不解决线程间共享数据的问题</p><p>②. ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</p><p>③. ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题每个线程持有一个只属于自己的专属Map并维护了ThreadLocal对象与具体实例的映射， 该Map由于只被持有它的线程访问，故不存在线程安全以及锁的问题</p><p>④. ThreadLocalMap的Entry对 ThreadLocal的的引用为弱引用，避免了ThreadLocal对象无法被回收的问题</p><p>⑤. 用完之后一定要remove操作</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.CompletableFuture</title>
      <link href="/posts/2400b711.html"/>
      <url>/posts/2400b711.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Future">1. Future</h2><p>Future是Java5新加的一个接口，它提供了一种异步并行计算的功能。如果主线程需要执行一个很耗时的计算任务，我们就可以通过Future把这个任务放到异步线程中执行。主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。</p><p>Future接口(FutureTask实现类)定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试取消执行此任务</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"><span class="comment">//判断任务是否被取消</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//判断任务执行是否完毕</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取异步任务的执行结果</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"><span class="comment">//带超时时间获取任务结果</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">       <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure><p>比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后， 主线程就去做其他事情了，忙其它事情或者先执行完，过了一会才去获取子任务的执行结果或变更的任务状态。<code>Future接口可以为主线程开一个分支任务，专门为主线程处理耗时和费力的复杂业务。</code></p><p>eg.比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。老师在上课，但是口渴，于是让班长这个线程去买水，自己可以继续上课，实现了异步任务。</p><h2 id="2-FutureTask">2. FutureTask</h2><h3 id="2-1-引入">2.1 引入</h3><p>异步多线程任务执行且有返回结果，三个特点：多线程/有返回/异步任务</p><div class="tabs" id="f30d28f3-bc66-4e97-8cc5-b2b95bc89e3e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#f30d28f3-bc66-4e97-8cc5-b2b95bc89e3e-1"><i class="fas fa-atom"></i>多线程</button></li><li class="tab"><button type="button" data-href="#f30d28f3-bc66-4e97-8cc5-b2b95bc89e3e-2"><i class="far fa-sun"></i>有返回</button></li><li class="tab"><button type="button" data-href="#f30d28f3-bc66-4e97-8cc5-b2b95bc89e3e-3"><i class="fas fa-wind"></i>异步任务</button></li><li class="tab"><button type="button" data-href="#f30d28f3-bc66-4e97-8cc5-b2b95bc89e3e-4"><i class="fas fa-fire-alt"></i>组合</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="f30d28f3-bc66-4e97-8cc5-b2b95bc89e3e-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f30d28f3-bc66-4e97-8cc5-b2b95bc89e3e-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>Runnable 接口 没有返回值 , Callable 接口有返回值</p></li><li><p>Runnable 接口 有抛异常 , Callable 接口没有抛异常</p></li></ol><p><code>但是Callable 接口不能替换 Runnable ，因为thread 类的构造方法中根本就没有 Callable 这个类型的参数，只有Runnable类型参数 ，这时我们无法直接使用 Callable 来实现多线程</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f30d28f3-bc66-4e97-8cc5-b2b95bc89e3e-3"><p>异步任务可以通过实现Future接口实现</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f30d28f3-bc66-4e97-8cc5-b2b95bc89e3e-4"><p>如何实现多线程/有返回/异步任务 流程以及思想</p><ol><li>我们无法直接传入一个 callable 的接口类型 , 这时需要找到一个中间人 , 将他们联系起来</li><li>我们知道 Thread 类中可以传入一个 Runnable 接口 , 所以根据这个就可以传入 Runnable的实现子类或者是Runnable 的一些子接口 , 可以发现它有一个叫做 RunnableFuture 子接口,这个子接口还有一个实现子类 叫做 FutureTask (中间人)</li><li>这个 FutureTask类 , 他有一个构造方法 , FutureTask (Callable<V> callable) , 这时我们可以发现 , 它能够传入一个 Callable 接口类型的参数</li><li>这时就连接上了 , 我在 Thread 中传入一个 futureTask (相当于 Runnable 的孙子)，Thread 就间接性的 达成了通过使用 Callable 接口 + FutureTask 来实现多线程/有返回/异步任务这三个特点</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>FutureTask 见名知意 : &quot; 未来的任务 &quot; , 就是使用它就处理一件比较复杂的事情 , 异步调用 , 在不影响主线程的正常执行的前提下 , 另启一条线程去做某些复杂耗时的事情 , 最后处理完成后在和主线程汇总。</p><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给   FutureTask 对象 在后台完成<br>当主线程将来需要时，就可以通过 FutureTask 对象 获得后台作业的计算结果或者执行状态。<br>一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。<br>仅在计算完成时才能检索结果 , 如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。只计算一次 , 因此需要将 get 方法放到最后 , 否则会出现阻塞。</p><h3 id="2-2-优缺点">2.2 优缺点</h3><p><strong>优点</strong></p><p>future+线程池异步多线程任务配合，能显著提高程序的执行效率。</p><div class="tabs" id="codetabs4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#codetabs4-1"><i class="fas fa-seedling"></i>代码</button></li><li class="tab"><button type="button" data-href="#codetabs4-2"><i class="fas fa-leaf"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="codetabs4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="type">long</span> startTime=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;FutureTask&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> j=i;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;task&quot;</span>+j+<span class="string">&quot; over&quot;</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">        threadPool.submit(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    list.forEach((task)-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> endTime=System.currentTimeMillis();</span><br><span class="line">    System.out.println(endTime-startTime);</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="codetabs4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task0 over</span><br><span class="line">task1 over</span><br><span class="line">task2 over</span><br><span class="line"><span class="number">674</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong>缺点</strong></p><div class="tabs" id="2c8e9a02-9d9d-44aa-bff5-5899faa336b8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2c8e9a02-9d9d-44aa-bff5-5899faa336b8-1"><i class="fas fa-atom"></i>get()阻塞</button></li><li class="tab"><button type="button" data-href="#2c8e9a02-9d9d-44aa-bff5-5899faa336b8-2"><i class="far fa-sun"></i>isDone()轮询空转</button></li><li class="tab"><button type="button" data-href="#2c8e9a02-9d9d-44aa-bff5-5899faa336b8-3"><i class="fas fa-fire-alt"></i>结论</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2c8e9a02-9d9d-44aa-bff5-5899faa336b8-1"><p>一旦调用get()方法，不管是否计算完成，都会导致阻塞（所以一般get方法放到最后）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2c8e9a02-9d9d-44aa-bff5-5899faa336b8-2"><p>在实际开发中，不能直接调用Get阻塞，可以等任务什么时候完成了，我们再Get</p><p>利用if(Task.isDone())的方式使得他在结束之后才get(),但是也会消耗cpu</p><p>轮询的方式会耗费无谓的CPU资源，而且也不见得能及时地得到计算结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(task.isDone())&#123;</span><br><span class="line">        System.out.println(task.get());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//暂停</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2c8e9a02-9d9d-44aa-bff5-5899faa336b8-3"><p>Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="2-3-应用现状">2.3 应用现状</h3><p>对于简单的业务场景使用Future完全OK，但是面对复杂的需求下，例如：</p><ul><li><p>回调通知</p><p>应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知。通过轮询的方式去判断任务是否完成，这样非常占CPU并且代码也不优雅</p></li><li><p>创建异步任务</p><p>Future+线程池配合</p></li><li><p>多个任务前后依赖可以组合</p><p>想将多个异步任务的计算结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值，将两个或多个异步计算合成一个异步计算，这几个异步计算相互独立，同时后面这个又依赖前一个处理的结果。比如买鱼-加料-烹饪</p></li><li><p>对计算速度选最快</p><p>当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果。</p></li><li><p>…</p><p>使用Future之前提供的那点API就囊中羞涩，处理起来不够优雅，这时候还是让CompletableFuture以声明式的方式优雅的处理这些需求从i到i++，o(n_n)O哈哈~<br>Future能干的，CompletableFuture都能干。</p></li></ul><h2 id="3-CompletableFuture">3. CompletableFuture</h2><h3 id="3-1-对Future的改进">3.1 对Future的改进</h3><p>get()方法在Future 计算完成之前会一直处在阻塞状态下，isDone()方法容易耗赀CPU资源，对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果。</p><p><code>阻寨的方式和异步编程的设计理念相违背，而轮询的方式会耗费无谓的CPU资源。</code></p><p>因此， JDK8设计出CompletableFuture。CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。它是Future的功能增强版，减少阻塞和轮询可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><hr><p>类架构</p><p>CompletableFuture同时实现了两个接口CompletionStage接口和Future接口。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230405132328616.png" alt="image-20230405132328616" style="zoom:50%;" /><p>Completionstage代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。</p><p>一个阶段的计算执行可以是一个Function,Consumer或者Runnable。比如：<code>stage.thenApply(x-&gt;square(x)).thenAccept (x -&gt; System.out.print(x)).thenRun(()-&gt; System.out.println())</code></p><p>一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</p><hr><p>在Java8中，CompletableFuture提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合CompletableFuture 的方法。它可能代表—个明确完成的Future，也有可能代表一个完成阶段(CompletionStage），它支持在计算完成以后触发一些函数或执行某些动作。</p><hr><h3 id="3-2-四个核心静态方法">3.2 四个核心静态方法</h3><p>利用核心的四个静态方法创建一个异步操作 | 不建议用new，直接new出来的是不完整的</p><p>参数说明：</p><ul><li>没有指定Executor的方法，直接使用默认的ForkJoinPool.commPool()作为它的线程池执行异步代码。</li><li>如果指定线程池，则使用我们定义的或者特别指定的线程池执行异步代码。</li></ul><p>其中，runAsync无返回值，supplyAsync有返回值。</p><div class="tabs" id="fc6817d3-06f5-49b8-a9c2-a1a2c8b295f6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fc6817d3-06f5-49b8-a9c2-a1a2c8b295f6-1"><i class="fas fa-bug"></i>runAsync</button></li><li class="tab"><button type="button" data-href="#fc6817d3-06f5-49b8-a9c2-a1a2c8b295f6-2"><i class="fas fa-cannabis"></i>runAsync+线程池</button></li><li class="tab"><button type="button" data-href="#fc6817d3-06f5-49b8-a9c2-a1a2c8b295f6-3"><i class="fas fa-candy-cane"></i>supplyAsync</button></li><li class="tab"><button type="button" data-href="#fc6817d3-06f5-49b8-a9c2-a1a2c8b295f6-4"><i class="fas fa-child"></i>supplyAsync+线程池</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fc6817d3-06f5-49b8-a9c2-a1a2c8b295f6-1"><p><code>public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</code></p><p>Void 也是一个类，不经常用到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//停顿几秒线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(voidCompletableFuture.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fc6817d3-06f5-49b8-a9c2-a1a2c8b295f6-2"><p><code>public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable,Executor executor)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">//加入线程池</span></span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//停顿几秒线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,executorService);</span><br><span class="line">    System.out.println(voidCompletableFuture.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fc6817d3-06f5-49b8-a9c2-a1a2c8b295f6-3"><p><code>public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; objectCompletableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;helllo supplyasync&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(objectCompletableFuture.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">helllo supplyasync</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fc6817d3-06f5-49b8-a9c2-a1a2c8b295f6-4"><p><code>public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,Executor executor)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);<span class="comment">//加入线程池</span></span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; objectCompletableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;helllo supplyasync&quot;</span>;</span><br><span class="line">    &#125;,executorService);</span><br><span class="line">    System.out.println(objectCompletableFuture.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">helllo supplyasync</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="3-3-基本功能">3.3 基本功能</h3><div class="tabs" id="d0a8342f-04a1-42bb-b173-a75a043f9cf1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d0a8342f-04a1-42bb-b173-a75a043f9cf1-1"><i class="fas fa-award"></i>完成Future的功能</button></li><li class="tab"><button type="button" data-href="#d0a8342f-04a1-42bb-b173-a75a043f9cf1-2"><i class="fas fa-baseball-ball"></i>减少阻塞和轮询</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d0a8342f-04a1-42bb-b173-a75a043f9cf1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;Object&gt; objectCompletableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;----副线程come in&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);<span class="comment">//产生一个随机数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1秒钟后出结果&quot;</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程先去忙其他任务&quot;</span>);</span><br><span class="line">    System.out.println(objectCompletableFuture.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span>----副线程come in</span><br><span class="line">main线程先去忙其他任务</span><br><span class="line"><span class="number">1</span>秒钟后出结果<span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>join和get对比</p><ul><li>功能几乎一样，区别在于编码时是否需要抛出异常<ul><li>get()方法需要抛出异常</li><li>join()方法不需要抛出异常</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d0a8342f-04a1-42bb-b173-a75a043f9cf1-2"><p><code>CompletableFuture</code>通过<code>whenComplete</code>来<strong>减少阻塞和轮询</strong>（自动回调）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--------副线程come in&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);<span class="comment">//产生随机数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;).whenComplete((v,e) -&gt; &#123;<span class="comment">//没有异常,v是值，e是异常</span></span><br><span class="line">        <span class="keyword">if</span>(e == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;------------------计算完成，更新系统updataValue&quot;</span>+v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally(e-&gt;&#123;<span class="comment">//有异常的情况</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;异常情况&quot;</span>+e.getCause()+<span class="string">&quot;\t&quot;</span>+e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭：暂停3秒钟线程</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程先去忙其他任务&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-<span class="number">1</span>--------副线程come in</span><br><span class="line">main线程先去忙其他任务</span><br><span class="line">------------------计算完成，更新系统updataValue7</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>CompletableFuture优点总结</p><ul><li>异步任务结束时，会<strong>自动回调</strong>某个对象的方法；</li><li>主线程设置好回调后，不再关心异步任务的执行，异步任务之间可以顺序执行</li><li>异步任务出错时，会自动回调某个对象的方法。</li></ul><hr><h3 id="3-4-实战精讲">3.4 实战精讲</h3><blockquote><p>1需求说明<br>同一款产品，同时搜索出同款产品在各大电商平台的售价；</p><p>2输出返回：<br>出来结果希望是同款产品的在不同地方的价格清单列表， 返回一个List<String><br>《mysql》in jd price is 88.05<br>《mysql》in dang dang price is 86.11<br>《mysql》in tao bao price is 90.43</p><p>3解决方案，比对同一个商品在各个平台上的价格，要求获得一个清单列表<br>1   stepbystep   ， 按部就班， 查完京东查淘宝， 查完淘宝查天猫…<br>2   all in       ，万箭齐发，一口气多线程异步任务同时查询。。。</p></blockquote><p>基本框架搭建</p><div class="tabs" id="423e5b22-a9ff-4ac1-aeb4-0e694dd2a889"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#423e5b22-a9ff-4ac1-aeb4-0e694dd2a889-1"><i class="fas fa-atom"></i>NetMall</button></li><li class="tab"><button type="button" data-href="#423e5b22-a9ff-4ac1-aeb4-0e694dd2a889-2"><i class="far fa-sun"></i>按部就班</button></li><li class="tab"><button type="button" data-href="#423e5b22-a9ff-4ac1-aeb4-0e694dd2a889-3"><i class="fas fa-wind"></i>万箭齐发</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="423e5b22-a9ff-4ac1-aeb4-0e694dd2a889-1"><p>模拟电商网站</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetMall</span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String netMallName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NetMall</span><span class="params">(String netMallName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.netMallName = netMallName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcPrice</span><span class="params">(String productName)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ThreadLocalRandom.current().nextDouble() * <span class="number">2</span> + productName.charAt(<span class="number">0</span>);<span class="comment">//用这句话来模拟价格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="423e5b22-a9ff-4ac1-aeb4-0e694dd2a889-2"><p>相当于是一个一个按部就班</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Case</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdang&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPrice</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list</span><br><span class="line">                .stream() <span class="comment">//----流式计算做了映射（利用map），希望出来的是有格式的字符串（利用String.format）,%是占位符</span></span><br><span class="line">                .map(netMall -&gt; String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                        netMall.getNetMallName(),<span class="comment">//第一个%</span></span><br><span class="line">                        netMall.calcPrice(productName))).collect(Collectors.toList());<span class="comment">//第二个%</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list1 = getPrice(list, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String element:list1)&#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;---当前操作花费时间----costTime:&quot;</span>+(endTime-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql in jd price is <span class="number">110.48</span></span><br><span class="line">mysql in dangdang price is <span class="number">109.06</span></span><br><span class="line">mysql in taobao price is <span class="number">110.96</span></span><br><span class="line">---当前操作花费时间----costTime:<span class="number">3098</span>毫秒</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="423e5b22-a9ff-4ac1-aeb4-0e694dd2a889-3"><p>这里是利用异步线程，万箭齐发。此处用了两步<strong>流式编程</strong>。性能差距巨大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Case</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;NetMall&gt; list = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;jd&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;dangdang&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NetMall</span>(<span class="string">&quot;taobao&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从功能到性能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getPricesByCompletableFuture</span><span class="params">(List&lt;NetMall&gt; list,String productName)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.stream().map(netMall -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(() -&gt; String.format(productName + <span class="string">&quot; in %s price is %.2f&quot;</span>,</span><br><span class="line">                                netMall.getNetMallName(),</span><br><span class="line">                                netMall.calcPrice(productName))))<span class="comment">//Stream&lt;CompletableFuture&lt;String&gt;&gt;</span></span><br><span class="line">                .collect(Collectors.toList())<span class="comment">//List&lt;CompletablFuture&lt;String&gt;&gt;</span></span><br><span class="line">                .stream()<span class="comment">//Stream&lt;CompletableFuture&lt;String&gt;</span></span><br><span class="line">                .map(s-&gt;s.join())<span class="comment">//Stream&lt;String&gt;</span></span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;String&gt; list2 = getPricesByCompletableFuture(list, <span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String element:list2)&#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;--性能版-当前操作花费时间----costTime:&quot;</span>+(endTime-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql in jd price is <span class="number">110.52</span></span><br><span class="line">mysql in dangdang price is <span class="number">110.41</span></span><br><span class="line">mysql in taobao price is <span class="number">110.42</span></span><br><span class="line">--性能版-当前操作花费时间----costTime:<span class="number">1137</span>毫秒</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="3-5-常用API">3.5 常用API</h3><h4 id="3-5-1-获得结果和触发计算">3.5.1 获得结果和触发计算</h4><div class="tabs" id="7aa97ce1-9a0e-4617-b937-a3c60341596f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c60341596f-1"><i class="fas fa-bug"></i>API</button></li><li class="tab"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c60341596f-2"><i class="fas fa-cannabis"></i>代码演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7aa97ce1-9a0e-4617-b937-a3c60341596f-1"><p>获取结果</p><p>-<code>public T get()</code>不见不散，容易阻塞</p><p>-<code>public T get(long timeout,TimeUnit unit)</code>过时不候，超过时间会爆异常<br>-<code>public T join()</code>类似于get()，区别在于是否需要抛出异常<br>-<code>public T getNow(T valueIfAbsent)</code></p><ul><li>没有计算完成的情况下，给一个替代结果</li><li>立即获取结果不阻塞<ul><li>计算完，返回计算完成后的结果</li><li>没算完，返回设定的valueAbsent</li></ul></li></ul><p>主动触发计算</p><p>-<code>public boolean complete(T value)</code>是否立即打断get()方法返回括号值</p><ul><li>执行要2s，等待只有1s，所以还没执行完就被打断了。返回true表示打断了获取这个过程，直接返回了备胎值value；如果没打断，返回false 和原来的计算完成结果</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7aa97ce1-9a0e-4617-b937-a3c60341596f-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureAPIDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; uCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);<span class="comment">//执行需要2秒</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);<span class="comment">//等待需要1秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// System.out.println(uCompletableFuture.getNow(&quot;xxx&quot;));//执2-等1 返回xxx</span></span><br><span class="line">        System.out.println(uCompletableFuture.complete(<span class="string">&quot;completeValue&quot;</span>)+<span class="string">&quot;\t&quot;</span>+uCompletableFuture.get());</span><br><span class="line">      <span class="comment">//执2-等1 返回true+备胎值completeValue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="3-5-2-对计算结果进行处理">3.5.2 对计算结果进行处理</h4><div class="tabs" id="7aa97ce1-9a0e-4617-b937-a3c603415961"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c603415961-1"><i class="fas fa-bug"></i>API</button></li><li class="tab"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c603415961-2"><i class="fas fa-cannabis"></i>thenApply演示</button></li><li class="tab"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c603415961-3"><i class="fas fa-anchor"></i>handle演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7aa97ce1-9a0e-4617-b937-a3c603415961-1"><p><code>thenApply</code>计算结果存在在依赖关系，使得线程串行化。因为依赖关系，所以一旦有异常，直接叫停。</p><p><code>handle</code>类似于thenApply，但是有异常的话仍然可以往下走一步。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7aa97ce1-9a0e-4617-b937-a3c603415961-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当一个线程依赖另一个线程时用 thenApply 方法来把这两个线程串行化,</span></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f + <span class="number">2</span>;</span><br><span class="line">    &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">        <span class="comment">//int age = 10/0; // 异常情况：那步出错就停在那步。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> f + <span class="number">3</span>;</span><br><span class="line">    &#125;).whenCompleteAsync((v,e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****v: &quot;</span>+v);</span><br><span class="line">    &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----正常情况</span></span><br><span class="line"><span class="comment">//111</span></span><br><span class="line"><span class="comment">//222</span></span><br><span class="line"><span class="comment">//333</span></span><br><span class="line"><span class="comment">//----计算结果： 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----异常情况</span></span><br><span class="line"><span class="comment">//111</span></span><br><span class="line"><span class="comment">//异常.....</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7aa97ce1-9a0e-4617-b937-a3c603415961-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureDemo2</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当一个线程依赖另一个线程时用 handle 方法来把这两个线程串行化,</span></span><br><span class="line">        <span class="comment">// 异常情况：有异常也可以往下一步走，根据带的异常参数可以进一步处理</span></span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;).handle((f,e) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;<span class="comment">//异常语句</span></span><br><span class="line">            System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> f + <span class="number">2</span>;</span><br><span class="line">        &#125;).handle((f,e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> f + <span class="number">3</span>;</span><br><span class="line">        &#125;).whenCompleteAsync((v,e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;*****v: &quot;</span>+v);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----异常情况</span></span><br><span class="line"><span class="comment">//111</span></span><br><span class="line"><span class="comment">//333</span></span><br><span class="line"><span class="comment">//异常，可以看到多走了一步333</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="3-5-3-对计算结果进行消费">3.5.3 对计算结果进行消费</h4><div class="tabs" id="7aa97ce1-9a0e-4617-b937-a3c6034159212"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c6034159212-1"><i class="fas fa-bug"></i>API</button></li><li class="tab"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c6034159212-2"><i class="fas fa-cannabis"></i>代码演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7aa97ce1-9a0e-4617-b937-a3c6034159212-1"><p><code>thenAccept</code>接收任务的处理结果，并消费处理，无返回结果</p><blockquote><p>补充</p><p>thenRun</p><ul><li>thenRun(Runnable runnable)</li><li>任务A执行完执行B，并且B不需要A的结果</li></ul><p>thenAccept</p><ul><li>thenAccept(Consumer action)</li><li>任务A执行完执行B，B需要A的结果，但是任务B无返回值</li></ul><p>thenApply</p><ul><li>thenApply(Function fn)</li><li>任务A执行完执行B，B需要A的结果，同时任务B有返回值</li></ul></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7aa97ce1-9a0e-4617-b937-a3c6034159212-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">&#123;</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> f + <span class="number">2</span>;</span><br><span class="line">    &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> f + <span class="number">3</span>;</span><br><span class="line">    &#125;).thenApply(f -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> f + <span class="number">4</span>;</span><br><span class="line">    &#125;).thenAccept(r -&gt; System.out.println(r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//消费一下，直接得到6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="3-5-4-对计算速度进行选用">3.5.4 对计算速度进行选用</h4><div class="tabs" id="7aa97ce1-9a0e-4617-b937-a3c603415963"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c603415963-1"><i class="fas fa-bug"></i>API</button></li><li class="tab"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c603415963-2"><i class="fas fa-cannabis"></i>代码演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7aa97ce1-9a0e-4617-b937-a3c603415963-1"><p><code>applyToEither</code>:两个任务有一个执行完成，获取它的返回值，处理任务有新的返回值</p><p><code>acceptEither</code>:两个任务有一个执行完成，获取它的返回值，处理任务，没有新的返回值</p><p><code>runAfterEither</code>:两个任务有一个执行完成，不需要获取结果，也没有返回值</p><p><code>anyOf</code>：获取率先完成的任务结果</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7aa97ce1-9a0e-4617-b937-a3c603415963-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; play1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">        <span class="comment">//暂停几秒钟线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">2</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;paly1计算完成&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;play1 &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; play2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">1</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;paly2计算完成&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;play2&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; thenCombineResult = play1.applyToEither(play2, f -&gt; &#123;<span class="comment">//对计算速度进行选用</span></span><br><span class="line">        <span class="keyword">return</span> f + <span class="string">&quot; is winner&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + thenCombineResult.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ForkJoinPool.commonPool-worker-1---come in </span></span><br><span class="line"><span class="comment">//ForkJoinPool.commonPool-worker-2---come in </span></span><br><span class="line"><span class="comment">//paly2计算完成</span></span><br><span class="line"><span class="comment">//mainplay2 is winner</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="3-5-5-对计算结果进行组合">3.5.5 对计算结果进行组合</h4><div class="tabs" id="7aa97ce1-9a0e-4617-b937-a3c603415964"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c603415964-1"><i class="fas fa-bug"></i>API</button></li><li class="tab"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c603415964-2"><i class="fas fa-cannabis"></i>分解版</button></li><li class="tab"><button type="button" data-href="#7aa97ce1-9a0e-4617-b937-a3c603415964-3"><i class="fas fa-anchor"></i>合并版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7aa97ce1-9a0e-4617-b937-a3c603415964-1"><p><code>thenCombine</code>：组合两个 future，获取两个 future 的返回结果，并返回当前任务的返回值</p><p><code>thenAcceptBoth</code>：组合两个 future，获取两个 future 任务的返回结果，然后处理任务，没有返回值。</p><p><code>runAfterBoth</code>：组合两个 future，不需要获取 future 的结果，只需两个 future 处理完任务后， 处理该任务。</p><p><code>allOf</code>：当所有给定的任务完成后，返回一个全新的已完成CompletableFuture</p><blockquote><p>其中任务组合都要完成</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7aa97ce1-9a0e-4617-b937-a3c603415964-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Integer&gt; thenCombineResult = completableFuture1.thenCombine(completableFuture2, (x, y) -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(thenCombineResult.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ForkJoinPool.commonPool-worker-1---come in </span></span><br><span class="line"><span class="comment">//ForkJoinPool.commonPool-worker-1---come in </span></span><br><span class="line"><span class="comment">//main---come in </span></span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7aa97ce1-9a0e-4617-b937-a3c603415964-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException</span><br><span class="line">&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; thenCombineResult = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;), (x,y) -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;),(a,b) -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;---come in 5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(thenCombineResult.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;-----主线程结束，END&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">10</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ForkJoinPool.commonPool-worker-1---come in 1</span></span><br><span class="line"><span class="comment">//ForkJoinPool.commonPool-worker-1---come in 2</span></span><br><span class="line"><span class="comment">//main---come in 3</span></span><br><span class="line"><span class="comment">//ForkJoinPool.commonPool-worker-1---come in 4</span></span><br><span class="line"><span class="comment">//main---come in 5</span></span><br><span class="line"><span class="comment">//60</span></span><br><span class="line"><span class="comment">//-----主线程结束，END</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="3-6-CompleteFuture和线程池">3.6 CompleteFuture和线程池</h3><div class="tabs" id="91b48b3c-345b-4d1c-92e0-9a3b25ef1583"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#91b48b3c-345b-4d1c-92e0-9a3b25ef1583-1"><i class="fas fa-atom"></i>区别</button></li><li class="tab"><button type="button" data-href="#91b48b3c-345b-4d1c-92e0-9a3b25ef1583-2"><i class="far fa-sun"></i>结论1-示例</button></li><li class="tab"><button type="button" data-href="#91b48b3c-345b-4d1c-92e0-9a3b25ef1583-3"><i class="fas fa-wind"></i>结论2.1-示例</button></li><li class="tab"><button type="button" data-href="#91b48b3c-345b-4d1c-92e0-9a3b25ef1583-4"><i class="fas fa-fire-alt"></i>结论2.2-示例</button></li><li class="tab"><button type="button" data-href="#91b48b3c-345b-4d1c-92e0-9a3b25ef1583-5"><i class="fas fa-child"></i>结论2.3-示例</button></li><li class="tab"><button type="button" data-href="#91b48b3c-345b-4d1c-92e0-9a3b25ef1583-6"><i class="fas fa-candy-cane"></i>结论3-示例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="91b48b3c-345b-4d1c-92e0-9a3b25ef1583-1"><p>上面的几个方法都有普通版本和后面加Async的版本</p><p>以thenRun和thenRunAsync为例，有什么区别？</p><p>先看结论</p><ol><li><p>没有传入自定义线程池，都用默认线程池ForkJoinPool</p></li><li><p>传入了一个自定义线程池如果你执行第一个任务的时候，传入了一个自定义线程池</p><ul><li>调用thenRun方法执行第二个任务的时候，则第二个任务和第一个任务是用同一个线程池</li><li>调用thenRunAsync执行第二个任务的时候，则第一个任务使用的是你自己传入的线程池，第二个任务没有传入线程池参数则使用的是默认ForkJoin线程池</li><li>调用thenRunAsync执行第二个任务的时候，传入了线程池，则使用你传入的线程池</li></ul></li><li><p>也有可能处理太快，系统优化切换原则，直接使用main线程处理（把sleep去掉）</p></li></ol><p>其它如：thenAccept和thenAcceptAsync，thenApply和thenApplyAsync等，它们之间的区别也是同理</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="91b48b3c-345b-4d1c-92e0-9a3b25ef1583-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;结束时间&quot;</span>+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;结束时间&quot;</span>+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;结束时间&quot;</span>+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;结束时间&quot;</span>+<span class="string">&quot;\t&quot;</span>+System.currentTimeMillis());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1号任务ForkJoinPool.commonPool-worker-1结束时间1680685553341</span></span><br><span class="line"><span class="comment">//2号任务ForkJoinPool.commonPool-worker-1结束时间1680685553366</span></span><br><span class="line"><span class="comment">//3号任务ForkJoinPool.commonPool-worker-1结束时间1680685553391</span></span><br><span class="line"><span class="comment">//4号任务ForkJoinPool.commonPool-worker-1结束时间1680685553415</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="91b48b3c-345b-4d1c-92e0-9a3b25ef1583-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    &#125;,threadPool).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1号任务pool-1-thread-1</span></span><br><span class="line"><span class="comment">//2号任务pool-1-thread-1</span></span><br><span class="line"><span class="comment">//3号任务pool-1-thread-1</span></span><br><span class="line"><span class="comment">//4号任务pool-1-thread-1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="91b48b3c-345b-4d1c-92e0-9a3b25ef1583-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    &#125;,threadPool).thenRunAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1号任务pool-1-thread-1</span></span><br><span class="line"><span class="comment">//2号任务ForkJoinPool.commonPool-worker-1</span></span><br><span class="line"><span class="comment">//3号任务ForkJoinPool.commonPool-worker-1</span></span><br><span class="line"><span class="comment">//4号任务ForkJoinPool.commonPool-worker-1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="91b48b3c-345b-4d1c-92e0-9a3b25ef1583-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    &#125;,threadPool).thenRunAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;,threadPool).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1号任务pool-1-thread-1</span></span><br><span class="line"><span class="comment">//2号任务pool-1-thread-2</span></span><br><span class="line"><span class="comment">//3号任务pool-1-thread-2</span></span><br><span class="line"><span class="comment">//4号任务pool-1-thread-2</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="91b48b3c-345b-4d1c-92e0-9a3b25ef1583-6"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    &#125;,threadPool).thenRunAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;).thenRun(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//try &#123;TimeUnit.MILLISECONDS.sleep(20);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;4号任务&quot;</span>+<span class="string">&quot;\t&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1号任务pool-1-thread-1</span></span><br><span class="line"><span class="comment">//2号任务main</span></span><br><span class="line"><span class="comment">//3号任务main</span></span><br><span class="line"><span class="comment">//4号任务main</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> ]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 线程安全集合类</title>
      <link href="/posts/b7fbfe85.html"/>
      <url>/posts/b7fbfe85.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程安全集合类概述">1. 线程安全集合类概述</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220316174115768.png" alt="image-20220316174115768"></p><p>线程安全集合类可以分为三大类：</p><ul><li>遗留的线程安全集合如<code>Hashtable</code>，<code>Vector</code></li><li>使用<code>Collections</code>装饰的线程安全集合，如：<br>-<code>Collections.synchronizedCollection</code><br>-<code>Collections.synchronizedList</code><br>-<code>Collections.synchronizedMap</code><br>-<code>Collections.synchronizedSet</code><br>-<code>Collections.synchronizedNavigableMap</code><br>-<code>Collections.synchronizedNavigableSet </code><br>-<code>Collections.synchronizedSortedMap</code><br>-<code>Collections.synchronizedSortedSet</code><ul><li>说明：以上集合均采用修饰模式设计，将非线程安全的集合包装后，在调用方法时包裹了一层synchronized代码块。其并发性并不比遗留的安全集合好。</li></ul></li><li>java.util.concurrent.*</li></ul><p>重点介绍<code>java.util.concurrent.*</code>下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： Blocking、CopyOnWrite、Concurrent</p><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法</li><li>CopyOnWrite 之类容器修改开销相对较重</li><li>Concurrent 类型的容器<ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li><li>弱一致性<ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍 历，这时内容是旧的</li><li>求大小弱一致性，size 操作未必是 100% 准确</li><li>读取弱一致性</li></ul></li></ul></li></ul><blockquote><p>遍历时如果发生了修改，对于非安全容器来讲，使用 <strong>fail-fast</strong> 机制也就是让遍历立刻失败，抛出 ConcurrentModificationException，不再继续遍历</p></blockquote><h2 id="2-ConcurrentHashMap">2. ConcurrentHashMap</h2><p>单词计数</p><p>在26个文件中，26个英文字母每个都有200个存在在这26个文件中，你现在需要从文件中统计出每个字母的个数。如果统计正确，那么每个字母的个数该为200个。</p><div class="tabs" id="6a32eea2-e5a0-46cb-a7ed-2f2789203ef0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6a32eea2-e5a0-46cb-a7ed-2f2789203ef0-1"><i class="fas fa-bug"></i>测试代码</button></li><li class="tab"><button type="button" data-href="#6a32eea2-e5a0-46cb-a7ed-2f2789203ef0-2"><i class="fas fa-cannabis"></i>HashMap统计</button></li><li class="tab"><button type="button" data-href="#6a32eea2-e5a0-46cb-a7ed-2f2789203ef0-3"><i class="fas fa-candy-cane"></i>错误使用ConcurrentHashMap</button></li><li class="tab"><button type="button" data-href="#6a32eea2-e5a0-46cb-a7ed-2f2789203ef0-4"><i class="fas fa-child"></i>正确使用ConcurrentHashMap</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6a32eea2-e5a0-46cb-a7ed-2f2789203ef0-1"><p>你所需要做的就是提供 Map和统计方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;V&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;Map&lt;String, V&gt;&gt; supplier, BiConsumer&lt;Map&lt;String, V&gt;, List&lt;String&gt;&gt; consumer)</span> &#123;</span><br><span class="line">    Map&lt;String, V&gt; counterMap = supplier.get();</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            List&lt;String&gt; words = readFromFile(idx);</span><br><span class="line">            consumer.accept(counterMap, words);</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ts.forEach(t -&gt; t.start());</span><br><span class="line">    ts.forEach(t -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(counterMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">readFromFile</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;tmp/&quot;</span> + i + <span class="string">&quot;.txt&quot;</span>)))) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> in.readLine();</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            words.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a32eea2-e5a0-46cb-a7ed-2f2789203ef0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">        () -&gt;<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;(),</span><br><span class="line">        (map,words)-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(String word :words)&#123;</span><br><span class="line"></span><br><span class="line">             <span class="type">Integer</span> <span class="variable">counter</span> <span class="operator">=</span>map.get(word);</span><br><span class="line">             <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span>counter==<span class="literal">null</span>?<span class="number">1</span>:counter+<span class="number">1</span>;</span><br><span class="line">             map.put(word,newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a=<span class="number">189</span>, b=<span class="number">198</span>, c=<span class="number">200</span>, d=<span class="number">188</span>, e=<span class="number">198</span>, f=<span class="number">188</span>, g=<span class="number">173</span>, h=<span class="number">198</span>, i=<span class="number">183</span>, j=<span class="number">200</span>, k=<span class="number">184</span>, l=<span class="number">189</span>, m=<span class="number">162</span>, n=<span class="number">200</span>, o=<span class="number">200</span>, p=<span class="number">194</span>, q=<span class="number">200</span>, r=<span class="number">185</span>, s=<span class="number">200</span>, t=<span class="number">200</span>, u=<span class="number">97</span>, v=<span class="number">92</span>, w=<span class="number">167</span>, x=<span class="number">200</span>, y=<span class="number">198</span>, z=<span class="number">190</span>&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a32eea2-e5a0-46cb-a7ed-2f2789203ef0-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">        () -&gt;<span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String,Integer&gt;(),</span><br><span class="line">        (map,words)-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span>(String word :words)&#123;</span><br><span class="line">             <span class="type">Integer</span> <span class="variable">counter</span> <span class="operator">=</span>map.get(word);</span><br><span class="line">             <span class="type">int</span> <span class="variable">newValue</span> <span class="operator">=</span>counter==<span class="literal">null</span>?<span class="number">1</span>:counter+<span class="number">1</span>;</span><br><span class="line">             map.put(word,newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a=<span class="number">196</span>, b=<span class="number">199</span>, c=<span class="number">141</span>, d=<span class="number">135</span>, e=<span class="number">188</span>, f=<span class="number">129</span>, g=<span class="number">183</span>, h=<span class="number">184</span>, i=<span class="number">132</span>, j=<span class="number">130</span>, k=<span class="number">169</span>, l=<span class="number">48</span>, m=<span class="number">141</span>, n=<span class="number">185</span>, o=<span class="number">197</span>, p=<span class="number">41</span>, q=<span class="number">34</span>, r=<span class="number">105</span>, s=<span class="number">199</span>, t=<span class="number">55</span>, u=<span class="number">186</span>, v=<span class="number">158</span>, w=<span class="number">67</span>, x=<span class="number">69</span>, y=<span class="number">125</span>, z=<span class="number">188</span>&#125;</span><br></pre></td></tr></table></figure><p>错误原因：</p><ul><li>ConcurrentHashMap虽然每个方法都是线程安全的，但是多个方法的组合并不是线程安全的。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a32eea2-e5a0-46cb-a7ed-2f2789203ef0-4"><p>原来是先要检查这个key有没有，没有的话进行Put，这个组合就不是线程安全的了。</p><p>computIfAbsent方法的作用是：当map中不存在以参数1为key对应的value时，会将参数2函数式接口的返回值作为value，put进map中，然后返回该value。如果存在key，则直接返回value。以上两部均是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">        () -&gt; <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, LongAdder&gt;(<span class="number">8</span>,<span class="number">0.75f</span>,<span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">        (map, words) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果缺少一个 key，则计算生成一个 value , 然后将  key value 放入 map</span></span><br><span class="line">              <span class="comment">// 保证 get Put 原子性</span></span><br><span class="line">                <span class="type">LongAdder</span> <span class="variable">value</span> <span class="operator">=</span> map.computeIfAbsent(word, (key) -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>());</span><br><span class="line">                <span class="comment">// 执行累加</span></span><br><span class="line">              <span class="comment">// 保证累加原子性</span></span><br><span class="line">                value.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;a=<span class="number">200</span>, b=<span class="number">200</span>, c=<span class="number">200</span>, d=<span class="number">200</span>, e=<span class="number">200</span>, f=<span class="number">200</span>, g=<span class="number">200</span>, h=<span class="number">200</span>, i=<span class="number">200</span>, j=<span class="number">200</span>, k=<span class="number">200</span>, l=<span class="number">200</span>, m=<span class="number">200</span>, n=<span class="number">200</span>, o=<span class="number">200</span>, p=<span class="number">200</span>, q=<span class="number">200</span>, r=<span class="number">200</span>, s=<span class="number">200</span>, t=<span class="number">200</span>, u=<span class="number">200</span>, v=<span class="number">200</span>, w=<span class="number">200</span>, x=<span class="number">200</span>, y=<span class="number">200</span>, z=<span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-1-ConcurrentHashMap-原理">2.1 ConcurrentHashMap 原理</h3><h4 id="2-1-1-HashMap-并发死链">2.1.1 HashMap 并发死链</h4><p>注意</p><ul><li>要在 JDK 7 下运行，否则扩容机制和 hash 的计算方法都变了（JDK7 插入采用头插法 JDK采用尾插法 七上八下）</li><li>以下测试代码是精心准备的，不要随便改动 JDK7 扩容并发死链</li></ul><div class="tabs" id="52ba4830-c292-46ee-b675-b4b7d2516a78"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#52ba4830-c292-46ee-b675-b4b7d2516a78-1"><i class="fas fa-bug"></i>测试代码</button></li><li class="tab"><button type="button" data-href="#52ba4830-c292-46ee-b675-b4b7d2516a78-2"><i class="fas fa-cannabis"></i>死链复现</button></li><li class="tab"><button type="button" data-href="#52ba4830-c292-46ee-b675-b4b7d2516a78-3"><i class="fas fa-candy-cane"></i>源码复现</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="52ba4830-c292-46ee-b675-b4b7d2516a78-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1, 35, 16, 50 当大小为16时，它们在一个桶内</span></span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="comment">// 放 12 个元素</span></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">5</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">6</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">7</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">8</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">9</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">10</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">16</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">35</span>, <span class="literal">null</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;扩容前大小[main]:&quot;</span>+map.size());</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">            map.put(<span class="number">50</span>, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扩容后大小[Thread-0]:&quot;</span>+map.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 放第 13 个元素, 发生扩容</span></span><br><span class="line">            map.put(<span class="number">50</span>, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;扩容后大小[Thread-1]:&quot;</span>+map.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="52ba4830-c292-46ee-b675-b4b7d2516a78-2"><p>调试工具使用 idea</p><p>在 HashMap 源码 590 行加断点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br></pre></td></tr></table></figure><p>断点的条件如下，目的是让 HashMap 在扩容为 32 时，并且线程为 Thread-0 或 Thread-1 时停下来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newTable.length==<span class="number">32</span> &amp;&amp;</span><br><span class="line"> (</span><br><span class="line"> Thread.currentThread().getName().equals(<span class="string">&quot;Thread-0&quot;</span>)||</span><br><span class="line"> Thread.currentThread().getName().equals(<span class="string">&quot;Thread-1&quot;</span>)</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>断点暂停方式选择 Thread，否则在调试 Thread-0 时，Thread-1 无法恢复运行</p><p>运行代码，程序在预料的断点位置停了下来，输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">长度为16时，桶下标为1的key </span><br><span class="line">1 </span><br><span class="line">16 </span><br><span class="line">35 </span><br><span class="line">50 </span><br><span class="line">长度为32时，桶下标为1的key </span><br><span class="line">1 </span><br><span class="line">35 </span><br><span class="line">扩容前大小[main]:12 </span><br></pre></td></tr></table></figure><p>接下来进入扩容流程调试</p><p>在 HashMap 源码 594 行加断点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next; <span class="comment">// 593</span></span><br><span class="line"><span class="keyword">if</span> (rehash) <span class="comment">// 594</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这是为了观察 e 节点和 next 节点的状态，Thread-0 单步执行到 594 行，再 594 处再添加一个断点（条件 Thread.currentThread().getName().equals(“Thread-0”)）</p><p>这时可以在 Variables 面板观察到 e 和 next 变量，使用<code>view as -&gt; Object</code>查看节点状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e (<span class="number">1</span>)-&gt;(<span class="number">35</span>)-&gt;(<span class="number">16</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">next</span> <span class="params">(<span class="number">35</span>)</span>-&gt;(<span class="number">16</span>)-&gt;<span class="literal">null</span> </span><br></pre></td></tr></table></figure><p>在 Threads 面板选中 Thread-1 恢复运行，可以看到控制台输出新的内容如下，Thread-1 扩容已完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTable[<span class="number">1</span>] (<span class="number">35</span>)-&gt;(<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩容后大小:13 </span><br></pre></td></tr></table></figure><p>这时 Thread-0 还停在 594 处， Variables 面板变量的状态已经变化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e (<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">next</span> <span class="params">(<span class="number">35</span>)</span>-&gt;(<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br></pre></td></tr></table></figure><p>为什么呢，因为 Thread-1 扩容时链表也是后加入的元素放入链表头，因此链表就倒过来了，但 Thread-1 虽然结 果正确，但它结束后 Thread-0 还要继续运行</p><p>接下来就可以单步调试（F8）观察死链的产生了</p><p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newTable[<span class="number">1</span>] (<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">e</span> <span class="params">(<span class="number">35</span>)</span>-&gt;(<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">next</span> <span class="params">(<span class="number">1</span>)</span>-&gt;<span class="literal">null</span></span><br></pre></td></tr></table></figure><p>下一轮循环到 594，将 e 搬迁到 newTable 链表头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newTable[<span class="number">1</span>] (<span class="number">35</span>)-&gt;(<span class="number">1</span>)-&gt;<span class="literal">null</span> </span><br><span class="line"><span class="title function_">e</span> <span class="params">(<span class="number">1</span>)</span>-&gt;<span class="literal">null</span> </span><br><span class="line">next <span class="literal">null</span> </span><br></pre></td></tr></table></figure><p>再看看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e.next = newTable[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 这时 e (1,35)</span></span><br><span class="line"><span class="comment">// 而 newTable[1] (35,1)-&gt;(1,35) 因为是同一个对象</span></span><br><span class="line">newTable[<span class="number">1</span>] = e; </span><br><span class="line"><span class="comment">// 再尝试将 e 作为链表头, 死链已成</span></span><br><span class="line">e = next;</span><br><span class="line"><span class="comment">// 虽然 next 是 null, 会进入下一个链表的复制, 但死链已经形成了</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="52ba4830-c292-46ee-b675-b4b7d2516a78-3"><p>HashMap 的并发死链发生在扩容时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 table 迁移至 newTable</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 1 处</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 2 处</span></span><br><span class="line">            <span class="comment">// 将新元素加入 newTable[i], 原 newTable[i] 作为新元素的 next</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 map 中初始元素是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">原始链表，格式：[下标] (key,next)</span><br><span class="line">[<span class="number">1</span>] (<span class="number">1</span>,<span class="number">35</span>)-&gt;(<span class="number">35</span>,<span class="number">16</span>)-&gt;(<span class="number">16</span>,<span class="literal">null</span>)</span><br><span class="line">线程 a 执行到 <span class="number">1</span> 处 ，此时局部变量 e 为 (<span class="number">1</span>,<span class="number">35</span>)，而局部变量 next 为 (<span class="number">35</span>,<span class="number">16</span>) 线程 a 挂起</span><br><span class="line">线程 b 开始执行</span><br><span class="line">第一次循环</span><br><span class="line">[<span class="number">1</span>] (<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第二次循环</span><br><span class="line">[<span class="number">1</span>] (<span class="number">35</span>,<span class="number">1</span>)-&gt;(<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第三次循环</span><br><span class="line">[<span class="number">1</span>] (<span class="number">35</span>,<span class="number">1</span>)-&gt;(<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">[<span class="number">17</span>] (<span class="number">16</span>,<span class="literal">null</span>)</span><br><span class="line">切换回线程 a，此时局部变量 e 和 next 被恢复，引用没变但内容变了：e 的内容被改为 (<span class="number">1</span>,<span class="literal">null</span>)，而 next 的内</span><br><span class="line">容被改为 (<span class="number">35</span>,<span class="number">1</span>) 并链向 (<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第一次循环</span><br><span class="line">[<span class="number">1</span>] (<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第二次循环，注意这时 e 是 (<span class="number">35</span>,<span class="number">1</span>) 并链向 (<span class="number">1</span>,<span class="literal">null</span>) 所以 next 又是 (<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">[<span class="number">1</span>] (<span class="number">35</span>,<span class="number">1</span>)-&gt;(<span class="number">1</span>,<span class="literal">null</span>)</span><br><span class="line">第三次循环，e 是 (<span class="number">1</span>,<span class="literal">null</span>)，而 next 是 <span class="literal">null</span>，但 e 被放入链表头，这样 e.next 变成了 <span class="number">35</span> （<span class="number">2</span> 处）</span><br><span class="line">[<span class="number">1</span>] (<span class="number">1</span>,<span class="number">35</span>)-&gt;(<span class="number">35</span>,<span class="number">1</span>)-&gt;(<span class="number">1</span>,<span class="number">35</span>)</span><br><span class="line">已经是死链了</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong>小结</strong></p><ul><li>究其原因，是因为在多线程环境下使用了非线程安全的 map 集合</li><li>JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能 够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</li></ul><h4 id="2-1-2-JDK8-CHM">2.1.2 JDK8 CHM</h4><div class="tabs" id="828127d7-517f-4c92-83cb-1be3abb84ae2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#828127d7-517f-4c92-83cb-1be3abb84ae2-1"><i class="fas fa-bug"></i>重要属性和内部类</button></li><li class="tab"><button type="button" data-href="#828127d7-517f-4c92-83cb-1be3abb84ae2-2"><i class="fas fa-cannabis"></i>重要方法</button></li><li class="tab"><button type="button" data-href="#828127d7-517f-4c92-83cb-1be3abb84ae2-3"><i class="fas fa-candy-cane"></i>构造器分析</button></li><li class="tab"><button type="button" data-href="#828127d7-517f-4c92-83cb-1be3abb84ae2-4"><i class="fas fa-child"></i>get流程</button></li><li class="tab"><button type="button" data-href="#828127d7-517f-4c92-83cb-1be3abb84ae2-5"><i class="fas fa-award"></i>put 流程</button></li><li class="tab"><button type="button" data-href="#828127d7-517f-4c92-83cb-1be3abb84ae2-6"><i class="fas fa-baseball-ball"></i>size计算</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="828127d7-517f-4c92-83cb-1be3abb84ae2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReservationNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="828127d7-517f-4c92-83cb-1be3abb84ae2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="828127d7-517f-4c92-83cb-1be3abb84ae2-3"><p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel) <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel; <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ... </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="828127d7-517f-4c92-83cb-1be3abb84ae2-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// spread 方法能确保返回结果是正数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果头结点已经是要查找的 key</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 正常遍历链表, 用 equals 比较</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果table不为空且长度大于0且索引位置有元素<ul><li>if 头节点key的hash值相等<ul><li>头节点的key指向同一个地址或者equals<ul><li>返回value</li></ul></li></ul></li><li>else if 头节点的hash为负数（bin在扩容或者是treebin）<ul><li>调用find方法查找</li></ul></li><li>进入循环（e不为空）：<ul><li>节点key的hash值相等，且key指向同一个地址或equals<ul><li>返回value</li></ul></li></ul></li></ul></li><li>返回null</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="828127d7-517f-4c92-83cb-1be3abb84ae2-5"><p>以下数组简称（table），链表简称（bin）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 其中 spread 方法会综合高位低位, 具有更好的 hash 性</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// f 是链表头节点</span></span><br><span class="line">        <span class="comment">// fh 是链表头结点的 hash</span></span><br><span class="line">        <span class="comment">// i 是链表在 table 中的下标</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 要创建 table</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化 table 使用了 cas, 无需 synchronized 创建成功, 进入下一轮循环</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 要创建链表头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加链表头使用了 cas, 无需 synchronized</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 帮忙扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮忙之后, 进入下一轮循环</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 锁住链表头节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次确认链表头节点没有被移动</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 找到相同的 key</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// 更新</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 已经是最后的节点了, 新增 Node, 追加至链表尾</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                              value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 释放链表头节点的锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 如果链表长度 &gt;= 树化阈值(8), 进行链表转为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加 size 计数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        <span class="comment">// 尝试将 sizeCtl 设置为 -1（表示初始化 table）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// check 是之前 binCount 的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addCount</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> check)</span> &#123;</span><br><span class="line">    CounterCell[] as; <span class="type">long</span> b, s;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 已经有了 counterCells, 向 cell 累加</span></span><br><span class="line">        (as = counterCells) != <span class="literal">null</span> ||</span><br><span class="line">        <span class="comment">// 还没有, 向 baseCount 累加</span></span><br><span class="line">        !U.compareAndSwapLong(<span class="built_in">this</span>, BASECOUNT, b = baseCount, s = b + x)</span><br><span class="line">    ) &#123;</span><br><span class="line">        CounterCell a; <span class="type">long</span> v; <span class="type">int</span> m;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 还没有 counterCells</span></span><br><span class="line">            as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 还没有 cell</span></span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// cell cas 增加计数失败</span></span><br><span class="line">            !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 创建累加单元数组和cell, 累加重试</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 获取元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="type">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// newtable 已经创建了，帮忙扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 需要扩容，这时 newtable 未创建</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>进入for循环：<ul><li>if  table为null或者长度 为0<ul><li>初始化表</li></ul></li><li>else if 索引处无节点<ul><li>创建节点，填入key和value，放入table，退出循环</li></ul></li><li>else if 索引处节点的hash值为MOVE（ForwardingNode），表示正在扩容和迁移<ul><li>帮忙</li></ul></li><li>else<ul><li>锁住头节点<ul><li>if 再次确认头节点没有被移动<ul><li>if  头节点hash值大于0（表示这是一个链表）<ul><li>遍历链表找到对应key，如果没有，创建。</li></ul></li><li>else if 节点为红黑树节点<ul><li>调用<code>putTreeVal</code>查看是否有对应key的数节点<ul><li>如果有且为覆盖模式，将值覆盖，返回旧值</li><li>如果没有，创建并插入，返回null</li></ul></li></ul></li></ul></li><li>解锁</li></ul></li><li>if binCount不为0<ul><li>如果binCount大于树化阈值8<ul><li>树化</li></ul></li><li>如果旧值不为null<ul><li>返回旧值</li></ul></li><li>break</li></ul></li></ul></li></ul></li><li>增加size计数</li><li>return null</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="828127d7-517f-4c92-83cb-1be3abb84ae2-6"><p>size 计算实际发生在 put，remove 改变集合元素的操作之中</p><ul><li>没有竞争发生，向 baseCount 累加计数</li><li>有竞争发生，新建 counterCells，向其中的一个 cell 累加计<ul><li>counterCells 初始有两个 cell</li><li>如果计数竞争比较激烈，会创建新的 cell 来累加计数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="comment">// 将 baseCount 计数与所有 cell 计数累加</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>总结</p><p><strong>Java 8</strong> 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）</p><ul><li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程 会用 synchronized 锁住链表头</li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素 添加至 bin 的尾部</li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新 table 进行搜索</li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可 做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中</li><li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加 即可</li></ul><p>源码分析 <a href="http://www.importnew.com/28263.html">http://www.importnew.com/28263.html</a></p><p>其它实现 <a href="https://github.com/boundary/high-scale-lib">Cliff Click’s high scale lib</a></p></blockquote><h4 id="2-1-3-JDK7-CHM">2.1.3 JDK7 CHM</h4><p>它维护了一个 segment 数组，每个 segment 对应一把锁</p><ul><li>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的</li><li>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</li></ul><div class="tabs" id="5b6f4c97-ee01-4078-ac5f-49d57c177243"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5b6f4c97-ee01-4078-ac5f-49d57c177243-1"><i class="fas fa-bug"></i>构造器分析</button></li><li class="tab"><button type="button" data-href="#5b6f4c97-ee01-4078-ac5f-49d57c177243-2"><i class="fas fa-cannabis"></i>put 流程</button></li><li class="tab"><button type="button" data-href="#5b6f4c97-ee01-4078-ac5f-49d57c177243-3"><i class="fas fa-candy-cane"></i>rehash流程</button></li><li class="tab"><button type="button" data-href="#5b6f4c97-ee01-4078-ac5f-49d57c177243-4"><i class="fas fa-child"></i>get 流程</button></li><li class="tab"><button type="button" data-href="#5b6f4c97-ee01-4078-ac5f-49d57c177243-5"><i class="fas fa-cat"></i>size 计算</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5b6f4c97-ee01-4078-ac5f-49d57c177243-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// ssize 必须是 2^n, 即 2, 4, 8, 16 ... 表示了 segments 数组的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sshift</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ssize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// segmentShift 默认是 32 - 4 = 28</span></span><br><span class="line">    <span class="built_in">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="comment">// segmentMask 默认是 15 即 0000 0000 0000 1111</span></span><br><span class="line">    <span class="built_in">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 创建 segments and segments[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Segment</span>&lt;K,V&gt;(loadFactor, (<span class="type">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">HashEntry</span>[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Segment</span>[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="built_in">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造完成，如下图所示</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317180837785.png" alt="image-20220317180837785" style="zoom:50%;" /><p>可以看到 ConcurrentHashMap 没有实现懒惰初始化，空间占用不友好</p><p>其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment</p><p>例如，根据某一 hash 值求 segment 位置，先将高位向低位移动 this.segmentShift 位</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317180919562.png" alt="image-20220317180919562"></p><p>结果再与 this.segmentMask 做位于运算，最终得到 1010 即下标为 10 的 segment</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317180935914.png" alt="image-20220317180935914"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5b6f4c97-ee01-4078-ac5f-49d57c177243-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 计算出 segment 下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得 segment 对象, 判断是否为 null, 是则创建该 segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject </span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这时不能确定是否真的为 null, 因为其它线程也发现该 segment 为 null,</span></span><br><span class="line">        <span class="comment">// 因此在 ensureSegment 里用 cas 方式保证该 segment 安全性</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入 segment 的put 流程</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>segment 继承了可重入锁（ReentrantLock），它的 put 方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> :</span><br><span class="line">    <span class="comment">// 如果不成功, 进入 scanAndLockForPut 流程</span></span><br><span class="line">    <span class="comment">// 如果是多核 cpu 最多 tryLock 64 次, 进入 lock 流程</span></span><br><span class="line">    <span class="comment">// 在尝试期间, 还可以顺便看该节点在链表中有没有, 如果没有顺便创建出来</span></span><br><span class="line">    scanAndLockForPut(key, hash, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到这里 segment 已经被成功加锁, 可以安全执行</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 更新</span></span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123; </span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 新增</span></span><br><span class="line">                <span class="comment">// 1) 之前等待锁时, node 已经被创建, next 指向链表头</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 2) 创建新 node</span></span><br><span class="line">                    node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>; </span><br><span class="line">                <span class="comment">// 3) 扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 将 node 作为链表头</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5b6f4c97-ee01-4078-ac5f-49d57c177243-3"><p>发生在 put 中，因为此时已经获得了锁，因此 rehash 时不需要考虑线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="type">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> <span class="title class_">HashEntry</span>[newCapacity];</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeMask</span> <span class="operator">=</span> newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>) <span class="comment">// Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="type">int</span> <span class="variable">lastIdx</span> <span class="operator">=</span> idx;</span><br><span class="line">                <span class="comment">// 过一遍链表, 尽可能把 rehash 后 idx 不变的节点重用</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="literal">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 剩余节点需要新建</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> p.value;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> p.hash;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩容完成, 才加入新的节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeIndex</span> <span class="operator">=</span> node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换为新的 HashEntry table</span></span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附，调试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ConcurrentHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">segmentIndex</span> <span class="operator">=</span> (hash &gt;&gt;&gt; <span class="number">28</span>) &amp; <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">if</span> (segmentIndex == <span class="number">4</span> &amp;&amp; hash % <span class="number">8</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;\t&quot;</span> + segmentIndex + <span class="string">&quot;\t&quot;</span> + hash % <span class="number">2</span> + <span class="string">&quot;\t&quot;</span> + hash % <span class="number">4</span> +</span><br><span class="line">                               <span class="string">&quot;\t&quot;</span> + hash % <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">15</span>, <span class="string">&quot;value&quot;</span>); <span class="comment">// 2 扩容为 4 15 的 hash%8 与其他不同</span></span><br><span class="line">    map.put(<span class="number">169</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">197</span>, <span class="string">&quot;value&quot;</span>); <span class="comment">// 4 扩容为 8</span></span><br><span class="line">    map.put(<span class="number">341</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">484</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">545</span>, <span class="string">&quot;value&quot;</span>); <span class="comment">// 8 扩容为 16</span></span><br><span class="line">    map.put(<span class="number">912</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    map.put(<span class="number">941</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5b6f4c97-ee01-4078-ac5f-49d57c177243-4"><p>get 时并未加锁，用了 UNSAFE 方法保证了可见性，扩容过程中，get 先发生就从旧表取内容，get 后发生就从新 表取内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// u 为 segment 对象在数组中的偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="comment">// s 即为 segment</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">        (tab = s.table) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">             (tab, ((<span class="type">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5b6f4c97-ee01-4078-ac5f-49d57c177243-5"><ul><li>计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回</li><li>如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="built_in">this</span>.segments;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="type">long</span> sum; <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// previous sum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">retries</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="comment">// 超过重试次数, 需要创建所有 segment 并加锁</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="literal">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="3-BlockingQueue">3. BlockingQueue</h2><p>基本的入队出队</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedBlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下列三种情况之一</span></span><br><span class="line"><span class="comment"> * - 真正的后继节点</span></span><br><span class="line"><span class="comment"> * - 自己, 发生在出队时</span></span><br><span class="line"><span class="comment"> * - null, 表示是没有后继节点, 是最后了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="2c4556f8-464e-43e9-b401-f7a2b3f91591"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2c4556f8-464e-43e9-b401-f7a2b3f91591-1"><i class="fas fa-atom"></i>初始化链表</button></li><li class="tab"><button type="button" data-href="#2c4556f8-464e-43e9-b401-f7a2b3f91591-2"><i class="far fa-sun"></i>节点入队</button></li><li class="tab"><button type="button" data-href="#2c4556f8-464e-43e9-b401-f7a2b3f91591-3"><i class="fas fa-wind"></i>出队</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2c4556f8-464e-43e9-b401-f7a2b3f91591-1"><p><code>last = head = new Node(null);</code>Dummy 节点用来占位，item 为 null</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220316215902936.png" alt="image-20220316215902936"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2c4556f8-464e-43e9-b401-f7a2b3f91591-2"><p><code>last = last.next = node;</code></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220316215925456.png" alt="image-20220316215925456"></p><p>再来一个节点入队<code>last = last.next = node;</code></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220316215949461.png" alt="image-20220316215949461"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2c4556f8-464e-43e9-b401-f7a2b3f91591-3"><h5 id=""></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//临时变量h用来指向哨兵</span></span><br><span class="line">Node&lt;E&gt; h = head;</span><br><span class="line"><span class="comment">//first用来指向第一个元素</span></span><br><span class="line">Node&lt;E&gt; first = h.next;</span><br><span class="line">h.next = h; <span class="comment">// help GC</span></span><br><span class="line"><span class="comment">//head赋值为first，表示first节点就是下一个哨兵。</span></span><br><span class="line">head = first;</span><br><span class="line"><span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line"><span class="comment">//删除first节点中的数据，表示真正成为了哨兵，第一个元素出队。</span></span><br><span class="line">first.item = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><p><code>h = head</code></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317142826808.png" alt="image-20220317142826808"></p><p><code>first = h.next</code></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317142906729.png" alt="image-20220317142906729"></p><p><code>h.next = h</code></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317142924725.png" alt="image-20220317142924725"></p><p><code>head = first</code></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317142942832.png" alt="image-20220317142942832"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">first.item = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317143001497.png" alt="image-20220317143001497"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>加锁分析</p><p><strong>高明之处</strong>在于用了两把锁和 dummy 节点</p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p>线程安全分析</p><ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是 head 节点的线程安全。两把锁保证了入队和出队没有竞争</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 用户 take(阻塞) poll(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure><div class="tabs" id="086864a5-94c2-483a-809a-97b3071fab65"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#086864a5-94c2-483a-809a-97b3071fab65-1"><i class="fas fa-award"></i>put 操作</button></li><li class="tab"><button type="button" data-href="#086864a5-94c2-483a-809a-97b3071fab65-2"><i class="fas fa-baseball-ball"></i>take 操作</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="086864a5-94c2-483a-809a-97b3071fab65-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//LinkedBlockingQueue不支持空元素</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="comment">// count 用来维护元素计数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 满了等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 倒过来读就好: 等待 notFull</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有空位, 入队且计数加一</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement(); </span><br><span class="line">        <span class="comment">// 除了自己 put 以外, 队列还有空位, 由自己叫醒其他 put 线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中有一个元素, 叫醒 take 线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里调用的是 notEmpty.signal() 而不是 notEmpty.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="086864a5-94c2-483a-809a-97b3071fab65-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中只有一个空位时, 叫醒 put 线程</span></span><br><span class="line">    <span class="comment">// 如果有多个线程进行出队, 第一个线程满足 c == capacity, 但后续线程 c &lt; capacity</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 这里调用的是 notFull.signal() 而不是 notFull.signalAll() 是为了减少竞争</span></span><br><span class="line">        signalNotFull()</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由 put 唤醒 put 是为了避免信号不足</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h2 id="4-ConcurrentLinkedQueue">4. ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p><ul><li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li><li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</li><li>只是这【锁】使用了 cas 来实现</li></ul><p>事实上，ConcurrentLinkedQueue 应用还是非常广泛的</p><p>例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了 ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230404204402766.png" alt="image-20230404204402766"></p><h2 id="5-CopyOnWriteArrayList">5. CopyOnWriteArrayList</h2><p><code>CopyOnWriteArraySet</code>是它的马甲 底层实现采用了 写入时拷贝 的思想，增删改操作会将底层数组拷贝一份，更 改操作在新数组上执行，这时不影响其它线程的<strong>并发读</strong>，<strong>读写分离</strong>。 以新增为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 获取旧的数组</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">        <span class="comment">// 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）</span></span><br><span class="line">        es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加新元素</span></span><br><span class="line">        es[len] = e;</span><br><span class="line">        <span class="comment">// 替换旧的数组</span></span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的源码版本是 Java 11，在 Java 1.8 中使用的是可重入锁而不是 synchronized</p></blockquote><p>其它读操作并未加锁，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (Object x : getArray()) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) x;</span><br><span class="line">        action.accept(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适合『读多写少』的应用场景</p><h3 id="5-1-get-弱一致性">5.1 get 弱一致性</h3><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317202641399.png" alt="image-20220317202641399"></p><table><thead><tr><th style="text-align:center">时间点</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Thread-0 getArray()</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Thread-1 getArray()</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Thread-1 setArray(arrayCopy)</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Thread-0 array[index]</td></tr></tbody></table><blockquote><p>不容易测试，但问题确实存在</p></blockquote><h3 id="5-2-迭代器弱一致性">5.2 迭代器弱一致性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;).start();</span><br><span class="line">sleep1s();</span><br><span class="line"><span class="comment">//此时主线程的iterator依旧指向旧的数组。</span></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不要觉得弱一致性就不好</p><ul><li>数据库的 MVCC 都是弱一致性的表现</li><li>并发高和一致性是矛盾的，需要权衡</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1共享模型之工具</title>
      <link href="/posts/9c5b9bb4.html"/>
      <url>/posts/9c5b9bb4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-自定义线程池">1. 自定义线程池</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220311170716250.png" alt="image-20220311170716250"></p><div class="tabs" id="fec406e4-a43c-4c0d-b1cd-8434dbb940a8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fec406e4-a43c-4c0d-b1cd-8434dbb940a8-1"><i class="fas fa-seedling"></i>步骤1</button></li><li class="tab"><button type="button" data-href="#fec406e4-a43c-4c0d-b1cd-8434dbb940a8-2"><i class="fas fa-leaf"></i>步骤2</button></li><li class="tab"><button type="button" data-href="#fec406e4-a43c-4c0d-b1cd-8434dbb940a8-3"><i class="fab fa-apple"></i>步骤3</button></li><li class="tab"><button type="button" data-href="#fec406e4-a43c-4c0d-b1cd-8434dbb940a8-4"><i class="fas fa-tree"></i>步骤4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fec406e4-a43c-4c0d-b1cd-8434dbb940a8-1"><p>自定义拒绝策略接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">//拒绝策略</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue,T task)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fec406e4-a43c-4c0d-b1cd-8434dbb940a8-2"><p>自定义任务队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">//阻塞队列，存放任务</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//队列的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">//锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">//生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超时阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//将时间转换为纳秒</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nanoTime</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//等待超时依旧没有获取，返回null</span></span><br><span class="line">                    <span class="keyword">if</span>(nanoTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//该方法返回的是剩余时间</span></span><br><span class="line">                    nanoTime = emptyWaitSet.awaitNanos(nanoTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.pollFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.pollFirst();</span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().toString() + <span class="string">&quot;等待加入任务队列:&quot;</span> + t.toString());</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().toString() + <span class="string">&quot;加入任务队列:&quot;</span> + t.toString());</span><br><span class="line">            queue.addLast(t);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//超时阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T t,<span class="type">long</span> timeout,TimeUnit timeUnit)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanoTime</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nanoTime &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;等待超时，加入失败：&quot;</span> + t);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().toString() + <span class="string">&quot;等待加入任务队列:&quot;</span> + t.toString());</span><br><span class="line">                    nanoTime = fullWaitSet.awaitNanos(nanoTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().toString() + <span class="string">&quot;加入任务队列:&quot;</span> + t.toString());</span><br><span class="line">            queue.addLast(t);</span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.size();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从形参接收拒绝策略的put方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy,T task)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size() == capacity)&#123;</span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>,task);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;加入任务队列：&quot;</span> + task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fec406e4-a43c-4c0d-b1cd-8434dbb940a8-3"><p>自定义线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>&#123;</span><br><span class="line">    <span class="comment">//阻塞队列</span></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; taskQue;</span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> coreSize,<span class="type">long</span> timeout,TimeUnit timeUnit,<span class="type">int</span> queueCapacity,RejectPolicy&lt;Runnable&gt; rejectPolicy)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">        taskQue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;Runnable&gt;(queueCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line">    <span class="comment">//任务超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line">    <span class="comment">//时间单元</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line">    <span class="comment">//线程池的执行方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">        <span class="comment">//当线程数大于等于coreSize的时候，将任务放入阻塞队列</span></span><br><span class="line">        <span class="comment">//当线程数小于coreSize的时候，新建一个Worker放入workers</span></span><br><span class="line">        <span class="comment">//注意workers类不是线程安全的， 需要加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(workers.size() &gt;= coreSize)&#123;</span><br><span class="line"><span class="comment">//                taskQue.put(task);</span></span><br><span class="line">                <span class="comment">//死等</span></span><br><span class="line">                <span class="comment">//带超时等待</span></span><br><span class="line">                <span class="comment">//让调用者放弃执行任务</span></span><br><span class="line">                <span class="comment">//让调用者抛出异常</span></span><br><span class="line">                <span class="comment">//让调用者自己执行任务</span></span><br><span class="line">                taskQue.tryPut(rejectPolicy,task);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                System.out.println(Thread.currentThread().toString() + <span class="string">&quot;新增worker:&quot;</span> + worker + <span class="string">&quot;,task:&quot;</span> + task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//巧妙的判断</span></span><br><span class="line">            <span class="keyword">while</span>(task != <span class="literal">null</span> || (task = taskQue.poll(timeout,timeUnit)) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().toString() + <span class="string">&quot;正在执行:&quot;</span> + task);</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (workers)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().toString() + <span class="string">&quot;worker被移除:&quot;</span> + <span class="built_in">this</span>.toString());</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fec406e4-a43c-4c0d-b1cd-8434dbb940a8-4"><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPool</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">1</span>,</span><br><span class="line">                <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="number">1</span>, (queue, task)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 1. 死等</span></span><br><span class="line"><span class="comment">//            queue.put(task);</span></span><br><span class="line">            <span class="comment">// 2) 带超时等待</span></span><br><span class="line"><span class="comment">//            queue.offer(task, 1500, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line"><span class="comment">//            log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">            <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(&quot;任务执行失败 &quot; + task);</span></span><br><span class="line">            <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-ThreadPoolExecutor">2. ThreadPoolExecutor</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220311171237519.png" alt="image-20220311171237519"></p><p>说明：</p><ul><li>ScheduledThreadPoolExecutor是带调度的线程池</li><li>ThreadPoolExecutor是不带调度的线程池</li></ul><h3 id="2-1-线程池状态">2.1 线程池状态</h3><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><p><code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code></p><table><thead><tr><th style="text-align:center">状态名</th><th style="text-align:center">高3位</th><th style="text-align:center">接收新任务</th><th style="text-align:center">处理阻塞队列任务</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">RUNNING</td><td style="text-align:center">111</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SHUTDOWN</td><td style="text-align:center">000</td><td style="text-align:center">N</td><td style="text-align:center">Y</td><td style="text-align:center">不会接收新任务，但会处理阻塞队列剩余 任务</td></tr><tr><td style="text-align:center">STOP</td><td style="text-align:center">001</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">会中断正在执行的任务，并抛弃阻塞队列 任务</td></tr><tr><td style="text-align:center">TIDYING</td><td style="text-align:center">010</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">任务全执行完毕，活动线程为 0 即将进入 终结</td></tr><tr><td style="text-align:center">TERMINATED</td><td style="text-align:center">011</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">终结状态</td></tr></tbody></table><p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p><p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-工作方式">2.2 工作方式</h3><p>在JDK中的线程池中，线程分为两种。一种叫做核心线程，一种叫做救急线程。一开始都是没有创建的，都为懒惰创建。</p><p>核心线程数+救急线程数=最大线程数</p><div class="tabs" id="6532fcb2-28ca-4ddf-bdb2-e36bd19febe0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-1"><i class="fas fa-atom"></i>初始状态</button></li><li class="tab"><button type="button" data-href="#6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-2"><i class="far fa-sun"></i>2</button></li><li class="tab"><button type="button" data-href="#6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-3"><i class="fas fa-wind"></i>3</button></li><li class="tab"><button type="button" data-href="#6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-4"><i class="fas fa-fire-alt"></i>4</button></li><li class="tab"><button type="button" data-href="#6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-5"><i class="fas fa-horse"></i>5</button></li><li class="tab"><button type="button" data-href="#6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-6"><i class="fas fa-cat"></i>6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-1"><p>初始状态 虚线 表示还未创建</p><p>c：corePoolSize  核心线程数目 2   m：maximumPoolSiz 最大线程线程数目 3</p><p>线程池中刚开始没有线程。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230403133115379.png" alt="image-20230403133115379" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-2"><p>实线表示已创建线程</p><p>当一个任务提交给线程池后，线程池会创建一个核心线程来执行任务。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230403120601163.png" alt="image-20230403120601163" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-3"><p>假设阻塞队列长度为2。</p><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230403120618728.png" alt="image-20230403120618728" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-4"><p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</p><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230403134809613.png" alt="image-20230403134809613"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-5"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220311174119508.png" alt="image-20220311174119508"></p><ul><li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li>CallerRunsPolicy 让调用者运行任务</li><li>DiscardPolicy 放弃本次任务</li><li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6532fcb2-28ca-4ddf-bdb2-e36bd19febe0-6"><p>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制，下次高峰期来了才会被再次创建。</p><p>而核心线程执行完任务后，会被保留在线程池中，不会被销毁。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230403135635202.png" alt="image-20230403135635202" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="2-3-构造方法">2.3 构造方法</h3><p>参数列表</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数目</td></tr><tr><td>maximumPoolSize</td><td>最大线程数目</td></tr><tr><td>keepAliveTime</td><td>生存时间 - 针对救急线程</td></tr><tr><td>unit</td><td>时间单位 - 针对救急线程</td></tr><tr><td>workQueue</td><td>阻塞队列</td></tr><tr><td>threadFactory</td><td>线程工厂 - 可以为线程创建时起个好名字</td></tr><tr><td>handler</td><td>拒绝策略</td></tr></tbody></table><div class="tabs" id="c7c54ee0-9eda-42fe-9d85-de5641ea0eda"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c7c54ee0-9eda-42fe-9d85-de5641ea0eda-1"><i class="fas fa-cat"></i>newFixedThreadPool</button></li><li class="tab"><button type="button" data-href="#c7c54ee0-9eda-42fe-9d85-de5641ea0eda-2"><i class="fas fa-horse"></i>newCachedThreadPool</button></li><li class="tab"><button type="button" data-href="#c7c54ee0-9eda-42fe-9d85-de5641ea0eda-3"><i class="fas fa-dove"></i>newSingleThreadExecutor</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c7c54ee0-9eda-42fe-9d85-de5641ea0eda-1"><p>固定大小线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li></ul><blockquote><p>评价 适用于任务量已知，相对耗时的任务</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c7c54ee0-9eda-42fe-9d85-de5641ea0eda-2"><p>带缓冲线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, </span><br><span class="line">            TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，<ul><li>意味着全部都是救急线程（60s 后可以回收）</li><li>救急线程可以无限创建</li></ul></li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li></ul><blockquote><p><strong>评价</strong> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 适合任务数比较密集，但每个任务执行时间较短的情况</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c7c54ee0-9eda-42fe-9d85-de5641ea0eda-3"><p>单线程线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>,</span><br><span class="line">                    TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程 也不会被释放。</p><p>区别：</p><ul><li>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</li><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改<ul><li>FinalizableDelegatedExecutorService 应用的是装饰器模式，在调用构造方法时将ThreadPoolExecutor对象传给了内部的ExecutorService接口。只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法，也不能重新设置线程池的大小。</li></ul></li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改<ul><li>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-4-提交任务">2.4 提交任务</h3><div class="tabs" id="e70e018e-6f3d-4523-837f-b5e47b1bd059"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e70e018e-6f3d-4523-837f-b5e47b1bd059-1"><i class="fas fa-award"></i>execute</button></li><li class="tab"><button type="button" data-href="#e70e018e-6f3d-4523-837f-b5e47b1bd059-2"><i class="fas fa-baseball-ball"></i>submit</button></li><li class="tab"><button type="button" data-href="#e70e018e-6f3d-4523-837f-b5e47b1bd059-3"><i class="fas fa-bone"></i>invokeAll</button></li><li class="tab"><button type="button" data-href="#e70e018e-6f3d-4523-837f-b5e47b1bd059-4"><i class="fas fa-anchor"></i>invokeAny</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e70e018e-6f3d-4523-837f-b5e47b1bd059-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e70e018e-6f3d-4523-837f-b5e47b1bd059-2"><p>submit与execute区别在于 submit接收参数是一个Callable类型的任务，Callable与Runable相比就是多了一个返回的结果，Runnable无返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br></pre></td></tr></table></figure><p>测试submit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    Future&lt;String&gt; future = pool.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//get方法如果线程没有执行完，主线程会阻塞</span></span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, future.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    method1(pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18:36:58.033 c.TestSubmit [pool-1-thread-1] - running</span><br><span class="line">18:36:59.034 c.TestSubmit [main] - ok</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e70e018e-6f3d-4523-837f-b5e47b1bd059-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间，时间超时后，会放弃执行后面的任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><p>测试invokeAll</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    List&lt;Future&lt;String&gt;&gt; futures = pool.invokeAll(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    futures.forEach( f -&gt;  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, f.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    method2(pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">13</span>:<span class="number">31.187</span> c.TestSubmit [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - begin</span><br><span class="line"><span class="number">16</span>:<span class="number">13</span>:<span class="number">31.187</span> c.TestSubmit [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - begin</span><br><span class="line"><span class="number">16</span>:<span class="number">13</span>:<span class="number">31.690</span> c.TestSubmit [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - begin</span><br><span class="line"><span class="number">16</span>:<span class="number">13</span>:<span class="number">33.704</span> c.TestSubmit [main] - <span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">13</span>:<span class="number">33.726</span> c.TestSubmit [main] - <span class="number">2</span></span><br><span class="line"><span class="number">16</span>:<span class="number">13</span>:<span class="number">33.726</span> c.TestSubmit [main] - <span class="number">3</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e70e018e-6f3d-4523-837f-b5e47b1bd059-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure><p>测试invokeAny</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ExecutorService pool)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> pool.invokeAny(Arrays.asList(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin 1&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;end 1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin 2&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;end 2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;begin 3&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;end 3&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;3&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    ));</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//ExecutorService pool = Executors.newFixedThreadPool(1);</span></span><br><span class="line">    method3(pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">19:44:46.314 c.TestSubmit [pool-1-thread-1] - begin 1</span><br><span class="line">19:44:46.314 c.TestSubmit [pool-1-thread-3] - begin 3</span><br><span class="line">19:44:46.314 c.TestSubmit [pool-1-thread-2] - begin 2</span><br><span class="line">19:44:46.817 c.TestSubmit [pool-1-thread-2] - end 2</span><br><span class="line">19:44:46.817 c.TestSubmit [main] - 2</span><br><span class="line">//若设置线程数目为1 则为下面结果</span><br><span class="line">19:47:16.063 c.TestSubmit [pool-1-thread-1] - begin 1</span><br><span class="line">19:47:17.063 c.TestSubmit [pool-1-thread-1] - end 1</span><br><span class="line">19:47:17.063 c.TestSubmit [pool-1-thread-1] - begin 2</span><br><span class="line">19:47:17.063 c.TestSubmit [main] - 1</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="2-5-关闭线程池">2.5 关闭线程池</h3><div class="tabs" id="fc1e405d-0438-41c8-9941-d7f538926b70"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fc1e405d-0438-41c8-9941-d7f538926b70-1"><i class="fas fa-bug"></i>shutdown</button></li><li class="tab"><button type="button" data-href="#fc1e405d-0438-41c8-9941-d7f538926b70-2"><i class="fas fa-cannabis"></i>shutdownNow</button></li><li class="tab"><button type="button" data-href="#fc1e405d-0438-41c8-9941-d7f538926b70-3"><i class="fas fa-candy-cane"></i>其他方法</button></li><li class="tab"><button type="button" data-href="#fc1e405d-0438-41c8-9941-d7f538926b70-4"><i class="fas fa-child"></i>测试</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fc1e405d-0438-41c8-9941-d7f538926b70-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 但已提交任务会执行完</span></span><br><span class="line"><span class="comment">- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// 扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fc1e405d-0438-41c8-9941-d7f538926b70-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将队列中的任务返回</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 打断所有线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 获取队列中剩余任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fc1e405d-0438-41c8-9941-d7f538926b70-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="comment">// 一般task是Callable类型的时候不用此方法，因为futureTask.get方法自带等待功能。</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fc1e405d-0438-41c8-9941-d7f538926b70-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestShutDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestShutDown</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; result1 = pool.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 1 running...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;task 1 finish...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; result2 = pool.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 2 running...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;task 2 finish...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; result3 = pool.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 3 running...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;task 3 finish...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;shutdown&quot;</span>);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        <span class="comment">//        pool.awaitTermination(3, TimeUnit.SECONDS);</span></span><br><span class="line">        <span class="comment">//        List&lt;Runnable&gt; runnables = pool.shutdownNow();</span></span><br><span class="line">        <span class="comment">//        log.debug(&quot;other.... &#123;&#125;&quot; , runnables);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#shutdown依旧会执行剩下的任务</span></span><br><span class="line">20:09:13.285 c.TestShutDown [main] - shutdown</span><br><span class="line">20:09:13.285 c.TestShutDown [pool-1-thread-1] - task 1 running...</span><br><span class="line">20:09:13.285 c.TestShutDown [pool-1-thread-2] - task 2 running...</span><br><span class="line">20:09:14.293 c.TestShutDown [pool-1-thread-2] - task 2 finish...</span><br><span class="line">20:09:14.293 c.TestShutDown [pool-1-thread-1] - task 1 finish...</span><br><span class="line">20:09:14.293 c.TestShutDown [pool-1-thread-2] - task 3 running...</span><br><span class="line">20:09:15.303 c.TestShutDown [pool-1-thread-2] - task 3 finish...</span><br><span class="line"><span class="comment">#shutdownNow立刻停止所有任务</span></span><br><span class="line">20:11:11.750 c.TestShutDown [main] - shutdown</span><br><span class="line">20:11:11.750 c.TestShutDown [pool-1-thread-1] - task 1 running...</span><br><span class="line">20:11:11.750 c.TestShutDown [pool-1-thread-2] - task 2 running...</span><br><span class="line">20:11:11.750 c.TestShutDown [main] - other.... [java.util.concurrent.FutureTask@66d33a]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-6-模式之-Worker-Thread">2.6 模式之 Worker Thread</h3><h4 id="2-6-1-定义">2.6.1 定义</h4><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式。</p><p>例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那 么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）</p><p>注意，不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率</p><p>例如，如果一个餐馆的工人既要招呼客人（任务类型A），又要到后厨做菜（任务类型B）显然效率不咋地，分成 服务员（线程池A）与厨师（线程池B）更为合理，当然你能想到更细致的分工</p><h4 id="2-6-2-饥饿">2.6.2 饥饿</h4><p>固定大小线程池会有饥饿现象</p><ul><li>两个工人是同一个线程池中的两个线程</li><li>他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作<ul><li>客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待</li><li>后厨做菜：没啥说的，做就是了</li></ul></li></ul><div class="tabs" id="72098094-2c84-45c0-9581-3fc5aedc6f83"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#72098094-2c84-45c0-9581-3fc5aedc6f83-1"><i class="fas fa-seedling"></i>正常情况</button></li><li class="tab"><button type="button" data-href="#72098094-2c84-45c0-9581-3fc5aedc6f83-2"><i class="fas fa-leaf"></i>饥饿情况</button></li><li class="tab"><button type="button" data-href="#72098094-2c84-45c0-9581-3fc5aedc6f83-3"><i class="fab fa-apple"></i>解决方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="72098094-2c84-45c0-9581-3fc5aedc6f83-1"><p>比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStarvation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">&quot;地三鲜&quot;</span>, <span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;辣子鸡丁&quot;</span>, <span class="string">&quot;烤鸡翅&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">cooking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//两个工人</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">Pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">      <span class="comment">//客人一</span></span><br><span class="line">        Pool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            <span class="comment">//找一个工人做菜</span></span><br><span class="line">            Future&lt;String&gt; f = Pool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//等待做菜结果</span></span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">07</span>:<span class="number">14.374</span> c.TestDeadLock [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - 处理点餐...</span><br><span class="line"><span class="number">18</span>:<span class="number">07</span>:<span class="number">14.379</span> c.TestDeadLock [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - 做菜</span><br><span class="line"><span class="number">18</span>:<span class="number">07</span>:<span class="number">14.380</span> c.TestDeadLock [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - 上菜: 宫保鸡丁</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="72098094-2c84-45c0-9581-3fc5aedc6f83-2"><p>但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStarvation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">&quot;地三鲜&quot;</span>, <span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;辣子鸡丁&quot;</span>, <span class="string">&quot;烤鸡翅&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">cooking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//两个工人</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">Pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">      <span class="comment">//客人一</span></span><br><span class="line">        Pool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            <span class="comment">//找一个工人做菜</span></span><br><span class="line">            Future&lt;String&gt; f = Pool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//等待做菜结果</span></span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       <span class="comment">//客人二</span></span><br><span class="line">       Pool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            <span class="comment">//找一个工人做菜</span></span><br><span class="line">            Future&lt;String&gt; f = Pool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//等待做菜结果</span></span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:09:<span class="number">35.527</span> c.TestDeadLock [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - 处理点餐...</span><br><span class="line"><span class="number">18</span>:09:<span class="number">35.527</span> c.TestDeadLock [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - 处理点餐...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="72098094-2c84-45c0-9581-3fc5aedc6f83-3"><p>解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，<code>不同的任务类型，采用不同的线程池</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStarvation</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; MENU = Arrays.asList(<span class="string">&quot;地三鲜&quot;</span>, <span class="string">&quot;宫保鸡丁&quot;</span>, <span class="string">&quot;辣子鸡丁&quot;</span>, <span class="string">&quot;烤鸡翅&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">cooking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MENU.get(RANDOM.nextInt(MENU.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//服务员</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">waiterPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//厨子</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">cookPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        waiterPool.execute(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;处理点餐...&quot;</span>);</span><br><span class="line">            Future&lt;String&gt; f = cookPool.submit(() -&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;做菜&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> cooking();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;上菜: &#123;&#125;&quot;</span>, f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">17:25:14.626 c.TestDeadLock [pool-1-thread-1] - 处理点餐... </span><br><span class="line">17:25:14.630 c.TestDeadLock [pool-2-thread-1] - 做菜</span><br><span class="line">17:25:14.631 c.TestDeadLock [pool-1-thread-1] - 上菜: 地三鲜</span><br><span class="line">17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 处理点餐... </span><br><span class="line">17:25:14.632 c.TestDeadLock [pool-2-thread-1] - 做菜</span><br><span class="line">17:25:14.632 c.TestDeadLock [pool-1-thread-1] - 上菜: 辣子鸡丁</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="2-6-3-创建多少线程池合适">2.6.3 创建多少线程池合适</h4><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿</li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><p><strong>CPU 密集型运算</strong></p><p>通常采用<code>cpu 核数 + 1</code>能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p><p><strong>I/O 密集型运算</strong></p><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。</p><p>经验公式如下</p><p><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code></p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 50% = 8</code></p><p>例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式</p><p><code>4 * 100% * 100% / 10% = 40</code></p><h3 id="2-7-任务调度线程池">2.7 任务调度线程池</h3><p>有时候我们希望任务延时执行，或者任务反复被执行每隔几秒就执行一次，那么这个时候我们就需要用到任务调度线程池。</p><div class="tabs" id="48895836-bcf8-493d-93c7-10ef0f0adbf7"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#48895836-bcf8-493d-93c7-10ef0f0adbf7-1"><i class="fas fa-cat"></i>Timer实现</button></li><li class="tab"><button type="button" data-href="#48895836-bcf8-493d-93c7-10ef0f0adbf7-2"><i class="fas fa-horse"></i>ScheduledExecutorService实现</button></li><li class="tab"><button type="button" data-href="#48895836-bcf8-493d-93c7-10ef0f0adbf7-3"><i class="fas fa-dove"></i>线程数少时</button></li><li class="tab"><button type="button" data-href="#48895836-bcf8-493d-93c7-10ef0f0adbf7-4"><i class="fas fa-dragon"></i>出现异常时</button></li><li class="tab"><button type="button" data-href="#48895836-bcf8-493d-93c7-10ef0f0adbf7-5"><i class="fas fa-atom"></i>定时执行</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="48895836-bcf8-493d-93c7-10ef0f0adbf7-1"><p>在『任务调度线程池』功能加入之前(JDK1.3)，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">    <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">    timer.schedule(task2, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20:46:09.444 c.TestTimer [main] - start... </span><br><span class="line">20:46:10.447 c.TestTimer [Timer-0] - task 1 </span><br><span class="line">20:46:12.448 c.TestTimer [Timer-0] - task 2 </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="48895836-bcf8-493d-93c7-10ef0f0adbf7-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line"><span class="comment">//任务一</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务二</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">任务1，执行时间：Thu Jan 03 12:45:17 CST 2019 </span><br><span class="line">任务2，执行时间：Thu Jan 03 12:45:17 CST 2019 </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="48895836-bcf8-493d-93c7-10ef0f0adbf7-3"><p>串行执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line"><span class="comment">//任务一</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务二</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">任务<span class="number">1</span>，执行时间：Mon Apr <span class="number">03</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">24</span> CST <span class="number">2023</span></span><br><span class="line">任务<span class="number">2</span>，执行时间：Mon Apr <span class="number">03</span> <span class="number">18</span>:<span class="number">48</span>:<span class="number">26</span> CST <span class="number">2023</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="48895836-bcf8-493d-93c7-10ef0f0adbf7-4"><p>任务一中 除零异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line"><span class="comment">//任务一</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务二</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">任务<span class="number">1</span>，执行时间：Mon Apr <span class="number">03</span> <span class="number">18</span>:<span class="number">50</span>:<span class="number">35</span> CST <span class="number">2023</span></span><br><span class="line">任务<span class="number">2</span>，执行时间：Mon Apr <span class="number">03</span> <span class="number">18</span>:<span class="number">50</span>:<span class="number">35</span> CST <span class="number">2023</span></span><br></pre></td></tr></table></figure><p>都执行，并未看到异常信息</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="48895836-bcf8-493d-93c7-10ef0f0adbf7-5"><p>scheduleAtFixedRate：真正的间隔时间，是由任务的执行时间和设置的间隔时间长短来决定的，谁长取谁。也就是说，以上一个任务开始的时间计时，period时间过去后，检测上一个任务是否执行完毕，如果上一个任务执行完毕，则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行。<br>scheduleWithFixedDelay：真正的间隔时间，是任务的执行时间加上设置的间隔时间。也就是说，是以上一个任务结束时开始计时，period时间过去后，立即执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">37.231</span> c.TestTimer [main] - start...</span><br><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">38.333</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">39.332</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">40.332</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">41.332</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">42.332</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">43.332</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">44.329</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">45.332</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">18</span>:<span class="number">56</span>:<span class="number">46.332</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleWithFixedDelay(()-&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">55.078</span> c.TestTimer [main] - start... </span><br><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">56.140</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">40</span>:<span class="number">59.143</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">41</span>:<span class="number">02.145</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br><span class="line"><span class="number">21</span>:<span class="number">41</span>:<span class="number">05.147</span> c.TestTimer [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - running... </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-8-正确处理执行任务异常">2.8 正确处理执行任务异常</h3><p>不论是哪个线程池，在线程执行的任务发生异常后既不会抛出，也不会捕获，这时就需要我们做一定的处理。</p><div class="tabs" id="1cbd0048-f807-4045-8580-23803459291a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1cbd0048-f807-4045-8580-23803459291a-1"><i class="fas fa-award"></i>方法1：主动捉异常</button></li><li class="tab"><button type="button" data-href="#1cbd0048-f807-4045-8580-23803459291a-2"><i class="fas fa-baseball-ball"></i>方法2：使用 Future</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1cbd0048-f807-4045-8580-23803459291a-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">21:59:04.558 c.TestTimer [pool-1-thread-1] - task1 </span><br><span class="line">21:59:04.562 c.TestTimer [pool-1-thread-1] - error: </span><br><span class="line">java.lang.ArithmeticException: / by zero </span><br><span class="line"> at cn.itcast.n8.TestTimer.lambda$main<span class="variable">$0</span>(TestTimer.java:28) </span><br><span class="line"> at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511) </span><br><span class="line"> at java.util.concurrent.FutureTask.run(FutureTask.java:266) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:748) </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1cbd0048-f807-4045-8580-23803459291a-2"><p>说明：</p><ul><li>lambda表达式内要有返回值，编译器才能将其识别为Callable，否则将识别为Runnable，也就不能用FutureTask</li><li>方法中如果出异常，<code>futuretask.get</code>会返回这个异常，否者正常返回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">21:54:58.208 c.TestTimer [pool-1-thread-1] - task1 </span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: </span><br><span class="line">java.lang.ArithmeticException: / by zero </span><br><span class="line"> at java.util.concurrent.FutureTask.report(FutureTask.java:122) </span><br><span class="line"> at java.util.concurrent.FutureTask.get(FutureTask.java:192) </span><br><span class="line"> at cn.itcast.n8.TestTimer.main(TestTimer.java:31) </span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero </span><br><span class="line"> at cn.itcast.n8.TestTimer.lambda$main<span class="variable">$0</span>(TestTimer.java:28) </span><br><span class="line"> at java.util.concurrent.FutureTask.run(FutureTask.java:266) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) </span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:748) </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="2-9-应用之定时任务">2.9 应用之定时任务</h3><p>如何让每周四 18:00:00 定时执行任务？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// 获取本周四 18:00:00.000</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">thursday</span> <span class="operator">=</span> </span><br><span class="line">    now.with(DayOfWeek.THURSDAY).withHour(<span class="number">18</span>).withMinute(<span class="number">0</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果当前时间已经超过 本周四 18:00:00.000， 那么找下周四 18:00:00.000</span></span><br><span class="line"><span class="keyword">if</span>(now.compareTo(thursday) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    thursday = thursday.plusWeeks(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算时间差，即延时执行时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">initialDelay</span> <span class="operator">=</span> Duration.between(now, thursday).toMillis();</span><br><span class="line"><span class="comment">// 计算间隔时间，即 1 周的毫秒值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">oneWeek</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;开始时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, initialDelay, oneWeek, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><h3 id="2-10-Tomcat-线程池">2.10 Tomcat 线程池</h3><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230403193219700.png" alt="image-20230403193219700" style="zoom: 33%;" /><ul><li>LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲</li><li>Acceptor 只负责【接收新的 socket 连接】</li><li>Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】</li><li>一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理</li><li>Executor 线程池中的工作线程最终负责【处理请求】</li></ul><blockquote><p>合理的分工是实现高并发的保障。图中Acceptor和、Poller和Executor中的线程都是线程。那为什么把它们分成三块呢？它们每一块处理的任务时不一样的。</p></blockquote><p>Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同</p><ul><li>如果总线程数达到 maximumPoolSize<ul><li>这时不会立刻抛 RejectedExecutionException 异常</li><li>而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常</li></ul></li></ul><div class="tabs" id="08eb1b2a-94d2-4d0c-92b5-acf34fc46e28"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#08eb1b2a-94d2-4d0c-92b5-acf34fc46e28-1"><i class="fas fa-seedling"></i>源码 tomcat-7.0.42</button></li><li class="tab"><button type="button" data-href="#08eb1b2a-94d2-4d0c-92b5-acf34fc46e28-2"><i class="fas fa-leaf"></i>TaskQueue.java</button></li><li class="tab"><button type="button" data-href="#08eb1b2a-94d2-4d0c-92b5-acf34fc46e28-3"><i class="fab fa-apple"></i>Connector 配置</button></li><li class="tab"><button type="button" data-href="#08eb1b2a-94d2-4d0c-92b5-acf34fc46e28-4"><i class="fas fa-tree"></i>Executor 线程配置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="08eb1b2a-94d2-4d0c-92b5-acf34fc46e28-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">    submittedCount.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.execute(command);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">super</span>.getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> (TaskQueue)<span class="built_in">super</span>.getQueue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Queue capacity is full.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                Thread.interrupted();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            submittedCount.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> rx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="08eb1b2a-94d2-4d0c-92b5-acf34fc46e28-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">force</span><span class="params">(Runnable o, <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> ( parent.isShutdown() ) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(</span><br><span class="line">        <span class="string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(o,timeout,unit); <span class="comment">//forces the item onto the queue, to be used if the task </span></span><br><span class="line">    is rejected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="08eb1b2a-94d2-4d0c-92b5-acf34fc46e28-3"><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>acceptorThreadCount</code></td><td style="text-align:center">1</td><td style="text-align:center">acceptor 线程数量</td></tr><tr><td style="text-align:center"><code>pollerThreadCount</code></td><td style="text-align:center">1</td><td style="text-align:center">poller 线程数量</td></tr><tr><td style="text-align:center"><code>minSpareThreads</code></td><td style="text-align:center">10</td><td style="text-align:center">核心线程数，即 corePoolSize</td></tr><tr><td style="text-align:center"><code>maxThreads</code></td><td style="text-align:center">200</td><td style="text-align:center">最大线程数，即 maximumPoolSize</td></tr><tr><td style="text-align:center"><code>executor</code></td><td style="text-align:center">-</td><td style="text-align:center"></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="08eb1b2a-94d2-4d0c-92b5-acf34fc46e28-4"><table><thead><tr><th style="text-align:center">配置项</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>threadPriority</code></td><td style="text-align:center">5</td><td style="text-align:center">线程优先级</td></tr><tr><td style="text-align:center"><code>daemon</code></td><td style="text-align:center">true</td><td style="text-align:center">是否守护线程</td></tr><tr><td style="text-align:center"><code>minSpareThreads</code></td><td style="text-align:center">25</td><td style="text-align:center">核心线程数，即corePoolSize</td></tr><tr><td style="text-align:center"><code>maxThreads</code></td><td style="text-align:center">200</td><td style="text-align:center">最大线程数，即 maximumPoolSize</td></tr><tr><td style="text-align:center"><code>maxIdleTime</code></td><td style="text-align:center">60000</td><td style="text-align:center">线程生存时间，单位是毫秒，默认值即 1 分钟</td></tr><tr><td style="text-align:center"><code>maxQueueSize</code></td><td style="text-align:center">Integer.MAX_VALUE</td><td style="text-align:center">队列长度</td></tr><tr><td style="text-align:center"><code>prestartminSpareThreads</code></td><td style="text-align:center">false</td><td style="text-align:center">核心线程是否在服务器启动时启动</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220312104017979.png" alt="image-20220312104017979"></p><h3 id="2-11-Fork-Join">2.11 Fork/Join</h3><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型 运算</p><p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解</p><p>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运 算效率</p><p>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p><p>提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务</p><h2 id="3-AQS-原理">3. AQS 原理</h2><h3 id="3-1-概述">3.1 概述</h3><p>全称是 AbstractQueuedSynchronizer，是<code>阻塞式锁和相关的同步器工具</code>的框架 (其它的同步器都是它的子类)</p><p>是用来实现锁或者其它同步器组件的公共基础部分的抽象实现， <span class='p red'>是重量级基础框架及整个JUC体系的基石，主要用于解决锁分配给"谁"的问题</span>。</p><p>整体就是一个抽象的<span class='p green'>FIFO队列</span>来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态。</p><p>既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p><p>如果共享资源被占用，<span class='p blue'>就需要一定的阻塞等待唤醒机制来保证锁分配</span>。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的结点对象（Node），通过 CAS、自旋以及LockSupport.park()的方式，维护state 变量的状态，使并发达到同步的效果。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230406141436231.png" alt="image-20230406141436231" style="zoom:80%;" /><p>特点：</p><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取 锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas 机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><div class="tabs" id="c3d3b843-622d-48b5-bc37-a885e1227037"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c3d3b843-622d-48b5-bc37-a885e1227037-1"><i class="fas fa-cat"></i>获取锁的姿势</button></li><li class="tab"><button type="button" data-href="#c3d3b843-622d-48b5-bc37-a885e1227037-2"><i class="fas fa-horse"></i>释放锁的姿势</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c3d3b843-622d-48b5-bc37-a885e1227037-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">    <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c3d3b843-622d-48b5-bc37-a885e1227037-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="3-2-AQS内部体系架构">3.2 AQS内部体系架构</h3><div class="tabs" id="aaa44ce3-b491-4ef6-bbda-652098c94817"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#aaa44ce3-b491-4ef6-bbda-652098c94817-1"><i class="fas fa-bug"></i>AQS架构</button></li><li class="tab"><button type="button" data-href="#aaa44ce3-b491-4ef6-bbda-652098c94817-2"><i class="fas fa-cannabis"></i>AQS的state变量</button></li><li class="tab"><button type="button" data-href="#aaa44ce3-b491-4ef6-bbda-652098c94817-3"><i class="fas fa-candy-cane"></i>AQS的CLH队列</button></li><li class="tab"><button type="button" data-href="#aaa44ce3-b491-4ef6-bbda-652098c94817-4"><i class="fas fa-child"></i>AQS的内部类Node</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="aaa44ce3-b491-4ef6-bbda-652098c94817-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230406133051207.png" alt="image-20230406133051207" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="aaa44ce3-b491-4ef6-bbda-652098c94817-2"><p>类似于银行办理业务的受理窗口状态，零就是没人，自由状态可以办理，大于等于1，有人占用窗口，等着去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="aaa44ce3-b491-4ef6-bbda-652098c94817-3"><p>CLH队列(三个大牛的名字组成),为一个双向队列</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230406140012073.png" alt="image-20230406140012073" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="aaa44ce3-b491-4ef6-bbda-652098c94817-4"><p>说人话,队列中每个排队的个体(线程)就是一个Node。Node的等待状态waitStatus就好比等候区其它顾客(其它线程)的等待状态。</p><div class="fj-gallery"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230406141040766.png" alt="image-20230406141040766" style="zoom:50%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230406141135307.png" alt="image-20230406141135307" style="zoom:50%;" />          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="3-3-实现不可重入锁">3.3 实现不可重入锁</h3><div class="tabs" id="a97c740e-6af2-4303-9a7c-bbf6a3a48fce"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a97c740e-6af2-4303-9a7c-bbf6a3a48fce-1"><i class="fas fa-atom"></i>自定义同步器</button></li><li class="tab"><button type="button" data-href="#a97c740e-6af2-4303-9a7c-bbf6a3a48fce-2"><i class="far fa-sun"></i>定义锁</button></li><li class="tab"><button type="button" data-href="#a97c740e-6af2-4303-9a7c-bbf6a3a48fce-3"><i class="fas fa-wind"></i>测试</button></li><li class="tab"><button type="button" data-href="#a97c740e-6af2-4303-9a7c-bbf6a3a48fce-4"><i class="fas fa-fire-alt"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a97c740e-6af2-4303-9a7c-bbf6a3a48fce-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占锁  同步器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 加上了锁，并设置 owner 为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 是否持有独占锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a97c740e-6af2-4303-9a7c-bbf6a3a48fce-2"><p>有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，可打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试一次，不成功返回，不进入队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，有时限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 生成条件变量</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a97c740e-6af2-4303-9a7c-bbf6a3a48fce-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLock</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a97c740e-6af2-4303-9a7c-bbf6a3a48fce-4"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">22:29:28.727 c.TestAqs [t1] - locking... </span><br><span class="line">22:29:29.732 c.TestAqs [t1] - unlocking... </span><br><span class="line">22:29:29.732 c.TestAqs [t2] - locking... </span><br><span class="line">22:29:29.732 c.TestAqs [t2] - unlocking... </span><br></pre></td></tr></table></figure><p>不可重入测试</p><p>如果改为下面代码，会发现自己也会被挡住（只会打印一次 locking）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">09:<span class="number">43</span>:<span class="number">50.394</span> c.TestAqs [t1] - locking...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="3-4-心得">3.4 心得</h3><div class="tabs" id="cea555e2-cdb8-4c02-b789-d424b82b74d8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#cea555e2-cdb8-4c02-b789-d424b82b74d8-1"><i class="fas fa-award"></i>起源</button></li><li class="tab"><button type="button" data-href="#cea555e2-cdb8-4c02-b789-d424b82b74d8-2"><i class="fas fa-baseball-ball"></i>目标</button></li><li class="tab"><button type="button" data-href="#cea555e2-cdb8-4c02-b789-d424b82b74d8-3"><i class="fas fa-bone"></i>设计</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="cea555e2-cdb8-4c02-b789-d424b82b74d8-1"><p>早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不 够优雅，于是在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cea555e2-cdb8-4c02-b789-d424b82b74d8-2"><p>AQS 要实现的功能目标</p><ul><li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire</li><li>获取锁超时机制</li><li>通过打断取消机制</li><li>独占机制及共享机制</li><li>条件不满足时的等待机制</li></ul><p>要实现的性能目标</p><blockquote><p>Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when synchronizers are contended.</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cea555e2-cdb8-4c02-b789-d424b82b74d8-3"><p>AQS 的基本思想其实很简单</p><p>获取锁的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(state 状态不允许获取) &#123;</span><br><span class="line">    <span class="keyword">if</span>(队列中还没有此线程) &#123;</span><br><span class="line">        入队并阻塞</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">当前线程出队</span><br></pre></td></tr></table></figure><p>释放锁的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(state 状态允许了) &#123;</span><br><span class="line">    恢复阻塞的线程(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要点</p><ul><li>原子维护 state 状态</li><li>阻塞及恢复线程</li><li>维护队列</li></ul><ol><li>state 设计<ul><li>state 使用 volatile 配合 cas 保证其修改时的原子性</li><li>state 使用了 32bit int 来维护同步状态，因为当时使用 long 在很多平台下测试的结果并不理想</li></ul></li></ol><ol start="2"><li>阻塞恢复设计<ul><li>早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume  那么 suspend 将感知不到</li><li>解决方法是使用 park &amp; unpark 来实现线程的暂停和恢复，具体原理在之前讲过了，先 unpark 再 park 也没 问题</li><li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</li><li>park 线程还可以通过 interrupt 打断</li></ul></li><li>队列设计<ul><li>使用了 FIFO 先入先出队列，并不支持优先级队列</li><li>设计时借鉴了 CLH 队列，它是一种单向无锁队列</li></ul></li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220312234238685.png" alt="image-20220312234238685"></p><p>队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态 入队伪代码，只需要考虑 tail 赋值的原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 原来的 tail</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 用 cas 在原来 tail 的基础上改为 node</span></span><br><span class="line">&#125; <span class="keyword">while</span>(tail.compareAndSet(prev, node))</span><br></pre></td></tr></table></figure><p>出队伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prev 是上一个节点</span></span><br><span class="line"><span class="keyword">while</span>((Node prev=node.prev).state != 唤醒状态) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置头节点</span></span><br><span class="line">head = node;</span><br></pre></td></tr></table></figure><p>CLH 好处：</p><ul><li>无锁，使用自旋</li><li>快速，无阻塞</li></ul><p>AQS 在一些方面改进了 CLH</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 队列中还没有元素 tail 为 null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 head 从 null -&gt; dummy</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 node 的 prev 设置为原来的 tail</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 将 tail 从原来的 tail 设置为 node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">// 原来 tail 的 next 设置为 node</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>主要用到 AQS 的并发工具类</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220312235232687.png" alt="image-20220312235232687"></p><h2 id="4-ReentrantLock-原理">4. ReentrantLock 原理</h2><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220312235320716.png" alt="image-20220312235320716" style="zoom:50%;" /><h3 id="4-1-非公平锁实现原理">4.1 非公平锁实现原理</h3><p><strong>加锁解锁流程</strong></p><div class="tabs" id="ab54601b-f609-4d3b-9625-e89aec82e01c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ab54601b-f609-4d3b-9625-e89aec82e01c-1"><i class="fas fa-bug"></i>加锁成功</button></li><li class="tab"><button type="button" data-href="#ab54601b-f609-4d3b-9625-e89aec82e01c-2"><i class="fas fa-cannabis"></i>加锁失败1</button></li><li class="tab"><button type="button" data-href="#ab54601b-f609-4d3b-9625-e89aec82e01c-3"><i class="fas fa-candy-cane"></i>加锁失败2</button></li><li class="tab"><button type="button" data-href="#ab54601b-f609-4d3b-9625-e89aec82e01c-4"><i class="fas fa-child"></i>解锁竞争成功</button></li><li class="tab"><button type="button" data-href="#ab54601b-f609-4d3b-9625-e89aec82e01c-5"><i class="fas fa-seedling"></i>解锁竞争失败</button></li><li class="tab"><button type="button" data-href="#ab54601b-f609-4d3b-9625-e89aec82e01c-6"><i class="fas fa-leaf"></i>加锁源码</button></li><li class="tab"><button type="button" data-href="#ab54601b-f609-4d3b-9625-e89aec82e01c-7"><i class="fab fa-apple"></i>解锁源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ab54601b-f609-4d3b-9625-e89aec82e01c-1"><p>先从构造器开始看，默认为非公平锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync 继承自 AQS</p><p>没有竞争时</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314153311208.png" alt="image-20220314153311208" style="zoom: 67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab54601b-f609-4d3b-9625-e89aec82e01c-2"><p>第一个竞争出现时</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314153333551.png" alt="image-20220314153333551" style="zoom: 67%;" /><p>Thread-1 执行了</p><ol><li>CAS 尝试将 state 由 0 改为 1，结果失败</li><li>进入 tryAcquire 逻辑，再尝试加锁，这时 state 已经是1，结果仍然失败</li><li>接下来进入 addWaiter 逻辑，构造 Node 队列<ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ul></li></ol><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314153434087.png" alt="image-20220314153434087" style="zoom: 67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab54601b-f609-4d3b-9625-e89aec82e01c-3"><p>当前线程进入 acquireQueued 逻辑</p><ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1(-1表示你有责任唤醒后继节点)，这次返回 false<img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314153526384.png" alt="image-20220314153526384" style="zoom: 67%;" /></li><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ol><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314153708216.png" alt="image-20220314153708216" style="zoom: 67%;" /><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314154029099.png" alt="image-20220314154029099" style="zoom: 67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab54601b-f609-4d3b-9625-e89aec82e01c-4"><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p><ul><li>设置 exclusiveOwnerThread 为 null</li><li>state = 0</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314153831407.png" alt="image-20220314153831407" style="zoom:67%;" /><p>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程</p><p>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p><p>回到 Thread-1 的 acquireQueued 流程</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314153919958.png" alt="image-20220314153919958" style="zoom:67%;" /><p>如果加锁成功（没有竞争），会设置</p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab54601b-f609-4d3b-9625-e89aec82e01c-5"><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314154048958.png" alt="image-20220314154048958" style="zoom:67%;" /><p>如果不巧又被 Thread-4 占了先</p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab54601b-f609-4d3b-9625-e89aec82e01c-6"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁实现</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果尝试失败，进入 ㈠</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// ㈡ tryAcquire </span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ 进入 ㈢</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈢ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果还没有获得锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取失败, 回到调用处</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈣ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//将当前node加入等待队列末尾等待，并返回当前node</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前线程关联到一个 Node 对象上, 模式为独占模式</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//非公平同步器中有head和tail两个引用分别指向了等待队列的第一个和最后一个节点</span></span><br><span class="line">        <span class="comment">//pred指的是node的前驱，从队尾插入，所以pred为tail</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 如果 tail 不为 null, 说明已经有了等待队列了，cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将node的前驱节点设置为pred</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//尝试将队列的tial从当前的pred修改为node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">// 双向链表</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果pred为null，说明等待队列还未创建，调用enq方法创建队列</span></span><br><span class="line">        <span class="comment">// 尝试将 Node 加入 AQS, 进入 ㈥</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈥ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//该方法就是创建等待队列，并将node插入队列的尾部。</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>())) &#123;</span><br><span class="line">                    <span class="comment">//将head赋值给tail，head和tail同时指向哨兵节点</span></span><br><span class="line">                    tail = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cas 尝试将 Node 对象加入 AQS 队列尾部</span></span><br><span class="line">                <span class="comment">//设置node的前驱节点为队列的最后一个节点</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">//尝试将队列的尾部从当前的tail设置为node</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    <span class="comment">//将node设为上一个tail的后继节点</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈤ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//在队列中循环等待，只有当排队排到第一名并且获得了锁才能出队并从方法中退出。</span></span><br><span class="line">    <span class="comment">//返回打断状态</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//找到当前node的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">// 获取成功, 设置自己（当前线程对应的 node）为 head</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// 上一个节点 help GC</span></span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 返回中断标记 false</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// 判断是否应当 park, 进入 ㈦</span></span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧</span></span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈦ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//判断acquire失败以后是否应该阻塞等待。从规则上来讲：</span></span><br><span class="line">    <span class="comment">//1.如果前驱节点都阻塞了，那么当前节点也应该阻塞</span></span><br><span class="line">    <span class="comment">//2.如果前驱节点取消，那么应该将前驱节点前移，直到其状态不为取消为止。</span></span><br><span class="line">    <span class="comment">//3.如果前两种情况都不是，尝试将前驱节点状态设为SIGNAL，返回false（不用阻塞，等到下次在阻塞）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取上一个节点的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点都在阻塞, 那么自己也阻塞好了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt; 0 表示取消状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这次还没有阻塞</span></span><br><span class="line">            <span class="comment">// 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈧ 阻塞当前线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>是否需要 unpark 是由当前节点的前驱节点的 waitStatus == Node.SIGNAL 来决定，而不是本节点的 waitStatus 决定</p></blockquote><p>总结：</p><ul><li>调用<code>lock</code>，尝试将state从0修改为1<ul><li>成功：将owner设为当前线程</li><li>失败：调用<code>acquire</code>-&gt;<code>tryAcquire</code>-&gt;<code>nonfairTryAcquire</code>，判断state=0则获得锁，或者state不为0但当前线程持有锁则重入锁，以上两种情况<code>tryAcquire</code>返回true，剩余情况返回false。<ul><li>true：获得锁</li><li>false：调用<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>,其中<code>addwiter</code>将关联线程的节点插入AQS队列尾部，进入<code>acquireQueued</code>中的for循环:<ul><li>如果当前节点是头节点，并尝试获得锁成功，将当前节点设为头节点，清除此节点信息，返回打断标记。</li><li>调用<code>shoudParkAfterFailure</code>,第一次调用返回false，并将前驱节点改为-1，第二次循环如果再进入此方法，会进入阻塞并检查打断的方法。</li></ul></li></ul></li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab54601b-f609-4d3b-9625-e89aec82e01c-7"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试释放锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// 队列头节点 unpark</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; </span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 队列不为 null</span></span><br><span class="line">                h != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                <span class="comment">// waitStatus == Node.SIGNAL 才需要 unpark</span></span><br><span class="line">                h.waitStatus != <span class="number">0</span></span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="comment">// unpark AQS 中等待的线程, 进入 ㈡</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果状态为 Node.SIGNAL 尝试重置状态为 0</span></span><br><span class="line">        <span class="comment">// 不成功也可以</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>-<code>unlock</code>-&gt;<code>syn.release</code>(1)-&gt;<code>tryRelease</code>(1),如果当前线程并不持有锁，抛异常。state减去1,如果之后state为0，解锁成功，返回true；如果仍大于0，表示解锁不完全，当前线程依旧持有锁，返回false。</p><ul><li>返回true：检查AQS队列第一个节点状态图是否为<code>SIGNAL</code>(意味着有责任唤醒其后记节点)，如果有，调用<code>unparkSuccessor</code>。<ul><li>再<code>unparkSuccessor</code>中，不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点，如果有，将其唤醒。</li></ul></li><li>返回false：</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="4-2-可重入原理">4.2 可重入原理</h3><p>当持有锁的线程再次尝试获取锁时，会将state的值加1，state表示锁的重入量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state-- </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-可打断原理">4.3 可打断原理</h3><div class="tabs" id="ae13c790-a91c-4377-b4a7-12544253fdda"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ae13c790-a91c-4377-b4a7-12544253fdda-1"><i class="fas fa-cat"></i>不可打断模式</button></li><li class="tab"><button type="button" data-href="#ae13c790-a91c-4377-b4a7-12544253fdda-2"><i class="fas fa-horse"></i>可打断模式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ae13c790-a91c-4377-b4a7-12544253fdda-1"><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，并将打断信号存储在一个interrupt变量中。一直要等到获得锁后方能得知自己被打断了,并且调用<code>selfInterrupt</code>方法打断自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应打断标记，打断自己</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ae13c790-a91c-4377-b4a7-12544253fdda-2"><p>此模式下即使线程在等待队列中等待，一旦被打断，就会立刻抛出打断异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="4-4-公平锁实现原理">4.4 公平锁实现原理</h3><p>简而言之，公平与非公平的区别在于，公平锁中的tryAcquire方法被重写了，新来的线程即便得知了锁的state为0，也要先判断等待队列中是否还有线程等待，只有当队列没有线程等待式，才获得锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            !tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">//存疑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            (</span><br><span class="line">            <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">            (s = h.next) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">            s.thread != Thread.currentThread()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-条件变量实现原理">4.5 条件变量实现原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p><p><strong>await流程</strong></p><div class="tabs" id="4b85b845-bd90-4107-aac7-bcd4f7b1d25a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4b85b845-bd90-4107-aac7-bcd4f7b1d25a-1"><i class="fas fa-atom"></i>1</button></li><li class="tab"><button type="button" data-href="#4b85b845-bd90-4107-aac7-bcd4f7b1d25a-2"><i class="far fa-sun"></i>2</button></li><li class="tab"><button type="button" data-href="#4b85b845-bd90-4107-aac7-bcd4f7b1d25a-3"><i class="fas fa-wind"></i>3</button></li><li class="tab"><button type="button" data-href="#4b85b845-bd90-4107-aac7-bcd4f7b1d25a-4"><i class="fas fa-fire-alt"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4b85b845-bd90-4107-aac7-bcd4f7b1d25a-1"><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程</p><p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314171543622.png" alt="image-20220314171543622" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4b85b845-bd90-4107-aac7-bcd4f7b1d25a-2"><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314171600661.png" alt="image-20220314171600661" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4b85b845-bd90-4107-aac7-bcd4f7b1d25a-3"><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314171619415.png" alt="image-20220314171619415" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4b85b845-bd90-4107-aac7-bcd4f7b1d25a-4"><p>park 阻塞 Thread-0</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314171637949.png" alt="image-20220314171637949" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>总结：</p><ul><li>创建一个节点，关联当前线程，并插入到当前Condition队列的尾部</li><li>调用<code>fullRelease</code>，完全释放同步器中的锁，并记录当前线程的锁重入数</li><li>唤醒(park)AQS队列中的第一个线程</li><li>调用park方法，阻塞当前线程。</li></ul><p><strong>signal 流程</strong></p><div class="tabs" id="32f53e83-10f0-4e18-bb38-c3ee28eb6cb2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#32f53e83-10f0-4e18-bb38-c3ee28eb6cb2-1"><i class="fas fa-award"></i>1</button></li><li class="tab"><button type="button" data-href="#32f53e83-10f0-4e18-bb38-c3ee28eb6cb2-2"><i class="fas fa-baseball-ball"></i>2</button></li><li class="tab"><button type="button" data-href="#32f53e83-10f0-4e18-bb38-c3ee28eb6cb2-3"><i class="fas fa-bone"></i>3</button></li><li class="tab"><button type="button" data-href="#32f53e83-10f0-4e18-bb38-c3ee28eb6cb2-4"><i class="fas fa-anchor"></i>源码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="32f53e83-10f0-4e18-bb38-c3ee28eb6cb2-1"><p>假设 Thread-1 要来唤醒 Thread-0</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314171703144.png" alt="image-20220314171703144" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="32f53e83-10f0-4e18-bb38-c3ee28eb6cb2-2"><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314171727397.png" alt="image-20220314171727397" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="32f53e83-10f0-4e18-bb38-c3ee28eb6cb2-3"><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314171749467.png" alt="image-20220314171749467" style="zoom:67%;" /><p>Thread-1 释放锁，进入 unlock 流程，略</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="32f53e83-10f0-4e18-bb38-c3ee28eb6cb2-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个等待节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionObject</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// ㈠ 添加一个 Node 至等待队列</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个关联当前线程的新 Node, 添加至队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 将没取消的第一个节点转移至 AQS 队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 已经是尾节点了</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>) &#123;</span><br><span class="line">                lastWaiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (</span><br><span class="line">            <span class="comment">// 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环 ㈢</span></span><br><span class="line">            !transferForSignal(first) &amp;&amp;</span><br><span class="line">            <span class="comment">// 队列还有节点</span></span><br><span class="line">            (first = firstWaiter) != <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈢ 如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果状态已经不是 Node.CONDITION, 说明被取消了</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 加入 AQS 队列尾部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// 上一个节点被取消</span></span><br><span class="line">            ws &gt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 上一个节点不能设置状态为 Node.SIGNAL</span></span><br><span class="line">            !compareAndSetWaitStatus(p, ws, Node.SIGNAL) </span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// unpark 取消阻塞, 让线程重新同步状态</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 等待队列的所有节点转移至 AQS 队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">        lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">            first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            transferForSignal(first);</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可打断等待 - 直到被唤醒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁, 见 ㈣</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 仅设置打断状态</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">        lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">            first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            transferForSignal(first);</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈡</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全部唤醒 - 必须持有锁才能唤醒, 因此 doSignalAll 内无需考虑加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不可打断等待 - 直到被唤醒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁, 见 ㈣</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 仅设置打断状态</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒后, 尝试竞争锁, 如果失败进入 AQS 队列</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="comment">// ㈣ 因为某线程可能重入，需要将 state 全部释放</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时重新设置打断状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 打断模式 - 在退出等待时抛出异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ㈤ 应用打断模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// park 阻塞</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向Condition中的等待队列中新增节点，并将此节点返回</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">        <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前节点是否在同步器中的队列中等待锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">         * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">         * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">         * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">         * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">         * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加一个 Node 至等待队列, 见 ㈠</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">        <span class="comment">// 释放节点持有的锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">        <span class="comment">// 获得最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果该节点还没有转移至 AQS 队列, 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 已超时, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// park 阻塞一定时间, spinForTimeoutThreshold 为 1000 ns</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="comment">// 如果被打断, 退出等待队列</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出等待队列后, 还需要获得 AQS 队列的锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="comment">// 所有已取消的 Node 从队列链表删除, 见 ㈡</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 应用打断模式, 见 ㈤</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 - 直到被唤醒或打断或超时, 逻辑类似于 awaitNanos</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工具方法 省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>总结：</p><ul><li>当前持有锁的线程唤醒等待队列中的线程，调用doSignal或doSignalAll方法，将等待队列中的第一个（或全部）节点插入到AQS队列中的尾部。</li><li>将插入的节点的状态从Condition设置为0，将插入节点的前一个节点的状态设置为-1（意味着要承担唤醒后一个节点的责任）</li><li>当前线程释放锁，parkAQS队列中的第一个节点线程。</li></ul><h2 id="5-读写锁">5. 读写锁</h2><h3 id="5-1-ReentrantReadWriteLock">5.1 ReentrantReadWriteLock</h3><p>当读操作远远高于写操作时，这时候使用<code>读写锁</code>让<code>读-读</code>可以并发，提高性能。</p><p>类似于数据库中的<code>select ... from ... lock in share mode</code></p><blockquote><p>简单来说，就是读锁可以共享，但是写锁必须独占</p></blockquote><p>示例：提供一个<code>数据容器类</code>内部分别使用<code>读锁</code>保护数据的 read() 方法，<code>写锁</code>保护数据的 write() 方法<div class="tabs" id="f35d3c3d-bc69-4924-92b2-8243c2220566"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#f35d3c3d-bc69-4924-92b2-8243c2220566-1"><i class="fas fa-bug"></i>代码</button></li><li class="tab"><button type="button" data-href="#f35d3c3d-bc69-4924-92b2-8243c2220566-2"><i class="fas fa-cannabis"></i>测试读锁-读锁可以并发</button></li><li class="tab"><button type="button" data-href="#f35d3c3d-bc69-4924-92b2-8243c2220566-3"><i class="fas fa-candy-cane"></i>测试读锁-写锁相互阻塞</button></li><li class="tab"><button type="button" data-href="#f35d3c3d-bc69-4924-92b2-8243c2220566-4"><i class="fas fa-child"></i>测试写锁-写锁相互阻塞</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="f35d3c3d-bc69-4924-92b2-8243c2220566-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f35d3c3d-bc69-4924-92b2-8243c2220566-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出结果，从这里可以看到 Thread-0 锁定期间，Thread-1 的读操作不受影响</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">14:05:14.341 c.DataContainer [t2] - 获取读锁... </span><br><span class="line">14:05:14.341 c.DataContainer [t1] - 获取读锁... </span><br><span class="line">14:05:14.345 c.DataContainer [t1] - 读取</span><br><span class="line">14:05:14.345 c.DataContainer [t2] - 读取</span><br><span class="line">14:05:15.365 c.DataContainer [t2] - 释放读锁... </span><br><span class="line">14:05:15.386 c.DataContainer [t1] - 释放读锁... </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f35d3c3d-bc69-4924-92b2-8243c2220566-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.write();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">21.838</span> c.DataContainer [t1] - 获取读锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">21.838</span> c.DataContainer [t2] - 获取写锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">21.841</span> c.DataContainer [t2] - 写入</span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">22.843</span> c.DataContainer [t2] - 释放写锁... </span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">22.843</span> c.DataContainer [t1] - 读取</span><br><span class="line"><span class="number">14</span>:<span class="number">04</span>:<span class="number">23.843</span> c.DataContainer [t1] - 释放读锁... </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f35d3c3d-bc69-4924-92b2-8243c2220566-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.write();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    dataContainer.write();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">52.665</span> c.DataContainer [t1] - 获取写锁...</span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">52.665</span> c.DataContainer [t2] - 获取写锁...</span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">52.667</span> c.DataContainer [t2] - 写入</span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">53.673</span> c.DataContainer [t2] - 释放写锁...</span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">53.674</span> c.DataContainer [t1] - 写入</span><br><span class="line"><span class="number">11</span>:<span class="number">33</span>:<span class="number">54.679</span> c.DataContainer [t1] - 释放写锁...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p><strong>注意事项</strong></p><div class="tabs" id="9055eaa3-a964-4954-a6d8-3159462eb4fd"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#9055eaa3-a964-4954-a6d8-3159462eb4fd-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#9055eaa3-a964-4954-a6d8-3159462eb4fd-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#9055eaa3-a964-4954-a6d8-3159462eb4fd-3"><i class="fab fa-apple"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="9055eaa3-a964-4954-a6d8-3159462eb4fd-1"><p>读锁不支持条件变量</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9055eaa3-a964-4954-a6d8-3159462eb4fd-2"><p>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    r.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9055eaa3-a964-4954-a6d8-3159462eb4fd-3"><p>重入时降级支持：即持有写锁的情况下去获取读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="comment">// 是否有效，如果失效，需要重新计算 data</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 获取写锁前必须释放读锁</span></span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其它线程已经获取了写锁、更新了缓存, 避免重复更新</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                        cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 降级为读锁, 释放写锁, 这样能够让其它线程读取缓存</span></span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自己用完数据, 释放读锁 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="5-2-读写锁原理">5.2 读写锁原理</h3><p>图解流程</p><div class="tabs" id="1a9249ba-6a46-4d14-b45f-183ba5c9fcba"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1a9249ba-6a46-4d14-b45f-183ba5c9fcba-1"><i class="fas fa-cat"></i>t1 w.lock，t2 r.lock</button></li><li class="tab"><button type="button" data-href="#1a9249ba-6a46-4d14-b45f-183ba5c9fcba-2"><i class="fas fa-horse"></i>t3 r.lock，t4 w.lock</button></li><li class="tab"><button type="button" data-href="#1a9249ba-6a46-4d14-b45f-183ba5c9fcba-3"><i class="fas fa-dove"></i>t1 w.unlock</button></li><li class="tab"><button type="button" data-href="#1a9249ba-6a46-4d14-b45f-183ba5c9fcba-4"><i class="fas fa-dragon"></i>t2 r.unlock，t3 r.unlock</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1a9249ba-6a46-4d14-b45f-183ba5c9fcba-1"><p>1） t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁 使用的是 state 的高 16 位</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314191716969.png" alt="image-20220314191716969" style="zoom: 67%;" /><p>2）t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写 锁占据，那么 tryAcquireShared 返回 -1 表示失败</p><blockquote><p>tryAcquireShared 返回值表示</p><ul><li>-1 表示失败</li><li>0 表示成功，但后继节点不会继续唤醒</li><li>正数表示成功，而且数值是还有几个后继节点需要唤醒，读写锁返回 1</li></ul></blockquote><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314191820931.png" alt="image-20220314191820931" style="zoom: 67%;" /><p>3）这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为<code>Node.SHARED</code>模式而非<code>Node.EXCLUSIVE</code>模式，注意此时 t2 仍处于活跃状态</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314191835250.png" alt="image-20220314191835250" style="zoom:67%;" /><p>4）t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁</p><p>5）如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一 次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314191859644.png" alt="image-20220314191859644" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1a9249ba-6a46-4d14-b45f-183ba5c9fcba-2"><p>这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314191927467.png" alt="image-20220314191927467" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1a9249ba-6a46-4d14-b45f-183ba5c9fcba-3"><p>这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314191953466.png" alt="image-20220314191953466" style="zoom:67%;" /><p>接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314192033493.png" alt="image-20220314192033493" style="zoom:67%;" /><p>这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314192048242.png" alt="image-20220314192048242" style="zoom:67%;" /><p>事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用 doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内 parkAndCheckInterrupt() 处恢复运行</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314192104962.png" alt="image-20220314192104962" style="zoom:67%;" /><p>这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314192123102.png" alt="image-20220314192123102" style="zoom:67%;" /><p>这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314192145552.png" alt="image-20220314192145552" style="zoom:67%;" /><p>下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1a9249ba-6a46-4d14-b45f-183ba5c9fcba-4"><p>t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314192222303.png" alt="image-20220314192222303" style="zoom:67%;" /><p>t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入 doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314192239120.png" alt="image-20220314192239120" style="zoom: 67%;" /><p>之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他 竞争，tryAcquire(1) 成功，修改头结点，流程结束</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220314192254698.png" alt="image-20220314192254698" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="5-3-StampedLock">5.3 StampedLock</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用 加解读锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure><p>加解写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure><p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通 过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line">    <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="5f17da48-39fe-4fb3-adb1-6b96a51c0809"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5f17da48-39fe-4fb3-adb1-6b96a51c0809-1"><i class="fas fa-award"></i>数据容器类</button></li><li class="tab"><button type="button" data-href="#5f17da48-39fe-4fb3-adb1-6b96a51c0809-2"><i class="fas fa-baseball-ball"></i>测试读-读</button></li><li class="tab"><button type="button" data-href="#5f17da48-39fe-4fb3-adb1-6b96a51c0809-3"><i class="fas fa-bone"></i>测试读-写</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5f17da48-39fe-4fb3-adb1-6b96a51c0809-1"><p>提供一个<code>数据容器类</code>内部分别使用读锁保护数据的<code>read()</code>方法，写锁保护数据的<code>write()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataContainerStamped</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> &#123;</span><br><span class="line">        <span class="comment">//获取戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        sleep(readTime);</span><br><span class="line">        <span class="comment">//读取数据之后再验戳</span></span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果验戳失败，说明已经数据已经被修改，需要升级锁重新读。</span></span><br><span class="line">        <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">        log.debug(<span class="string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            sleep(readTime);</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5f17da48-39fe-4fb3-adb1-6b96a51c0809-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果，可以看到实际没有加读锁</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">15:58:50.217 c.DataContainerStamped [t1] - optimistic <span class="built_in">read</span> locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - optimistic <span class="built_in">read</span> locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - <span class="built_in">read</span> finish...256, data:1 </span><br><span class="line">15:58:51.220 c.DataContainerStamped [t1] - <span class="built_in">read</span> finish...256, data:1 </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5f17da48-39fe-4fb3-adb1-6b96a51c0809-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.write(<span class="number">100</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">15:57:00.219 c.DataContainerStamped [t1] - optimistic <span class="built_in">read</span> locking...256 </span><br><span class="line">15:57:00.717 c.DataContainerStamped [t2] - write lock 384 </span><br><span class="line">15:57:01.225 c.DataContainerStamped [t1] - updating to <span class="built_in">read</span> lock... 256 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t2] - write unlock 384 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t1] - <span class="built_in">read</span> lock 513 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - <span class="built_in">read</span> finish...513, data:1000 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - <span class="built_in">read</span> unlock 513 </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <blockquote><p><strong>注意</strong></p><ul><li>StampedLock 不支持条件变量</li><li>StampedLock 不支持可重入</li></ul></blockquote><h2 id="6-Semaphore">6. Semaphore</h2><h3 id="6-1-基本使用">6.1 基本使用</h3><p>信号量，用来限制能同时访问共享资源的线程上限。</p><div class="tabs" id="be1198a9-b921-40a1-b900-cc9c2f9126a0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#be1198a9-b921-40a1-b900-cc9c2f9126a0-1"><i class="fas fa-bug"></i>代码</button></li><li class="tab"><button type="button" data-href="#be1198a9-b921-40a1-b900-cc9c2f9126a0-2"><i class="fas fa-cannabis"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="be1198a9-b921-40a1-b900-cc9c2f9126a0-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3. 获取许可</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            <span class="comment">//对于非打断式获取，如果此过程中被打断，线程依旧会等到获取了信号量之后才进入catch块。</span></span><br><span class="line">            <span class="comment">//catch块中的线程依旧持有信号量，捕获该异常后catch块可以不做任何处理。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 4. 释放许可</span></span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="be1198a9-b921-40a1-b900-cc9c2f9126a0-2"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">07:35:15.485 c.TestSemaphore [Thread-2] - running... </span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-1] - running... </span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-0] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-2] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-0] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-1] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-3] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-5] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-4] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-5] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-4] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-3] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-6] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-7] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-9] - running... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-6] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-7] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-9] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-8] - running... </span><br><span class="line">07:35:19.492 c.TestSemaphore [Thread-8] - end... </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>说明：</p><ul><li>Semaphore有两个构造器：<code>Semaphore(int permits)</code>和<code>Semaphore(int permits,boolean fair)</code></li><li>permits表示允许同时访问共享资源的线程数。</li><li>fair表示公平与否，与之前的ReentrantLock一样。</li></ul><h3 id="6-2-Semaphore-应用">6.2 Semaphore 应用</h3><p>semaphore 限制对共享资源的使用</p><ul><li>使用 Semaphore 限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机 线程数量，并且仅是限制线程数，而不是限制资源数（例如连接数，请对比 Tomcat LimitLatch 的实现）</li><li>用 Semaphore 实现简单连接池，对比『享元模式』下的实现（用wait notify），性能和可读性显然更好， 注意下面的实现中线程数和数据库连接数是相等的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Pool&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;</span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="comment">// 让许可数与资源数一致</span></span><br><span class="line">        <span class="built_in">this</span>.semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(poolSize);</span><br><span class="line">        <span class="built_in">this</span>.connections = <span class="keyword">new</span> <span class="title class_">Connection</span>[poolSize];</span><br><span class="line">        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">borrow</span><span class="params">()</span> &#123;<span class="comment">// t1, t2, t3</span></span><br><span class="line">        <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire(); <span class="comment">// 没有许可的线程，在此等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取空闲连接</span></span><br><span class="line">            <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                    <span class="keyword">return</span> connections[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不会执行到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Semaphore-原理">6.3 Semaphore 原理</h3><p><strong>加锁解锁流程</strong></p><div class="tabs" id="391f4b61-142c-44aa-99c6-3134e7ac1fe6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#391f4b61-142c-44aa-99c6-3134e7ac1fe6-1"><i class="fas fa-candy-cane"></i>1</button></li><li class="tab"><button type="button" data-href="#391f4b61-142c-44aa-99c6-3134e7ac1fe6-2"><i class="fas fa-child"></i>2</button></li><li class="tab"><button type="button" data-href="#391f4b61-142c-44aa-99c6-3134e7ac1fe6-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#391f4b61-142c-44aa-99c6-3134e7ac1fe6-4"><i class="fas fa-tree"></i>4</button></li><li class="tab"><button type="button" data-href="#391f4b61-142c-44aa-99c6-3134e7ac1fe6-5"><i class="fas fa-leaf"></i>源码分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="391f4b61-142c-44aa-99c6-3134e7ac1fe6-1"><p>Semaphore有点像一个停车场，permits就好像停车位数量，当线程获得了permits就像是获得了停车位，然后停车场显示空余车位减一。</p><p>刚开始，permits（state）为 3，这时 5 个线程来获取资源</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220315211610470.png" alt="image-20220315211610470" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="391f4b61-142c-44aa-99c6-3134e7ac1fe6-2"><p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列 park 阻塞</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220315211646132.png" alt="image-20220315211646132" style="zoom:67%;" /><p>加锁流程总结：</p><p>-<code>acquire</code>-&gt;<code>acquireSharedInterruptibly(1)</code>-&gt;<code>tryAcquireShared(1)</code>-&gt;<code>nonfairTryAcquireShared(1)</code>,如果资源用完了，返回负数，<code>tryAcquireShared</code>返回负数，表示失败。否则返回正数，<code>tryAcquireShared</code>返回正数,表示成功。</p><ul><li>如果成功，获取信号量成功。</li><li>如果失败，调用<code>doAcquireSharedInterruptibly</code>,进入for循环：<ul><li>如果当前驱节点为头节点，调用<code>tryAcquireShared</code>尝试获取锁<ul><li>如果结果大于等于0，表明获取锁成功，调用<code>setHeadAndPropagate</code>，将当前节点设为头节点，之后又调用<code>doReleaseShared</code>，唤醒后继节点。</li></ul></li><li>调用<code>shoudParkAfterFailure</code>,第一次调用返回false，并将前驱节点改为-1，第二次循环如果再进入此方法，会进入阻塞并检查打断的方法。</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="391f4b61-142c-44aa-99c6-3134e7ac1fe6-3"><p>这时 Thread-4 释放了 permits，状态如下</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220315211712384.png" alt="image-20220315211712384" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="391f4b61-142c-44aa-99c6-3134e7ac1fe6-4"><p>接下来 Thread-0 竞争成功，permits 再次设置为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接 下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状态</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220315211741166.png" alt="image-20220315211741166" style="zoom:67%;" /><p>解锁流程总结：</p><p>-<code>release</code>-&gt;<code>sync.releaseShared(1)</code>-&gt;<code>tryReleaseShared(1)</code>,只要不发生整数溢出，就返回true</p><ul><li>如果返回true，调用<code>doReleaseShared</code>，唤醒后继节点。</li><li>如果返回false，解锁失败。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="391f4b61-142c-44aa-99c6-3134e7ac1fe6-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line">    NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">        <span class="comment">// permits 即 state</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Semaphore 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获得共享锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires; </span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                <span class="comment">// 如果许可已经用完, 返回负数, 表示获取失败, 进入 doAcquireSharedInterruptibly</span></span><br><span class="line">                remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                <span class="comment">// 如果 cas 重试成功, 返回正数, 表示获取成功</span></span><br><span class="line">                compareAndSetState(available, remaining)</span><br><span class="line">            ) &#123;</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再次尝试获取许可</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 成功后本线程出队（AQS）, 所在 Node设置为 head</span></span><br><span class="line">                        <span class="comment">// 如果 head.waitStatus == Node.SIGNAL ==&gt; 0 成功, 下一个节点 unpark</span></span><br><span class="line">                        <span class="comment">// 如果 head.waitStatus == 0 ==&gt; Node.PROPAGATE </span></span><br><span class="line">                        <span class="comment">// r 表示可用资源数, 为 0 则不会继续传播</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不成功, 设置上一个节点 waitStatus = Node.SIGNAL, 下轮进入 park 阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Semaphore 方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 设置自己为 head</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// propagate 表示有共享资源（例如共享读锁或信号量）</span></span><br><span class="line">    <span class="comment">// 原 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">    <span class="comment">// 现在 head waitStatus == Node.SIGNAL 或 Node.PROPAGATE</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 如果是最后一个节点或者是等待共享读锁的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared()) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="7-CountdownLatch">7. CountdownLatch</h2><p>倒计时锁</p><p>用来进行线程同步协作，等待所有线程完成倒计时。</p><p>CountDownLatch的作用很简单，就是一个或者一组线程在开始执行操作之前，必须要等到其他线程执行完才可以。我们举一个例子来说明，在考试的时候，老师必须要等到所有人交了试卷才可以走。此时老师就相当于等待线程，而学生就好比是执行的线程。</p><p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p><div class="tabs" id="7693d943-0807-4763-9f97-316e9fc10617"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7693d943-0807-4763-9f97-316e9fc10617-1"><i class="fas fa-cat"></i>示例</button></li><li class="tab"><button type="button" data-href="#7693d943-0807-4763-9f97-316e9fc10617-2"><i class="fas fa-horse"></i>输出</button></li><li class="tab"><button type="button" data-href="#7693d943-0807-4763-9f97-316e9fc10617-3"><i class="fas fa-dove"></i>比较</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7693d943-0807-4763-9f97-316e9fc10617-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line">    log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    latch.await();</span><br><span class="line">    log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7693d943-0807-4763-9f97-316e9fc10617-2"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">18:44:00.778 c.TestCountDownLatch [main] - waiting... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-2] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-0] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-1] - begin... </span><br><span class="line">18:44:01.782 c.TestCountDownLatch [Thread-0] - end...2 </span><br><span class="line">18:44:02.283 c.TestCountDownLatch [Thread-2] - end...1 </span><br><span class="line">18:44:02.782 c.TestCountDownLatch [Thread-1] - end...0 </span><br><span class="line">18:44:02.782 c.TestCountDownLatch [main] - <span class="built_in">wait</span> end... </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7693d943-0807-4763-9f97-316e9fc10617-3"><p>Join属于比较底层的API，大多数情况下我们不会自己创建线程，而是由线程池创建。</p><p>相比于join，CountDownLatch能配合线程池使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="7-1-同步等待多线程准备完毕">7.1 同步等待多线程准备完毕</h3><p>在打王者的时候，在开局前所有人都必须要加载到100%才可以进入。否则所有玩家都相互等待。</p><div class="tabs" id="ebba993d-4410-4763-840b-9e15257709d2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ebba993d-4410-4763-840b-9e15257709d2-1"><i class="fas fa-atom"></i>代码</button></li><li class="tab"><button type="button" data-href="#ebba993d-4410-4763-840b-9e15257709d2-2"><i class="far fa-sun"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ebba993d-4410-4763-840b-9e15257709d2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>, (r) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;t&quot;</span> + num.getAndIncrement());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">String[] all = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> j;</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//随机休眠，模拟网络延迟</span></span><br><span class="line">                Thread.sleep(r.nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            all[x] = Thread.currentThread().getName() + <span class="string">&quot;(&quot;</span> + (i + <span class="string">&quot;%&quot;</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="comment">//\r可以让当前输出覆盖上一次的输出。</span></span><br><span class="line">            System.out.print(<span class="string">&quot;\r&quot;</span> + Arrays.toString(all));</span><br><span class="line">        &#125;</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">&quot;\n游戏开始...&quot;</span>);</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ebba993d-4410-4763-840b-9e15257709d2-2"><p>中间输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[t0(52%), t1(47%), t2(51%), t3(40%), t4(49%), t5(44%), t6(49%), t7(52%), t8(46%), t9(46%)] </span><br></pre></td></tr></table></figure><p>最后输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[t0(100%), t1(100%), t2(100%), t3(100%), t4(100%), t5(100%), t6(100%), t7(100%), t8(100%), </span><br><span class="line">t9(100%)] </span><br><span class="line">游戏开始... </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="7-2-同步等待多个远程调用结束">7.2 同步等待多个远程调用结束</h3><div class="tabs" id="6296e3e4-7d8c-4fca-b83c-11b30da560ec"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6296e3e4-7d8c-4fca-b83c-11b30da560ec-1"><i class="fas fa-wind"></i>代码</button></li><li class="tab"><button type="button" data-href="#6296e3e4-7d8c-4fca-b83c-11b30da560ec-2"><i class="fas fa-fire-alt"></i>rest远程调用</button></li><li class="tab"><button type="button" data-href="#6296e3e4-7d8c-4fca-b83c-11b30da560ec-3"><i class="fas fa-seedling"></i>执行结果</button></li><li class="tab"><button type="button" data-href="#6296e3e4-7d8c-4fca-b83c-11b30da560ec-4"><i class="fas fa-leaf"></i>future改进</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6296e3e4-7d8c-4fca-b83c-11b30da560ec-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCountDownlatchController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/order/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">order</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        map.put(<span class="string">&quot;total&quot;</span>, <span class="string">&quot;2300.00&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/product/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">product</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小爱音箱&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;price&quot;</span>, <span class="number">300</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小米手机&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;price&quot;</span>, <span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/logistics/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">logistics</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, id);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;中通快递&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2500</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> millis)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(millis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6296e3e4-7d8c-4fca-b83c-11b30da560ec-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">4</span>);</span><br><span class="line">Future&lt;Map&lt;String,Object&gt;&gt; f1 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/order/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f2 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f3 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f4 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; r =</span><br><span class="line">        restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/logistics/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(f1.get());</span><br><span class="line">System.out.println(f2.get());</span><br><span class="line">System.out.println(f3.get());</span><br><span class="line">System.out.println(f4.get());</span><br><span class="line">log.debug(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6296e3e4-7d8c-4fca-b83c-11b30da560ec-3"><p>执行结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19:51:39.711 c.TestCountDownLatch [main] - begin </span><br><span class="line">&#123;total=2300.00, <span class="built_in">id</span>=1&#125; </span><br><span class="line">&#123;price=300, name=小爱音箱, <span class="built_in">id</span>=1&#125; </span><br><span class="line">&#123;price=2000, name=小米手机, <span class="built_in">id</span>=2&#125; </span><br><span class="line">&#123;name=中通快递, <span class="built_in">id</span>=1&#125; </span><br><span class="line">19:51:42.407 c.TestCountDownLatch [main] - 执行完毕</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6296e3e4-7d8c-4fca-b83c-11b30da560ec-4"><p>这种等待多个带有返回值的任务的场景，还是用future比较合适，CountdownLatch适合任务没有返回值的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">log.debug(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">4</span>);</span><br><span class="line">Future&lt;Map&lt;String,Object&gt;&gt; f1 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; response = restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/order/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f2 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; response1 = restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> response1;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f3 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; response1 = restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> response1;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Map&lt;String, Object&gt;&gt; f4 = service.submit(() -&gt; &#123;</span><br><span class="line">    Map&lt;String, Object&gt; response3 = restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/logistics/&#123;1&#125;&quot;</span>, Map.class, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> response3;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(f1.get());</span><br><span class="line">System.out.println(f2.get());</span><br><span class="line">System.out.println(f3.get());</span><br><span class="line">System.out.println(f4.get());</span><br><span class="line">log.debug(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h2 id="8-CyclicBarrier">8. CyclicBarrier</h2><div class="tabs" id="c8262116-9df2-473d-ab68-c09ee454370a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c8262116-9df2-473d-ab68-c09ee454370a-1"><i class="fas fa-award"></i>CountdownLatch缺点</button></li><li class="tab"><button type="button" data-href="#c8262116-9df2-473d-ab68-c09ee454370a-2"><i class="fas fa-baseball-ball"></i>CyclicBarrier改进</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c8262116-9df2-473d-ab68-c09ee454370a-1"><p>CountdownLatch的缺点在于不能重用，想要重复使用CountdownLatch进行同步，必须创建多个CountDownLatch对象，见下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task1 start...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task2 start...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;task1 task2 finish...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c8262116-9df2-473d-ab68-c09ee454370a-2"><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执 行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, ()-&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;task1, task2 finish...&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// task1  task2  task1</span></span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1 begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await(); <span class="comment">// 2-1=1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task2 begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await(); <span class="comment">// 1-1=0</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></table></figure><blockquote><p>注意：线程个数应该与倒计时个数相同，如果线程池线程个数为3，可能task1  task2  task1都执行，可能为两个task1 完成了倒计时</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <blockquote><p><strong>注意</strong></p><ul><li>CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的 CyclicBarrier 可以被比 喻为『人满发车』</li><li>CountDownLatch的计数和阻塞方法是分开的两个方法，而CyclicBarrier是一个方法。</li><li>CyclicBarrier的构造器还有一个Runnable类型的参数，在计数为0时会执行其中的run方法。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.共享模型之不可变</title>
      <link href="/posts/b4f56904.html"/>
      <url>/posts/b4f56904.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-日期转换的问题">1. 日期转换的问题</h2><p>DateFormat类中，有个protected的属性calendar，用于<code>存储设置的时间</code>。DateFormat中提供了很多共有方法去更改此属性，如将DateFormat设置为一个全局变量。时间转换都使用此变量进行转换，每次转换时间，都将更改此全局对象中的calendar信息。</p><p>多线程情况下会导致线程不安全的问题，即一个线程更改此属性后，在计算格式化或者换行成日期的过程中，其他线程对此属性进行了更改，导致计算报错，或者计算不正确。</p><div class="tabs" id="c6805b8b-82e2-4033-abb0-34e10e54f5d9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c6805b8b-82e2-4033-abb0-34e10e54f5d9-1"><i class="fas fa-atom"></i>代码</button></li><li class="tab"><button type="button" data-href="#c6805b8b-82e2-4033-abb0-34e10e54f5d9-2"><i class="far fa-sun"></i>异常结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c6805b8b-82e2-4033-abb0-34e10e54f5d9-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c6805b8b-82e2-4033-abb0-34e10e54f5d9-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">36.357</span> cn.itcast.n6.Test [Thread-<span class="number">8</span>] - &#123;&#125;</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">&quot;&quot;</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2082</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at cn.itcast.n6.Test.lambda$main$<span class="number">0</span>(Test.java:<span class="number">17</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">36.357</span> cn.itcast.n6.Test [Thread-<span class="number">3</span>] - &#123;&#125;</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">&quot;&quot;</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">601</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2082</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">1869</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at cn.itcast.n6.Test.lambda$main$<span class="number">0</span>(Test.java:<span class="number">17</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">33</span>:<span class="number">36.357</span> cn.itcast.n6.Test [Thread-<span class="number">2</span>] - &#123;&#125;</span><br><span class="line">java.lang.NumberFormatException: For input string: <span class="string">&quot;21.&quot;</span></span><br><span class="line">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:<span class="number">65</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">589</span>)</span><br><span class="line">at java.lang.Long.parseLong(Long.java:<span class="number">631</span>)</span><br><span class="line">at java.text.DigitList.getLong(DigitList.java:<span class="number">195</span>)</span><br><span class="line">at java.text.DecimalFormat.parse(DecimalFormat.java:<span class="number">2082</span>)</span><br><span class="line">at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:<span class="number">2162</span>)</span><br><span class="line">at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:<span class="number">1514</span>)</span><br><span class="line">at java.text.DateFormat.parse(DateFormat.java:<span class="number">364</span>)</span><br><span class="line">at cn.itcast.n6.Test.lambda$main$<span class="number">0</span>(Test.java:<span class="number">17</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>解决方法：</p><div class="tabs" id="2a6e9693-9369-476f-ae6c-ca9b47a16238"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2a6e9693-9369-476f-ae6c-ca9b47a16238-1"><i class="fas fa-dove"></i>思路 - 同步锁</button></li><li class="tab"><button type="button" data-href="#2a6e9693-9369-476f-ae6c-ca9b47a16238-2"><i class="fas fa-dragon"></i>思路 - 不可变</button></li><li class="tab"><button type="button" data-href="#2a6e9693-9369-476f-ae6c-ca9b47a16238-3"><i class="fas fa-cat"></i>Threadlocal</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2a6e9693-9369-476f-ae6c-ca9b47a16238-1"><p>这样虽能解决问题，但带来的是性能上的损失，并不算很好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2a6e9693-9369-476f-ae6c-ca9b47a16238-2"><p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> dtf.parse(<span class="string">&quot;2018-10-01&quot;</span>, LocalDate::from);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, date);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看 DateTimeFormatter 的文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@implSpec</span></span><br><span class="line"><span class="comment">//This class is immutable and thread-safe.</span></span><br></pre></td></tr></table></figure><p>不可变对象，实际是另一种避免竞争的方式。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2a6e9693-9369-476f-ae6c-ca9b47a16238-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-不可变设计">2. 不可变设计</h2><h3 id="2-1-String类的设计">2.1 String类的设计</h3><p>另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>将类声明为final，避免被带外星方法的子类继承，从而破坏了不可变性。</li><li>将字符数组声明为final，避免被修改</li><li>hash虽然不是final的，但是其只有在调用<code>hash()</code>方法的时候才被赋值，除此之外再无别的方法修改。</li></ul><h3 id="2-2-final-的使用">2.2 final 的使用</h3><p>发现该类、类中所有属性都是 final 的</p><ul><li>属性用 final 修饰保证了该属性是只读的，不能修改</li><li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li></ul><h3 id="2-3-保护性拷贝">2.3 保护性拷贝</h3><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做出 了修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）</p><h3 id="2-4-模式之享元">2.4 模式之享元</h3><h4 id="2-4-1-简介">2.4.1 简介</h4><p><strong>定义</strong>  享元模式（Flyweight Pattern）是一种结构型设计模式，其目的是通过共享尽可能多的对象状态来最小化内存使用和提高性能。</p><blockquote><p>wikipedia： A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects</p></blockquote><p><strong>出自</strong>  “Gang of Four” design patterns</p><p><strong>归类</strong> Structual patterns</p><h4 id="2-4-2-体现">2.4.2 体现</h4><p><strong>包装类</strong></p><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LongCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LongCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> <span class="title class_">Long</span>[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Long</span>(i - <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：</p><ul><li>Byte, Short, Long 缓存的范围都是 -128~127</li><li>Character 缓存的范围是 0~127</li><li>Integer的默认范围是 -128~127<ul><li>最小值不能变</li><li>但最大值可以通过调整虚拟机参数<code> -Djava.lang.Integer.IntegerCache.high</code>来改变</li></ul></li><li>Boolean 缓存了 TRUE 和 FALSE</li></ul></blockquote><p><strong>String 串池</strong>（不可变、线程安全）</p><p>详见jvm</p><p><strong>BigDecimal BigInteger</strong>(不可变、线程安全)</p><p>一部分数字使用了享元模式进行了缓存。</p><blockquote><p>注意：</p><p>之前篇章中取钱用到BigDecimal，线程安全的，为什么要用原子引用保护起来呢?因为操作过程中，涉及到获取值，设置值，它们的组合并不是原子的。单个方法运行起来是线程安全的，多个方法的组合不能保证线程安全。</p></blockquote><h4 id="2-4-3-手写连接池">2.4.3 手写连接池</h4><p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时 预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。<div class="tabs" id="00f37546-0a35-4056-a4df-02b7fef00f02"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#00f37546-0a35-4056-a4df-02b7fef00f02-1"><i class="fas fa-atom"></i>实现连接池</button></li><li class="tab"><button type="button" data-href="#00f37546-0a35-4056-a4df-02b7fef00f02-2"><i class="far fa-sun"></i>使用连接池</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="00f37546-0a35-4056-a4df-02b7fef00f02-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;</span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="built_in">this</span>.connections = <span class="keyword">new</span> <span class="title class_">Connection</span>[poolSize];</span><br><span class="line">        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">borrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取空闲连接</span></span><br><span class="line">                <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有空闲连接，当前线程进入等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockConnection</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="comment">// 实现略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="00f37546-0a35-4056-a4df-02b7fef00f02-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pool</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> pool.borrow();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        pool.free(conn);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p>以上实现没有考虑：</p><ul><li>连接的动态增长与收缩</li><li>连接保活（可用性检测）</li><li>等待超时处理</li><li>分布式 hash</li></ul><p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p><h3 id="2-5-原理之-final">2.5 原理之 final</h3><h4 id="2-5-1-设置-final-变量原理">2.5.1 设置 final 变量原理</h4><p>理解了 volatile 原理，再对比 final 的实现就比较简单了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0</span><br><span class="line">1: invokespecial <span class="comment">#1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">4: aload_0</span><br><span class="line">5: bipush 20</span><br><span class="line">7: putfield <span class="comment">#2 // Field a:I</span></span><br><span class="line"> &lt;-- 写屏障</span><br><span class="line">10: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><p>发现 final 变量的赋值也会通过 putfield 指令来完成，同样在这条指令之后也会加入写屏障，这样对final变量的写入不会重排序到构造方法之外，保证在其它线程读到 它的值时不会出现为 0 的情况。普通变量不能保证这一点了。</p><h4 id="2-5-2-读取final变量原理">2.5.2 读取final变量原理</h4><div class="tabs" id="dcacee9f-bafa-4ef0-b8fa-7032a2810c37"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dcacee9f-bafa-4ef0-b8fa-7032a2810c37-1"><i class="fas fa-seedling"></i>代码</button></li><li class="tab"><button type="button" data-href="#dcacee9f-bafa-4ef0-b8fa-7032a2810c37-2"><i class="fas fa-leaf"></i>test方法字节码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dcacee9f-bafa-4ef0-b8fa-7032a2810c37-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFinal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UseFinal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">A1</span> <span class="operator">=</span> TestFinal.A;</span><br><span class="line">        <span class="type">int</span> <span class="variable">B1</span> <span class="operator">=</span> TestFinal.B;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> TestFinal.a;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> TestFinal.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dcacee9f-bafa-4ef0-b8fa-7032a2810c37-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> ldc #<span class="number">4</span> &lt;<span class="number">32768</span>&gt;</span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> getstatic #<span class="number">5</span> &lt;cn/itcast/n6/TestFinal.a&gt;</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> getstatic #<span class="number">6</span> &lt;cn/itcast/n6/TestFinal.b&gt;</span><br><span class="line"><span class="number">13</span> istore <span class="number">4</span></span><br><span class="line"><span class="number">15</span> getstatic #<span class="number">7</span> &lt;cn/itcast/n6/TestFinal.c&gt;</span><br><span class="line"><span class="number">18</span> istore <span class="number">5</span></span><br><span class="line"><span class="number">20</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>可以看见，jvm对final变量的访问做出了优化：另一个类中的方法调用final变量是，不是从final变量所在类中获取（共享内存），而是直接复制一份到方法栈栈帧中的操作数栈中（工作内存），这样可以提升效率，是一种优化。</p><p>总结：</p><ul><li>对于较小的static final变量：复制一份到操作数栈中</li><li>对于较大的static final变量：复制一份到当前类的常量池中</li><li>对于非静态final变量，优化同上。</li></ul><h4 id="2-5-3-final总结">2.5.3 final总结</h4><p><strong>final关键字的好处：</strong></p><p>（1）final关键字提高了性能。JVM和Java应用都会缓存final变量。</p><p>（2）final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</p><p>（3）使用final关键字，JVM会对方法、变量及类进行优化。</p><p><strong>关于final的重要知识点</strong></p><p>1、final关键字可以用于成员变量、本地变量、方法以及类。</p><p>2、final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</p><p>3、你不能够对final变量再次赋值。</p><p>4、本地变量必须在声明时赋值。</p><p>5、在匿名类中所有变量都必须是final变量。</p><p>6、final方法不能被重写。</p><p>7、final类不能被继承。</p><p>8、final关键字不同于finally关键字，后者用于异常处理。</p><p>9、final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。</p><p>10、接口中声明的所有变量本身是final的。</p><p>11、final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</p><p>12、final方法在编译阶段绑定，称为静态绑定(static binding)。</p><p>13、没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。</p><p>14、将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</p><p>15、按照Java代码惯例，final变量就是常量，而且通常常量名要大写。</p><p>16、对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容。</p><blockquote><p>参考链接：<a href="https://www.php.cn/java-article-413390.html">Java中final实现原理的深入分析（附示例）-java教程-PHP中文网</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.共享模型之无锁</title>
      <link href="/posts/943faa28.html"/>
      <url>/posts/943faa28.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题提出-应用之互斥">1. 问题提出 (应用之互斥)</h2><p>有如下需求，保证 account.withdraw 取款方法的线程安全</p><div class="tabs" id="82baad96-94cd-48cb-a4ff-33f009288334"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#82baad96-94cd-48cb-a4ff-33f009288334-1"><i class="fas fa-seedling"></i>Account接口</button></li><li class="tab"><button type="button" data-href="#82baad96-94cd-48cb-a4ff-33f009288334-2"><i class="fas fa-leaf"></i>不安全的实现类</button></li><li class="tab"><button type="button" data-href="#82baad96-94cd-48cb-a4ff-33f009288334-3"><i class="fab fa-apple"></i>测试&结果</button></li><li class="tab"><button type="button" data-href="#82baad96-94cd-48cb-a4ff-33f009288334-4"><i class="fas fa-tree"></i>为什么不安全</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="82baad96-94cd-48cb-a4ff-33f009288334-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    Integer <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end-start)/<span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="82baad96-94cd-48cb-a4ff-33f009288334-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="82baad96-94cd-48cb-a4ff-33f009288334-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Account.demo(<span class="keyword">new</span> <span class="title class_">AccountUnsafe</span>(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某次的执行结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">330 cost: 306 ms</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="82baad96-94cd-48cb-a4ff-33f009288334-4"><p><code>withdraw</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ALOAD <span class="number">0</span> <span class="comment">// &lt;- this</span></span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line">GETFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; <span class="comment">// &lt;- this.balance</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I <span class="comment">// 拆箱</span></span><br><span class="line">ALOAD <span class="number">1</span> <span class="comment">// &lt;- amount</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I <span class="comment">// 拆箱</span></span><br><span class="line">ISUB <span class="comment">// 减法</span></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; <span class="comment">// 结果装箱</span></span><br><span class="line">PUTFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer; <span class="comment">// -&gt; this.balance</span></span><br></pre></td></tr></table></figure><p>多线程执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ALOAD <span class="number">0</span> <span class="comment">// thread-0 &lt;- this </span></span><br><span class="line">ALOAD <span class="number">0</span> </span><br><span class="line">GETFIELD cn/itcast/AccountUnsafe.balance <span class="comment">// thread-0 &lt;- this.balance </span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue <span class="comment">// thread-0 拆箱</span></span><br><span class="line">ALOAD <span class="number">1</span> <span class="comment">// thread-0 &lt;- amount </span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue <span class="comment">// thread-0 拆箱</span></span><br><span class="line">ISUB <span class="comment">// thread-0 减法</span></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf <span class="comment">// thread-0 结果装箱</span></span><br><span class="line">PUTFIELD cn/itcast/AccountUnsafe.balance <span class="comment">// thread-0 -&gt; this.balance </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ALOAD <span class="number">0</span> <span class="comment">// thread-1 &lt;- this </span></span><br><span class="line">ALOAD <span class="number">0</span> </span><br><span class="line">GETFIELD cn/itcast/AccountUnsafe.balance <span class="comment">// thread-1 &lt;- this.balance </span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue <span class="comment">// thread-1 拆箱</span></span><br><span class="line">ALOAD <span class="number">1</span> <span class="comment">// thread-1 &lt;- amount </span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue <span class="comment">// thread-1 拆箱</span></span><br><span class="line">ISUB <span class="comment">// thread-1 减法</span></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf <span class="comment">// thread-1 结果装箱</span></span><br><span class="line">PUTFIELD cn/itcast/AccountUnsafe.balance <span class="comment">// thread-1 -&gt; this.balance</span></span><br></pre></td></tr></table></figure><p>原因：Integer虽然是不可变类，其方法是线程安全的，但是以上操作涉及到了多个方法的组合，等价于以下代码：</p><p>balance = new Integer(Integer.valueOf(balance) - amount);</p><p>前一个方法(valueOf)的结果决定后一个方法(构造方法)，这种组合在多线程环境下线程不安全。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-1-解决思路">1.1 解决思路</h3><div class="tabs" id="7d446aa0-c56c-45d1-852b-e1eaa10d29c6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7d446aa0-c56c-45d1-852b-e1eaa10d29c6-1"><i class="fas fa-cat"></i>锁-悲观互斥</button></li><li class="tab"><button type="button" data-href="#7d446aa0-c56c-45d1-852b-e1eaa10d29c6-2"><i class="fas fa-horse"></i>无锁-乐观重试</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7d446aa0-c56c-45d1-852b-e1eaa10d29c6-1"><p>首先想到的是给 Account 对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountUnsafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> cost: <span class="number">399</span> ms </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7d446aa0-c56c-45d1-852b-e1eaa10d29c6-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountSafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountSafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以简化为下面的方法</span></span><br><span class="line">        <span class="comment">// balance.addAndGet(-1 * amount);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Account.demo(<span class="keyword">new</span> <span class="title class_">AccountSafe</span>(<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某次的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> cost: <span class="number">302</span> ms</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-CAS-与-volatile">2. CAS 与 volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 比如拿到了旧值 1000</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="comment">// 在这个基础上 1000-10 = 990</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span></span><br><span class="line"><span class="comment">             - 不一致了，next 作废，返回 false 表示失败</span></span><br><span class="line"><span class="comment">             比如，别的线程已经做了减法，当前值已经被减成了 990</span></span><br><span class="line"><span class="comment">             那么本线程的这次 990 就作废了，进入 while 下次循环重试</span></span><br><span class="line"><span class="comment">             - 一致，以 next 设置为新值，返回 true 表示成功</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//或者简洁一点：</span></span><br><span class="line">            <span class="comment">//balance.getAndAdd(-1 * amount);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220308180039801.png" alt="image-20220308180039801" style="zoom:67%;" /><blockquote><p><strong>注意</strong></p><p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交 换】的原子性。</p><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再 开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子 的。</p></blockquote><h3 id="2-1-volatile">2.1 volatile</h3><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><blockquote><p><strong>注意</strong></p><p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</p></blockquote><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果。</p><h3 id="2-2-为什么无锁效率高">2.2 为什么无锁效率高</h3><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，类似于自旋。而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。线程的上下文切换是费时的，在重试次数不是太多时，无锁的效率高于有锁。</li><li>线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火， 等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</li><li>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑 道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还 是会导致上下文切换。所以总的来说，当线程数小于等于cpu核心数时，使用无锁方案是很合适的，因为有足够多的cpu让线程运行。当线程数远多于cpu核心数时，无锁效率相比于有锁就没有太大优势，因为依旧会发生上下文切换。</li></ul><h3 id="2-3-CAS-的特点">2.3 CAS 的特点</h3><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="3-原子整数">3. 原子整数</h2><p>J.U.C 并发包提供了：</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>以 AtomicInteger 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line"><span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">System.out.println(i.decrementAndGet());</span><br><span class="line"><span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"><span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 获取并更新(更新方式可以自定义，函数式接口)（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>以上方法都是以CAS为基础进行了封装，保证了方法的原子性和变量的可见性。</p><p><code>updateAndGet原理</code></p><div class="tabs" id="913c8794-ca5f-4754-9bc9-eff6be9dbded"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#913c8794-ca5f-4754-9bc9-eff6be9dbded-1"><i class="fas fa-atom"></i>自己动手实现</button></li><li class="tab"><button type="button" data-href="#913c8794-ca5f-4754-9bc9-eff6be9dbded-2"><i class="far fa-sun"></i>改进1</button></li><li class="tab"><button type="button" data-href="#913c8794-ca5f-4754-9bc9-eff6be9dbded-3"><i class="fas fa-wind"></i>改进2</button></li><li class="tab"><button type="button" data-href="#913c8794-ca5f-4754-9bc9-eff6be9dbded-4"><i class="fas fa-fire-alt"></i>原生实现</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="913c8794-ca5f-4754-9bc9-eff6be9dbded-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> prev=i.get();</span><br><span class="line">        <span class="type">int</span> next=prev*<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(i.compareAndSet(prev,next))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="913c8794-ca5f-4754-9bc9-eff6be9dbded-2"><p>这样做代码没有任何通用性，具体的计算操作已经写死了，所以我们需要把操作当做变化的内容传进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    updateAndGet(i);</span><br><span class="line">    System.out.println(i.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateAndGet</span><span class="params">(AtomicInteger i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> prev=i.get();</span><br><span class="line">        <span class="type">int</span> next=prev*<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(i.compareAndSet(prev,next))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="913c8794-ca5f-4754-9bc9-eff6be9dbded-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>);</span><br><span class="line">    updateAndGet(i, operand -&gt; operand/<span class="number">2</span>);</span><br><span class="line">    System.out.println(i.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateAndGet</span><span class="params">(AtomicInteger i, IntUnaryOperator operator)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> prev=i.get();</span><br><span class="line">        <span class="type">int</span> next=operator.applyAsInt(prev);</span><br><span class="line">        <span class="keyword">if</span>(i.compareAndSet(prev,next))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="913c8794-ca5f-4754-9bc9-eff6be9dbded-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h2 id="3-原子引用">3. 原子引用</h2><p>为什么需要原子引用类型？</p><ul><li>AtomicReference</li><li>AtomicMarkableReference</li><li>AtomicStampedReference</li></ul><p>实际开发的过程中我们使用的不一定是int、long等基本数据类型，也有可能时BigDecimal这样的类型，这时就需要用到原子引用作为容器。原子引用设置值使用的是<code>unsafe.compareAndSwapObject()</code>方法。原子引用中表示数据的类型需要重写<code>equals()</code>方法。<div class="tabs" id="2bae6376-5a46-4999-bad9-046428061114"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2bae6376-5a46-4999-bad9-046428061114-1"><i class="fas fa-seedling"></i>DecimalAccoun接口</button></li><li class="tab"><button type="button" data-href="#2bae6376-5a46-4999-bad9-046428061114-2"><i class="fas fa-tree"></i>使用锁</button></li><li class="tab"><button type="button" data-href="#2bae6376-5a46-4999-bad9-046428061114-3"><i class="fas fa-leaf"></i>使用 CAS</button></li><li class="tab"><button type="button" data-href="#2bae6376-5a46-4999-bad9-046428061114-4"><i class="fab fa-apple"></i>测试&结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2bae6376-5a46-4999-bad9-046428061114-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    BigDecimal <span class="title function_">getBalance</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment"> * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(DecimalAccount account)</span> &#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bae6376-5a46-4999-bad9-046428061114-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountSafeLock</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    BigDecimal balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountSafeLock</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="built_in">this</span>.getBalance();</span><br><span class="line">            <span class="built_in">this</span>.balance = balance.subtract(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bae6376-5a46-4999-bad9-046428061114-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DecimalAccountSafeCas</span> <span class="keyword">implements</span> <span class="title class_">DecimalAccount</span> &#123;</span><br><span class="line">    AtomicReference&lt;BigDecimal&gt; ref;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecimalAccountSafeCas</span><span class="params">(BigDecimal balance)</span> &#123;</span><br><span class="line">        ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ref.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(BigDecimal amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">next</span> <span class="operator">=</span> prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (ref.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bae6376-5a46-4999-bad9-046428061114-4"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DecimalAccount.demo(new DecimalAccountUnsafe(new BigDecimal(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">DecimalAccount.demo(new DecimalAccountSafeLock(new BigDecimal(<span class="string">&quot;10000&quot;</span>)));</span><br><span class="line">DecimalAccount.demo(new DecimalAccountSafeCas(new BigDecimal(<span class="string">&quot;10000&quot;</span>)));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4310 cost: 425 ms </span><br><span class="line">0 cost: 285 ms </span><br><span class="line">0 cost: 274 ms</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h3 id="3-1-ABA-问题及解决">3.1 ABA 问题及解决</h3><p>ABA问题是指在多线程并发访问中，一个共享变量的值从A变为B，又从B变回A，这时，如果一个线程在检查该变量值是否为A时，可能会被误导认为该变量值一直没有发生改变。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取值 A</span></span><br><span class="line">    <span class="comment">// 这个共享变量被它线程修改过？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.get();</span><br><span class="line">    other();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 尝试改为 C</span></span><br><span class="line">    log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:29:52.325 c.Test36 [main] - main start... </span><br><span class="line">11:29:52.379 c.Test36 [t1] - change A-&gt;B <span class="literal">true</span> </span><br><span class="line">11:29:52.879 c.Test36 [t2] - change B-&gt;A <span class="literal">true</span> </span><br><span class="line">11:29:53.880 c.Test36 [main] - change A-&gt;C <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程 希望：</p><p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号</p><div class="tabs" id="0f439f44-44d6-43b9-b786-95ff64c89826"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0f439f44-44d6-43b9-b786-95ff64c89826-1"><i class="fas fa-cat"></i>AtomicStampedReference</button></li><li class="tab"><button type="button" data-href="#0f439f44-44d6-43b9-b786-95ff64c89826-2"><i class="fas fa-horse"></i>输出</button></li><li class="tab"><button type="button" data-href="#0f439f44-44d6-43b9-b786-95ff64c89826-3"><i class="fas fa-dove"></i>AtomicMarkableReference</button></li><li class="tab"><button type="button" data-href="#0f439f44-44d6-43b9-b786-95ff64c89826-4"><i class="fas fa-dragon"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0f439f44-44d6-43b9-b786-95ff64c89826-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取值 A</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">    <span class="comment">// 获取版本号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> ref.getStamp();</span><br><span class="line">    log.debug(<span class="string">&quot;版本 &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">    <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">    other();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 尝试改为 C</span></span><br><span class="line">    log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">other</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>,</span><br><span class="line">                ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>,</span><br><span class="line">                ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0f439f44-44d6-43b9-b786-95ff64c89826-2"><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如：<code>A -&gt; B -&gt; A -&gt; C</code>，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">15:41:34.891 c.Test36 [main] - main start... </span><br><span class="line">15:41:34.894 c.Test36 [main] - 版本 0 </span><br><span class="line">15:41:34.956 c.Test36 [t1] - change A-&gt;B <span class="literal">true</span> </span><br><span class="line">15:41:34.956 c.Test36 [t1] - 更新版本为 1 </span><br><span class="line">15:41:35.457 c.Test36 [t2] - change B-&gt;A <span class="literal">true</span> </span><br><span class="line">15:41:35.457 c.Test36 [t2] - 更新版本为 2 </span><br><span class="line">15:41:36.457 c.Test36 [main] - change A-&gt;C <span class="literal">false</span> </span><br></pre></td></tr></table></figure><p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 AtomicMarkableReference</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230402145328927.png" alt="image-20230402145328927" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0f439f44-44d6-43b9-b786-95ff64c89826-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">bag</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;装满了垃圾&quot;</span>);</span><br><span class="line">        <span class="comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span></span><br><span class="line">        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(bag, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="type">GarbageBag</span> <span class="variable">prev</span> <span class="operator">=</span> ref.getReference();</span><br><span class="line">        log.debug(prev.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">            bag.setDesc(<span class="string">&quot;空垃圾袋&quot;</span>);</span><br><span class="line">            ref.compareAndSet(bag, bag, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            log.debug(bag.toString());</span><br><span class="line">        &#125;,<span class="string">&quot;保洁阿姨&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;想换一只新垃圾袋？&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> ref.compareAndSet(prev, <span class="keyword">new</span> <span class="title class_">GarbageBag</span>(<span class="string">&quot;空垃圾袋&quot;</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;换了么？&quot;</span> + success);</span><br><span class="line">        log.debug(ref.getReference().toString());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GarbageBag</span> &#123;</span><br><span class="line">    String desc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GarbageBag</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString() + <span class="string">&quot; &quot;</span> + desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0f439f44-44d6-43b9-b786-95ff64c89826-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">43.062</span> c.Test38 [main] - start...</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">43.066</span> c.Test38 [main] - cn.itcast.test.GarbageBag@6aceb1a5 装满了垃圾</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">43.223</span> c.Test38 [保洁阿姨] - start...</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">43.227</span> c.Test38 [保洁阿姨] - cn.itcast.test.GarbageBag@6aceb1a5 空垃圾袋</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">44.237</span> c.Test38 [main] - 想换一只新垃圾袋？</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">44.238</span> c.Test38 [main] - 换了么？<span class="literal">false</span></span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>:<span class="number">44.238</span> c.Test38 [main] - cn.itcast.test.GarbageBag@6aceb1a5 空垃圾袋</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="4-原子数组">4. 原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><div class="tabs" id="32db3c34-225f-48e2-ac57-d9ce08f287b4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#32db3c34-225f-48e2-ac57-d9ce08f287b4-1"><i class="fas fa-atom"></i>封装方法</button></li><li class="tab"><button type="button" data-href="#32db3c34-225f-48e2-ac57-d9ce08f287b4-2"><i class="far fa-sun"></i>不安全的数组</button></li><li class="tab"><button type="button" data-href="#32db3c34-225f-48e2-ac57-d9ce08f287b4-3"><i class="fas fa-wind"></i>安全的数组</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="32db3c34-225f-48e2-ac57-d9ce08f287b4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 参数1，提供数组、可以是线程不安全数组或线程安全数组</span></span><br><span class="line"><span class="comment"> 参数2，获取数组长度的方法</span></span><br><span class="line"><span class="comment"> 参数3，自增方法，回传 array, index</span></span><br><span class="line"><span class="comment"> 参数4，打印数组的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// supplier 提供者 无中生有 ()-&gt;结果</span></span><br><span class="line"><span class="comment">// function 函数 一个参数一个结果 (参数)-&gt;结果 , BiFunction (参数1,参数2)-&gt;结果</span></span><br><span class="line"><span class="comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; arraySupplier, Function&lt;T, Integer&gt; lengthFun,</span></span><br><span class="line"><span class="params">        BiConsumer&lt;T, Integer&gt; putConsumer, Consumer&lt;T&gt; printConsumer )</span> &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">T</span> <span class="variable">array</span> <span class="operator">=</span> arraySupplier.get();</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> lengthFun.apply(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">// 每个线程对数组作 10000 次操作</span></span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                putConsumer.accept(array, j%length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    ts.forEach(t -&gt; t.start()); <span class="comment">// 启动所有线程</span></span><br><span class="line">    ts.forEach(t -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); <span class="comment">// 等所有线程结束</span></span><br><span class="line">    printConsumer.accept(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="32db3c34-225f-48e2-ac57-d9ce08f287b4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">    ()-&gt;<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>],</span><br><span class="line">    (array)-&gt;array.length,</span><br><span class="line">    (array, index) -&gt; array[index]++,</span><br><span class="line">    array-&gt; System.out.println(Arrays.toString(array))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[9870, 9862, 9774, 9697, 9683, 9678, 9679, 9668, 9680, 9698] </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="32db3c34-225f-48e2-ac57-d9ce08f287b4-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo(</span><br><span class="line">    ()-&gt; <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="number">10</span>),</span><br><span class="line">    (array) -&gt; array.length(),</span><br><span class="line">    (array, index) -&gt; array.getAndIncrement(index),</span><br><span class="line">    array -&gt; System.out.println(array)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h2 id="5-字段更新器">5. 字段更新器</h2><ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现 异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> field;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicIntegerFieldUpdater</span> <span class="variable">fieldUpdater</span> <span class="operator">=</span></span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">Test5</span> <span class="variable">test5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test5</span>();</span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 修改成功 field = 10</span></span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">        <span class="comment">// 修改成功 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">        <span class="comment">// 修改失败 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">20</span> </span><br></pre></td></tr></table></figure><h2 id="6-原子累加器">6. 原子累加器</h2><p><strong>原子类型累加器</strong>是<strong>JDK1.8</strong>引进的并发新技术，它可以看做<strong>AtomicLong</strong>和<strong>AtomicDouble</strong>的部分加强类型。</p><p><strong>原子类型累加器</strong>有如下四种：</p><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><p>根据Oracle官方文档的介绍，LongAdder在高并发的场景下会比它的前辈—AtomicLong 具有更好的性能，代价是消耗更多的内存空间</p><p>我们知道，<strong>AtomicLong</strong>是利用了底层的CAS操作来提供并发性的，比如<strong>addAndGet</strong>方法：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/bVbeJG6.png" alt="clipboard.png"></p><p>上述方法调用了<strong>Unsafe</strong>类的<strong>getAndAddLong</strong>方法，该方法是个<strong>native</strong>方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。</p><p>在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时<strong>AtomicLong</strong>的自旋会成为瓶颈。</p><p>这就是<strong>LongAdder</strong>引入的初衷——解决高并发环境下<strong>AtomicLong</strong>的自旋瓶颈问题。</p><h3 id="6-1-累加器性能比较">6.1 累加器性能比较</h3><div class="tabs" id="89dc092d-f028-4c6e-9fed-f34e1e27d053"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#89dc092d-f028-4c6e-9fed-f34e1e27d053-1"><i class="fas fa-seedling"></i>封装方法</button></li><li class="tab"><button type="button" data-href="#89dc092d-f028-4c6e-9fed-f34e1e27d053-2"><i class="fas fa-leaf"></i>比较 AtomicLong 与 LongAdder</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="89dc092d-f028-4c6e-9fed-f34e1e27d053-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">() -&gt; 结果    提供累加器对象</span></span><br><span class="line"><span class="comment">(参数) -&gt;     执行累加操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">adder</span> <span class="operator">=</span> adderSupplier.get();</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        ts.add(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                action.accept(adder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    ts.forEach(t -&gt; t.start());</span><br><span class="line">    ts.forEach(t -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start) / <span class="number">1000_000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="89dc092d-f028-4c6e-9fed-f34e1e27d053-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    demo(() -&gt; <span class="keyword">new</span> <span class="title class_">LongAdder</span>(), adder -&gt; adder.increment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    demo(() -&gt; <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2000000</span> cost:<span class="number">33</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">8</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">13</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">8</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">7</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">86</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">79</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">68</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">72</span></span><br><span class="line"><span class="number">2000000</span> cost:<span class="number">74</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>我们知道，<strong>AtomicLong</strong>中有个内部变量<strong>value</strong>保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。</p><p><strong>LongAdder</strong>的基本思路就是<strong>分散热点</strong>，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。非竞态条件下，直接累加到Base变量上。在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><h3 id="6-2-原理之伪共享-CPU-缓存结构">6.2 原理之伪共享(CPU 缓存结构)</h3><h4 id="6-2-1-CPU-缓存结构">6.2.1 CPU 缓存结构</h4><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317203911517.png" alt="image-20220317203911517" style="zoom: 50%;" /><p>速度比较</p><table><thead><tr><th style="text-align:center">从cpu到</th><th style="text-align:center">大约需要的时钟周期</th></tr></thead><tbody><tr><td style="text-align:center">寄存器</td><td style="text-align:center">1 cycle</td></tr><tr><td style="text-align:center">L1</td><td style="text-align:center">3~4 cycle</td></tr><tr><td style="text-align:center">L2</td><td style="text-align:center">10~20 cycle</td></tr><tr><td style="text-align:center">L3</td><td style="text-align:center">40~45 cycle</td></tr><tr><td style="text-align:center">内存</td><td style="text-align:center">120~240 cycle</td></tr></tbody></table><p>cpu 拿到的内存地址格式是这样的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[高位组标记][低位索引][偏移量]</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317204208269.png" alt="image-20220317204208269"></p><h4 id="6-2-2-CPU-缓存读">6.2.2 CPU 缓存读</h4><p>读取数据流程如下</p><ul><li>根据低位，计算在缓存中的索引</li><li>判断是否有效<ul><li>0 去内存读取新数据更新缓存行</li><li>1 再对比高位组标记是否一致<ul><li>一致，根据偏移量返回缓存数据</li><li>不一致，去内存读取新数据更新缓存行</li></ul></li></ul></li></ul><h4 id="6-2-3-MESI-协议">6.2.3 MESI 协议</h4><p>对于单核CPU来说，不存在数据一致性问题；然而对于多核系统来说，不同CPU上的cache和ram可能具有同一个数据的多个副本。这就会导致数据观察者（CPU/GPU/DMA）能看到的数据不一致。</p><p>MESI这四个字母分别代表Modify、Exclusive、Shared和Invalid。Cache Line的状态必须是这四个中的一种。前三种状态均是数据有效下的状态。Cache Line有两个标志-脏（dirty）和有效（valid)。</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>M</td><td>数据已被修改，和内存的数据不一致，该数据只存在于此Cache Line中</td></tr><tr><td>E</td><td>数据和内存中一致，该数据只存在于此Cache Line中</td></tr><tr><td>S</td><td>数据和内存中一致，多个Cache Line持有这行数据的副本</td></tr><tr><td>I</td><td>这行数据无效</td></tr></tbody></table><ol><li>E、S、M 状态的缓存行都可以满足 CPU 的读请求</li><li>E 状态的缓存行，有写请求，会将状态改为 M，这时并不触发向主存的写</li><li>E 状态的缓存行，必须监听该缓存行的读操作，如果有，要变为 S 状态</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317204411550.png" alt="image-20220317204411550"></p><ol start="4"><li>M 状态的缓存行，必须监听该缓存行的读操作，如果有，先将其它缓存（S 状态）中该缓存行变成 I 状态（即 6. 的流程），写入主存，自己变为 S 状态</li><li>S 状态的缓存行，有写请求，走 4. 的流程</li><li>S 状态的缓存行，必须监听该缓存行的失效操作，如果有，自己变为 I 状态</li><li>I 状态的缓存行，有读请求，必须从主存读取</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317204507325.png" alt="image-20220317204507325"></p><h4 id="6-2-4-内存屏障">6.2.4 内存屏障</h4><p>Memory Barrier（Memory Fence）</p><p>可见性</p><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul><p>有序性</p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317204610541.png" alt="image-20220317204610541"></p><h3 id="6-3-源码之LongAdder">6.3 源码之LongAdder</h3><p>LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧</p><p>LongAdder 类有几个关键域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加单元数组, 懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"><span class="comment">// 基础值, 如果没有竞争, 则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"><span class="comment">// 在 cells 创建或扩容时, 置为 1, 表示加锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure><p>其中 Cell 即为累加单元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最重要的方法, 用来 cas 方式进行累加, prev 表示旧值, next 表示新值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略不重要代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得从缓存说起  因为 CPU 与 内存的速度差异很大，需要靠预读数据至缓存来提升效率。</p><p>而缓存以缓存行为单位，每个缓存行对应着一块内存，一般是 64 byte（8 个 long）</p><p>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中</p><p>CPU 要保证数据的一致性，如果某个 CPU 核心更改了数据，其它 CPU 核心对应的整个缓存行必须失效</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317205206297.png" alt="image-20220317205206297" style="zoom:67%;" /><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1]</li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，比如Core-0 中<code>Cell[0]=6000, Cell[1]=8000</code>要累加<code>Cell[0]=6001, Cell[1]=8000</code>，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317205321951.png" alt="image-20220317205321951" style="zoom:67%;" /><p>累加主要调用下面的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// as 为累加单元数组</span></span><br><span class="line">    <span class="comment">// b 为基础值</span></span><br><span class="line">    <span class="comment">// x 为累加值</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// 进入 if 的两个条件</span></span><br><span class="line">    <span class="comment">// 1. as 有值, 表示已经发生过竞争, 进入 if</span></span><br><span class="line">    <span class="comment">// 2. cas 给 base 累加时失败了, 表示 base 发生了竞争, 进入 if</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// uncontended 表示 cell 没有竞争</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            <span class="comment">// as 还没有创建</span></span><br><span class="line">            as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 当前线程对应的 cell 还没有</span></span><br><span class="line">            <span class="comment">// getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span></span><br><span class="line">            <span class="comment">// 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span></span><br><span class="line">            <span class="comment">// 除非刻意修改它</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// cas 给当前线程的 cell 累加失败 uncontended=false ( a 为当前线程的 cell )</span></span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 进入 cell 数组创建、cell 创建的流程</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结 ：</p><ul><li>如果已经<code>有了累加数组</code>或<code>给base累加发生了竞争导致失败</code><ul><li>如果<code>累加数组没有创建</code>或者<code>累加数组长度为1</code>或者<code>当前线程还没有对应的cell</code>或者<code>累加cell失败</code><ul><li>进入累加数组的创建流程</li></ul></li><li>否者说明累加成功，退出。</li></ul></li><li>否则累加成功</li></ul><p>add 流程图</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317205409166.png" alt="image-20220317205409166"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">longAccumulate</span><span class="params">(<span class="type">long</span> x, LongBinaryOperator fn,</span></span><br><span class="line"><span class="params">                          <span class="type">boolean</span> wasUncontended)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 当前线程还没有对应的 cell, 需要随机生成一个 h 值用来将当前线程绑定到 cell</span></span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 初始化 probe</span></span><br><span class="line">        ThreadLocalRandom.current();</span><br><span class="line">        <span class="comment">// h 对应新的 probe 值, 用来对应 cell</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collide 为 true 表示最后一个槽非空，需要扩容</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">collide</span> <span class="operator">=</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="type">int</span> n; <span class="type">long</span> v;</span><br><span class="line">        <span class="comment">// 已经有了 cells</span></span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还没有 cell</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 为 cellsBusy 加锁, 创建 cell, cell 的初始累加值为 x</span></span><br><span class="line">                <span class="comment">// 成功则 break, 否则继续 continue 循环</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="type">Cell</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cell</span>(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">created</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="type">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="literal">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有竞争, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</span><br><span class="line">                wasUncontended = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// cas 尝试累加, fn 配合 LongAccumulator 不为 null, 配合 LongAdder 为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果 cells 长度已经超过了最大长度, 或者已经扩容, 改变线程对应的 cell 来重试 cas</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                collide = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="comment">// 加锁成功, 扩容</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 改变线程对应的 cell</span></span><br><span class="line">            h = advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还没有 cells, 尝试给 cellsBusy 加锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="comment">// 加锁成功, 初始化 cells, 最开始长度为 2, 并填充一个 cell</span></span><br><span class="line">            <span class="comment">// 成功则 break;</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">init</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> <span class="title class_">Cell</span>[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cell</span>(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上两种情况失败, 尝试给 base 累加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="literal">null</span>) ? v + x : fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>先判断当前线程有没有对应的Cell</p><ul><li>如果没有，随机生成一个值，这个值与当前线程绑定，通过这个值的取模运算定位当前线程Cell的位置。</li></ul></li><li><p>进入for循环</p><ul><li><p>if 有Cells累加数组且长度大于0</p><ul><li><p>if 如果当前线程没有cell</p><ul><li>准备扩容，如果前累加数组不繁忙（正在扩容之类）<ul><li>将新建的cell放入对应的槽位中，新建Cell成功，进入下一次循环，尝试cas累加。</li></ul></li><li>将collide置为false，表示无需扩容。</li></ul></li><li><p>else if 有竞争</p><ul><li>将wasUncontended置为tue，进入分支底部，改变线程对应的cell来cas重试</li></ul></li><li><p>else if cas重试累加成功</p><ul><li>退出循环。</li></ul></li><li><p>else if  cells 长度已经超过了最大长度, 或者已经扩容,</p><ul><li>collide置为false，进入分支底部，改变线程对应的 cell 来重试 cas</li></ul></li><li><p>else if collide为false</p><ul><li>将collide置为true（确保 collide 为 false 进入此分支, 就不会进入下面的 else if 进行扩容了）</li></ul></li><li><p>else if 累加数组不繁忙且加锁成功</p><ul><li>退出本次循环，进入下一次循环（扩容）</li></ul></li><li><p>改变线程对应的 cell 来重试 cas</p></li></ul></li><li><p>else if 数组不繁忙且数组为null且加锁成功</p><ul><li>新建数组，在槽位处新建cell，释放锁，退出循环。</li></ul></li><li><p>else if 尝试给base累加成功</p><ul><li>退出循环</li></ul></li></ul></li></ul><p>longAccumulate 流程图</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317205457078.png" alt="image-20220317205457078"></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317205515695.png" alt="image-20220317205515695"></p><p>每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位）</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317205530752.png" alt="image-20220317205530752"></p><p>获取最终结果通过 sum 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Unsafe">7. Unsafe</h2><h3 id="7-1-概述">7.1 概述</h3><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe类是&quot;final&quot;的，不允许继承，且构造函数是private的，只能通过反射获得。</p><p>Unsafe的功能如下图：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/webp" alt="img"></p><p>Unsafe类的获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeAccessor</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Unsafe-CAS-操作">7.2 Unsafe CAS 操作</h3><div class="tabs" id="bb235cdf-d14b-4b3f-a34a-6eeafc5bac34"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#bb235cdf-d14b-4b3f-a34a-6eeafc5bac34-1"><i class="fas fa-cat"></i>unsafe实现字段更新</button></li><li class="tab"><button type="button" data-href="#bb235cdf-d14b-4b3f-a34a-6eeafc5bac34-2"><i class="fas fa-horse"></i>unsafe实现原子整数类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="bb235cdf-d14b-4b3f-a34a-6eeafc5bac34-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> UnsafeAccessor.getUnsafe();</span><br><span class="line"><span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 获得成员变量的偏移量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(id);</span><br><span class="line"><span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(name);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">// 使用 cas 方法替换成员变量的值</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, <span class="number">0</span>, <span class="number">20</span>); <span class="comment">// 返回 true</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, <span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 返回 true</span></span><br><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(<span class="built_in">id</span>=20, name=张三) </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bb235cdf-d14b-4b3f-a34a-6eeafc5bac34-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> DATA_OFFSET;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        unsafe = UnsafeAccessor.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span></span><br><span class="line">            DATA_OFFSET = unsafe.objectFieldOffset(AtomicData.class.getDeclaredField(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtomicData</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> oldValue;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span></span><br><span class="line">            oldValue = data;</span><br><span class="line">            <span class="comment">// cas 尝试修改 data 为 旧值 + amount，如果期间旧值被别的线程改了，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="built_in">this</span>, DATA_OFFSET, oldValue, oldValue - amount)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.共享模型之内存</title>
      <link href="/posts/20410f72.html"/>
      <url>/posts/20410f72.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java-内存模型">1. Java 内存模型</h2><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><p>JMM的意义</p><ul><li>计算机硬件底层的内存结构过于复杂，JMM的意义在于避免程序员直接管理计算机底层内存，用一些关键字synchronized、volatile等可以方便的管理内存。</li></ul><p>JMM 体现在以下几个方面</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="2-可见性">2. 可见性</h2><h3 id="2-1-退不出的循环">2.1 退不出的循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么呢？分析一下：</p><div class="tabs" id="79f5f556-04c6-4010-a9d2-774abb2d9f58"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#79f5f556-04c6-4010-a9d2-774abb2d9f58-1"><i class="fas fa-atom"></i>1</button></li><li class="tab"><button type="button" data-href="#79f5f556-04c6-4010-a9d2-774abb2d9f58-2"><i class="far fa-sun"></i>2</button></li><li class="tab"><button type="button" data-href="#79f5f556-04c6-4010-a9d2-774abb2d9f58-3"><i class="fas fa-wind"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="79f5f556-04c6-4010-a9d2-774abb2d9f58-1"><ol><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li></ol><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220305192346249.png" alt="image-20220305192346249" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="79f5f556-04c6-4010-a9d2-774abb2d9f58-2"><ol start="2"><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ol><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220305192416102.png" alt="image-20220305192416102" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="79f5f556-04c6-4010-a9d2-774abb2d9f58-3"><ol start="3"><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值</li></ol><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220305192512523.png" alt="image-20220305192512523" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <blockquote><p>解决方法</p><p>volatile（易变关键字）</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p></blockquote><h3 id="2-2-可见性-vs-原子性">2.2 可见性 vs 原子性</h3><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性，<code>仅用在一个写线程，多个读线程</code>的情况： 上例从字节码理解是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run true </span></span><br><span class="line">putstatic run <span class="comment">// 线程 main 修改 run 为 false， 仅此一次</span></span><br><span class="line">getstatic run <span class="comment">// 线程 t 获取 run false </span></span><br></pre></td></tr></table></figure><p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i-- ，只能保证看到最新值，不能解决指令交错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设i的初始值为0 </span></span><br><span class="line">getstatic i <span class="comment">// 线程2-获取静态变量i的值 线程内i=0 </span></span><br><span class="line">getstatic i <span class="comment">// 线程1-获取静态变量i的值 线程内i=0 </span></span><br><span class="line">iconst_1 <span class="comment">// 线程1-准备常量1 </span></span><br><span class="line">iadd <span class="comment">// 线程1-自增 线程内i=1 </span></span><br><span class="line">putstatic i <span class="comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1 </span></span><br><span class="line">iconst_1 <span class="comment">// 线程2-准备常量1 </span></span><br><span class="line">isub <span class="comment">// 线程2-自减 线程内i=-1 </span></span><br><span class="line">putstatic i <span class="comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1 </span></span><br></pre></td></tr></table></figure><blockquote><p><code>注意</code></p><p>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低 。</p><p>JMM关于synchronized的两条规定：</p><p>1）线程解锁前，必须把共享变量的最新值刷新到主内存中</p><p>2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值</p><p>（注意：加锁与解锁需要是同一把锁）</p><p>通过以上两点，可以看到synchronized能够实现可见性。同时，由于synchronized具有同步锁，所以它也具有原子性</p><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？(println方法中有synchronized代码块保证了可见性)</p><p>synchronized关键字不能阻止指令重排，但在一定程度上能保证有序性（如果共享变量没有逃逸出同步代码块的话）。因为在单线程的情况下指令重排不影响结果，相当于保障了有序性。</p></blockquote><h3 id="2-3-模式之两阶段终止">2.3 模式之两阶段终止</h3><p>Two Phase Termination</p><p>在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。</p><p>错误思路</p><ul><li>使用线程对象的 stop() 方法停止线程<ul><li>stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁， 其它线程将永远无法获取锁</li></ul></li><li>使用 System.exit(int) 方法停止线程<ul><li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul></li></ul><div class="tabs" id="e534a3ae-a48e-4600-b307-289713ffc247"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e534a3ae-a48e-4600-b307-289713ffc247-1"><i class="fas fa-seedling"></i>利用 isInterrupted</button></li><li class="tab"><button type="button" data-href="#e534a3ae-a48e-4600-b307-289713ffc247-2"><i class="fas fa-leaf"></i>调用&输出</button></li><li class="tab"><button type="button" data-href="#e534a3ae-a48e-4600-b307-289713ffc247-3"><i class="fab fa-apple"></i>利用volatile修饰的停止标记</button></li><li class="tab"><button type="button" data-href="#e534a3ae-a48e-4600-b307-289713ffc247-4"><i class="fas fa-tree"></i>调用&输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e534a3ae-a48e-4600-b307-289713ffc247-1"><p>interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TPTInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//打断sleep线程会清除打断标记，所以要添加标记</span></span><br><span class="line">                    current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行监控操作 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e534a3ae-a48e-4600-b307-289713ffc247-2"><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TPTInterrupt</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPTInterrupt</span>();</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">log.debug(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">t.stop();</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11:49:42.915 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:43.919 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:44.919 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:45.413 c.TestTwoPhaseTermination [main] - stop </span><br><span class="line">11:49:45.413 c.TwoPhaseTermination [监控线程] - 料理后事</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e534a3ae-a48e-4600-b307-289713ffc247-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span></span><br><span class="line"><span class="comment">// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TPTVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                     &#125;</span><br><span class="line">                <span class="comment">// 执行监控操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//让线程立即停止而不是等待sleep结束</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e534a3ae-a48e-4600-b307-289713ffc247-4"><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TPTVolatile</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPTVolatile</span>();</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">log.debug(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">t.stop();</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11:54:52.003 c.TPTVolatile [监控线程] - 将结果保存</span><br><span class="line">11:54:53.006 c.TPTVolatile [监控线程] - 将结果保存</span><br><span class="line">11:54:54.007 c.TPTVolatile [监控线程] - 将结果保存</span><br><span class="line">11:54:54.502 c.TestTwoPhaseTermination [main] - stop </span><br><span class="line">11:54:54.502 c.TPTVolatile [监控线程] - 料理后事</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="3-有序性">3. 有序性</h2><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> j;</span><br><span class="line"><span class="comment">// 在某个线程内执行如下赋值操作</span></span><br><span class="line">i = ...; </span><br><span class="line">j = ...; </span><br></pre></td></tr></table></figure><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ...; </span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = ...;</span><br><span class="line">i = ...; </span><br></pre></td></tr></table></figure><p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？从 CPU 执行指令的原理来理解一下吧</p><h3 id="3-1-原理之指令级并行">3.1 原理之指令级并行</h3><p>名词：</p><p><code>Clock Cycle Time</code></p><p>主频的概念大家接触的比较多，而 CPU 的 Clock Cycle Time（时钟周期时间），等于主频的倒数，意思是 CPU 能 够识别的最小时间单位，比如说 4G 主频的 CPU 的 Clock Cycle Time 就是 0.25 ns，作为对比，我们墙上挂钟的 Cycle Time 是 1s</p><p>例如，运行一条加法指令一般需要一个时钟周期时间</p><p><code>CPI</code></p><p>有的指令需要更多的时钟周期时间，所以引出了 CPI （Cycles Per Instruction）指令平均时钟周期数</p><p><code>IPC</code></p><p>IPC（Instruction Per Clock Cycle） 即 CPI 的倒数，表示每个时钟周期能够运行的指令数</p><p><code>CPU 执行时间</code></p><p>程序的 CPU 执行时间，即我们前面提到的 user + system 时间，可以用下面的公式来表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序 CPU 执行时间 = 指令数 * CPI * Clock Cycle Time</span><br></pre></td></tr></table></figure><p><code>指令重排序优化</code></p><p>事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？可以想到指令 还可以再划分成一个个更小的阶段，例如，每条指令都可以分为：<code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code>这 5 个阶段</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220306122605032.png" alt="image-20220306122605032"></p><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现指令级并行，这一技术在 80’s 中 叶到 90’s 中叶占据了计算架构的重要地位。</p><blockquote><p><strong>提示</strong>：</p><p>分阶段，分工是提升效率的关键！</p></blockquote><p>指令重排的前提是，重排指令不能影响结果，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以重排的例子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 指令2</span></span><br><span class="line">System.out.println( a + b );</span><br><span class="line"><span class="comment">// 不能重排的例子</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 指令1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a - <span class="number">5</span>; <span class="comment">// 指令2</span></span><br></pre></td></tr></table></figure><div class="tabs" id="7ffbf873-2465-4c87-9b21-b825a0f410f8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7ffbf873-2465-4c87-9b21-b825a0f410f8-1"><i class="fas fa-atom"></i>支持流水线的处理器</button></li><li class="tab"><button type="button" data-href="#7ffbf873-2465-4c87-9b21-b825a0f410f8-2"><i class="far fa-sun"></i>SuperScalar 处理器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7ffbf873-2465-4c87-9b21-b825a0f410f8-1"><p>现代 CPU 支持<strong>多级指令流水线</strong>，例如支持同时执行<code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code>的处理 器，就可以称之为<strong>五级指令流水线</strong>。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间最长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了 指令地吞吐率。</p><blockquote><p><strong>提示</strong>：</p><p>奔腾四（Pentium 4）支持高达 35 级流水线，但由于功耗太高被废弃</p></blockquote><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220306123819512.png" alt="image-20220306123819512"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7ffbf873-2465-4c87-9b21-b825a0f410f8-2"><p>大多数处理器包含多个执行单元，并不是所有计算功能都集中在一起，可以再细分为整数运算单元、浮点数运算单 元等，这样可以把多条指令也可以做到并行获取、译码等，CPU 可以在一个时钟周期内，执行多于一条指令，IPC &gt; 1</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220306123933327.png" alt="image-20220306123933327"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>诡异的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123; </span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><p>有同学这么分析</p><p>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</p><p>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</p><p>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</p><p>但我告诉你，结果还有可能是 0 😁😁😁，信不信吧！</p><p>这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2</p><p>相信很多人已经晕了 😵😵😵</p><p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：</p><p>借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DinteractiveMode=<span class="literal">false</span> -DarchetypeGroupId=org.openjdk.jcstress -</span><br><span class="line">DarchetypeArtifactId=jcstress-java-test-archetype -DarchetypeVersion=0.5 -DgroupId=cn.itcast -</span><br><span class="line">DartifactId=ordering -Dversion=1.0 </span><br></pre></td></tr></table></figure><p>创建 maven 项目，提供如下测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrencyTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install </span><br><span class="line">java -jar target/jcstress.jar </span><br></pre></td></tr></table></figure><p>会输出我们感兴趣的结果，摘录其中一次结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*** INTERESTING tests </span><br><span class="line"> Some interesting behaviors observed. This is <span class="keyword">for</span> the plain curiosity. </span><br><span class="line"> </span><br><span class="line"> 2 matching <span class="built_in">test</span> results. </span><br><span class="line"> [OK] test.ConcurrencyTest </span><br><span class="line"> (JVM args: [-XX:-TieredCompilation]) </span><br><span class="line">    Observed state Occurrences Expectation Interpretation </span><br><span class="line">    0 1,729 ACCEPTABLE_INTERESTING !!!! </span><br><span class="line"> 1 42,617,915 ACCEPTABLE ok </span><br><span class="line"> 4 5,146,627 ACCEPTABLE ok </span><br><span class="line"> </span><br><span class="line"> [OK] test.ConcurrencyTest </span><br><span class="line"> (JVM args: []) </span><br><span class="line"> Observed state Occurrences Expectation Interpretation </span><br><span class="line"> 0 1,652 ACCEPTABLE_INTERESTING !!!! </span><br><span class="line"> 1 46,460,657 ACCEPTABLE ok </span><br><span class="line"> 4 4,571,072 ACCEPTABLE ok </span><br></pre></td></tr></table></figure><p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p><p>解决方法</p><p>volatile 修饰的变量，可以禁用指令重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrencyTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** INTERESTING tests </span><br><span class="line"> Some interesting behaviors observed. This is <span class="keyword">for</span> the plain curiosity. </span><br><span class="line"> 0 matching <span class="built_in">test</span> results. </span><br></pre></td></tr></table></figure><h3 id="3-2-原理之-volatile">3.2 原理之 volatile</h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h4 id="3-2-1-如何保证可见性">3.2.1 如何保证可见性</h4><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量(num和ready)的改动，都同步到主存当中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220306125622336.png" alt="image-20220306125622336" style="zoom: 67%;" /><h4 id="3-2-2-如何保证有序性">3.2.2 如何保证有序性</h4><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220306130348150.png" alt="image-20220306130348150" style="zoom: 67%;" /><p>还是那句话，不能解决指令交错：</p><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li></ul><p>以i++ i–为例</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220306130731767.png" alt="image-20220306130731767" style="zoom: 67%;" /><h4 id="3-2-3-双重检查锁问题">3.2.3 双重检查锁问题</h4><p>以著名的 double-checked locking 单例模式为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t2 t1</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><p>但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">3: ifnonnull 37</span><br><span class="line">6: ldc <span class="comment">#3 // class cn/itcast/n5/Singleton</span></span><br><span class="line">8: dup</span><br><span class="line">9: astore_0</span><br><span class="line">10: monitorenter</span><br><span class="line">11: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">14: ifnonnull 27</span><br><span class="line">17: new <span class="comment">#3 // class cn/itcast/n5/Singleton</span></span><br><span class="line">20: dup</span><br><span class="line">21: invokespecial <span class="comment">#4 // Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">24: putstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">27: aload_0</span><br><span class="line">28: monitorexit</span><br><span class="line">29: goto 37</span><br><span class="line">32: astore_1</span><br><span class="line">33: aload_0</span><br><span class="line">34: monitorexit</span><br><span class="line">35: aload_1</span><br><span class="line">36: athrow</span><br><span class="line">37: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">40: areturn</span><br></pre></td></tr></table></figure><p>其中</p><ul><li>17 表示创建对象，将对象引用入栈 // new Singleton</li><li>20 表示复制一份对象引用 // 引用地址</li><li>21 表示利用一个对象引用，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p>也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230401160623110.png" alt="image-20230401160623110" style="zoom: 33%;" /><p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值</p><p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初 始化完毕的单例</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><h4 id="3-2-4-双重检查锁解决">3.2.4 双重检查锁解决</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例没创建，才会进入内部的 synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// t2</span></span><br><span class="line">                <span class="comment">// 也许有其它线程已经创建实例，所以再判断一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码上看不出来 volatile 指令的效果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span><br><span class="line">0: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">3: ifnonnull 37</span><br><span class="line">6: ldc <span class="comment">#3 // class cn/itcast/n5/Singleton</span></span><br><span class="line">8: dup</span><br><span class="line">9: astore_0</span><br><span class="line">10: monitorenter -----------------------&gt; 保证原子性、可见性</span><br><span class="line">11: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">14: ifnonnull 27</span><br><span class="line">17: new <span class="comment">#3 // class cn/itcast/n5/Singleton</span></span><br><span class="line">20: dup</span><br><span class="line">21: invokespecial <span class="comment">#4 // Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">24: putstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span><br><span class="line">27: aload_0</span><br><span class="line">28: monitorexit ------------------------&gt; 保证原子性、可见性</span><br><span class="line">29: goto 37</span><br><span class="line">32: astore_1</span><br><span class="line">33: aload_0</span><br><span class="line">34: monitorexit</span><br><span class="line">35: aload_1</span><br><span class="line">36: athrow</span><br><span class="line">37: getstatic <span class="comment">#2 // Field INSTANCE:Lcn/itcast/n5/Singleton;</span></span><br><span class="line">40: areturn</span><br></pre></td></tr></table></figure><p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p><ul><li>可见性<ul><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul></li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</li></ul><h4 id="3-2-5-happens-before规则">3.2.5 happens-before规则</h4><p>happens-before规则规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见 <div class="tabs" id="0d60299e-3ed8-46ed-82f2-8ce4b9694d1a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-1"><i class="fas fa-atom"></i>规则1</button></li><li class="tab"><button type="button" data-href="#0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-2"><i class="far fa-sun"></i>规则2</button></li><li class="tab"><button type="button" data-href="#0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-3"><i class="fas fa-wind"></i>规则3</button></li><li class="tab"><button type="button" data-href="#0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-4"><i class="fas fa-fire-alt"></i>规则4</button></li><li class="tab"><button type="button" data-href="#0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-5"><i class="fas fa-cat"></i>规则5</button></li><li class="tab"><button type="button" data-href="#0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-6"><i class="fas fa-dragon"></i>规则6</button></li><li class="tab"><button type="button" data-href="#0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-7"><i class="fas fa-horse"></i>规则7</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-1"><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见(synchronized关键字的可见性、监视器规则)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-2"><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见(volatile关键字的可见性、volatile规则)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-3"><p>线程 start 前对变量的写，对该线程开始后对该变量的读可见(程序顺序规则+线程启动规则)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-4"><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待 它结束）(线程终止规则)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-5"><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）（线程中断机制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    <span class="keyword">while</span>(!t2.isInterrupted()) &#123;</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-6"><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0d60299e-3ed8-46ed-82f2-8ce4b9694d1a-7"><p>具有传递性，如果<code>x hb-&gt; y</code>并且<code>y hb-&gt; z</code>那么有<code>x hb-&gt; z</code>，配合 volatile 的防指令重排，有下面的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; </span><br><span class="line">    y = <span class="number">10</span>;</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span></span><br><span class="line">    System.out.println(x); </span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><blockquote><p>变量都是指成员变量或静态成员变量</p><p>参考： 第17页</p><p>在JMM中有一个很重要的概念对于我们了解JMM有很大的帮助，那就是happens-before规则。happens-before规则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据。JSR-133S使用happens-before概念阐述了两个操作之间的内存可见性。在JMM中，如果一个操作的结果需要对另一个操作可见，那么这两个操作则存在happens-before关系。</p><p>那什么是happens-before呢？在JSR-133中，happens-before关系定义如下：</p><ol><li>如果一个操作happens-before另一个操作，那么意味着第一个操作的结果对第二个操作可见，而且第一个操作的执行顺序将排在第二个操作的前面。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须按照happens-before关系指定的顺序来执行。如果重排序之后的结果，与按照happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）</li></ol><p>happens-before规则如下：</p><ol><li>程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。</li><li>监视器规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li>volatile规则：对一个volatile变量的写，happens-before于任意后续对一个volatile变量的读。</li><li>传递性：若果A happens-before B，B happens-before C，那么A happens-before C。</li><li>线程启动规则：Thread对象的start()方法，happens-before于这个线程的任意后续操作。</li><li>线程终止规则：线程中的任意操作，happens-before于该线程的终止监测。我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li><li>线程中断操作：对线程interrupt()方法的调用，happens-before于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到线程是否有中断发生。</li><li>对象终结规则：一个对象的初始化完成，happens-before于这个对象的finalize()方法的开始。</li></ol><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/77157725">happens-before规则解析 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="4-习题">4. 习题</h2><h3 id="4-1-balking-模式习题">4.1 balking 模式习题</h3><p>希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialized) &#123; <span class="comment">//t1 t2</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        doInit();<span class="comment">// t1 t2</span></span><br><span class="line">        initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="4-2-线程安全单例习题">4.2 线程安全单例习题</h3><p>单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题</p><blockquote><p>饿汉式：类加载就会导致该单实例对象被创建</p><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><div class="tabs" id="7c0c5838-fe44-480d-b317-5bcc661905ce"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7c0c5838-fe44-480d-b317-5bcc661905ce-1"><i class="fas fa-seedling"></i>饿汉式</button></li><li class="tab"><button type="button" data-href="#7c0c5838-fe44-480d-b317-5bcc661905ce-2"><i class="fas fa-leaf"></i>枚举类</button></li><li class="tab"><button type="button" data-href="#7c0c5838-fe44-480d-b317-5bcc661905ce-3"><i class="fab fa-apple"></i>synchronized方法</button></li><li class="tab"><button type="button" data-href="#7c0c5838-fe44-480d-b317-5bcc661905ce-4"><i class="fas fa-tree"></i>DCL+volatile</button></li><li class="tab"><button type="button" data-href="#7c0c5838-fe44-480d-b317-5bcc661905ce-5"><i class="fas fa-fire-alt"></i>内部类初始化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7c0c5838-fe44-480d-b317-5bcc661905ce-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：为什么加 final(防止被子类继承从而重写方法改写单例)</span></span><br><span class="line"><span class="comment">// 问题2：如果实现了序列化接口, 还要做什么来防止反序列化破坏单例(重写readResolve方法)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 问题3：为什么设置为私有? 是否能防止反射创建新的实例?(防止外部调用构造方法创建多个实例；不能)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 问题4：这样初始化是否能保证单例对象创建时的线程安全?(能，线程安全性由类加载器保障)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">// 问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由(可以保证instance的安全性，也能方便实现一些附加逻辑)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7c0c5838-fe44-480d-b317-5bcc661905ce-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题1：枚举单例是如何限制实例个数的 (枚举类会按照声明的个数在类加载时实例化对象)</span></span><br><span class="line"><span class="comment">// 问题2：枚举单例在创建时是否有并发问题(没有，由类加载器保障安全性)</span></span><br><span class="line"><span class="comment">// 问题3：枚举单例能否被反射破坏单例(不能)</span></span><br><span class="line"><span class="comment">// 问题4：枚举单例能否被反序列化破坏单例(不能)</span></span><br><span class="line"><span class="comment">// 问题5：枚举单例属于懒汉式还是饿汉式(饿汉)</span></span><br><span class="line"><span class="comment">// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做(写构造方法)</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7c0c5838-fe44-480d-b317-5bcc661905ce-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 分析这里的线程安全, 并说明有什么缺点(没有线程安全问题，同步代码块粒度太大，性能差)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( INSTANCE != <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125; </span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7c0c5838-fe44-480d-b317-5bcc661905ce-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：解释为什么要加 volatile ?(防止putstatic和invokespecial重排导致的异常)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 问题2：对比实现3, 说出这样做的意义 (缩小了锁的粒度，提高了性能)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">            <span class="comment">// 问题3：为什么还要在这里加为空判断, 之前不是判断过了吗</span></span><br><span class="line">            <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123; <span class="comment">// t2 </span></span><br><span class="line">                <span class="keyword">return</span> INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7c0c5838-fe44-480d-b317-5bcc661905ce-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// 问题1：属于懒汉式还是饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 问题2：在创建时是否有并发问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.共享模型之管程</title>
      <link href="/posts/3f9c0b8e.html"/>
      <url>/posts/3f9c0b8e.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-共享带来的问题">1. 共享带来的问题</h2><h3 id="1-1-小故事-示例">1.1 小故事&amp;示例</h3><div class="tabs" id="632e1c38-4593-41ef-a8ce-7bda29448e44"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#632e1c38-4593-41ef-a8ce-7bda29448e44-1"><i class="fas fa-seedling"></i>小故事-1</button></li><li class="tab"><button type="button" data-href="#632e1c38-4593-41ef-a8ce-7bda29448e44-2"><i class="fas fa-leaf"></i>小故事-2</button></li><li class="tab"><button type="button" data-href="#632e1c38-4593-41ef-a8ce-7bda29448e44-3"><i class="fab fa-apple"></i>小故事-3</button></li><li class="tab"><button type="button" data-href="#632e1c38-4593-41ef-a8ce-7bda29448e44-4"><i class="fas fa-seedling"></i>小故事-4</button></li><li class="tab"><button type="button" data-href="#632e1c38-4593-41ef-a8ce-7bda29448e44-5"><i class="fas fa-leaf"></i>Java代码示例</button></li><li class="tab"><button type="button" data-href="#632e1c38-4593-41ef-a8ce-7bda29448e44-6"><i class="fab fa-apple"></i>输出&分析</button></li><li class="tab"><button type="button" data-href="#632e1c38-4593-41ef-a8ce-7bda29448e44-7"><i class="fas fa-tree"></i>结论</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="632e1c38-4593-41ef-a8ce-7bda29448e44-1"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329085103871.png" alt="image-20230329085103871"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="632e1c38-4593-41ef-a8ce-7bda29448e44-2"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329085149594.png" alt="image-20230329085149594"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="632e1c38-4593-41ef-a8ce-7bda29448e44-3"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329085218114.png" alt="image-20230329085218114"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="632e1c38-4593-41ef-a8ce-7bda29448e44-4"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329085726138.png" alt="image-20230329085726138"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="632e1c38-4593-41ef-a8ce-7bda29448e44-5"><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="632e1c38-4593-41ef-a8ce-7bda29448e44-6"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">09</span><span class="string">:00:59.709</span> <span class="string">c.Test1</span> [<span class="string">main</span>] <span class="bullet">-</span> <span class="number">0</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="number">09</span><span class="string">:01:20.733</span> <span class="string">c.Test1</span> [<span class="string">main</span>] <span class="bullet">-</span> <span class="number">-55</span></span><br></pre></td></tr></table></figure><p>问题分析</p><p>以上的结果可能是正数、负数、零。为什么呢？<code>分时系统</code>,就可能会产生指令的交错。 因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329090622052.png" alt="image-20230329090622052"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="632e1c38-4593-41ef-a8ce-7bda29448e44-7"><p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题，但多线程下这 8 行代码可能交错运行。</p><div class="tabs" id="95484648-9d8c-40dd-807b-5c62202541c5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#95484648-9d8c-40dd-807b-5c62202541c5-1">单线程</button></li><li class="tab"><button type="button" data-href="#95484648-9d8c-40dd-807b-5c62202541c5-2">多线程-1</button></li><li class="tab"><button type="button" data-href="#95484648-9d8c-40dd-807b-5c62202541c5-3">多线程-2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="95484648-9d8c-40dd-807b-5c62202541c5-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329091004566.png" alt="image-20230329091004566" style="zoom: 33%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="95484648-9d8c-40dd-807b-5c62202541c5-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329091037804.png" alt="image-20230329091037804" style="zoom: 33%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="95484648-9d8c-40dd-807b-5c62202541c5-3"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329091110387.png" alt="image-20230329091110387" style="zoom: 33%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-2-临界区-竞态条件">1.2 临界区&amp;竞态条件</h3><ul><li><p>一个程序运行多个线程本身是没有问题的</p></li><li><p>问题出在多个线程访问<code>共享资源</code></p><ul><li><p>多个线程读<code>共享资源</code>其实也没有问题</p></li><li><p>在多个线程对<code>共享资源</code>读写操作时发生指令交错，就会出现问题</p></li></ul></li><li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<code>临界区</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个线程在<code>临界区</code>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<code>竞态条件</code></p><h2 id="2-synchronized-解决方案">2. synchronized 解决方案</h2><span class='p green'>应用->互斥</span> <p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><blockquote><p><strong>注意</strong></p><p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul></blockquote><h3 id="2-1-synchronized">2.1 synchronized</h3><div class="tabs" id="8e7661b7-b5d5-49ff-875f-881747f1d8ff"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8e7661b7-b5d5-49ff-875f-881747f1d8ff-1"><i class="fas fa-seedling"></i>语法</button></li><li class="tab"><button type="button" data-href="#8e7661b7-b5d5-49ff-875f-881747f1d8ff-2"><i class="fas fa-leaf"></i>解决</button></li><li class="tab"><button type="button" data-href="#8e7661b7-b5d5-49ff-875f-881747f1d8ff-3"><i class="fab fa-apple"></i>分析</button></li><li class="tab"><button type="button" data-href="#8e7661b7-b5d5-49ff-875f-881747f1d8ff-4"><i class="fas fa-tree"></i>流程</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8e7661b7-b5d5-49ff-875f-881747f1d8ff-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)</span><br><span class="line">&#123;</span><br><span class="line">    临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8e7661b7-b5d5-49ff-875f-881747f1d8ff-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8e7661b7-b5d5-49ff-875f-881747f1d8ff-3"><p>你可以做这样的类比：</p><ul><li>synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人</li><li>线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行count++ 代码</li><li>这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了</li><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入</li><li>当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count-- 代码</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329093820961.png" alt="image-20230329093820961" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8e7661b7-b5d5-49ff-875f-881747f1d8ff-4"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230329093343861.png" alt="image-20230329093343861" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p><p>为了加深理解，请思考下面的问题</p><ul><li>如果把 synchronized(obj) 放在 for 循环的外面，如何理解？-- 原子性</li><li>如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？-- 锁对象</li><li>如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？-- 锁对象</li></ul><h3 id="2-2-面向对象改进">2.2 面向对象改进</h3><p>把需要保护的共享变量放入一个类</p><div class="tabs" id="888d00e1-d8b1-4d7f-97e3-7d7cc5a4aa6a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#888d00e1-d8b1-4d7f-97e3-7d7cc5a4aa6a-1"><i class="fas fa-seedling"></i>锁对象</button></li><li class="tab"><button type="button" data-href="#888d00e1-d8b1-4d7f-97e3-7d7cc5a4aa6a-2"><i class="fas fa-leaf"></i>示例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="888d00e1-d8b1-4d7f-97e3-7d7cc5a4aa6a-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            value--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="888d00e1-d8b1-4d7f-97e3-7d7cc5a4aa6a-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            room.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            room.decrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, room.getCounter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-3-方法上的synchronized">2.3 方法上的synchronized</h3><div class="tabs" id="ef394c11-045f-4cb7-b17c-c89ad509af68"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ef394c11-045f-4cb7-b17c-c89ad509af68-1"><i class="fas fa-seedling"></i>成员方法</button></li><li class="tab"><button type="button" data-href="#ef394c11-045f-4cb7-b17c-c89ad509af68-2"><i class="fas fa-leaf"></i>静态方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ef394c11-045f-4cb7-b17c-c89ad509af68-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ef394c11-045f-4cb7-b17c-c89ad509af68-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>不加 synchronzied 的方法就好比不遵守规则的人，不去老实排队（好比翻窗户进去的）</p><h3 id="2-4-“线程八锁”">2.4 “线程八锁”</h3><p>就是考察 synchronized 锁住的是哪个对象</p><div class="tabs" id="2f283a08-661c-43f8-969d-3d0bdf1d4e52"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2f283a08-661c-43f8-969d-3d0bdf1d4e52-1"><i class="fas fa-seedling"></i>情况一</button></li><li class="tab"><button type="button" data-href="#2f283a08-661c-43f8-969d-3d0bdf1d4e52-2"><i class="fas fa-leaf"></i>情况二</button></li><li class="tab"><button type="button" data-href="#2f283a08-661c-43f8-969d-3d0bdf1d4e52-3"><i class="fab fa-apple"></i>情况三</button></li><li class="tab"><button type="button" data-href="#2f283a08-661c-43f8-969d-3d0bdf1d4e52-4"><i class="fas fa-tree"></i>情况四</button></li><li class="tab"><button type="button" data-href="#2f283a08-661c-43f8-969d-3d0bdf1d4e52-5"><i class="fas fa-seedling"></i>情况五</button></li><li class="tab"><button type="button" data-href="#2f283a08-661c-43f8-969d-3d0bdf1d4e52-6"><i class="fas fa-leaf"></i>情况六</button></li><li class="tab"><button type="button" data-href="#2f283a08-661c-43f8-969d-3d0bdf1d4e52-7"><i class="fab fa-apple"></i>情况七</button></li><li class="tab"><button type="button" data-href="#2f283a08-661c-43f8-969d-3d0bdf1d4e52-8"><i class="fas fa-tree"></i>情况八</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2f283a08-661c-43f8-969d-3d0bdf1d4e52-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： ①：12  ②：21</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2f283a08-661c-43f8-969d-3d0bdf1d4e52-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： ①：sleep(1)后 12  ②：2 sleep(1)后 1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2f283a08-661c-43f8-969d-3d0bdf1d4e52-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.c(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：①：3 sleep(1) 12   ②：23 sleep(1) 1  ③：32 sleep(1) 1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2f283a08-661c-43f8-969d-3d0bdf1d4e52-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p>①：2 sleep(1) 1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2f283a08-661c-43f8-969d-3d0bdf1d4e52-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： ①：2 sleep(1) 1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2f283a08-661c-43f8-969d-3d0bdf1d4e52-6"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： ①：sleep(1)后 12  ②：2 sleep(1)后 1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2f283a08-661c-43f8-969d-3d0bdf1d4e52-7"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： ①：2 sleep(1)后 1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2f283a08-661c-43f8-969d-3d0bdf1d4e52-8"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Number&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：  ①：sleep(1)后 12  ②：2 sleep(1)后 1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="3-变量的线程安全分析">3. 变量的线程安全分析</h2><p><strong>成员变量和静态变量是否线程安全？</strong></p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><p><strong>局部变量是否线程安全？</strong></p><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><h3 id="3-1-局部变量的线程安全分析">3.1 局部变量的线程安全分析</h3><p>局部变量</p><div class="tabs" id="3f1e03cc-0bfc-4ad1-9d25-db4bcb2236b9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3f1e03cc-0bfc-4ad1-9d25-db4bcb2236b9-1"><i class="fas fa-seedling"></i>代码</button></li><li class="tab"><button type="button" data-href="#3f1e03cc-0bfc-4ad1-9d25-db4bcb2236b9-2"><i class="fas fa-leaf"></i>字节码</button></li><li class="tab"><button type="button" data-href="#3f1e03cc-0bfc-4ad1-9d25-db4bcb2236b9-3"><i class="fab fa-apple"></i>图解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3f1e03cc-0bfc-4ad1-9d25-db4bcb2236b9-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3f1e03cc-0bfc-4ad1-9d25-db4bcb2236b9-2"><p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line"> descriptor: ()V </span><br><span class="line"> flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"> Code:</span><br><span class="line"> stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span>: istore_0</span><br><span class="line"> <span class="number">3</span>: iinc <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"> <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line"> LineNumberTable:</span><br><span class="line"> line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line"> line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line"> line <span class="number">12</span>: <span class="number">6</span></span><br><span class="line"> LocalVariableTable:</span><br><span class="line"> Start Length Slot Name Signature</span><br><span class="line"> <span class="number">3</span>        <span class="number">4</span>     <span class="number">0</span>   i      I</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3f1e03cc-0bfc-4ad1-9d25-db4bcb2236b9-3"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220303005909688.png" alt="image-20220303005909688"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><p>局部变量的引用稍有不同  先看一个成员变量的例子</p><div class="tabs" id="4419593a-95db-45a7-9cc7-3242fb5d02ac"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4419593a-95db-45a7-9cc7-3242fb5d02ac-1"><i class="fas fa-seedling"></i>代码</button></li><li class="tab"><button type="button" data-href="#4419593a-95db-45a7-9cc7-3242fb5d02ac-2"><i class="fas fa-leaf"></i>执行</button></li><li class="tab"><button type="button" data-href="#4419593a-95db-45a7-9cc7-3242fb5d02ac-3"><i class="fab fa-apple"></i>结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4419593a-95db-45a7-9cc7-3242fb5d02ac-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadUnsafe</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="comment">// &#123; 临界区, 会产生竞态条件</span></span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">            <span class="comment">// &#125; 临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4419593a-95db-45a7-9cc7-3242fb5d02ac-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_NUMBER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOOP_NUMBER</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadUnsafe</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafe</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_NUMBER; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            test.method1(LOOP_NUMBER);</span><br><span class="line">        &#125;, <span class="string">&quot;Thread&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4419593a-95db-45a7-9cc7-3242fb5d02ac-3"><p>其中一种情况是，如果线程2 还未 add，线程1 remove 就会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread1&quot;</span> java.lang.IndexOutOfBoundsException: Index: <span class="number">0</span>, Size: <span class="number">0</span> </span><br><span class="line"> at java.util.ArrayList.rangeCheck(ArrayList.java:<span class="number">657</span>) </span><br><span class="line"> at java.util.ArrayList.remove(ArrayList.java:<span class="number">496</span>) </span><br><span class="line"> at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:<span class="number">35</span>) </span><br><span class="line"> at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:<span class="number">26</span>) </span><br><span class="line"> at cn.itcast.n6.TestThreadSafe.lambda$main$<span class="number">0</span>(TestThreadSafe.java:<span class="number">14</span>) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>分析：</p><ul><li>无论哪个线程中的 method2 引用的都是同一个对象中的 list 成员变量</li><li>method3 与 method2 分析相同</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220303010311338.png" alt="image-20220303010311338" style="zoom:50%;" /><p>将 list 修改为局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就不会有上述问题了</p><p>分析：</p><ul><li>list 是局部变量，每个线程调用时会创建其不同实例，没有共享</li><li>而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象</li><li>method3 的参数分析与 method2 相同</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220303010518661.png" alt="image-20220303010518661" style="zoom:50%;" /><p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？</p><ul><li>情况1：有其它线程调用 method2 和 method3</li><li>情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title class_">ThreadSafe</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;Thread1&quot;</span> java.lang.IndexOutOfBoundsException: Index: <span class="number">0</span>, Size: <span class="number">0</span> </span><br><span class="line"> at java.util.ArrayList.rangeCheck(ArrayList.java:<span class="number">657</span>) </span><br><span class="line"> at java.util.ArrayList.remove(ArrayList.java:<span class="number">496</span>) </span><br><span class="line"> at cn.itcast.n6.ThreadUnsafe.method3(TestThreadSafe.java:<span class="number">35</span>) </span><br><span class="line"> at cn.itcast.n6.ThreadUnsafe.method1(TestThreadSafe.java:<span class="number">26</span>) </span><br><span class="line"> at cn.itcast.n6.TestThreadSafe.lambda$main$<span class="number">0</span>(TestThreadSafe.java:<span class="number">14</span>) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:<span class="number">748</span>) </span><br></pre></td></tr></table></figure><p>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</p><h2 id="4-常见的线程安全类">4. 常见的线程安全类</h2><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><ul><li>它们的每个方法是原子的</li><li>但注意它们多个方法的组合不是原子的，见后面分析</li></ul><h3 id="4-1-线程安全类方法的组合">4.1 线程安全类方法的组合</h3><p>分析下面代码是否线程安全？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220303011322077.png" alt="image-20220303011322077"></p><h3 id="4-2-不可变类线程安全性">4.2 不可变类线程安全性</h3><p>String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？</p><p>以String的substring为例子：会创建一个新的字符串，包含截取的结果，用新的对象来实现不可变效果。</p><div class="tabs" id="0ce61650-ca88-4c15-935d-8242ef1d9d88"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0ce61650-ca88-4c15-935d-8242ef1d9d88-1"><i class="fas fa-seedling"></i>substring</button></li><li class="tab"><button type="button" data-href="#0ce61650-ca88-4c15-935d-8242ef1d9d88-2"><i class="fas fa-leaf"></i>new String</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0ce61650-ca88-4c15-935d-8242ef1d9d88-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ce61650-ca88-4c15-935d-8242ef1d9d88-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="4-3-实例分析">4.3 实例分析</h3><p>servlet运行在Tomcat环境下，会被Tomcat的多个线程共享使用，成员变量都存在共享问题</p><div class="tabs" id="c55383bb-2db1-4375-925e-f451bff12eb2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c55383bb-2db1-4375-925e-f451bff12eb2-1"><i class="fas fa-seedling"></i>例一</button></li><li class="tab"><button type="button" data-href="#c55383bb-2db1-4375-925e-f451bff12eb2-2"><i class="fas fa-leaf"></i>例二</button></li><li class="tab"><button type="button" data-href="#c55383bb-2db1-4375-925e-f451bff12eb2-3"><i class="fab fa-apple"></i>例三</button></li><li class="tab"><button type="button" data-href="#c55383bb-2db1-4375-925e-f451bff12eb2-4"><i class="fas fa-tree"></i>例四</button></li><li class="tab"><button type="button" data-href="#c55383bb-2db1-4375-925e-f451bff12eb2-5"><i class="fas fa-seedling"></i>例五</button></li><li class="tab"><button type="button" data-href="#c55383bb-2db1-4375-925e-f451bff12eb2-6"><i class="fas fa-leaf"></i>例六</button></li><li class="tab"><button type="button" data-href="#c55383bb-2db1-4375-925e-f451bff12eb2-7"><i class="fab fa-apple"></i>例七</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c55383bb-2db1-4375-925e-f451bff12eb2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？  否 HashMap不安全</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 是否安全？  是</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">S1</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    <span class="comment">// 是否安全？  是</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">S2</span> <span class="operator">=</span> <span class="string">&quot;...&quot;</span>;</span><br><span class="line">    <span class="comment">// 是否安全？  否</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">D1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// 是否安全？  否</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Date</span> <span class="variable">D2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用上述变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c55383bb-2db1-4375-925e-f451bff12eb2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？  否</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 记录调用次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c55383bb-2db1-4375-925e-f451bff12eb2-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全？ 否 spring默认单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        start = System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;cost time:&quot;</span> + (end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c55383bb-2db1-4375-925e-f451bff12eb2-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全 安全 service有成员变量 但是是私有的，没有其他地方修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全 dao没有成员变量 安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 是否安全 局部变量 安全</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c55383bb-2db1-4375-925e-f451bff12eb2-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全  不安全 成员变量 多线程下别人close</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c55383bb-2db1-4375-925e-f451bff12eb2-6"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        userService.update(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="comment">// 是否安全 service每次调用都创建一个新的dao 安全</span></span><br><span class="line">    <span class="type">private</span> <span class="variable">Connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user set password = ? where username = ?&quot;</span>;</span><br><span class="line">        conn = DriverManager.getConnection(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c55383bb-2db1-4375-925e-f451bff12eb2-7"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 是否安全</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        foo(sdf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">foo</span><span class="params">(SimpleDateFormat sdf)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>().bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 foo 的行为是不确定的，可能导致不安全的发生，被称之为<strong>外星方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(SimpleDateFormat sdf)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;1999-10-11 00:00:00&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sdf.parse(dateStr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请比较 JDK 中 String 类的实现，设计为final，就是避免子类覆盖其方法，安全的就会变成不安全的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="5-Monitor-概念">5. Monitor 概念</h2><h3 id="5-1-JAVA对象头">5.1 JAVA对象头</h3><p>​    由于Java面向对象的思想，在JVM中需要大量存储对象，存储时为了实现一些额外的功能，需要在对象中添加一些标记字段用于增强对象功能，这些标记字段组成了对象头。</p><p>​    对象头包含两部分：<code>运行时元数据（Mark Word）</code>（存储对象自身的运行时数据）和<code>类型指针（Klass Word）</code></p><p>其中，运行时元数据Mark Word结构为：</p><p>哈希值（HashCode），可以看作是堆中对象的地址<br>GC分代年龄（年龄计数器） (用于新生代from/to区晋升老年代的标准, 阈值为15)<br>锁状态标志 (用于JDK1.6对synchronized的优化 -&gt; 轻量级锁)<br>线程持有的锁<br>偏向线程ID (用于JDK1.6对synchronized的优化 -&gt; 偏向锁)<br>偏向时间戳<br>类型指针： 指向类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息，Java虚拟机通过这个指针来确定是哪个类的实例。</p><p>以 32 位虚拟机为例</p><p>int 4字节</p><p>Integer 8+4=12字节</p><div class="tabs" id="55289838-2fe6-47de-800e-ff3d19e5698d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#55289838-2fe6-47de-800e-ff3d19e5698d-1"><i class="fas fa-seedling"></i>普通对象</button></li><li class="tab"><button type="button" data-href="#55289838-2fe6-47de-800e-ff3d19e5698d-2"><i class="fas fa-leaf"></i>数组对象</button></li><li class="tab"><button type="button" data-href="#55289838-2fe6-47de-800e-ff3d19e5698d-3"><i class="fab fa-apple"></i>32位Mark Word结构</button></li><li class="tab"><button type="button" data-href="#55289838-2fe6-47de-800e-ff3d19e5698d-4"><i class="fas fa-tree"></i>64位Mark Word结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="55289838-2fe6-47de-800e-ff3d19e5698d-1"><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                    Object Header (64 bits)                   </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|       <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)          |<span class="params">   Klass Word (32 bits)  </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="55289838-2fe6-47de-800e-ff3d19e5698d-2"><p>数组对象：<strong>数组对象还需要记录数组长度</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">---------------------------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params">                             Object Header (96 bits)                             </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br><span class="line">|<span class="params">        Mark Word(32bits)       </span>|   <span class="title class_">Klass</span> <span class="title class_">Word</span>(32bits)  |<span class="params">  array length(32bits)  </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="55289838-2fe6-47de-800e-ff3d19e5698d-3"><p>在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4中数据，如表所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                  <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)                  |<span class="params">        State       </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|    <span class="symbol">hashcode:</span><span class="number">25</span>  |<span class="params"> age:4 </span>|   <span class="symbol">biased_lock:</span><span class="number">0</span>   |<span class="params">   01    </span>|       <span class="title class_">Normal</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">thread:23</span>|<span class="symbol">epoch:</span><span class="number">2</span>|<span class="params"> age:4 </span>|   <span class="symbol">biased_lock:</span><span class="number">1</span>   |<span class="params">   01    </span>|       <span class="title class_">Biased</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">          ptr_to_lock_record:30              </span>|   <span class="number">00</span>    |<span class="params"> Lightweight Locked </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|          <span class="symbol">ptr_to_heavyweight_monitor:</span><span class="number">30</span>      |<span class="params">   10    </span>| <span class="title class_">Heavyweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                                             </span>|   <span class="number">11</span>    |<span class="params">    Marked <span class="keyword">for</span> GC   </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br></pre></td></tr></table></figure><div class="table-box"><table><thead><tr><th align="center">锁状态</th><th align="center">25bit</th><th align="center">4bit</th><th align="center">1bit是否是偏向锁</th><th align="center">2bit锁标志位</th></tr></thead><tbody><tr><td align="center">无锁状态  </td><td align="center">对象的HashCode</td><td align="center">对象分代年龄</td><td align="center">0</td><td align="center">01</td></tr></tbody></table></div><div class="table-box"><table><tbody><tr align="center"><th rowspan="2">锁状态</th><th colspan="2">25bit</th><th rowspan="2">4bit</th><th>1bit</th><th>2bit</th></tr><tr align="center"><th>23bit</th><th>2bit</th><th>是否是偏向锁</th><th>锁标志位</th></tr><tr align="center"><th>轻量级锁</th><td colspan="4">指向栈中锁记录的指针</td><td>00</td></tr><tr align="center"><th>重量级锁</th><td colspan="4">指向互斥量（重量级锁）的指针</td><td>10</td></tr><tr align="center"><th>GC标记</th><td colspan="4">空</td><td>11</td></tr><tr align="center"><th>偏向锁</th><td>线程ID</td><td>Epoch</td><td>对象分代年龄</td><td>1</td><td>01</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="55289838-2fe6-47de-800e-ff3d19e5698d-4"><p>64 位虚拟机 Mark Word</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                          <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">64</span> bits)                       |<span class="params">        State       </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| <span class="symbol">unused:</span><span class="number">25</span> |<span class="params"> hashcode:31 </span>| <span class="symbol">unused:</span><span class="number">1</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span> |<span class="params">  01   </span>|        <span class="title class_">Normal</span>      |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> thread:54 </span>|   <span class="symbol">epoch:</span><span class="number">2</span>   |<span class="params"> unused:1 </span>| <span class="symbol">age:</span><span class="number">4</span> |<span class="params"> biased_lock:1 </span>|  <span class="number">01</span>   |<span class="params">        Biased      </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                    <span class="symbol">ptr_to_lock_record:</span><span class="number">62</span>                   |<span class="params">  00   </span>| <span class="title class_">Lightweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                 ptr_to_heavyweight_monitor:62              </span>|  <span class="number">10</span>   |<span class="params"> Heavyweight Locked </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                                                            |<span class="params">  11   </span>|    <span class="title class_">Marked</span> <span class="keyword">for</span> <span class="variable constant_">GC</span>   |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br></pre></td></tr></table></figure><div class="table-box"><table><tbody><tr align="center"><th rowspan="2">锁状态</th><th>25bit</th><th>31bit</th><th>1bit</th><th>4bit</th><th>1bit</th><th>2bit</th></tr><tr align="center"><th></th><th></th><th>cms_free</th><th>分代年龄</th><th>偏向锁</th><th>锁标志位</th></tr><tr align="center"><th>无锁</th><td>unused</td><td>HashCode</td><td></td><td></td><td>0</td><td>01</td></tr><tr align="center"><th>偏向锁</th><td colspan="2">ThreadID(54bit) Epoch(2bit)</td><td></td><td></td><td>1</td><td>01</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="5-2-Monitor-锁">5.2 Monitor(锁)</h3><p>Monitor 被翻译为<code>监视器</code>或<code>管程</code></p><p>Monitor工作原理：</p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁<code>（重量级）</code>之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针，原本Mark Word当中的内容会存储到Monitor当中，释放时会取出这些内容再次放到Mark Word。</p><div class="tabs" id="253d8353-d44d-448f-97c6-9db8e2a858ec"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#253d8353-d44d-448f-97c6-9db8e2a858ec-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#253d8353-d44d-448f-97c6-9db8e2a858ec-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#253d8353-d44d-448f-97c6-9db8e2a858ec-3"><i class="fas fa-dove"></i>3</button></li><li class="tab"><button type="button" data-href="#253d8353-d44d-448f-97c6-9db8e2a858ec-4"><i class="fas fa-dragon"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="253d8353-d44d-448f-97c6-9db8e2a858ec-1"><p>线程2 要来执行临界区代码，执行这段代码时，就会把这个Java中的obj对象与操作系统提供的Monitor对象相关联。该obj的MarkWord中就记录了它的Monitor对象的指针地址。</p><p>Thread-2就成为这个Montior的Owner<br><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330131156867.png" style="zoom:50%;" /></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330132128736.png" alt="image-20230330132128736" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="253d8353-d44d-448f-97c6-9db8e2a858ec-2"><p>如果还有别的线程，也执行到临界区代码，该线程就会先检查一下这个obj有没有关联一个monitor锁，结果发现该obj已经关联一个monitor锁，所以就会检查一下这个锁有没有主人，发现锁的主人已经是Thread-2，获得不了锁。Thread-1就和这个Monitor中的EntryList相关联，并进入到阻塞状态。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330132906262.png" style="zoom:50%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330132834897.png" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="253d8353-d44d-448f-97c6-9db8e2a858ec-3"><p>Thread-3 同理</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330133756183.png" alt="image-20230330133756183" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="253d8353-d44d-448f-97c6-9db8e2a858ec-4"><p>当Thread-2把临界区代码都执行完后，Owner就空出来了，会通知Monitor中的EntryList中线程唤醒并竞争，竞争是非公平的</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330134054149.png" alt="image-20230330134054149" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p><strong>注意</strong>：</p><ul><li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li><li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li><li>图中 WaitSet ，是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</li></ul></blockquote><h2 id="6-原理之-synchronized">6. 原理之 synchronized</h2><div class="tabs" id="a5a6161e-0c2b-4005-9ed3-898f411eb92a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a5a6161e-0c2b-4005-9ed3-898f411eb92a-1"><i class="fas fa-cat"></i>代码</button></li><li class="tab"><button type="button" data-href="#a5a6161e-0c2b-4005-9ed3-898f411eb92a-2"><i class="fas fa-dragon"></i>字节码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a5a6161e-0c2b-4005-9ed3-898f411eb92a-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5a6161e-0c2b-4005-9ed3-898f411eb92a-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">              flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">              Code:</span><br><span class="line">              stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">              <span class="number">0</span>: getstatic #<span class="number">2</span> <span class="comment">// &lt;- lock引用 （synchronized开始）</span></span><br><span class="line">              <span class="number">3</span>: dup</span><br><span class="line">              <span class="number">4</span>: astore_1 <span class="comment">// lock引用 -&gt; slot 1</span></span><br><span class="line">              <span class="number">5</span>: monitorenter <span class="comment">// 将 lock对象 MarkWord 置为 Monitor 指针 C实现</span></span><br><span class="line">              <span class="number">6</span>: getstatic #<span class="number">3</span> <span class="comment">// &lt;- i</span></span><br><span class="line">              <span class="number">9</span>: iconst_1 <span class="comment">// 准备常数 1</span></span><br><span class="line">              <span class="number">10</span>: iadd <span class="comment">// +1</span></span><br><span class="line">              <span class="number">11</span>: putstatic #<span class="number">3</span> <span class="comment">// -&gt; i</span></span><br><span class="line">              <span class="number">14</span>: aload_1 <span class="comment">// &lt;- lock引用</span></span><br><span class="line">              <span class="number">15</span>: monitorexit <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line">              <span class="number">16</span>: goto <span class="number">24</span></span><br><span class="line">              <span class="number">19</span>: astore_2 <span class="comment">// e -&gt; slot 2 </span></span><br><span class="line">              <span class="number">20</span>: aload_1 <span class="comment">// &lt;- lock引用</span></span><br><span class="line">              <span class="number">21</span>: monitorexit <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line">              <span class="number">22</span>: aload_2 <span class="comment">// &lt;- slot 2 (e)</span></span><br><span class="line">              <span class="number">23</span>: athrow <span class="comment">// throw e</span></span><br><span class="line">              <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">              Exception table:</span><br><span class="line">              from to target type</span><br><span class="line">              <span class="number">6</span>    <span class="number">16</span>  <span class="number">19</span>    any</span><br><span class="line">              <span class="number">19</span>   <span class="number">22</span>  <span class="number">19</span>    any</span><br><span class="line">              LineNumberTable:</span><br><span class="line">              line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">              line <span class="number">9</span>: <span class="number">6</span></span><br><span class="line">              line <span class="number">10</span>: <span class="number">14</span></span><br><span class="line">              line <span class="number">11</span>: <span class="number">24</span></span><br><span class="line">              LocalVariableTable:</span><br><span class="line">              Start Length Slot Name Signature</span><br><span class="line">              <span class="number">0</span>     <span class="number">25</span>     <span class="number">0</span>    args [Ljava/lang/String;</span><br><span class="line">              StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">              frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">              offset_delta = <span class="number">19</span></span><br><span class="line">              locals = [ class <span class="string">&quot;[Ljava/lang/String;&quot;</span>, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object ]</span><br><span class="line">              stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Throwable ]</span><br><span class="line">              frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">              offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p><strong>注意</strong></p><p>方法级别的 synchronized 不会在字节码指令中有所体现</p></blockquote><h2 id="8-原理之-synchronized进阶">8. 原理之 synchronized进阶</h2><h3 id="8-1-小故事">8.1 小故事</h3><div class="tabs" id="342c43e6-2d14-4269-a7ef-d61a3dd67322"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#342c43e6-2d14-4269-a7ef-d61a3dd67322-1"><i class="fas fa-atom"></i>故事角色</button></li><li class="tab"><button type="button" data-href="#342c43e6-2d14-4269-a7ef-d61a3dd67322-2"><i class="far fa-sun"></i>故事</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="342c43e6-2d14-4269-a7ef-d61a3dd67322-1"><p>故事角色</p><ul><li><p>老王 - JVM</p></li><li><p>小南 - 线程</p></li><li><p>小女 - 线程</p></li><li><p>房间 - 对象</p></li><li><p>房间门上 - 防盗锁 - Monitor</p></li><li><p>房间门上 - 小南书包 - 轻量级锁</p></li><li><p>房间门上 - 刻上小南大名 - 偏向锁</p></li><li><p>批量重刻名 - 一个类的偏向锁撤销到达 20 阈值</p></li><li><p>不能刻名字 - 批量撤销该类对象的偏向锁，设置该类不可偏向</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="342c43e6-2d14-4269-a7ef-d61a3dd67322-2"><p>小南要使用房间保证计算不被其它人干扰（原子性），最初，他用的是防盗锁，当上下文切换时，锁住门。这样，即使他离开了，别人也进不了门，他的工作就是安全的。</p><p>但是，很多情况下没人跟他来竞争房间的使用权。小女是要用房间，但使用的时间上是错开的，小南白天用，小女晚上用。每次上锁太麻烦了，有没有更简单的办法呢？</p><p>小南和小女商量了一下，约定不锁门了，而是谁用房间，谁把自己的书包挂在门口，但他们的书包样式都一样，因此每次进门前得翻翻书包，看课本是谁的，如果是自己的，那么就可以进门，这样省的上锁解锁了。万一书包不是自己的，那么就在门外等，并通知对方下次用锁门的方式。</p><p>后来，小女回老家了，很长一段时间都不会用这个房间。小南每次还是挂书包，翻书包，虽然比锁门省事了，但仍然觉得麻烦。</p><p>于是，小南干脆在门上刻上了自己的名字：【小南专属房间，其它人勿用】，下次来用房间时，只要名字还在，那么说明没人打扰，还是可以安全地使用房间。如果这期间有其它人要用这个房间，那么由使用者将小南刻的名字擦掉，升级为挂书包的方式。</p><p>同学们都放假回老家了，小南就膨胀了，在 20 个房间刻上了自己的名字，想进哪个进哪个。后来他自己放假回老家了，这时小女回来了（她也要用这些房间），结果就是得一个个地擦掉小南刻的名字，升级为挂书包的方式。老王觉得这成本有点高，提出了一种批量重刻名的方法，他让小女不用挂书包了，可以直接在门上刻上自己的名字。</p><p>后来，刻名的现象越来越频繁，老王受不了了：算了，这些房间都不能刻名了，只能挂书包</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="8-2-轻量级锁">8.2 轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p><p>轻量级锁对使用者是透明的，即语法仍然是 synchronized</p><p>假设有两个方法同步块，利用同一个对象加锁</p><div class="tabs" id="ca665ee3-33f0-49bd-a1a4-59a3b938e8b2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-1"><i class="fas fa-fire-alt"></i>代码</button></li><li class="tab"><button type="button" data-href="#ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-2"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-3"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-4"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-5"><i class="fas fa-tree"></i>4</button></li><li class="tab"><button type="button" data-href="#ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-6"><i class="fas fa-cat"></i>5</button></li><li class="tab"><button type="button" data-href="#ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-7"><i class="fas fa-horse"></i>6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-2"><p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317183003930.png" alt="image-20220317183003930"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-3"><p>00 轻量级锁状态 01正常状态未加锁</p><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317183043247.png" alt="image-20220317183043247"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-4"><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317183112363.png" alt="image-20220317183112363"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-5"><p>如果 cas 失败，有两种情况</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317183158959.png" alt="image-20220317183158959"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-6"><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317183219677.png" alt="image-20220317183219677"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca665ee3-33f0-49bd-a1a4-59a3b938e8b2-7"><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用cas将Mark Word的值恢复给对象头</p><ul><li>成功，则解锁成功</li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="8-3-锁膨胀">8.3 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="81b72517-7212-413d-a530-9d15bd789ffd"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#81b72517-7212-413d-a530-9d15bd789ffd-1"><i class="fas fa-atom"></i>1</button></li><li class="tab"><button type="button" data-href="#81b72517-7212-413d-a530-9d15bd789ffd-2"><i class="far fa-sun"></i>2</button></li><li class="tab"><button type="button" data-href="#81b72517-7212-413d-a530-9d15bd789ffd-3"><i class="fas fa-wind"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="81b72517-7212-413d-a530-9d15bd789ffd-1"><p>当前Thread-0已经对Object加了轻量级锁，这时来了Thread-1，也是优先采用轻量级的加锁方式</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317183453057.png" alt="image-20220317183453057"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="81b72517-7212-413d-a530-9d15bd789ffd-2"><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</p><ul><li>即为 Object 对象申请 Monitor 锁，让 Object的 MarkWord中指针指向重量级锁地址</li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317183547387.png" alt="image-20220317183547387"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="81b72517-7212-413d-a530-9d15bd789ffd-3"><p>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁 流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="8-4-自旋优化">8.4 自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化<code>（暂时先不进入阻塞）</code>，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞。</p><div class="tabs" id="5330635d-da0f-42e3-84be-e2cf8e598e79"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5330635d-da0f-42e3-84be-e2cf8e598e79-1"><i class="fas fa-dove"></i>自旋重试成功的情况</button></li><li class="tab"><button type="button" data-href="#5330635d-da0f-42e3-84be-e2cf8e598e79-2"><i class="fas fa-dragon"></i>自旋重试失败的情况</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5330635d-da0f-42e3-84be-e2cf8e598e79-1"><p>旋重试成功的情况</p><table><thead><tr><th style="text-align:center">线程1 (  core 1上)</th><th style="text-align:center">对象Mark</th><th style="text-align:center">线程2 ( core 2上)</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">访问同步块，获取monitor</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">成功（加锁）</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10(重量锁）重量锁指针</td><td style="text-align:center">访问同步块，获取 monitor</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">执行完毕</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">成功（解锁）</td><td style="text-align:center">01（无锁）</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">成功（加锁)</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">执行同步块</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5330635d-da0f-42e3-84be-e2cf8e598e79-2"><table><thead><tr><th style="text-align:center">线程1 ( core 1上)</th><th style="text-align:center">对象Mark</th><th style="text-align:center">线程2( core 2上)</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">10（重量锁）</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">访问同步块，获取monitor</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">成功（加锁)</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">访问同步块，获取monitor</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">自旋重试</td></tr><tr><td style="text-align:center">执行同步块</td><td style="text-align:center">10（重量锁）重量锁指针</td><td style="text-align:center">阻塞,进入EntryList</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><h3 id="8-5-偏向锁">8.5 偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><p>出同步块，obj中的线程ID也不会清0</p><p>例如：</p><div class="tabs" id="6f3eb04d-761f-417c-87bf-8ba1103971e9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6f3eb04d-761f-417c-87bf-8ba1103971e9-1"><i class="fas fa-seedling"></i>代码实例</button></li><li class="tab"><button type="button" data-href="#6f3eb04d-761f-417c-87bf-8ba1103971e9-2"><i class="fas fa-leaf"></i>轻量级锁</button></li><li class="tab"><button type="button" data-href="#6f3eb04d-761f-417c-87bf-8ba1103971e9-3"><i class="fas fa-tree"></i>偏向锁</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6f3eb04d-761f-417c-87bf-8ba1103971e9-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6f3eb04d-761f-417c-87bf-8ba1103971e9-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330144351008.png" alt="image-20230330144351008" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6f3eb04d-761f-417c-87bf-8ba1103971e9-3"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330144432492.png" alt="image-20230330144432492" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="8-5-1-偏向状态">8.5.1 偏向状态</h4><p>回忆一下对象头格式</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                          <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">64</span> bits)                       |<span class="params">        State       </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| <span class="symbol">unused:</span><span class="number">25</span> |<span class="params"> hashcode:31 </span>| <span class="symbol">unused:</span><span class="number">1</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span> |<span class="params">  01   </span>|        <span class="title class_">Normal</span>      |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> thread:54 </span>|   <span class="symbol">epoch:</span><span class="number">2</span>   |<span class="params"> unused:1 </span>| <span class="symbol">age:</span><span class="number">4</span> |<span class="params"> biased_lock:1 </span>|  <span class="number">01</span>   |<span class="params">        Biased      </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                    <span class="symbol">ptr_to_lock_record:</span><span class="number">62</span>                   |<span class="params">  00   </span>| <span class="title class_">Lightweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">                 ptr_to_heavyweight_monitor:62              </span>|  <span class="number">10</span>   |<span class="params"> Heavyweight Locked </span>|</span><br><span class="line">|<span class="params">--------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                                                            |<span class="params">  11   </span>|    <span class="title class_">Marked</span> <span class="keyword">for</span> <span class="variable constant_">GC</span>   |<span class="params"></span></span><br><span class="line"><span class="params"></span>|--------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br></pre></td></tr></table></figure><p>一个对象创建时：</p><ul><li><p>如果开启了偏向锁（默认开启），那么对象创建后，markword 值最后 3 位为 101<code>Biased状态</code>，这时它的 thread、epoch、age 都为 0</p></li><li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数<code>- XX:BiasedLockingStartupDelay=0</code>来禁用延迟</p></li><li><p>如果没有开启偏向锁，那么对象创建后，markword 值最后 3 位为 001<code>Normal状态</code>，这时它的 hashcode、 age 都为 0</p></li></ul><h4 id="8-5-2-撤销-调用对象hashcode">8.5.2 撤销-调用对象hashcode</h4><ul><li>hashcode是懒加载，在调用hashCode方法后才会保存在对象头中。</li><li>当对象头中没有hashcode时，对象头锁的状态是 可偏向（ biasable，101，且无线程id）。</li><li>如果在同步代码块之前调用hashCode方法，则对象头中会有hashcode，且锁状态是 不可偏向 （0 01），这时候再执行同步代码块，锁直接是 轻量级锁00。</li><li>如果是在同步代码块中执行hashcode，则锁是从 偏向锁 直接膨胀为 重量级锁。</li></ul><p>轻量级锁会在锁记录中记录 hashCode</p><p>重量级锁会在 Monitor 中记录 hashCode</p><h4 id="8-5-3-撤销-其它线程使用对象">8.5.3 撤销 - 其它线程使用对象</h4><p>当有其它线程使用偏向锁对象时(错开使用，若同时使用就会膨胀)，会将偏向锁升级为轻量级锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        TestBiased.class.notify();</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestBiased.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TestBiased.class.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            log.debug(ClassLayout.parseInstance(d).toPrintable(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(ClassLayout.parseInstance(d).toPrintable(<span class="literal">true</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[t1] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000101</span>   进入同步代码块前  偏向状态</span><br><span class="line">[t1] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">01000001</span> <span class="number">00010000</span> <span class="number">00000101</span>   t1线程ID+<span class="number">101</span></span><br><span class="line">[t1] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">01000001</span> <span class="number">00010000</span> <span class="number">00000101</span>  t1线程ID+<span class="number">101</span></span><br><span class="line">[t2] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011111</span> <span class="number">01000001</span> <span class="number">00010000</span> <span class="number">00000101</span>   t1线程ID+<span class="number">101</span></span><br><span class="line">[t2] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00100000</span> <span class="number">01001011</span> <span class="number">11110011</span> <span class="number">00100000</span>   t2线程加轻量级锁 锁记录+<span class="number">000</span></span><br><span class="line">[t2] - <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span>   无锁状态 偏向状态被撤销</span><br></pre></td></tr></table></figure><h4 id="8-5-4-撤销-调用-wait-notify">8.5.4 撤销 - 调用 wait/notify</h4><p>wait/notify只有重量级锁有</p><h4 id="8-5-5-批量重偏向">8.5.5 批量重偏向</h4><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID</p><p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至 加锁线程</p><div class="tabs" id="e0ea9519-0165-48a8-8333-4b4a8b88289c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e0ea9519-0165-48a8-8333-4b4a8b88289c-1"><i class="fas fa-cat"></i>代码</button></li><li class="tab"><button type="button" data-href="#e0ea9519-0165-48a8-8333-4b4a8b88289c-2"><i class="fas fa-horse"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e0ea9519-0165-48a8-8333-4b4a8b88289c-1"><p>t1线程 t2线程错开执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Vector&lt;Dog&gt; list = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">            list.add(d);</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            list.notify();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e0ea9519-0165-48a8-8333-4b4a8b88289c-2"><p>t1线程 0-29加的都是偏向锁（线程ID+101）</p><p>t2线程 偏向锁 变成轻量级锁 解锁 循环 从第20个对象开始 又变成偏向锁（线程ID+101）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - ===============&gt; </span><br><span class="line">[t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101</span><br><span class="line">[t2] - 7 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 8 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 9 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 9 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 10 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 10 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 11 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 11 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 12 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 12 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 13 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 13 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 14 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 14 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 15 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 15 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 16 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 16 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 17 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 17 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 </span><br><span class="line">[t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 </span><br><span class="line">[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 </span><br><span class="line">[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br><span class="line">[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="8-5-6-批量撤销">8.5.6 批量撤销</h4><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向的，新建的对象也是不可偏向的</p><h3 id="8-6-锁消除">8.6 锁消除</h3><p>JIT即时编译器会对代码进行逃逸分析，发现局部变量不会逃离方法后，不可能被共享，加锁就没必要了。</p><p>可以通过开关控制 -XX:-EliminateLocks 锁消除</p><div class="tabs" id="8cff80bf-aa9c-4d4c-a752-aec833649197"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8cff80bf-aa9c-4d4c-a752-aec833649197-1"><i class="fas fa-cat"></i>测试代码</button></li><li class="tab"><button type="button" data-href="#8cff80bf-aa9c-4d4c-a752-aec833649197-2"><i class="fas fa-horse"></i>默认开启测试</button></li><li class="tab"><button type="button" data-href="#8cff80bf-aa9c-4d4c-a752-aec833649197-3"><i class="fas fa-dove"></i>关闭后测试结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8cff80bf-aa9c-4d4c-a752-aec833649197-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Fork(1)</span></span><br><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span></span><br><span class="line"><span class="meta">@Warmup(iterations=3)</span></span><br><span class="line"><span class="meta">@Measurement(iterations=5)</span></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBenchmark</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8cff80bf-aa9c-4d4c-a752-aec833649197-2"><p>发现加锁与不加锁得分相差不大</p><p><code>java -jar benchmarks.jar</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Benchmark Mode Samples Score Score error Units </span><br><span class="line">c.i.MyBenchmark.a avgt 5 1.542 0.056 ns/op </span><br><span class="line">c.i.MyBenchmark.b avgt 5 1.518 0.091 ns/op </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8cff80bf-aa9c-4d4c-a752-aec833649197-3"><p>关闭后相差较大</p><p><code>java -XX:-EliminateLocks -jar benchmarks.jar</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Benchmark Mode Samples Score Score error Units </span><br><span class="line">c.i.MyBenchmark.a avgt 5 1.507 0.108 ns/op </span><br><span class="line">c.i.MyBenchmark.b avgt 5 16.976 1.572 ns/op</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="9-Wait-Notify">9. Wait &amp; Notify</h2><h3 id="9-1-小故事-为什么需要-wait">9.1 小故事 - 为什么需要 wait</h3><div class="tabs" id="14c28997-7b76-48a8-ba7d-7393d9e64cb0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#14c28997-7b76-48a8-ba7d-7393d9e64cb0-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#14c28997-7b76-48a8-ba7d-7393d9e64cb0-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#14c28997-7b76-48a8-ba7d-7393d9e64cb0-3"><i class="fas fa-dove"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="14c28997-7b76-48a8-ba7d-7393d9e64cb0-1"><p>小南费劲九牛二虎之力争抢到了锁，成为了主人，计算过程中发现有些条件不满足</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330164151398.png" alt="image-20230330164151398"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="14c28997-7b76-48a8-ba7d-7393d9e64cb0-2"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330164414278.png" alt="image-20230330164414278"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="14c28997-7b76-48a8-ba7d-7393d9e64cb0-3"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230330164528815.png" alt="image-20230330164528815"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="9-2-原理之-wait-notify">9.2 原理之 wait / notify</h3><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220317191950175.png" alt="image-20220317191950175"></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</li></ul><h3 id="9-3-API介绍">9.3 API介绍</h3><p>-<code>obj.wait()</code>让进入 object 监视器（获得锁）的线程到 waitSet 等待<br>-<code>obj.notify()</code>在 object 上正在 waitSet 等待的线程中挑一个唤醒<br>-<code>obj.notifyAll()</code>让 object 上正在 waitSet 等待的线程全部唤醒</p><p><code>wait()</code>方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到 notify 为止</p><p><code>wait(long n)</code>有时限的等待, 到 n 毫秒后结束等待，或是被 notify</p><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</p><div class="tabs" id="7582f5ab-170b-499b-8fd7-51fbf927d646"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7582f5ab-170b-499b-8fd7-51fbf927d646-1"><i class="fas fa-atom"></i>不获取锁，调用</button></li><li class="tab"><button type="button" data-href="#7582f5ab-170b-499b-8fd7-51fbf927d646-2"><i class="far fa-sun"></i>获取锁再调用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7582f5ab-170b-499b-8fd7-51fbf927d646-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">at cn.itcast.test.Test18.main(Test18.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7582f5ab-170b-499b-8fd7-51fbf927d646-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="9-4-wait-notify-的正确姿势">9.4 wait notify 的正确姿势</h3><p>开始之前先看看</p><p><code>sleep(long n)</code>和<code>wait(long n)</code>的区别</p><ol><li>sleep 是 Thread 方法，而 wait 是 Object 的方法</li><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用</li><li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li><li>它们 状态 TIMED_WAITING</li></ol><p>思考下面的解决方案好不好，为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><div class="tabs" id="23c61133-258a-4d7f-ab94-6da8725566cc"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#23c61133-258a-4d7f-ab94-6da8725566cc-1"><i class="fas fa-cat"></i>方案1</button></li><li class="tab"><button type="button" data-href="#23c61133-258a-4d7f-ab94-6da8725566cc-2"><i class="fas fa-horse"></i>输出1</button></li><li class="tab"><button type="button" data-href="#23c61133-258a-4d7f-ab94-6da8725566cc-3"><i class="fas fa-dove"></i>方案二</button></li><li class="tab"><button type="button" data-href="#23c61133-258a-4d7f-ab94-6da8725566cc-4"><i class="fas fa-dragon"></i>输出二</button></li><li class="tab"><button type="button" data-href="#23c61133-258a-4d7f-ab94-6da8725566cc-5"><i class="fas fa-seedling"></i>测试三</button></li><li class="tab"><button type="button" data-href="#23c61133-258a-4d7f-ab94-6da8725566cc-6"><i class="fas fa-leaf"></i>输出三</button></li><li class="tab"><button type="button" data-href="#23c61133-258a-4d7f-ab94-6da8725566cc-7"><i class="fab fa-apple"></i>方案四</button></li><li class="tab"><button type="button" data-href="#23c61133-258a-4d7f-ab94-6da8725566cc-8"><i class="fas fa-tree"></i>输出四</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="23c61133-258a-4d7f-ab94-6da8725566cc-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里能不能加 synchronized (room)？</span></span><br><span class="line">    hasCigarette = <span class="literal">true</span>;</span><br><span class="line">    log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="23c61133-258a-4d7f-ab94-6da8725566cc-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">49.883</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">49.887</span> [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">50.882</span> [送烟的] c.TestCorrectPosture - 烟到了噢！</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">true</span>] </span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [小南] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.887</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.888</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.888</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line"><span class="number">20</span>:<span class="number">49</span>:<span class="number">51.888</span> [其它人] c.TestCorrectPosture - 可以开始干活了</span><br></pre></td></tr></table></figure><ul><li>其它干活的线程，都要一直阻塞，效率太低</li><li>小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来</li><li>加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 没加 synchronized 就好像 main 线程是翻窗户进来的</li><li>解决方法，使用 wait - notify 机制</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="23c61133-258a-4d7f-ab94-6da8725566cc-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;其它人&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasCigarette = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">        room.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="23c61133-258a-4d7f-ab94-6da8725566cc-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">36.095</span> c.TestCorrectPosture [小南] - 有烟没？[<span class="literal">false</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">36.101</span> c.TestCorrectPosture [小南] - 没烟，先歇会！</span><br><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">36.102</span> c.TestCorrectPosture [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">36.102</span> c.TestCorrectPosture [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">36.102</span> c.TestCorrectPosture [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">36.102</span> c.TestCorrectPosture [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">36.102</span> c.TestCorrectPosture [其它人] - 可以开始干活了</span><br><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">37.097</span> c.TestCorrectPosture [送烟的] - 烟到了噢！</span><br><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">37.098</span> c.TestCorrectPosture [小南] - 有烟没？[<span class="literal">true</span>]</span><br><span class="line"><span class="number">19</span>:<span class="number">06</span>:<span class="number">37.098</span> c.TestCorrectPosture [小南] - 可以开始干活了</span><br></pre></td></tr></table></figure><ul><li>解决了其它干活的线程阻塞的问题</li><li>但如果有其它线程也在等待呢，notify时会不会错误叫醒了其他线程？</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="23c61133-258a-4d7f-ab94-6da8725566cc-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">        <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (!hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                room.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">        <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">        hasTakeout = <span class="literal">true</span>;</span><br><span class="line">        log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">        room.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="23c61133-258a-4d7f-ab94-6da8725566cc-6"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">20:53:12.173 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:53:12.176 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line">20:53:12.176 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line">20:53:12.176 [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line">20:53:13.174 [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line">20:53:13.174 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:53:13.174 [小南] c.TestCorrectPosture - 没干成活... </span><br></pre></td></tr></table></figure><ul><li>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】</li><li>解决方法，改为 notifyAll</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20:55:23.978 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:55:23.982 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line">20:55:23.982 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line">20:55:23.982 [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line">20:55:24.979 [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line">20:55:24.979 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">true</span>] </span><br><span class="line">20:55:24.980 [小女] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:55:24.980 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:55:24.980 [小南] c.TestCorrectPosture - 没干成活... </span><br></pre></td></tr></table></figure><ul><li>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了</li><li>解决方法，用 while + wait，当条件不成立，再次 wait</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="23c61133-258a-4d7f-ab94-6da8725566cc-7"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!hasCigarette) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        room.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改动后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        room.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="23c61133-258a-4d7f-ab94-6da8725566cc-8"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">20:58:34.322 [小南] c.TestCorrectPosture - 有烟没？[<span class="literal">false</span>] </span><br><span class="line">20:58:34.326 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br><span class="line">20:58:34.326 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">false</span>] </span><br><span class="line">20:58:34.326 [小女] c.TestCorrectPosture - 没外卖，先歇会！</span><br><span class="line">20:58:35.323 [送外卖的] c.TestCorrectPosture - 外卖到了噢！</span><br><span class="line">20:58:35.324 [小女] c.TestCorrectPosture - 外卖送到没？[<span class="literal">true</span>] </span><br><span class="line">20:58:35.324 [小女] c.TestCorrectPosture - 可以开始干活了</span><br><span class="line">20:58:35.324 [小南] c.TestCorrectPosture - 没烟，先歇会！</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>正确姿势：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立) &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 干活</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5-模式之保护性暂停">9.5 模式之保护性暂停</h3><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><p>要点</p><ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li><li>因为要等待另一方的结果，因此归类到同步模式</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220304134602353.png" alt="image-20220304134602353"></p><div class="tabs" id="30c67623-2bc9-45f2-b399-d2eb68b62fc8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#30c67623-2bc9-45f2-b399-d2eb68b62fc8-1"><i class="fas fa-atom"></i>实现</button></li><li class="tab"><button type="button" data-href="#30c67623-2bc9-45f2-b399-d2eb68b62fc8-2"><i class="far fa-sun"></i>测试</button></li><li class="tab"><button type="button" data-href="#30c67623-2bc9-45f2-b399-d2eb68b62fc8-3"><i class="fas fa-wind"></i>执行结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="30c67623-2bc9-45f2-b399-d2eb68b62fc8-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件不满足则等待</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="30c67623-2bc9-45f2-b399-d2eb68b62fc8-2"><p>一个线程等待另一个线程的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 子线程执行下载</span></span><br><span class="line">            List&lt;String&gt; response = download();</span><br><span class="line">            log.debug(<span class="string">&quot;download complete...&quot;</span>);</span><br><span class="line">            guardedObject.complete(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    <span class="comment">// 主线程阻塞等待</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> guardedObject.get();</span><br><span class="line">    log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="30c67623-2bc9-45f2-b399-d2eb68b62fc8-3"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">08:42:18.568 [main] c.TestGuardedObject - waiting...</span><br><span class="line">08:42:23.312 [Thread-0] c.TestGuardedObject - download complete...</span><br><span class="line">08:42:23.312 [main] c.TestGuardedObject - get response: [3] lines</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><p>改进带超时版 GuardedObject：可以控制超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObjectV2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> millis - timePassed;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span></span><br><span class="line">                timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">                log.debug(<span class="string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>,</span><br><span class="line">                        timePassed, response == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            log.debug(<span class="string">&quot;notify...&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>多任务版GuardedObject</p><p>图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员 。</p><p>如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类， 这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220304141821782.png" alt="image-20220304141821782"></p><div class="tabs" id="bb55dde2-f71b-47fa-aff5-45737640b7c7"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#bb55dde2-f71b-47fa-aff5-45737640b7c7-1"><i class="fas fa-cat"></i>Guarded Object</button></li><li class="tab"><button type="button" data-href="#bb55dde2-f71b-47fa-aff5-45737640b7c7-2"><i class="fas fa-horse"></i>中间解耦类</button></li><li class="tab"><button type="button" data-href="#bb55dde2-f71b-47fa-aff5-45737640b7c7-3"><i class="fas fa-dove"></i>业务相关类</button></li><li class="tab"><button type="button" data-href="#bb55dde2-f71b-47fa-aff5-45737640b7c7-4"><i class="fas fa-dragon"></i>测试</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="bb55dde2-f71b-47fa-aff5-45737640b7c7-1"><p>新增 id 用来标识 Guarded Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="comment">// 标识 Guarded Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结果</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="comment">// 获取结果</span></span><br><span class="line">    <span class="comment">// timeout 表示要等待多久 2000</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 开始时间 15:00:00</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">passedTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 这一轮循环应该等待的时间</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> timeout - passedTime;</span><br><span class="line">                <span class="comment">// 经历的时间超过了最大等待时间时，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> (timeout - passedTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait(waitTime); <span class="comment">// 虚假唤醒 15:00:01</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 求得经历时间</span></span><br><span class="line">                passedTime = System.currentTimeMillis() - begin; <span class="comment">// 15:00:02 1s</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 产生结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 给结果成员变量赋值</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bb55dde2-f71b-47fa-aff5-45737640b7c7-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mailboxes</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardedObject&gt; boxes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 产生唯一 id，方法必须声明为synchronized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">getGuardedObject</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">createGuardedObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>(generateId());</span><br><span class="line">        boxes.put(go.getId(), go);</span><br><span class="line">        <span class="keyword">return</span> go;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getIds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boxes.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bb55dde2-f71b-47fa-aff5-45737640b7c7-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 收信</span></span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.createGuardedObject();</span><br><span class="line">        log.debug(<span class="string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">mail</span> <span class="operator">=</span> guardedObject.get(<span class="number">5000</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Postman</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Postman</span><span class="params">(<span class="type">int</span> id, String mail)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.mail = mail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Mailboxes.getGuardedObject(id);</span><br><span class="line">        log.debug(<span class="string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);</span><br><span class="line">        guardedObject.complete(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bb55dde2-f71b-47fa-aff5-45737640b7c7-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">People</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">    Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Postman</span>(id, <span class="string">&quot;内容&quot;</span> + id).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某次运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">05.689</span> c.People [Thread-<span class="number">1</span>] - 开始收信 id:<span class="number">3</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">05.689</span> c.People [Thread-<span class="number">2</span>] - 开始收信 id:<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">05.689</span> c.People [Thread-<span class="number">0</span>] - 开始收信 id:<span class="number">2</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.Postman [Thread-<span class="number">4</span>] - 送信 id:<span class="number">2</span>, 内容:内容<span class="number">2</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.Postman [Thread-<span class="number">5</span>] - 送信 id:<span class="number">1</span>, 内容:内容<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.People [Thread-<span class="number">0</span>] - 收到信 id:<span class="number">2</span>, 内容:内容<span class="number">2</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.People [Thread-<span class="number">2</span>] - 收到信 id:<span class="number">1</span>, 内容:内容<span class="number">1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.688</span> c.Postman [Thread-<span class="number">3</span>] - 送信 id:<span class="number">3</span>, 内容:内容<span class="number">3</span></span><br><span class="line"><span class="number">10</span>:<span class="number">35</span>:<span class="number">06.689</span> c.People [Thread-<span class="number">1</span>] - 收到信 id:<span class="number">3</span>, 内容:内容<span class="number">3</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="9-6-原理之-join">9.6 原理之 join</h3><p>是调用者轮询检查线程 alive 状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1.join();</span><br></pre></td></tr></table></figure><p>等价于下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line">    <span class="comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span></span><br><span class="line">    <span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line">        t1.wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>join 体现的是【保护性暂停】模式，请参考之</p></blockquote><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带参</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带参</span></span><br><span class="line"><span class="comment">//等待时长的实现类似于之前的保护性暂停</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-7-模式之生产者消费者">9.7 模式之生产者消费者</h3><p>要点</p><ul><li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220304142831627.png" alt="image-20220304142831627"></p><div class="tabs" id="06619b53-37b9-4d2e-9afb-27d27fadbbeb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#06619b53-37b9-4d2e-9afb-27d27fadbbeb-1"><i class="fas fa-dragon"></i>消息实现</button></li><li class="tab"><button type="button" data-href="#06619b53-37b9-4d2e-9afb-27d27fadbbeb-2"><i class="fas fa-seedling"></i>消息队列实现</button></li><li class="tab"><button type="button" data-href="#06619b53-37b9-4d2e-9afb-27d27fadbbeb-3"><i class="fas fa-leaf"></i>测试</button></li><li class="tab"><button type="button" data-href="#06619b53-37b9-4d2e-9afb-27d27fadbbeb-4"><i class="fab fa-apple"></i>测试结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="06619b53-37b9-4d2e-9afb-27d27fadbbeb-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> id, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Message&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="06619b53-37b9-4d2e-9afb-27d27fadbbeb-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Class MessageQueue &#123;</span><br><span class="line">    <span class="comment">// 消息的队列集合</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capcity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 检查队列是否为空</span></span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span>(list.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列为空, 消费者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从队列头部获取消息并返回</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">            log.debug(<span class="string">&quot;已消费消息 &#123;&#125;&quot;</span>, message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">// 检查对象是否已满</span></span><br><span class="line">            <span class="keyword">while</span>(list.size() == capcity) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;队列已满, 生产者线程等待&quot;</span>);</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将消息加入队列尾部</span></span><br><span class="line">            list.addLast(message);</span><br><span class="line">            log.debug(<span class="string">&quot;已生产消息 &#123;&#125;&quot;</span>, message);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="06619b53-37b9-4d2e-9afb-27d27fadbbeb-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id , <span class="string">&quot;值&quot;</span>+id));</span><br><span class="line">        &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//每隔一秒消息一个消息</span></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="06619b53-37b9-4d2e-9afb-27d27fadbbeb-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">09:<span class="number">42</span>:<span class="number">46.548</span> c.MessageQueue [生产者<span class="number">0</span>] - 已生产消息 Message&#123;id=<span class="number">0</span>, value=值<span class="number">0</span>&#125;</span><br><span class="line">09:<span class="number">42</span>:<span class="number">46.558</span> c.MessageQueue [生产者<span class="number">2</span>] - 已生产消息 Message&#123;id=<span class="number">2</span>, value=值<span class="number">2</span>&#125;</span><br><span class="line">09:<span class="number">42</span>:<span class="number">46.558</span> c.MessageQueue [生产者<span class="number">1</span>] - 队列已满, 生产者线程等待</span><br><span class="line">09:<span class="number">42</span>:<span class="number">47.548</span> c.MessageQueue [消费者] - 已消费消息 Message&#123;id=<span class="number">0</span>, value=值<span class="number">0</span>&#125;</span><br><span class="line">09:<span class="number">42</span>:<span class="number">47.548</span> c.MessageQueue [生产者<span class="number">1</span>] - 已生产消息 Message&#123;id=<span class="number">1</span>, value=值<span class="number">1</span>&#125;</span><br><span class="line">09:<span class="number">42</span>:<span class="number">48.547</span> c.MessageQueue [消费者] - 已消费消息 Message&#123;id=<span class="number">2</span>, value=值<span class="number">2</span>&#125;</span><br><span class="line">09:<span class="number">42</span>:<span class="number">49.550</span> c.MessageQueue [消费者] - 已消费消息 Message&#123;id=<span class="number">1</span>, value=值<span class="number">1</span>&#125;</span><br><span class="line">09:<span class="number">42</span>:<span class="number">50.552</span> c.MessageQueue [消费者] - 队列为空, 消费者线程等待</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="10-Park-Unpark">10. Park &amp; Unpark</h2><p>基本使用</p><p>它们是 LockSupport 类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park(); </span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure><div class="tabs" id="549b0847-55b6-44cd-b3e9-c4a1bb32a189"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#549b0847-55b6-44cd-b3e9-c4a1bb32a189-1"><i class="fas fa-atom"></i>先 park 再 unpark</button></li><li class="tab"><button type="button" data-href="#549b0847-55b6-44cd-b3e9-c4a1bb32a189-2"><i class="far fa-sun"></i>输出</button></li><li class="tab"><button type="button" data-href="#549b0847-55b6-44cd-b3e9-c4a1bb32a189-3"><i class="fas fa-wind"></i>先 unpark 再 park</button></li><li class="tab"><button type="button" data-href="#549b0847-55b6-44cd-b3e9-c4a1bb32a189-4"><i class="fas fa-fire-alt"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="549b0847-55b6-44cd-b3e9-c4a1bb32a189-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="549b0847-55b6-44cd-b3e9-c4a1bb32a189-2"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18:42:52.585 c.TestParkUnpark [t1] - start... </span><br><span class="line">18:42:53.589 c.TestParkUnpark [t1] - park... </span><br><span class="line">18:42:54.583 c.TestParkUnpark [main] - unpark... </span><br><span class="line">18:42:54.583 c.TestParkUnpark [t1] - resume... </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="549b0847-55b6-44cd-b3e9-c4a1bb32a189-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="549b0847-55b6-44cd-b3e9-c4a1bb32a189-4"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18:43:50.765 c.TestParkUnpark [t1] - start... </span><br><span class="line">18:43:51.764 c.TestParkUnpark [main] - unpark... </span><br><span class="line">18:43:52.769 c.TestParkUnpark [t1] - park... </span><br><span class="line">18:43:52.769 c.TestParkUnpark [t1] - resume... </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>特点</p><blockquote><p>与 Object 的 wait &amp; notify 相比</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll  是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li></ul></blockquote><h3 id="10-1-原理之park和unpark">10.1 原理之park和unpark</h3><p>每个线程都有自己的一个 Parker 对象(由C++编写，java中不可见)，由三部分组成<code>_counter</code>，<code>_cond</code>和<code>_mutex</code>打个比喻</p><ul><li>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中 的备用干粮（0 为耗尽，1 为充足）</li><li>调用 park 就是要看需不需要停下来歇息<ul><li>如果备用干粮耗尽，那么钻进帐篷歇息</li><li>如果备用干粮充足，那么不需停留，继续前进</li></ul></li><li>调用 unpark，就好比令干粮充足<ul><li>如果这时线程还在帐篷，就唤醒让他继续前进</li><li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进<ul><li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li></ul></li></ul></li></ul><div class="tabs" id="39df6706-9f63-496c-b263-5bd8ebeacb7f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#39df6706-9f63-496c-b263-5bd8ebeacb7f-1"><i class="fas fa-cat"></i>情况一</button></li><li class="tab"><button type="button" data-href="#39df6706-9f63-496c-b263-5bd8ebeacb7f-2"><i class="fas fa-horse"></i>情况二</button></li><li class="tab"><button type="button" data-href="#39df6706-9f63-496c-b263-5bd8ebeacb7f-3"><i class="fas fa-dove"></i>情况三</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="39df6706-9f63-496c-b263-5bd8ebeacb7f-1"><ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量阻塞</li><li>设置 _counter = 0</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220304144415441.png" alt="image-20220304144415441"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="39df6706-9f63-496c-b263-5bd8ebeacb7f-2"><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 恢复运行</li><li>设置 _counter 为 0</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220304144548871.png" alt="image-20220304144548871"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="39df6706-9f63-496c-b263-5bd8ebeacb7f-3"><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li><li>设置 _counter 为 0</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220304144626180.png" alt="image-20220304144626180"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="11-重新理解线程状态转换">11. 重新理解线程状态转换</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220304151245960.png" alt="image-20220304151245960"></p><p>假设有线程<code>Thread t</code></p><div class="tabs" id="cc24504c-fd6f-4944-8865-bde78ce984ad"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-3"><i class="fas fa-dove"></i>3</button></li><li class="tab"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-4"><i class="fas fa-dragon"></i>4</button></li><li class="tab"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-5"><i class="fas fa-atom"></i>5</button></li><li class="tab"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-6"><i class="far fa-sun"></i>6</button></li><li class="tab"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-7"><i class="fas fa-wind"></i>7</button></li><li class="tab"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-8"><i class="fas fa-fire-alt"></i>8</button></li><li class="tab"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-9"><i class="fab fa-apple"></i>9</button></li><li class="tab"><button type="button" data-href="#cc24504c-fd6f-4944-8865-bde78ce984ad-10"><i class="fas fa-tree"></i>10</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="cc24504c-fd6f-4944-8865-bde78ce984ad-1"><p>NEW-&gt;RUNNABLE</p><p>当调用<code>t.start()</code>方法时，由 NEW --&gt; RUNNABLE</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc24504c-fd6f-4944-8865-bde78ce984ad-2"><p>RUNNABLE&lt;-&gt;WAITING</p><p><strong>t 线程</strong>用<code>synchronized(obj)</code>获取了对象锁后</p><ul><li>调用<code>obj.wait()</code>方法时，<strong>t 线程</strong>从<code>RUNNABLE --&gt; WAITING</code></li><li>调用<code>obj.notify()</code>，<code>obj.notifyAll()</code>，<code>t.interrupt()</code>时<ul><li>竞争锁成功，<strong>t 线程</strong>从<code>WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，<strong>t 线程</strong>从`WAITING --&gt; BLOCKED</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc24504c-fd6f-4944-8865-bde78ce984ad-3"><p>RUNNABLE&lt;-&gt;WAITING</p><ul><li><strong>当前线程</strong>调用<code>t.join()</code>方法时，<strong>当前线程</strong>从<code>RUNNABLE --&gt; WAITING</code>注意是<strong>当前线程</strong>在<strong>t 线程对象</strong>的监视器上等待</li><li><strong>t 线程</strong>运行结束，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从<code>WAITING --&gt; RUNNABLE</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc24504c-fd6f-4944-8865-bde78ce984ad-4"><p>RUNNABLE&lt;-&gt;WAITING</p><ul><li><strong>当前线程</strong>调用<code>LockSupport.park()</code>方法会让<strong>当前线程</strong>从<code>RUNNABLE --&gt; WAITING</code></li><li>调用<code>LockSupport.unpark</code>(目标线程) 或调用了线程 的<code>interrupt()</code>，会让目标线程从<code>WAITING --&gt;  RUNNABLE</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc24504c-fd6f-4944-8865-bde78ce984ad-5"><p>RUNNABLE&lt;-&gt;TIMED_WAITING</p><p><strong>t 线程</strong>用<code>synchronized(obj)</code>获取了对象锁后</p><ul><li>调用<code>obj.wait(long n)</code>方法时，<strong>t 线程</strong>从<code>RUNNABLE --&gt; TIMED_WAITING</code></li><li><strong>t 线程</strong>等待时间超过了 n 毫秒，或调用<code>obj.notify()</code>，<code>obj.notifyAll()</code>，<code>t.interrupt()</code>时<ul><li>竞争锁成功，<strong>t 线程</strong>从<code>TIMED_WAITING --&gt; RUNNABLE</code></li><li>竞争锁失败，<strong>t 线程</strong>从<code>TIMED_WAITING --&gt; BLOCKED</code></li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc24504c-fd6f-4944-8865-bde78ce984ad-6"><p>RUNNABLE&lt;-&gt;TIMED_WAITING</p><ul><li><strong>当前线程</strong>调用<code>t.join(long n)</code>方法时，<strong>当前线程</strong>从<code>RUNNABLE --&gt; TIMED_WAITING</code>注意是当前线程在<strong>t 线程</strong>对象的监视器上等待</li><li><strong>当前线程</strong>等待时间超过了 n 毫秒，或<strong>t 线程</strong>运行结束，或调用了<strong>当前线程</strong>的<code>interrupt()</code>时，当前线程从<code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc24504c-fd6f-4944-8865-bde78ce984ad-7"><p>RUNNABLE&lt;-&gt;TIMED_WAITING</p><ul><li><strong>当前线程</strong>调用<code>Thread.sleep(long n)</code>，<strong>当前线程</strong>从<code>RUNNABLE --&gt; TIMED_WAITING</code></li><li><strong>当前线程</strong>等待时间超过了 n 毫秒，<strong>当前线程</strong>从<code>TIMED_WAITING --&gt; RUNNABLE</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc24504c-fd6f-4944-8865-bde78ce984ad-8"><p>RUNNABLE&lt;-&gt;TIMED_WAITIN</p><ul><li><strong>当前线程</strong>调用<code>LockSupport.parkNanos(long nanos)</code>或<code>LockSupport.parkUntil(long millis)</code>时，<strong>当前线程</strong>从<code>RUNNABLE --&gt; TIMED_WAITING</code></li><li>调用<code>LockSupport.unpark</code>(目标线程) 或调用了线程 的<code>interrupt()</code>，或是等待超时，会让目标线程从<code>TIMED_WAITING--&gt; RUNNABLE</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc24504c-fd6f-4944-8865-bde78ce984ad-9"><p>RUNNABLE&lt;-&gt;BLOCKED</p><ul><li><strong>t 线程</strong>用<code>synchronized(obj)</code>获取了对象锁时如果竞争失败，从<code>RUNNABLE --&gt; BLOCKED</code></li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有<code>BLOCKED</code>的线程重新竞争，如果其中 <strong>t 线程</strong>竞争 成功，从<code>BLOCKED --&gt; RUNNABLE</code>，其它失败的线程仍然<code>BLOCKED</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc24504c-fd6f-4944-8865-bde78ce984ad-10"><p>RUNNABLE&lt;-&gt;TERMINATED</p><p>当前线程所有代码运行完毕，进入<code>TERMINATED</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="12-多把锁">12. 多把锁</h2><p><strong>多把不相干的锁</strong></p><p>一间大屋子有两个功能：睡觉、学习，互不相干。</p><p>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低</p><p>解决方法是准备多个房间（多个对象锁）</p><div class="tabs" id="2e4e6892-7182-42f4-8bd2-c0a51fbe73fd"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2e4e6892-7182-42f4-8bd2-c0a51fbe73fd-1"><i class="fas fa-seedling"></i>例子</button></li><li class="tab"><button type="button" data-href="#2e4e6892-7182-42f4-8bd2-c0a51fbe73fd-2"><i class="fas fa-leaf"></i>执行&结果</button></li><li class="tab"><button type="button" data-href="#2e4e6892-7182-42f4-8bd2-c0a51fbe73fd-3"><i class="fab fa-apple"></i>改进</button></li><li class="tab"><button type="button" data-href="#2e4e6892-7182-42f4-8bd2-c0a51fbe73fd-4"><i class="fas fa-tree"></i>执行结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2e4e6892-7182-42f4-8bd2-c0a51fbe73fd-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2e4e6892-7182-42f4-8bd2-c0a51fbe73fd-2"><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigRoom</span> <span class="variable">bigRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigRoom</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    bigRoom.compute();</span><br><span class="line">&#125;,<span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    bigRoom.sleep();</span><br><span class="line">&#125;,<span class="string">&quot;小女&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12:13:54.471 [小南] c.BigRoom - study 1 小时</span><br><span class="line">12:13:55.476 [小女] c.BigRoom - sleeping 2 小时</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2e4e6892-7182-42f4-8bd2-c0a51fbe73fd-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bedRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (bedRoom) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;sleeping 2 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (studyRoom) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;study 1 小时&quot;</span>);</span><br><span class="line">            Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2e4e6892-7182-42f4-8bd2-c0a51fbe73fd-4"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12:15:35.069 [小南] c.BigRoom - study 1 小时</span><br><span class="line">12:15:35.069 [小女] c.BigRoom - sleeping 2 小时</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>将锁的粒度细分</p><ul><li>好处，是可以增强并发度</li><li>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</li><li>前提：两把锁锁住的两段代码互不相关</li></ul><h2 id="13-活跃性">13. 活跃性</h2><h3 id="13-1-死锁">13.1 死锁</h3><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁</p><p><code>t1 线程</code>获得<code>A对象</code>锁，接下来想获取<code>B对象</code>的锁</p><p><code>t2 线程</code>获得<code>B对象</code>锁，接下来想获取<code>A对象</code>的锁</p><p>例：</p><div class="tabs" id="fbfd646f-a763-4991-bacf-ad453492eaa5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fbfd646f-a763-4991-bacf-ad453492eaa5-1"><i class="fas fa-wind"></i>死锁示例</button></li><li class="tab"><button type="button" data-href="#fbfd646f-a763-4991-bacf-ad453492eaa5-2"><i class="fas fa-fire-alt"></i>定位死锁</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fbfd646f-a763-4991-bacf-ad453492eaa5-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12:22:06.962 [t2] c.TestDeadLock - lock B </span><br><span class="line">12:22:06.962 [t1] c.TestDeadLock - lock A</span><br></pre></td></tr></table></figure><p>解决方式：</p><ul><li>ReentrantLock</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fbfd646f-a763-4991-bacf-ad453492eaa5-2"><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd &gt; jps</span><br><span class="line">Picked up JAVA_TOOL_OPTIONS: -Dfile.encoding=UTF-8</span><br><span class="line">12320 Jps</span><br><span class="line">22816 KotlinCompileDaemon</span><br><span class="line">33200 TestDeadLock // JVM 进程</span><br><span class="line">11508 Main</span><br><span class="line">28468 Launcher</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmd &gt; jstack 33200</span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line"> waiting to lock monitor 0x000000000361d378 (object 0x000000076b5bf1c0, a java.lang.Object),</span><br><span class="line"> <span class="built_in">which</span> is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line"> waiting to lock monitor 0x000000000361e768 (object 0x000000076b5bf1d0, a java.lang.Object),</span><br><span class="line"> <span class="built_in">which</span> is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>避免死锁要注意加锁顺序</li><li>另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 jstack 排查</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="13-2-哲学家就餐问题">13.2 哲学家就餐问题</h3><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230331110454999.png" alt="image-20230331110454999" style="zoom:33%;" /><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li></ul><div class="tabs" id="7cbaa0d2-e3c1-4597-8593-412d0a0583fd"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7cbaa0d2-e3c1-4597-8593-412d0a0583fd-1"><i class="fas fa-seedling"></i>筷子类</button></li><li class="tab"><button type="button" data-href="#7cbaa0d2-e3c1-4597-8593-412d0a0583fd-2"><i class="fas fa-leaf"></i>哲学家类</button></li><li class="tab"><button type="button" data-href="#7cbaa0d2-e3c1-4597-8593-412d0a0583fd-3"><i class="fab fa-apple"></i>就餐</button></li><li class="tab"><button type="button" data-href="#7cbaa0d2-e3c1-4597-8593-412d0a0583fd-4"><i class="fas fa-tree"></i>检测死锁</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7cbaa0d2-e3c1-4597-8593-412d0a0583fd-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7cbaa0d2-e3c1-4597-8593-412d0a0583fd-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//　尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7cbaa0d2-e3c1-4597-8593-412d0a0583fd-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    <span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>, c1, c5).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行不多会，就执行不下去了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">33</span>:<span class="number">15.575</span> [苏格拉底] c.Philosopher - eating...</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>:<span class="number">33</span>:<span class="number">15.575</span> [亚里士多德] c.Philosopher - eating...</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>:<span class="number">33</span>:<span class="number">16.580</span> [阿基米德] c.Philosopher - eating...</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>:<span class="number">33</span>:<span class="number">17.580</span> [阿基米德] c.Philosopher - eating...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卡在这里, 不向下运行</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7cbaa0d2-e3c1-4597-8593-412d0a0583fd-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------------------------------------</span><br><span class="line">名称: 阿基米德</span><br><span class="line">状态: cn.itcast.Chopstick@<span class="number">1540e19d</span> (筷子<span class="number">1</span>) 上的BLOCKED, 拥有者: 苏格拉底</span><br><span class="line">总阻止数: <span class="number">2</span>, 总等待数: <span class="number">1</span></span><br><span class="line">堆栈跟踪:</span><br><span class="line">cn.itcast.Philosopher.run(TestDinner.java:<span class="number">48</span>)</span><br><span class="line">- 已锁定 cn.itcast.Chopstick@6d6f6e28 (筷子<span class="number">5</span>)</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">名称: 苏格拉底</span><br><span class="line">状态: cn.itcast.Chopstick@677327b6 (筷子<span class="number">2</span>) 上的BLOCKED, 拥有者: 柏拉图</span><br><span class="line">总阻止数: <span class="number">2</span>, 总等待数: <span class="number">1</span></span><br><span class="line">堆栈跟踪:</span><br><span class="line">cn.itcast.Philosopher.run(TestDinner.java:<span class="number">48</span>)</span><br><span class="line">- 已锁定 cn.itcast.Chopstick@<span class="number">1540e19d</span> (筷子<span class="number">1</span>)</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">名称: 柏拉图</span><br><span class="line">状态: cn.itcast.Chopstick@14ae5a5 (筷子<span class="number">3</span>) 上的BLOCKED, 拥有者: 亚里士多德</span><br><span class="line">总阻止数: <span class="number">2</span>, 总等待数: <span class="number">0</span></span><br><span class="line">堆栈跟踪:</span><br><span class="line">cn.itcast.Philosopher.run(TestDinner.java:<span class="number">48</span>)</span><br><span class="line">- 已锁定 cn.itcast.Chopstick@677327b6 (筷子<span class="number">2</span>)</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">名称: 亚里士多德</span><br><span class="line">状态: cn.itcast.Chopstick@7f31245a (筷子<span class="number">4</span>) 上的BLOCKED, 拥有者: 赫拉克利特</span><br><span class="line">总阻止数: <span class="number">1</span>, 总等待数: <span class="number">1</span></span><br><span class="line">堆栈跟踪:</span><br><span class="line">cn.itcast.Philosopher.run(TestDinner.java:<span class="number">48</span>)</span><br><span class="line">- 已锁定 cn.itcast.Chopstick@14ae5a5 (筷子<span class="number">3</span>)</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">名称: 赫拉克利特</span><br><span class="line">状态: cn.itcast.Chopstick@6d6f6e28 (筷子<span class="number">5</span>) 上的BLOCKED, 拥有者: 阿基米德</span><br><span class="line">总阻止数: <span class="number">2</span>, 总等待数: <span class="number">0</span></span><br><span class="line">堆栈跟踪:</span><br><span class="line">cn.itcast.Philosopher.run(TestDinner.java:<span class="number">48</span>)</span><br><span class="line">- 已锁定 cn.itcast.Chopstick@7f31245a (筷子<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情况</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="13-3-活锁">13.3 活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方式：</p><ul><li>错开线程的运行时间，使得一方不能改变另一方的结束条件。</li><li>将睡眠时间调整为随机数。</li></ul><h3 id="13-4-饥饿">13.4 饥饿</h3><p>很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题</p><p>下面我讲一下我遇到的一个线程饥饿的例子，先来看看使用顺序加锁的方式解决之前的死锁问题</p><p>线程1 尝试获取锁顺序AB</p><p>线程1 尝试获取锁顺序BA</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220304205818794.png" alt="image-20220304205818794" style="zoom:50%;" /><p>顺序加锁的解决方案</p><p>让获得锁顺序都为AB</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220304205837519.png" alt="image-20220304205837519" style="zoom:50%;" /><p>说明：</p><ul><li>顺序加锁可以解决死锁问题，但也会导致一些线程一直得不到锁，产生饥饿现象。</li><li>解决方式：ReentrantLock</li></ul><h2 id="14-ReentrantLock">14. ReentrantLock</h2><blockquote><p>lock介绍</p><p>在Synchronized锁“横行”的时代，假设现在需求是非阻塞地获取锁、响应中断地获取锁、超时地获取锁等需求的时候，Synchronized便解决不了，于是Lock便登场了。相对于 synchronized 它具备如下特点 可中断 可以设置超时时间 可以设置为公平锁 支持多个条件变量</p></blockquote><div class="tabs" id="ff5b6d3d-ca78-4547-87d7-0bc463418d20"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ff5b6d3d-ca78-4547-87d7-0bc463418d20-1"><i class="fas fa-cat"></i>主要特性</button></li><li class="tab"><button type="button" data-href="#ff5b6d3d-ca78-4547-87d7-0bc463418d20-2"><i class="fas fa-horse"></i>API</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ff5b6d3d-ca78-4547-87d7-0bc463418d20-1"><p>Lock接口提供的主要特性 (synchronized关键字所不具备的）</p><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>尝试非阻塞地获取锁</td><td>当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</td></tr><tr><td>能被中断地获取锁</td><td>与 synchronized 不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时， 中断异常将会被抛出，同时锁会被释放</td></tr><tr><td>超时获取锁</td><td>在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回。</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ff5b6d3d-ca78-4547-87d7-0bc463418d20-2"><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>void lock()</td><td>获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回</td></tr><tr><td>void lockInterruptibly()</td><td>可中断地获取锁，和 lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程</td></tr><tr><td>boolean tryLock()</td><td>尝试非阻塞的获取锁，调用该方法后立刻返回，如果能够获取则返回 true，否则返回 false</td></tr><tr><td>boolean tryLock(long time, TimeUnit unit)</td><td>超时的获取锁，当前线程在以下 3种情况下会返回：<br/>①当前线程在超时时间内获得了锁<br/>②当前线程在超时时间内被中断<br/>③超时时间结束，返回 false</td></tr><tr><td>void unlock()</td><td>释放锁</td></tr><tr><td>Condition newCondition()</td><td>获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的 wait()方法，而调用后，当前线程将释放锁</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>与 synchronized 一样，都支持可重入</p><p>基本语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁 尽量放在外面 避免由于其它方法抛出异常，导致在finally代码块中，unlock 对未加锁的对象解锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// 释放锁</span></span><br><span class="line"> reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-1-可重入">14.1 可重入</h3><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>);</span><br><span class="line">        method3();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17:59:11.862 [main] c.TestReentrant - execute method1 </span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method2 </span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method3</span><br></pre></td></tr></table></figure><h3 id="14-2-可打断">14.2 可打断</h3><p>可打断指的是处于阻塞状态等待锁的线程可以被打断等待。注意<code>lock.lockInterruptibly()</code>和<code>lock.trylock()</code>方法是可打断的,<code>lock.lock()</code>不是。可打断的意义在于避免得不到锁的线程无限制地等待下去，防止死锁的一种方式。</p><div class="tabs" id="37f6603d-8ac2-421f-949f-0cfc85b4cc9f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#37f6603d-8ac2-421f-949f-0cfc85b4cc9f-1"><i class="fas fa-cat"></i>lockInterruptibly()打断实例</button></li><li class="tab"><button type="button" data-href="#37f6603d-8ac2-421f-949f-0cfc85b4cc9f-2"><i class="fas fa-horse"></i>lockInterruptibly()打断输出</button></li><li class="tab"><button type="button" data-href="#37f6603d-8ac2-421f-949f-0cfc85b4cc9f-3"><i class="fas fa-dove"></i>lock()打断示例</button></li><li class="tab"><button type="button" data-href="#37f6603d-8ac2-421f-949f-0cfc85b4cc9f-4"><i class="fas fa-dragon"></i>lock()打断输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="37f6603d-8ac2-421f-949f-0cfc85b4cc9f-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//如果没有竞争那么此方法就会获取lock对象锁</span></span><br><span class="line">      <span class="comment">//如果有竞争就进入阻塞队列，可以被其他线程用interrupt方法打断</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37f6603d-8ac2-421f-949f-0cfc85b4cc9f-2"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">18:02:40.520 [main] c.TestInterrupt - 获得了锁</span><br><span class="line">18:02:40.524 [t1] c.TestInterrupt - 启动... </span><br><span class="line">18:02:41.530 [main] c.TestInterrupt - 执行打断</span><br><span class="line">java.lang.InterruptedException </span><br><span class="line"> at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898) </span><br><span class="line"> at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222) </span><br><span class="line"> at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) </span><br><span class="line"> at cn.itcast.n4.reentrant.TestInterrupt.lambda$main<span class="variable">$0</span>(TestInterrupt.java:17) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:748) </span><br><span class="line">18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37f6603d-8ac2-421f-949f-0cfc85b4cc9f-3"><p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37f6603d-8ac2-421f-949f-0cfc85b4cc9f-4"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18:06:56.261 [main] c.TestInterrupt - 获得了锁</span><br><span class="line">18:06:56.265 [t1] c.TestInterrupt - 启动... </span><br><span class="line">18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="line">18:06:58.267 [main] c.TestInterrupt - 释放了锁</span><br><span class="line">18:06:58.267 [t1] c.TestInterrupt - 获得了锁</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="14-3-锁超时">14.3 锁超时</h3><div class="tabs" id="d1a81628-c6ee-4779-948d-92a9b4718e79"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d1a81628-c6ee-4779-948d-92a9b4718e79-1"><i class="fas fa-cat"></i>立刻失败</button></li><li class="tab"><button type="button" data-href="#d1a81628-c6ee-4779-948d-92a9b4718e79-2"><i class="fas fa-horse"></i>超时失败</button></li><li class="tab"><button type="button" data-href="#d1a81628-c6ee-4779-948d-92a9b4718e79-3"><i class="fas fa-dragon"></i>使用 tryLock 解决哲学家就餐问题</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d1a81628-c6ee-4779-948d-92a9b4718e79-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:15:02.918 [main] c.TestTimeout - 获得了锁</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 启动... </span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d1a81628-c6ee-4779-948d-92a9b4718e79-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取等待 1s 后失败，返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:19:40.537 [main] c.TestTimeout - 获得了锁</span><br><span class="line">18:19:40.544 [t1] c.TestTimeout - 启动... </span><br><span class="line">18:19:41.547 [t1] c.TestTimeout - 获取等待 1s 后失败，返回</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d1a81628-c6ee-4779-948d-92a9b4718e79-3"><p>继承ReentrantLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="14-4-公平锁">14.4 公平锁</h3><p>ReentrantLock 默认是不公平的</p><div class="tabs" id="07b5ace6-abcd-4567-bafa-b7f987dff620"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#07b5ace6-abcd-4567-bafa-b7f987dff620-1"><i class="fas fa-atom"></i>默认:不公平锁</button></li><li class="tab"><button type="button" data-href="#07b5ace6-abcd-4567-bafa-b7f987dff620-2"><i class="fas fa-wind"></i>输出</button></li><li class="tab"><button type="button" data-href="#07b5ace6-abcd-4567-bafa-b7f987dff620-3"><i class="far fa-sun"></i>公平锁</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="07b5ace6-abcd-4567-bafa-b7f987dff620-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1s 之后去争抢锁</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start...&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;强行插入&quot;</span>).start();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="07b5ace6-abcd-4567-bafa-b7f987dff620-2"><p>强行插入，有机会在中间输出</p><blockquote><p><strong>注意</strong>：该实验不一定总能复现</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t39 running... </span><br><span class="line">t40 running... </span><br><span class="line">t41 running... </span><br><span class="line">t42 running... </span><br><span class="line">t43 running... </span><br><span class="line">强行插入 start... </span><br><span class="line">强行插入 running... </span><br><span class="line">t44 running... </span><br><span class="line">t45 running... </span><br><span class="line">t46 running... </span><br><span class="line">t47 running... </span><br><span class="line">t49 running... </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="07b5ace6-abcd-4567-bafa-b7f987dff620-3"><p>改为公平锁后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>强行插入，总是在最后输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t465 running... </span><br><span class="line">t464 running... </span><br><span class="line">t477 running... </span><br><span class="line">t442 running... </span><br><span class="line">t468 running... </span><br><span class="line">t493 running... </span><br><span class="line">t482 running... </span><br><span class="line">t485 running... </span><br><span class="line">t481 running... </span><br><span class="line">强行插入 running... </span><br></pre></td></tr></table></figure><p>公平锁一般没有必要，会降低并发度，后面分析原理时会讲解</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="14-5-条件变量">14.5 条件变量</h3><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><blockquote><p>使用要点</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul></blockquote><div class="tabs" id="dd3e5e35-f46d-4096-a5fc-234bb16f150d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dd3e5e35-f46d-4096-a5fc-234bb16f150d-1"><i class="fas fa-cat"></i>详细API</button></li><li class="tab"><button type="button" data-href="#dd3e5e35-f46d-4096-a5fc-234bb16f150d-2"><i class="fas fa-horse"></i>示例</button></li><li class="tab"><button type="button" data-href="#dd3e5e35-f46d-4096-a5fc-234bb16f150d-3"><i class="fas fa-dove"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dd3e5e35-f46d-4096-a5fc-234bb16f150d-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up one waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up all waiting threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dd3e5e35-f46d-4096-a5fc-234bb16f150d-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//等待烟的休息室</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">//等待外卖的休息室</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitbreakfastQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasCigrette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasBreakfast</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitCigaretteQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的烟&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasBreakfast) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitbreakfastQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的早餐&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendBreakfast();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendCigarette();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendCigarette</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送烟来了&quot;</span>);</span><br><span class="line">        hasCigrette = <span class="literal">true</span>;</span><br><span class="line">        waitCigaretteQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendBreakfast</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送早餐来了&quot;</span>);</span><br><span class="line">        hasBreakfast = <span class="literal">true</span>;</span><br><span class="line">        waitbreakfastQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dd3e5e35-f46d-4096-a5fc-234bb16f150d-3"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18:52:27.680 [main] c.TestCondition - 送早餐来了</span><br><span class="line">18:52:27.682 [Thread-1] c.TestCondition - 等到了它的早餐</span><br><span class="line">18:52:28.683 [main] c.TestCondition - 送烟来了</span><br><span class="line">18:52:28.683 [Thread-0] c.TestCondition - 等到了它的烟</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="14-6-同步模式之顺序控制">14.6 同步模式之顺序控制</h3><h4 id="14-6-1-固定输出顺序">14.6.1 固定输出顺序</h4><p>比如，必须先 2 后 1 打印</p><div class="tabs" id="2bc8ea38-6300-4d31-b849-4925d1756110"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2bc8ea38-6300-4d31-b849-4925d1756110-1"><i class="fas fa-cat"></i>wait notify 版</button></li><li class="tab"><button type="button" data-href="#2bc8ea38-6300-4d31-b849-4925d1756110-2"><i class="fas fa-horse"></i>Park Unpark 版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2bc8ea38-6300-4d31-b849-4925d1756110-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来同步的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// t2 运行标记， 代表 t2 是否执行过</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">t2runed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 如果 t2 没有执行过</span></span><br><span class="line">            <span class="keyword">while</span> (!t2runed) &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// t1 先等一会</span></span><br><span class="line">                    obj.wait(); </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// 修改运行标记</span></span><br><span class="line">            t2runed = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 通知 obj 上等待的线程（可能有多个，因此需要用 notifyAll）</span></span><br><span class="line">            obj.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bc8ea38-6300-4d31-b849-4925d1756110-2"><p>可以看到，实现上很麻烦：</p><ul><li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该 wait</li><li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决 此问题</li><li>最后，唤醒对象上的 wait 线程需要使用 notifyAll，因为『同步对象』上的等待线程可能不止一个</li></ul><p>可以使用 LockSupport 类的 park 和 unpark 来简化上面的题目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">    <span class="comment">// 当没有『许可』时，当前线程暂停运行；有『许可』时，用掉这个『许可』，当前线程恢复运行</span></span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span></span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』， 不需要『同步对象』和『运行标记』</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="14-6-2-交替输出顺序">14.6.2 交替输出顺序</h4><p>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</p><div class="tabs" id="fb0c53f1-b17f-443c-b9b2-f7a444fd474f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fb0c53f1-b17f-443c-b9b2-f7a444fd474f-1"><i class="fas fa-dove"></i>wait notify 版</button></li><li class="tab"><button type="button" data-href="#fb0c53f1-b17f-443c-b9b2-f7a444fd474f-2"><i class="fas fa-dragon"></i>Lock 条件变量版</button></li><li class="tab"><button type="button" data-href="#fb0c53f1-b17f-443c-b9b2-f7a444fd474f-3"><i class="fas fa-atom"></i>Park Unpark 版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fb0c53f1-b17f-443c-b9b2-f7a444fd474f-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SyncWaitNotify</span> <span class="variable">syncWaitNotify</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncWaitNotify</span>(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输出内容       等待标记     下一个标记</span></span><br><span class="line"><span class="comment">         a           1             2</span></span><br><span class="line"><span class="comment">         b           2             3</span></span><br><span class="line"><span class="comment">         c           3             1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            syncWaitNotify.print(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            syncWaitNotify.print(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            syncWaitNotify.print(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncWaitNotify</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> flag;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SyncWaitNotify</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.flag = flag;</span><br><span class="line">            <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> waitFlag, <span class="type">int</span> nextFlag, String str)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="built_in">this</span>.flag != waitFlag) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="built_in">this</span>.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(str);</span><br><span class="line">                    flag = nextFlag;</span><br><span class="line">                    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fb0c53f1-b17f-443c-b9b2-f7a444fd474f-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AwaitSignal</span> <span class="variable">as</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">aWaitSet</span> <span class="operator">=</span> as.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">bWaitSet</span> <span class="operator">=</span> as.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">cWaitSet</span> <span class="operator">=</span> as.newCondition();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            as.print(<span class="string">&quot;a&quot;</span>, aWaitSet, bWaitSet);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            as.print(<span class="string">&quot;b&quot;</span>, bWaitSet, cWaitSet);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            as.print(<span class="string">&quot;c&quot;</span>, cWaitSet, aWaitSet);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        as.start(aWaitSet);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Condition first)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">            first.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition current, Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();</span><br><span class="line">                log.debug(str);</span><br><span class="line">                next.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignal</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>该实现没有考虑 a，b，c 线程都就绪再开始</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fb0c53f1-b17f-443c-b9b2-f7a444fd474f-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SyncPark</span> <span class="variable">syncPark</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncPark</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            syncPark.print(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            syncPark.print(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            syncPark.print(<span class="string">&quot;c\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        syncPark.setThreads(t1, t2, t3);</span><br><span class="line">        syncPark.start();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SyncPark</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNumber;</span><br><span class="line">    <span class="keyword">private</span> Thread[] threads;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SyncPark</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNumber = loopNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setThreads</span><span class="params">(Thread... threads)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threads = threads;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.print(str);</span><br><span class="line">            LockSupport.unpark(nextThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Thread <span class="title function_">nextThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(threads[i] == current) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; threads.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> threads[index+<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> threads[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(threads[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> ]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.Java线程</title>
      <link href="/posts/766dd8c2.html"/>
      <url>/posts/766dd8c2.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建和运行线程">1. 创建和运行线程</h2><h3 id="1-1-使用-Thread">1.1 使用 Thread</h3><div class="tabs" id="codetabs1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#codetabs1-1"><i class="fas fa-seedling"></i>代码</button></li><li class="tab"><button type="button" data-href="#codetabs1-2"><i class="fas fa-leaf"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="codetabs1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法的参数是给线程指定名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// run 方法内实现了要执行的任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="codetabs1-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">19</span>:<span class="number">00</span> [t1] c.ThreadStarter - hello</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="1-2-Runnable-配合-Thread">1.2 Runnable 配合 Thread</h3><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><div class="tabs" id="codetabs2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#codetabs2-1"><i class="fas fa-seedling"></i>代码</button></li><li class="tab"><button type="button" data-href="#codetabs2-2"><i class="fas fa-leaf"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="codetabs2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="codetabs2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">19</span>:<span class="number">00</span> [t2] c.ThreadStarter - hello</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>Java 8 以后可以使用 lambda 精简代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><span class='p green'>原理之Thread与Runnable的关系：</span> <div class="tabs" id="codetabs3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#codetabs3-1"><i class="fas fa-seedling"></i>构造函数</button></li><li class="tab"><button type="button" data-href="#codetabs3-2"><i class="fas fa-leaf"></i>init函数</button></li><li class="tab"><button type="button" data-href="#codetabs3-3"><i class="fab fa-apple"></i>run函数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="codetabs3-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">---</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target, String name)</span> &#123;</span><br><span class="line">        init(<span class="literal">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="codetabs3-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.target=target;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="codetabs3-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">       target.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>小结</p><ul><li>方法1 是把线程和任务合并在了一起方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="1-3-FutureTask-配合-Thread">1.3 FutureTask 配合 Thread</h3><p>详细内容可见另一篇文章：</p><div class="tag link"><a class="link-card" title="CompletableFuture" href="/posts/2400b711.html"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_9.webp"/></div><div class="right"><p class="text">CompletableFuture</p><p class="url">/posts/2400b711.html</p></div></a></div><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><div class="tabs" id="codetabs4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#codetabs4-1"><i class="fas fa-seedling"></i>代码</button></li><li class="tab"><button type="button" data-href="#codetabs4-2"><i class="fas fa-leaf"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="codetabs4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task3.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="codetabs4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">22</span>:<span class="number">27</span> [t3] c.ThreadStarter - hello</span><br><span class="line"><span class="number">19</span>:<span class="number">22</span>:<span class="number">27</span> [main] c.ThreadStarter - 结果是:<span class="number">100</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-查看进程线程的方法">2. 查看进程线程的方法</h2><div class="tabs" id="codetabs5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#codetabs5-1"><i class="fas fa-seedling"></i>windows</button></li><li class="tab"><button type="button" data-href="#codetabs5-2"><i class="fas fa-leaf"></i>Linux</button></li><li class="tab"><button type="button" data-href="#codetabs5-3"><i class="fab fa-apple"></i>Java</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="codetabs5-1"><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程<br>-<code>tasklist</code>|<code>findstr</code>(查找关键字)</li><li>taskkill 杀死进程<ul><li>taskkill /F(彻底杀死）/PID(进程PID)</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="codetabs5-2"><ul><li>ps -fe 查看所有进程</li><li>ps -fT -p  查看某个进程（PID）的所有线程</li><li>kill 杀死进程</li><li>top 动态监视进程</li><li>top -H -p  查看某个进程（PID）的所有线程信息</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="codetabs5-3"><ul><li>jps 命令查看所有 Java 进程</li><li>jstack  查看某个 Java 进程（PID）的所有线程状态</li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h2 id="3-原理之线程运行">3. 原理之线程运行</h2><span class='p red'>栈与栈帧</span> <p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><span class='p red'>线程上下文切换（Thread Context Switch）</span>  <p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h2 id="4-常见方法">4. 常见方法</h2><table><thead><tr><th style="text-align:center">方法</th><th>功能</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center"><strong>public void start()</strong></td><td>启动一个新线程；Java虚拟机调用此线程的run方法</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻 运行（CPU 的时间片还没分给它）。每个线程对象的 start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException</td></tr><tr><td style="text-align:center"><strong>public void run()</strong></td><td>线程启动后调用该方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默 认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为</td></tr><tr><td style="text-align:center"><strong>public void setName(String name)</strong></td><td>给当前线程取名字</td><td></td></tr><tr><td style="text-align:center"><strong>public void getName()</strong></td><td>获取当前线程的名字。线程存在默认名称：子线程是Thread-索引，主线程是main</td><td></td></tr><tr><td style="text-align:center"><strong>public static Thread currentThread()</strong></td><td>获取当前线程对象，代码在哪个线程中执行</td><td></td></tr><tr><td style="text-align:center"><strong>public static void sleep(long time)</strong></td><td>让当前线程休眠多少毫秒再继续执行。<strong>Thread.sleep(0)</strong> : 让操作系统立刻重新进行一次cpu竞争</td><td></td></tr><tr><td style="text-align:center"><strong>public static native void yield()</strong></td><td>提示线程调度器让出当前线程对CPU的使用</td><td>主要是为了测试和调试</td></tr><tr><td style="text-align:center"><strong>public final int getPriority()</strong></td><td>返回此线程的优先级</td><td></td></tr><tr><td style="text-align:center"><strong>public final void setPriority(int priority)</strong></td><td>更改此线程的优先级，常用1 5 10</td><td>java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率</td></tr><tr><td style="text-align:center"><strong>public void interrupt()</strong></td><td>中断这个线程，异常处理机制</td><td></td></tr><tr><td style="text-align:center"><strong>public static boolean interrupted()</strong></td><td>判断当前线程是否被打断，清除打断标记</td><td></td></tr><tr><td style="text-align:center"><strong>public boolean isInterrupted()</strong></td><td>判断当前线程是否被打断，不清除打断标记</td><td></td></tr><tr><td style="text-align:center"><strong>public final void join()</strong></td><td>等待这个线程结束</td><td></td></tr><tr><td style="text-align:center"><strong>public final void join(long millis)</strong></td><td>等待这个线程死亡millis毫秒，0意味着永远等待</td><td></td></tr><tr><td style="text-align:center"><strong>public final native boolean isAlive()</strong></td><td>线程是否存活（还没有运行完毕）</td><td></td></tr><tr><td style="text-align:center"><strong>public final void setDaemon(boolean on)</strong></td><td>将此线程标记为守护线程或用户线程</td><td></td></tr><tr><td style="text-align:center"><strong>public long getId()</strong></td><td>获取线程长整型 的 id</td><td>id 唯一</td></tr><tr><td style="text-align:center"><strong>public state getState()</strong></td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING,  TIMED_WAITING, TERMINATED</td></tr><tr><td style="text-align:center"><strong>public boolean isInterrupted()</strong></td><td>判断是否被打断</td><td>不会清除 打断标记</td></tr></tbody></table><h3 id="4-1-start-与-run">4.1 start 与 run</h3><div class="tabs" id="37a7a653-d3c7-430b-9d4c-4ae74634c993"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#37a7a653-d3c7-430b-9d4c-4ae74634c993-1"><i class="fas fa-seedling"></i>调用run</button></li><li class="tab"><button type="button" data-href="#37a7a653-d3c7-430b-9d4c-4ae74634c993-2"><i class="fas fa-leaf"></i>调用 start</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="37a7a653-d3c7-430b-9d4c-4ae74634c993-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">        FileReader.read(Constants.MP4_FULL_PATH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t1.run();</span><br><span class="line">log.debug(<span class="string">&quot;do other things...&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">39</span>:<span class="number">14</span> [main] c.TestStart - main</span><br><span class="line"><span class="number">19</span>:<span class="number">39</span>:<span class="number">14</span> [main] c.FileReader - read [<span class="number">1.</span>mp4] start ...</span><br><span class="line"><span class="number">19</span>:<span class="number">39</span>:<span class="number">18</span> [main] c.FileReader - read [<span class="number">1.</span>mp4] end ... cost: <span class="number">4227</span> ms</span><br><span class="line"><span class="number">19</span>:<span class="number">39</span>:<span class="number">18</span> [main] c.TestStart - <span class="keyword">do</span> other things ...</span><br></pre></td></tr></table></figure><p>程序仍在 main 线程运行， FileReader.read() 方法调用还是同步的</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37a7a653-d3c7-430b-9d4c-4ae74634c993-2"><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="built_in">new</span> Thread(&quot;t1&quot;) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">log</span>.<span class="keyword">debug</span>(&quot;running...&quot;);</span><br><span class="line">        FileReader.<span class="keyword">read</span>(Constants.MP4_FULL_PATH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">t1.<span class="keyword">start</span>();</span><br><span class="line"><span class="keyword">log</span>.<span class="keyword">debug</span>(&quot;do other things...&quot;);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">30</span> [main] c.TestStart - <span class="keyword">do</span> other things ...</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">30</span> [t1] c.TestStart - t1</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">30</span> [t1] c.FileReader - read [<span class="number">1.</span>mp4] start ...</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">35</span> [t1] c.FileReader - read [<span class="number">1.</span>mp4] end ... cost: <span class="number">4542</span> ms</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>程序在 t1 线程运行， FileReader.read() 方法调用是异步的</p><p>小结</p><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程使用</li><li>start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul><h3 id="4-2-sleep-与-yield">4.2 sleep 与 yield</h3> <span class='p red'>sleep</span><ol><li><p>调用 sleep 会让当前线程从<code>Running</code>进入<code>Timed Waiting</code>状态（阻塞）</p></li><li><p>其它线程可以使用<code>interrupt</code>方法打断正在睡眠的线程，这时 sleep 方法会抛出<code>InterruptedException</code></p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p></li></ol><div class="tabs" id="3b3240a2-7334-448d-a058-86575d758a4a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3b3240a2-7334-448d-a058-86575d758a4a-1"><i class="fas fa-seedling"></i>sleep</button></li><li class="tab"><button type="button" data-href="#3b3240a2-7334-448d-a058-86575d758a4a-2"><i class="fas fa-leaf"></i>interrupt</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3b3240a2-7334-448d-a058-86575d758a4a-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line">log.debug(<span class="string">&quot;t1 state: &#123;&#125;&quot;</span>, t1.getState());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">log.debug(<span class="string">&quot;t1 state: &#123;&#125;&quot;</span>, t1.getState());</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">48</span>:<span class="number">28.583</span> c.Test6 [main] - t1 state: RUNNABLE</span><br><span class="line"><span class="number">19</span>:<span class="number">48</span>:<span class="number">29.093</span> c.Test6 [main] - t1 state: TIMED_WAITING</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3b3240a2-7334-448d-a058-86575d758a4a-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;enter sleep...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;wake up...&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">log.debug(<span class="string">&quot;interrupt...&quot;</span>);</span><br><span class="line">t1.interrupt();</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">47</span>:<span class="number">28.034</span> c.Test7 [t1] - enter sleep...</span><br><span class="line"><span class="number">19</span>:<span class="number">47</span>:<span class="number">29.035</span> c.Test7 [main] - interrupt...</span><br><span class="line"><span class="number">19</span>:<span class="number">47</span>:<span class="number">29.036</span> c.Test7 [t1] - wake up...</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">  at java.lang.Thread.sleep(Native Method)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <span class='p red'>yield</span><ol><li>调用 yield 会让当前线程从<code>Running</code>进入<code>Runnable</code>就绪状，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><span class='p red'>线程优先级</span> <ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><hr><span class='p green'>应用->限制对 CPU 的使用:sleep实现</span><p>在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权给其他程序</p><div class="tabs" id="77ec7c60-8160-4630-b5cd-b0877ffaa8eb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#77ec7c60-8160-4630-b5cd-b0877ffaa8eb-1"><i class="fas fa-seedling"></i>不加sleep</button></li><li class="tab"><button type="button" data-href="#77ec7c60-8160-4630-b5cd-b0877ffaa8eb-2"><i class="fas fa-leaf"></i>加了sleep</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="77ec7c60-8160-4630-b5cd-b0877ffaa8eb-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Thread.sleep(50);</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230328202021650.png" alt="image-20230328202021650"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="77ec7c60-8160-4630-b5cd-b0877ffaa8eb-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230328202215363.png" alt="image-20230328202215363"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>对比差距明显 前：CPU占用率达到98% 后：CPU占用率仅为4%</p><ul><li>可以用 wait 或 条件变量达到类似的效果</li><li>不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景</li><li>sleep 适用于无需锁同步的场景</li></ul><h3 id="4-3-join">4.3 join</h3><h4 id="4-3-1-为什么需要-join？">4.3.1 为什么需要 join？</h4><p>join():等待这个线程结束</p><p>下面的代码执行，打印 r 是什么？<div class="tabs" id="e86601f4-66de-4283-b742-f4fc07296e30"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e86601f4-66de-4283-b742-f4fc07296e30-1"><i class="fas fa-seedling"></i>无join</button></li><li class="tab"><button type="button" data-href="#e86601f4-66de-4283-b742-f4fc07296e30-2"><i class="fas fa-leaf"></i>join后</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e86601f4-66de-4283-b742-f4fc07296e30-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">//t1.join();</span></span><br><span class="line">    log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">57.122</span> c.Test10 [main] - 开始</span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">57.208</span> c.Test10 [t1] - 开始</span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">57.208</span> c.Test10 [main] - 结果为:<span class="number">0</span></span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">57.215</span> c.Test10 [main] - 结束</span><br><span class="line"><span class="number">20</span>:<span class="number">31</span>:<span class="number">58.218</span> c.Test10 [t1] - 结束</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e86601f4-66de-4283-b742-f4fc07296e30-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">32</span>:<span class="number">24.676</span> c.Test10 [main] - 开始</span><br><span class="line"><span class="number">20</span>:<span class="number">32</span>:<span class="number">24.760</span> c.Test10 [t1] - 开始</span><br><span class="line"><span class="number">20</span>:<span class="number">32</span>:<span class="number">25.769</span> c.Test10 [t1] - 结束</span><br><span class="line"><span class="number">20</span>:<span class="number">32</span>:<span class="number">25.770</span> c.Test10 [main] - 结果为:<span class="number">10</span></span><br><span class="line"><span class="number">20</span>:<span class="number">32</span>:<span class="number">25.775</span> c.Test10 [main] - 结束</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p>分析</p><ul><li>因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10</li><li>而主线程一开始就要打印 r 的结果，所以只能打印出 r=0</li></ul><p>解决方法</p><ul><li>用 sleep，睡眠时间不太好把握</li><li>用 join，加在 t1.start() 之后即可</li></ul><span class='p green'>应用之同步</span> <p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20220224020718153.png" alt="image-20220224020718153"></p><span class='p blue'>等待多个结果</span> <p>问，下面代码 cost 大约多少秒？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        r2 = <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">&quot;join begin&quot;</span>);</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;t1 join end&quot;</span>);</span><br><span class="line">    t1.join();</span><br><span class="line">    log.debug(<span class="string">&quot;t2 join end&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>分析如下</p><ul><li>第一个 join：等待 t1 时, t2 并没有停止, 而在运行</li><li>第二个 join：1s 后, 执行到此, t2 也运行了 1s, 因此也只需再等待 1s</li></ul><p>如果颠倒两个 join 呢？</p><p>最终都是输出</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">20:50:36.894 c.TestJoin [main] - <span class="built_in">join</span> begin</span><br><span class="line">20:50:37.897 c.TestJoin [main] - t1 <span class="built_in">join</span> end</span><br><span class="line">20:50:38.896 c.TestJoin [main] - t2 <span class="built_in">join</span> end</span><br><span class="line">20:50:38.897 c.TestJoin [main] - r1: 10 r2: 20 cost: 2012</span><br></pre></td></tr></table></figure><h4 id="4-3-2-有时效的join">4.3.2 有时效的join</h4><p><code>public final void join(long millis)</code></p><div class="tabs" id="92e88be6-bfba-468b-90c6-0a618f0a04f0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#92e88be6-bfba-468b-90c6-0a618f0a04f0-1"><i class="fas fa-seedling"></i>当线程执行时间没有超过join设定时间</button></li><li class="tab"><button type="button" data-href="#92e88be6-bfba-468b-90c6-0a618f0a04f0-2"><i class="fas fa-leaf"></i>当执行时间超时join设定时间</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="92e88be6-bfba-468b-90c6-0a618f0a04f0-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// 线程执行结束会导致 join 结束</span></span><br><span class="line">    t1.join(<span class="number">1500</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">48</span>:<span class="number">01.320</span> [main] c.TestJoin - r1: <span class="number">10</span> r2: <span class="number">0</span> cost: <span class="number">1010</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="92e88be6-bfba-468b-90c6-0a618f0a04f0-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test3();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// 线程执行结束会导致 join 结束</span></span><br><span class="line">    t1.join(<span class="number">1500</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">52</span>:<span class="number">15.623</span> [main] c.TestJoin - r1: <span class="number">0</span> r2: <span class="number">0</span> cost: <span class="number">1502</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <h3 id="4-4-interrupt方法详解">4.4 interrupt方法详解</h3><blockquote><p>interrupt() 中断这个线程，异常处理机制</p><p>isInterrupted() 判断是否被打断，不会清除打断标记</p><p>interrupted() 判断当前线程是否被打断，会清除打断标记</p></blockquote><h4 id="4-4-1-Interrupt说明">4.4.1 Interrupt说明</h4><p><code>interrupt</code>的本质是将线程的打断标记设为true，并调用线程的三个parker对象（C++实现级别）unpark该线程。</p><p>基于以上本质，有如下说明：</p><ul><li>打断线程不等于中断线程，有以下两种情况：<ul><li>打断正在运行中的线程并不会影响线程的运行，但如果线程监测到了打断标记为true，可以自行决定后续处理。</li><li>打断阻塞中的线程会让此线程产生一个<code>InterruptedException</code>异常，结束线程的运行。但如果该异常被线程捕获住，该线程依然可以自行决定后续处理（终止运行，继续运行，做一些善后工作等等）</li></ul></li></ul><div class="tabs" id="49a6a199-6c57-4024-96bf-35414686bad9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#49a6a199-6c57-4024-96bf-35414686bad9-1"><i class="fas fa-seedling"></i>打断sleep，wait，join 的线程</button></li><li class="tab"><button type="button" data-href="#49a6a199-6c57-4024-96bf-35414686bad9-2"><i class="fas fa-leaf"></i>打断正常运行的线程</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="49a6a199-6c57-4024-96bf-35414686bad9-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line"> at java.lang.Thread.sleep(Native Method)</span><br><span class="line"> at java.lang.Thread.sleep(Thread.java:<span class="number">340</span>)</span><br><span class="line"> at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line"> at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class="number">8</span>)</span><br><span class="line"> at cn.itcast.n4.TestInterrupt.lambda$test1$<span class="number">3</span>(TestInterrupt.java:<span class="number">59</span>)</span><br><span class="line"> at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">18</span>:<span class="number">10.374</span> [main] c.TestInterrupt - 打断状态: <span class="literal">false</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="49a6a199-6c57-4024-96bf-35414686bad9-2"><p>打断正常运行的线程, 不会清空打断状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">57</span>:<span class="number">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class="literal">true</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><span class='p yellow'>模式->两阶段终止</span><p>Two Phase Termination</p><p>在一个线程 T1 中如何“优雅”终止线程 T2？</p><p>这里的【优雅】指的是给 T2 一个料理后事的机会。</p><p>错误思路</p><ul><li>使用线程对象的 stop() 方法停止线程<ul><li>stop 方法会真正杀死线程，会立即释放CPU资源和释放锁,强行把执行到一半的线程终止，是不安全的,可能会导致数据不同步和一些清理性的工作得不到完成</li></ul></li><li>使用 System.exit(int) 方法停止线程<ul><li>目的仅是停止一个线程，但这种做法会让整个程序都停止</li></ul></li></ul><div class="tabs" id="0467aa06-fc60-4b4f-b765-2f69cae104e4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0467aa06-fc60-4b4f-b765-2f69cae104e4-1"><i class="fas fa-seedling"></i>代码</button></li><li class="tab"><button type="button" data-href="#0467aa06-fc60-4b4f-b765-2f69cae104e4-2"><i class="fas fa-leaf"></i>调用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0467aa06-fc60-4b4f-b765-2f69cae104e4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TPTInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  <span class="comment">//重新设置打断标记</span></span><br><span class="line">                    current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行监控操作 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0467aa06-fc60-4b4f-b765-2f69cae104e4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TPTInterrupt</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPTInterrupt</span>();</span><br><span class="line">t.start();</span><br><span class="line">Thread.sleep(<span class="number">3500</span>);</span><br><span class="line">log.debug(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">t.stop();</span><br></pre></td></tr></table></figure><p>结果：</p><p>正常情况被打断：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11:49:42.915 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:43.919 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:44.919 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:45.413 c.TestTwoPhaseTermination [main] - stop </span><br><span class="line">11:49:45.413 c.TwoPhaseTermination [监控线程] - 料理后事</span><br></pre></td></tr></table></figure><p>Sleep情况被打断：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">11:49:42.915 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:43.919 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">11:49:44.919 c.TwoPhaseTermination [监控线程] - 将结果保存</span><br><span class="line">java.lang.InterruptedException: <span class="built_in">sleep</span> interrupted</span><br><span class="line"> at java.lang.Thread.<span class="built_in">sleep</span>(Native Method)</span><br><span class="line"> ...</span><br><span class="line">11:49:45.413 c.TwoPhaseTermination [监控线程] - 料理后事</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230328220322812.png" alt="image-20230328220322812"></p><h3 id="4-5-不推荐的方法">4.5 不推荐的方法</h3><p>还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">static</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">stop()</td><td style="text-align:center"></td><td style="text-align:center">停止线程运行</td></tr><tr><td style="text-align:center">suspend()</td><td style="text-align:center"></td><td style="text-align:center">挂起（暂停）线程运行</td></tr><tr><td style="text-align:center">resume()</td><td style="text-align:center"></td><td style="text-align:center">恢复线程运行</td></tr></tbody></table><h2 id="5-主线程与守护线程">5. 主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><p>例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">     log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line">     sleep(<span class="number">2</span>);</span><br><span class="line">     log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;daemon&quot;</span>);</span><br><span class="line"><span class="comment">// 设置该线程为守护线程</span></span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">08:26:38.123 [main] c.TestDaemon - 开始运行... </span><br><span class="line">08:26:38.213 [daemon] c.TestDaemon - 开始运行... </span><br><span class="line">08:26:39.215 [main] c.TestDaemon - 运行结束... </span><br></pre></td></tr></table></figure><blockquote><p>注意</p><ul><li>垃圾回收器线程就是一种守护线程</li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul></blockquote><h2 id="6-线程状态模型">6. 线程状态模型</h2><h3 id="6-1-五种状态">6.1 五种状态</h3><p>这是从<code>操作系统</code>层面来描述的</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230328225841170.png" alt="image-20230328225841170"></p><ul><li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</li><li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li><li>【运行状态】指获取了 CPU 时间片运行中的状态<ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li>【阻塞状态】<ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 调度它们</li></ul></li><li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ul><h3 id="6-2-六种状态">6.2 六种状态</h3><p>这是从<code>Java API</code>层面来描述的</p><p>根据 Thread.State 枚举，分为六种状态</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230328225953696.png" alt="image-20230328225953696"></p><ul><li>NEW 线程刚被创建，但是还没有调用 start() 方法</li><li>RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li><li>BLOCKED ， WAITING ， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节 详述</li><li>TERMINATED 当线程代码运行结束</li></ul><div class="tabs" id="0091ddbb-7624-40c0-b929-7f012b5c82d6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0091ddbb-7624-40c0-b929-7f012b5c82d6-1">NEW</button></li><li class="tab"><button type="button" data-href="#0091ddbb-7624-40c0-b929-7f012b5c82d6-2">RUNNABLE</button></li><li class="tab"><button type="button" data-href="#0091ddbb-7624-40c0-b929-7f012b5c82d6-3">TERMINATED</button></li><li class="tab"><button type="button" data-href="#0091ddbb-7624-40c0-b929-7f012b5c82d6-4">TIMED_WAITING</button></li><li class="tab"><button type="button" data-href="#0091ddbb-7624-40c0-b929-7f012b5c82d6-5">WAITING</button></li><li class="tab"><button type="button" data-href="#0091ddbb-7624-40c0-b929-7f012b5c82d6-6">BLOCKED</button></li><li class="tab"><button type="button" data-href="#0091ddbb-7624-40c0-b929-7f012b5c82d6-7">输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0091ddbb-7624-40c0-b929-7f012b5c82d6-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">log.debug(<span class="string">&quot;t1 state &#123;&#125;&quot;</span>, t1.getState());</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0091ddbb-7624-40c0-b929-7f012b5c82d6-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t2.start();</span><br><span class="line">log.debug(<span class="string">&quot;t2 state &#123;&#125;&quot;</span>, t2.getState());</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0091ddbb-7624-40c0-b929-7f012b5c82d6-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t3.start();</span><br><span class="line">log.debug(<span class="string">&quot;t3 state &#123;&#125;&quot;</span>, t3.getState());</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0091ddbb-7624-40c0-b929-7f012b5c82d6-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestState.class) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000000</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t4.start();</span><br><span class="line">log.debug(<span class="string">&quot;t4 state &#123;&#125;&quot;</span>, t4.getState());</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0091ddbb-7624-40c0-b929-7f012b5c82d6-5"><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread t5 = <span class="keyword">new</span> Thread(<span class="string">&quot;t5&quot;</span>) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.<span class="keyword">join</span>(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t5.start();</span><br><span class="line">log.debug(<span class="string">&quot;t5 state &#123;&#125;&quot;</span>, t5.getState());</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0091ddbb-7624-40c0-b929-7f012b5c82d6-6"><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Thread t6 = <span class="keyword">new</span> Thread(<span class="string">&quot;t6&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (TestState.<span class="keyword">class</span>) &#123; </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t6.start();</span><br><span class="line">log.<span class="keyword">debug</span>(<span class="string">&quot;t6 state &#123;&#125;&quot;</span>, t6.getState());</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0091ddbb-7624-40c0-b929-7f012b5c82d6-7"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">08:<span class="number">30</span>:<span class="number">14.858</span> c.TestState [t3] - running...</span><br><span class="line">08:<span class="number">30</span>:<span class="number">15.356</span> c.TestState [main] - t1 state NEW</span><br><span class="line">08:<span class="number">30</span>:<span class="number">15.361</span> c.TestState [main] - t2 state RUNNABLE</span><br><span class="line">08:<span class="number">30</span>:<span class="number">15.361</span> c.TestState [main] - t3 state TERMINATED</span><br><span class="line">08:<span class="number">30</span>:<span class="number">15.361</span> c.TestState [main] - t4 state TIMED_WAITING</span><br><span class="line">08:<span class="number">30</span>:<span class="number">15.361</span> c.TestState [main] - t5 state WAITING</span><br><span class="line">08:<span class="number">30</span>:<span class="number">15.361</span> c.TestState [main] - t6 state BLOCKED</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.进程与线程</title>
      <link href="/posts/792b4657.html"/>
      <url>/posts/792b4657.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="JUC并发编程" href="www.bilibili.com/video/BV16J411h7Rd"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/cc9c854fba9e3eb1139ee772d18fbdb9d056eac5.png@320w_200h_!web-space-upload-video.avif"/></div><div class="right"><p class="text">JUC并发编程</p><p class="url">www.bilibili.com/video/BV16J411h7Rd</p></div></a></div><h2 id="1-线程与进程">1.线程与进程</h2><span class='p red'>进程</span><p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备。进程就是用来加载指令，管理内存，管理OI的。<br>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。<br>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本，画图，浏览器等），也有程序只能启动一个实例进程（例如网易云音乐，360安全卫士等）。</p><span class='p red'>线程</span><p>一个进程之内可以分为一到多个线程。<br>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行。<br>java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows中进程是不活动的，只是作为线程的容器。</p><span class='p red'>二者对比</span><p>进程基本上相互独立，而线程存在于进程内，是进程的一个子集。<br>进程拥有共享的资源，如内存空间，供其内部的线程共享。<br>进程间通信较为复杂<br>同一台计算机的进程通信称为IPC（Inter-process communication).<br>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，如HTTP。<br>线程通信相对简单，因为它们共享进程内的内存。一个例子是多个线程可以访问同一个共享变量。<br>线程更轻量，线程上下文切换成本一般比进程上下文切换低。</p><h2 id="2-并行与并发">2.并行与并发</h2><span class='p red'>并发</span><p>单核cpu下，线程实际还<span class='p red'>串行执行</span> 的。操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约15毫秒）分给不同线程使用，只是由于cpu在线程间（时间片很短）的切换非常快。人类感觉是同时运行的。总结一句话就是：<span class='p green'>微观串行，宏观并行</span> 。</p><span class='p red'>同一时刻，其实只有一个事件发生</span><p>一般会将这种线程轮流使用cpu的做法称为并发（concurrent）。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1OTY2NDQw,size_16,color_FFFFFF,t_70.png" alt="img"></p><table><thead><tr><th style="text-align:center">CPU</th><th style="text-align:center">时间片 1</th><th style="text-align:center">时间片 2</th><th style="text-align:center">时间片 3</th><th style="text-align:center">时间片 4</th></tr></thead><tbody><tr><td style="text-align:center">core</td><td style="text-align:center">线程 1</td><td style="text-align:center">线程 2</td><td style="text-align:center">线程 3</td><td style="text-align:center">线程 4</td></tr></tbody></table><span class='p red'>并行</span> <p>多核cpu下，每个核（core）都可以调度运行线程，这时候线程可以是并行的。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1OTY2NDQw,size_16,color_FFFFFF,t_70-20230328115500809.png" alt="在这里插入图片描述"></p><table><thead><tr><th style="text-align:center">CPU</th><th style="text-align:center">时间片 1</th><th style="text-align:center">时间片 2</th><th style="text-align:center">时间片 3</th><th style="text-align:center">时间片 4</th></tr></thead><tbody><tr><td style="text-align:center">core1</td><td style="text-align:center">线程 1</td><td style="text-align:center">线程 2</td><td style="text-align:center">线程 3</td><td style="text-align:center">线程 4</td></tr><tr><td style="text-align:center">core2</td><td style="text-align:center">线程 4</td><td style="text-align:center">线程 4</td><td style="text-align:center">线程 2</td><td style="text-align:center">线程 2</td></tr></tbody></table><p>引用 Rob Pike 的一段描述：</p><p>​并发（concurrent）是同一时间应对（dealing with）多件事情的能力 。</p><p>​并行（parallel）是同一时间动手做（doing）多件事情的能力。</p><h2 id="3-应用">3.应用</h2><span class='p green'>应用之异步调用</span> <blockquote><ul><li>需要等待结果返回，才能继续运行就是同步。</li><li>不需要等待结果返回，就能继续运行就是异步。</li></ul></blockquote><p>1）设计</p><p>多线程可以让方法执行变为异步（即不要干巴巴等着）比如说读取磁盘文件时，假设读取操作花费了5秒钟，如果没有线程调度机制，这5秒cpu什么都做不了，其他代码都得暂停。</p><p>（2）结论</p><p>比如在项目中，视频文件需要转换格式等操作比较费时时，这时开一个新线程处理视频转换，避免阻塞主线程。<br>tomcat的异步servlet也是类似目的，让用户线程处理耗时较长的操作，避免阻塞tomcat的工作线程。<br>ui程序中，开线程进行其他操作，避免阻塞ui线程。</p><span class='p green'>应用之提高效率</span> <p>充分利用多核cpu的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><blockquote><p>计算1 花费 10 ms<br>计算2 花费 11 ms<br>计算3 花费 9 ms<br>汇总需要 1 ms</p></blockquote><p>如果是串行执行，那么总共花费的时间是<br>10+11+9+1=31ms</p><p>但如果是四核cpu，各个核心分别使用线程1执行计算1，线程2执行计算1，线程3执行计算3，那么3个线程是并行的吗，花费时间只取决于最长的那个线程运行的时间，11ms最后加上汇总时间总共只花费 12ms。</p><blockquote><p>注意</p><p>需要在多核cpu中才能提高效率，单核仍然是轮流执行</p></blockquote><p>结论</p><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于字符串字面量进入到字符串常量池的时机</title>
      <link href="/posts/f9285b5c.html"/>
      <url>/posts/f9285b5c.html</url>
      
        <content type="html"><![CDATA[<h1>Q1：什么是字符串常量池</h1><p><strong>字符串常量池</strong>，即<code>String Constant Pool</code>，又叫做<code>String Pool</code>，<code>String Table</code>。顾名思义，即用于存放字符串常量的运行时内存结构，其底层实现为一种<code>Hashtable</code>。其中所指的<strong>字符串常量</strong>，可以是编译期在源码中显式的<strong>字符串字面量</strong>，也可以是之后在程序运行时创建的字符串String对象。</p><p>在<strong>JDK1.6</strong>及之前，字符串常量池中只会存放具体的String实例，在使用<code>String.intern</code>方法时，若字符串常量池中有满足<code>String.equals</code>方法的String对象，则返回其引用；若字符串常量池中没有相同的String对象，则当前String对象为堆上对象，故在字符串常量池中创建一个相同的String对象，并返回其引用。</p><p>在<strong>JDK1.7</strong>及之后，字符串常量池中不仅可以存放String实例，同时还能存放指向Java堆中某个String实例的引用。在使用<code>String.intern</code>方法时，若字符串常量池中有满足<code>String.equals</code>方法的String对象，则返回其引用，这一点和JDK1.6相同；若字符串常量池中没有相同的String对象，则当前String对象为堆上对象，故在字符串常量池中存放一个指向堆上此String对象的引用，并返回此引用。</p><p>参考资料</p><ul><li><a href="https://stackoverflow.com/questions/16783971/string-constant-pool-vs-string-pool">stackoverflow: String Constant Pool vs String pool</a></li><li><a href="https://stackoverflow.com/questions/23252767/string-pool-vs-constant-pool">stackoverflow: String pool vs Constant pool</a></li><li><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">美团技术团队: 深入解析String#intern</a></li><li>在IDK1.6中，intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用。而JDK1.7中（以及部分其他虚拟机，例如 JRockit）的 intern() 实现不会再复制实例，只是在常量池中记录首次出现的实例引用。<br>——《深入理解 Java 虚拟机（第2版）》2.4.3 方法区和运行时常量池溢出</li><li>JDK 7（以及部分其他虚拟机，例如 JRockit）的 intern() 方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到 Java 堆中，那只需要在常量池里记录一下首次出现的实例引用即可。<br>——《深入理解 Java 虚拟机（第3版）》2.4.3 方法区和运行时常量池溢出</li><li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用<br>——《深入理解 Java 虚拟机（第3版）》3.2.2 可达性分析</li></ul><h1>Q2：字符串常量池在JVM中的分布</h1><p>在<strong>JDK1.6</strong>及之前，字符串常量和其他的基本类型的常量一样，存放在 <strong>运行时常量池（Run-Time Constant Pool）</strong> 中，即在<strong>方法区</strong>（HotSpot中为<strong>永久代PermGen</strong>）中。</p><p>在<strong>JDK1.7</strong>及之后，字符串常量的存放位置已经从运行时常量池中分离到了 <strong>Java堆（Heap）</strong> 中，形成了独立的<strong>字符串常量池（String Pool）</strong>，其中一方面也是因为在永久代中创建String对象，容易耗尽永久代内存空间。</p><p>参考资料</p><ul><li><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">美团技术团队: 深入解析String#intern</a></li><li>在IDK1.6中，intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用。而JDK1.7中（以及部分其他虚拟机，例如 JRockit）的 intern() 实现不会再复制实例，只是在常量池中记录首次出现的实例引用。<br>——《深入理解 Java 虚拟机（第2版）》2.4.3 方法区和运行时常量池溢出</li><li>JDK 7（以及部分其他虚拟机，例如 JRockit）的 intern() 方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到 Java 堆中，那只需要在常量池里记录一下首次出现的实例引用即可。<br>——《深入理解 Java 虚拟机（第3版）》2.4.3 方法区和运行时常量池溢出</li></ul><h1>Q3：字符串字面量在class文件中的位置</h1><p>源码经过Java编译器编译后，其中的字符串字面量以<code>CONSTANT_String_info</code>的形式存放在class文件的<strong>常量池（Constant Pool）</strong> 中。</p><p>class文件的常量池，可以通过<code>javac -verbose</code>命令显式查看。</p><p>示例代码（JDK1.8）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tomandersen.javastudy.LeetCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;He&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>javac -verbose</code>编译结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">10.</span>#<span class="number">28</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = String             #<span class="number">29</span>            <span class="comment">// llo</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">9.</span>#<span class="number">30</span>         <span class="comment">// cn/tomandersen/javastudy/LeetCode/Test.s2:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">4</span> = Fieldref           #<span class="number">31.</span>#<span class="number">32</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">5</span> = String             #<span class="number">33</span>            <span class="comment">// Hello</span></span><br><span class="line">   #<span class="number">6</span> = Methodref          #<span class="number">34.</span>#<span class="number">35</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">7</span> = String             #<span class="number">36</span>            <span class="comment">// He</span></span><br><span class="line">   #<span class="number">8</span> = Fieldref           #<span class="number">9.</span>#<span class="number">37</span>         <span class="comment">// cn/tomandersen/javastudy/LeetCode/Test.s1:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">38</span>            <span class="comment">// cn/tomandersen/javastudy/LeetCode/Test</span></span><br><span class="line">  #<span class="number">10</span> = Class              #<span class="number">39</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">11</span> = Utf8               s1</span><br><span class="line">  #<span class="number">12</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">13</span> = Utf8               s2</span><br><span class="line">  #<span class="number">14</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">15</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">16</span> = Utf8               Code</span><br><span class="line">  #<span class="number">17</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">18</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">19</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">20</span> = Utf8               Lcn/tomandersen/javastudy/LeetCode/Test;</span><br><span class="line">  #<span class="number">21</span> = Utf8               main</span><br><span class="line">  #<span class="number">22</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">23</span> = Utf8               args</span><br><span class="line">  #<span class="number">24</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">25</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">26</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">27</span> = Utf8               Test.java</span><br><span class="line">  #<span class="number">28</span> = NameAndType        #<span class="number">14</span>:#<span class="number">15</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">29</span> = Utf8               llo</span><br><span class="line">  #<span class="number">30</span> = NameAndType        #<span class="number">13</span>:#<span class="number">12</span>        <span class="comment">// s2:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">31</span> = Class              #<span class="number">40</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">32</span> = NameAndType        #<span class="number">41</span>:#<span class="number">42</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">33</span> = Utf8               Hello</span><br><span class="line">  #<span class="number">34</span> = Class              #<span class="number">43</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">35</span> = NameAndType        #<span class="number">44</span>:#<span class="number">45</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">36</span> = Utf8               He</span><br><span class="line">  #<span class="number">37</span> = NameAndType        #<span class="number">11</span>:#<span class="number">12</span>        <span class="comment">// s1:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">38</span> = Utf8               cn/tomandersen/javastudy/LeetCode/Test</span><br><span class="line">  #<span class="number">39</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">40</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">41</span> = Utf8               out</span><br><span class="line">  #<span class="number">42</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">43</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">44</span> = Utf8               println</span><br><span class="line">  #<span class="number">45</span> = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p><strong>从javac工具的编译结果来看，可以发现class文件的常量池（Constant Pool）中保存有源码中出现的所有字符串字面量。</strong></p><p>参考资料</p><ul><li>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。<br>——《深入理解 Java 虚拟机（第3版）》6.3.2 常量池</li></ul><h1>Q4：字符串字面量何时进入到字符串常量池中</h1><p>字符串字面量，和其他基本类型的字面量或常量不同，并不会在类加载中的<strong>解析（resolve）</strong> 阶段填充并驻留在字符串常量池中，而是以特殊的形式存储在 <strong>运行时常量池（Run-Time Constant Pool）</strong> 中。而是只有当此字符串字面量被调用时（如对其执行<code>ldc</code>字节码指令，将其添加到栈顶），HotSpot VM才会对其进行resolve，为其在字符串常量池中创建对应的String实例。</p><p>在<strong>JDK1.7</strong>的HotSpot VM中，这种还未真正解析（resolve）的String字面量，以<code>JVM_CONSTANT_UnresolvedString</code>的形式存放在运行时常量池中，此时并未为其创建String实例；</p><p>在<strong>JDK1.8</strong>的HotSpot VM中，这种未真正解析（resolve）的String字面量，被称为<code>pseudo-string</code>，以<code>JVM_CONSTANT_String</code>的形式存放在运行时常量池中，此时并未为其创建String实例。</p><p>在<strong>编译期</strong>，字符串字面量以<code>&quot;CONSTANT_String_info&quot;</code>+<code>&quot;CONSTANT_Utf8_info&quot;</code>的形式存放在class文件的 <strong>常量池（Constant Pool）</strong> 中；</p><p>在<strong>类加载之后</strong>，字符串字面量以<code>&quot;JVM_CONSTANT_UnresolvedString(JDK1.7)&quot;</code>或者<code>&quot;JVM_CONSTANT_String(JDK1.8)&quot;</code>的形式存放在 <strong>运行时常量池（Run-time Constant Pool）</strong> 中；</p><p>在<strong>首次使用某个字符串字面量时</strong>，字符串字面量以真正的String对象的方式存放在 <strong>字符串常量池（String Pool）</strong> 中。</p><p>示例代码（JDK1.8）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tomandersen.javastudy.LeetCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;He&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;llo&quot;</span>);<span class="comment">// 堆上创建&quot;Hello&quot;,&quot;He&quot;,&quot;llo&quot;实例,String Pool中创建&quot;He&quot;和&quot;llo&quot;实例</span></span><br><span class="line">        s1.intern();<span class="comment">// 将堆上&quot;Hello&quot;的引用存入String Pool</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;<span class="comment">// 获取String Pool中的&quot;Hello&quot;的引用</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料</p><p><a href="https://www.zhihu.com/question/55994121/answer/147296098">知乎: Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的?</a></p><p><a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/share/vm/oops/constantPoolOop.cpp">OpenJDK1.7 HotSpot: src/share/vm/oops/constantPoolOop.cpp</a></p><p><a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/constantPool.cpp">OpenJDK1.8 HotSpot: src/share/vm/oops/constantPool.cpp</a></p><h1>Q5：创建了几个对象</h1><p><code>new String(&quot;Hello&quot;)</code></p><p>基于对之前问题的解答，这个问题就比较好解答了：</p><ul><li>若此代码运行之前没有显示使用过&quot;Hello&quot;字面量，也没有调用某个值为&quot;Hello&quot;字符串对象的<code>intern</code>方法，那么<code>new String(&quot;Hello&quot;)</code>运行时会创建两个对象，一个在<strong>堆</strong>上，一个在<strong>字符串常量池</strong>中</li><li>若此代码运行之前已经使用过&quot;Hello&quot;字面量，或者调用了<code>intern</code>方法，在字符串常量池中创建了相同的实例或者保存了堆上相同对象的引用，那么<code>new String(&quot;Hello&quot;)</code>运行时只会创建一个对象，在<strong>堆</strong>上</li></ul><p>注意</p><p>若在某个类的静态变量中使用了某个字符串字面量，如&quot;Hello&quot;，则在类加载的初始化（initialize）阶段，便会在字符串常量池中创建对应的String实例，并将其赋值给对应的静态变量</p><p>示例代码（JDK1.8）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tomandersen.javastudy.LeetCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;He&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">        <span class="comment">// 堆上创建&quot;Hello&quot;,&quot;He&quot;,&quot;llo&quot;实例,String Pool中创建&quot;He&quot;和&quot;llo&quot;实例</span></span><br><span class="line">        s1.intern();</span><br><span class="line">        <span class="comment">// String Pool中已有&quot;Hello&quot;,故没有将s1的引用添加到String Pool中,返回的是String Pool中已有的&quot;Hello&quot;的引用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String Pool中的&quot;Hello&quot;的引用</span></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">// false</span></span><br><span class="line">        System.out.println(s == s2);<span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常量池 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/2013454d.html"/>
      <url>/posts/2013454d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Markdown语法自带格式">1.Markdown语法自带格式</h2><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h3 id="1-1-代码块">1.1 代码块</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-2-多级标题">1.2 多级标题</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-3-文字样式">1.3 文字样式</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h3 id="1-4-引用">1.4 引用</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-5-分割线">1.5 分割线</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h3><h4 id="1-6-1-无序列表">1.6.1 无序列表</h4><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-7-图片">1.7 图片</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-8-表格">1.8 表格</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="1-9-公式">1.9 公式</h4><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-Butterfly外挂标签">2.Butterfly外挂标签</h2><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h3 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-2-行内文本-span">2.2 行内文本 span</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>字体</code>: logo, code<br>2.<code>颜色</code>: red,yellow,green,cyan,blue,gray<br>3.<code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra<br>4.<code>对齐方向</code>: left, center, right</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-3-段落文本-p">2.3 段落文本 p</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>字体</code>: logo, code<br>2.<code>颜色</code>: red,yellow,green,cyan,blue,gray<br>3.<code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra<br>4.<code>对齐方向</code>: left, center, right</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-4-引用note">2.4 引用note</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-5-上标标签-tip">2.5 上标标签 tip</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell<br>2.<code>自定义图标</code>: 支持fontawesome。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-6-动态标签-anima">2.6 动态标签 anima</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>样式</code>: plus, minus, times<br>2.<code>颜色</code>: red,yellow,green,cyan,blue,gray<br>3.<code>选中状态</code>: checked</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-8-单选列表-radio">2.8 单选列表 radio</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>颜色</code>: red,yellow,green,cyan,blue,gray<br>2.<code>选中状态</code>: checked</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>title</code>:标题/时间线<br>2.<code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有<span class="code">`hexo-lazyload-image`</span>插件，需要删除并重新安装最新版本，设置<span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了<span class="code">`use_cdn: true`</span>则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶<span class="code">`top: true`</span>改为了<span class="code">`pin: true`</span>，并且同样适用于<span class="code">`layout: page`</span>的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了<span class="code">`hexo-offline`</span>插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索<span class="code">`seotitle`</span>并替换为<span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span>对应的组件名必须是<span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的<span class="code">`short_title`</span>其次是<span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有<code>hexo-lazyload-image</code>插件，需要删除并重新安装最新版本，设置<code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了<code>use_cdn: true</code>则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶<code>top: true</code>改为了<code>pin: true</code>，并且同样适用于<code>layout: page</code>的页面。</li><li>如果使用了<code>hexo-offline</code>插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索<code>seotitle</code>并替换为<code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code>对应的组件名必须是<code>group_name</code>。</li><li>group 组件的列表名优先显示文章的<code>short_title</code>其次是<code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-10-链接卡片-link">2.10 链接卡片 link</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-11-按钮-btns">2.11 按钮 btns</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加<code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>left</code>：徽标左边的信息，必选参数。<br>2.<code>right</code>: 徽标右边的信息，必选参数，<br>3.<code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。<br>4.<code>color</code>：徽标右边的颜色，可选参数。<br>5. <code>link</code>：指向的链接，可选参数。<br>6.<code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。<br>7.<code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>高度</code>：height=20px</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-16-单张图片-image">2.16 单张图片 image</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-17-音频-audio">2.17 音频 audio</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-18-视频-video">2.18 视频 video</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>对齐方向</code>：left, center, right<br>2.<code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-19-相册-gallery">2.19 相册 gallery</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-20-折叠框-folding">2.20 折叠框 folding</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><p>1.<code>颜色</code>：blue, cyan, green, yellow, red</p><p>2.<code>状态</code>：状态填写 open 代表默认打开。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-21-分栏-tab">2.21 分栏 tab</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.<code>title</code>：诗词标题<br>2.<code>author</code>：作者，可以不写</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。<br>2.<code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-24-特效标签wow">2.24 特效标签wow</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a><br>2.<code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。<br>3.<code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。<br>4.<code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）<br>5.<code>iteration</code>: 选填项，动画重复的次数</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-25-进度条-progress">2.25  进度条 progress</h3><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>width</code>: 0到100的阿拉伯数字<br>2.<code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray<br>3.<code>text</code>:进度条上的文字内容</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-26-注释-notation">2.26 注释 notation</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>label</code>: 注释词汇</p><p>2.<code>text</code>: 悬停显示的注解内容</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>content</code>: 注释词汇<br>2.<code>notation</code>: 悬停显示的注解内容<br>3.<code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-28-引用文献-reference">2.28 引用文献 reference</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><p>-<code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p><p>-<code>literature</code>: 引用的参考文献名称</p></li><li><p>referfrom 引用出处</p><p>-<code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p><p>-<code>literature</code>: 引用的参考文献名称</p><p>-<code>url</code>: 引用的参考文献链接，可省略</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-29-PDF展示">2.29 PDF展示</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>1.<code>文件路径</code>: 可以是相对路径或者是在线链接</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'Amap'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-31-隐藏块">2.31 隐藏块</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
