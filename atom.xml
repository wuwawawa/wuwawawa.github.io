<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LuckyBoy🥝</title>
  
  
  <link href="https://wuwawawa.github.io/atom.xml" rel="self"/>
  
  <link href="https://wuwawawa.github.io/"/>
  <updated>2023-10-07T01:15:35.220Z</updated>
  <id>https://wuwawawa.github.io/</id>
  
  <author>
    <name>LuckyBoy🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法模版</title>
    <link href="https://wuwawawa.github.io/posts/bb13e2f5.html"/>
    <id>https://wuwawawa.github.io/posts/bb13e2f5.html</id>
    <published>2023-10-04T03:38:05.000Z</published>
    <updated>2023-10-07T01:15:35.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口">滑动窗口</h2><h3 id="经典模版题">经典模版题</h3><p>关键词： 满足xxx条件（计算结果(加减乘除)、出现次数(cnt数组准备)、同时包含）长度最长/最短子串/子数组</p><p>注意点<br>1.if/while使用条件判断<br>2.right-left+1的重要性</p><div class="tabs" id="df3b0974-b073-4def-8595-8222f2f2897c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#df3b0974-b073-4def-8595-8222f2f2897c-1"><i class="fas fa-seedling"></i>209</button></li><li class="tab"><button type="button" data-href="#df3b0974-b073-4def-8595-8222f2f2897c-2"><i class="fas fa-leaf"></i>713</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="df3b0974-b073-4def-8595-8222f2f2897c-1"><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = <span class="number">0</span> , len = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; len)&#123;</span><br><span class="line">        sum += nums[r];    </span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            res = Math.min(res , r - l + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="df3b0974-b073-4def-8595-8222f2f2897c-2"><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">乘积小于 K 的子数组</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回子数组内所有元素的乘积严格小于 <code>k</code> 的连续子数组的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayProductLessThanK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">1</span> , len = nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; len)&#123;</span><br><span class="line">        product *= nums[r];</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">while</span>(product &gt;= k &amp;&amp; l &lt; r)&#123;</span><br><span class="line">            product /= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        res += r - l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="两端滑动窗口套路模板题">两端滑动窗口套路模板题</h3><p>正难则反，从两边拿难思考，最大化拿外面等价转换为最小化拿里面<br>由此变为模板题：从两端取数字等等，连续子数组，字串，可以想到滑动窗口解决</p><div class="tabs" id="174d806e-4979-4493-a287-fb02300675f0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#174d806e-4979-4493-a287-fb02300675f0-1"><i class="fas fa-seedling"></i>2516</button></li><li class="tab"><button type="button" data-href="#174d806e-4979-4493-a287-fb02300675f0-2"><i class="fas fa-leaf"></i>1423</button></li><li class="tab"><button type="button" data-href="#174d806e-4979-4493-a287-fb02300675f0-3"><i class="fab fa-apple"></i>1658</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="174d806e-4979-4493-a287-fb02300675f0-1"><p><a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/"> 每种字符至少取 K 个</a></p><p>给你一个由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p><p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回 <code>-1</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">takeCharacters</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cs.length;</span><br><span class="line">    <span class="comment">// 统计词频</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;a&#x27;</span>,-k);</span><br><span class="line">    map.put(<span class="string">&#x27;b&#x27;</span>,-k);</span><br><span class="line">    map.put(<span class="string">&#x27;c&#x27;</span>,-k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : cs) &#123;</span><br><span class="line">       map.merge(c,<span class="number">1</span>,Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 窗口</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">rc</span> <span class="operator">=</span> cs[r];</span><br><span class="line">        window.merge(rc, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">while</span> (window.get(rc) &gt; map.get(rc) &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">lc</span> <span class="operator">=</span> cs[l];</span><br><span class="line">            window.merge(lc, -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, r - l + <span class="number">1</span>);</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="174d806e-4979-4493-a287-fb02300675f0-2"><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">可获得的最大点数</a></p><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(<span class="type">int</span>[] cardPoints, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cardPoints.length;</span><br><span class="line">    k = len - k;</span><br><span class="line">    <span class="comment">// 计算sum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(cardPoints).sum();</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> cardPoints[r];</span><br><span class="line">        total += rx;</span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> == k + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lx</span> <span class="operator">=</span> cardPoints[l];</span><br><span class="line">            total -= lx;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">            ans = Math.min(ans, total);</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="174d806e-4979-4493-a287-fb02300675f0-3"><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">将 x 减到 0 的最小操作数</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p><p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回 <strong>最小操作数</strong> ；否则，返回 <code>-1</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum - x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (x == sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在窗口内找到最长子数组 其和等于target</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> nums[r];</span><br><span class="line">        s += rx;</span><br><span class="line">        <span class="keyword">while</span> (s &gt; target &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lx</span> <span class="operator">=</span> nums[l];</span><br><span class="line">            s -= lx;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == target) &#123;</span><br><span class="line">            res = Math.max(res, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == -<span class="number">1</span> ? -<span class="number">1</span> : len - res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="两个left计算区间个数">两个left计算区间个数</h3><p>滑动窗口区间个数计算模板题（两个left计算区间个数）</p><p>主要解决的问题是利用滑动窗口的两个left计算区间个数的模板解决相关套路题。</p><p>题目中往往包含<span class='p green'>恰好字眼</span></p><blockquote><p>把「恰好」 转换成为 「最多」。</p></blockquote><blockquote><p>例如求恰好k个，就用最多k个 - 最多k-1个 = 恰好k个</p></blockquote><div class="tabs" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8c93d26e-1b54-4ffd-9dce-d4803af8693d-1"><i class="fas fa-seedling"></i>LC930</button></li><li class="tab"><button type="button" data-href="#8c93d26e-1b54-4ffd-9dce-d4803af8693d-2"><i class="fas fa-leaf"></i>LC1248</button></li><li class="tab"><button type="button" data-href="#8c93d26e-1b54-4ffd-9dce-d4803af8693d-3"><i class="fab fa-apple"></i>LC992</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d-1"><p><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">和相同的二元子数组</a></p><p>给你一个二元数组 <code>nums</code> ，<code>nums[i]</code> 不是 <code>0</code> 就是 <code>1 </code>，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cal(nums, goal) - cal(nums, goal - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        s += x;</span><br><span class="line">        <span class="keyword">while</span> (s &gt; k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            s -= nums[left];</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d-2"><p><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/">统计优美子数组</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。如果某个连续子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中 <strong>「优美子数组」</strong> 的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cal(nums, k) - cal(nums, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">countOdd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        countOdd += ((x &amp; <span class="number">1</span>) == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (countOdd &gt; k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            countOdd -= ((nums[left] &amp; <span class="number">1</span>) == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d-3"><p><a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/"> K 个不同整数的子数组</a></p><p>给定一个正整数数组 <code>nums</code>和一个整数 <code>k</code>，返回 <code>nums</code> 中 「<strong>好子数组」</strong> 的数目。</p><p>如果 <code>nums</code> 的某个子数组中不同整数的个数恰好为 <code>k</code>，则称 <code>nums</code> 的这个连续、不一定不同的子数组为 <strong>「好子数组 」</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cal(nums, k) - cal(nums, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        map.merge(rx, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">while</span> (map.size() &gt; k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lx</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            map.merge(lx, -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            <span class="keyword">if</span> (map.get(lx) == <span class="number">0</span>) &#123;</span><br><span class="line">                map.remove(lx);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="双向BFS">双向BFS</h2><p>「双向 BFS」的基本实现思路如下：</p><p>创建「两个队列」分别用于两个方向的搜索；<br>创建「两个哈希表」用于「解决相同节点重复搜索」和「记录转换次数」；<br>为了尽可能让两个搜索方向“平均”，每次从队列中取值进行扩展时，先判断哪个队列容量较少；<br>如果在搜索过程中「搜索到对方搜索过的节点」，说明找到了最短路径。<br>「双向 BFS」基本思路对应的伪代码大致如下：</p><div class="tabs" id="019b1ae0-3bce-4c44-8e19-84a975519e1b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#019b1ae0-3bce-4c44-8e19-84a975519e1b-1"><i class="fas fa-seedling"></i>伪代码</button></li><li class="tab"><button type="button" data-href="#019b1ae0-3bce-4c44-8e19-84a975519e1b-2"><i class="fas fa-leaf"></i>示例代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="019b1ae0-3bce-4c44-8e19-84a975519e1b-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d1、d2 为两个方向的队列</span><br><span class="line">m1、m2 为两个方向的哈希表，记录每个节点距离起点的</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 只有两个队列都不空，才有必要继续往下搜索</span></span><br><span class="line"><span class="comment">// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点</span></span><br><span class="line"><span class="keyword">while</span>(!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.size() &lt; d2.size()) &#123;</span><br><span class="line">        update(d1, m1, m2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update(d2, m2, m1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update 为将当前队列 d 中包含的元素取出，进行「一次完整扩展」的逻辑（按层拓展）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Deque d, Map cur, Map other)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="019b1ae0-3bce-4c44-8e19-84a975519e1b-2"><p><a href="https://leetcode.cn/problems/minimum-operations-to-convert-number/">转化数字的最小运算数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(<span class="type">int</span>[] _nums, <span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    nums = _nums;</span><br><span class="line">    Deque&lt;Long&gt; d1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(), d2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Long, Integer&gt; m1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    d1.addLast(s * <span class="number">1L</span>);</span><br><span class="line">    d2.addLast(t * <span class="number">1L</span>);</span><br><span class="line">    m1.put(s * <span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">    m2.put(t * <span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d1.size() &lt; d2.size()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> update(d1, m1, d2, m2, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans != -<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> update(d2, m2, d1, m1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans != -<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(Deque&lt;Long&gt; d1, Map&lt;Long, Integer&gt; m1, Deque&lt;Long&gt; d2, Map&lt;Long, Integer&gt; m2, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> d1.size();</span><br><span class="line">    <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> d1.pollFirst();</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> m1.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// 正向搜索：进行出队检查，只有出队元素符合条件，才能使用出队元素往下拓展</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= cur &amp;&amp; cur &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                    <span class="type">long</span>[] result = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;cur + i, cur - i, cur ^ i&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">long</span> next : result) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (m2.containsKey(next)) <span class="keyword">return</span> step + <span class="number">1</span> + m2.get(next);</span><br><span class="line">                        <span class="keyword">if</span> (!m1.containsKey(next)) &#123;</span><br><span class="line">                            d1.addLast(next);</span><br><span class="line">                            m1.put(next, step + <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反向搜索：进行入队检查，只有拓展元素符合条件，才能将拓展元素入队</span></span><br><span class="line">                <span class="type">long</span>[] result = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;cur + i, cur - i, cur ^ i&#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">long</span> next : result) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= next &amp;&amp; next &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (m2.containsKey(next)) <span class="keyword">return</span> step + <span class="number">1</span> + m2.get(next);</span><br><span class="line">                        <span class="keyword">if</span> (!m1.containsKey(next)) &#123;</span><br><span class="line">                            d1.addLast(next);</span><br><span class="line">                            m1.put(next, step + <span class="number">1</span>);</span><br><span class="line">                        &#125;   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="树形DP">树形DP</h2><h2 id="换根DP">换根DP</h2><hr><h2 id="数位DP">数位DP</h2><p>将 n 转换成字符串 s，定义 <code>f(i,mask,isLimit,hasNum)</code> 表示构造第 i 位及其之后数位的合法方案数，其参数的含义为:</p><ul><li>mask 表示前面选过的数字集合，换句话说，第 i 位要选的数字不能在 mask 中。</li><li>isLimit 表示当前是否受到了 n 的约束（注意要构造的数字不能超过 n）。若为真，则第 i 位填入的数字至多为 s[i]，否则可以是 9。如果在受到约束的情况下填了 s[i]，那么后续填入的数字仍会受到 n 的约束。例如 n=123，那么 i=0 填的是 1 的话，i=1 的这一位至多填 2。</li><li>hasNum 表示 i 前面的数位是否填了数字。若为假，则当前位可以跳过（不填数字），或者要填入的数字至少为 1；若为真，则要填入的数字可以从 0 开始。例如 n=1233，在 i=0 时跳过的话，相当于后面要构造的是一个 9 以内的数字了，如果 i=1 不跳过，那么相当于构造一个 10 到 99 的两位数，如果 i=1 跳过，相当于构造的是一个 9 以内的数字。</li></ul><blockquote><p>如果一个正整数每一个数位都是 <strong>互不相同</strong> 的，我们称它是 <strong>特殊整数</strong> 。给你一个 <strong>正</strong> 整数 <code>n</code> ，请你返回区间 <code>[1, n]</code> 之间特殊整数的数目。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] memo;   <span class="comment">// memo[i][mask]记录当前选择顺位为i，已选状态为mask时，构造第i位及后面位的合法方案数</span></span><br><span class="line">    <span class="type">char</span>[] s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参考灵神の数位DP记忆化DFS模板：</span></span><br><span class="line"><span class="comment">        注意这题与LC1012是一样的，不过这题更直接求每一位都不相同数字</span></span><br><span class="line"><span class="comment">        dfs(i, mask, isLimit, hasNum) 代表从左到右选到第i个数字时(i从0开始)，前面数字已选状态为mask时的合法方案数</span></span><br><span class="line"><span class="comment">        各个参数的含义如下:</span></span><br><span class="line"><span class="comment">        i:当前选择的数字位次，从0开始</span></span><br><span class="line"><span class="comment">        mask:前面已择数字的状态，是一个10位的二进制数，如:0000000010就代表前面已经选了1</span></span><br><span class="line"><span class="comment">        isLimit:boolean类型，代表当前位选择是否被前面位的选择限制了；</span></span><br><span class="line"><span class="comment">            如n=1234，前面选了12，选第3位的时候会被限制在0~3，isLimit=true；否则是0~9，isLimit=false</span></span><br><span class="line"><span class="comment">        hasNum:表示前面是否已经选择了数字，若选择了就为true(识别直接构造低位的情况)</span></span><br><span class="line"><span class="comment">        时间复杂度:O(1024*M*10) 空间复杂度:O(1024*M)</span></span><br><span class="line"><span class="comment">        记忆化DFS的时间复杂度=状态数*每一次枚举的情况数</span></span><br><span class="line"><span class="comment">        **记忆化本质就是减少前面已选状态一致的情况，将1eM的时间复杂度压缩至1&lt;&lt;M，效率非常高**</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s = String.valueOf(n).toCharArray();    <span class="comment">// 转化为字符数组形式</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];     <span class="comment">// i∈[0,m-1]，mask为一个10位二进制数</span></span><br><span class="line">        <span class="comment">// 初始化memo为-1代表该顺位下该已选状态还没进行计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意一开始最高位是有限制的，isLimit=true</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs(i, mask, isLimit, hasNum) 代表从左到右选第i个数字时，前面已选状态为mask时的合法方案数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> mask, <span class="type">boolean</span> isLimit, <span class="type">boolean</span> hasNum)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="comment">// i越过最后一位，此时前面选了就算一个，没选的就不算，因为不选后面也没得选了</span></span><br><span class="line">        <span class="keyword">if</span> (i == s.length) <span class="keyword">return</span> hasNum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 已经计算过该状态，并且该状态是有效的，直接返回该状态</span></span><br><span class="line">        <span class="comment">// 这一步是降低时间复杂度的关键，使得记忆化dfs的时间复杂度控制得很低</span></span><br><span class="line">        <span class="comment">// !isLimit表示没有被限制的才可以直接得出结果，否则还要根据后面的数字进行计算子问题计算</span></span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; hasNum &amp;&amp; memo[i][mask] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][mask];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 结果</span></span><br><span class="line">        <span class="comment">// 本位可以取0(可直接构造低位数)的情况，此时要加上构造低位数0xxx的方案数</span></span><br><span class="line">        <span class="comment">// 将是否选了数字作为分类条件是为了避免出现00010这样有多个0的就不能统计了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasNum) res = dfs(i + <span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 构造与当前顺位相同位数的数字就要枚举可选的数字进行DFS</span></span><br><span class="line">        <span class="comment">// 枚举的起点要视hasNum而定，如果前面选择了数字，那么现在可以选0；否则只能从1开始</span></span><br><span class="line">        <span class="comment">// 枚举得终点视isLimit而定，若被限制了只能到s[i]，否则可以到9</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> hasNum ? <span class="number">0</span> : <span class="number">1</span>, end = isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>; k &lt;= end; k++) &#123;</span><br><span class="line">            <span class="comment">// 如果该数字k还没有被选中，那猫就可以选该位数字</span></span><br><span class="line">            <span class="keyword">if</span> (((mask &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 方案数遵循加法原理</span></span><br><span class="line">                <span class="comment">// i:进行下一位的DFS，因此为i+1</span></span><br><span class="line">                <span class="comment">// mask:由于该位选中了k，mask掩膜传下去就要更新，已选状态加上k</span></span><br><span class="line">                <span class="comment">// isLimit:当且仅当前面的被限制了且该位被限制</span></span><br><span class="line">                <span class="comment">// hasNum:该位选了必定为true</span></span><br><span class="line">                res += dfs(i + <span class="number">1</span>, mask | (<span class="number">1</span> &lt;&lt; k), isLimit &amp;&amp; k == end, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; hasNum) memo[i][mask] = res;    <span class="comment">// 如果前面没有限制，表明后面都是同质的，可以记录进memo中</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="并查集">并查集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启了路径压缩和按秩合并的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    <span class="comment">// 当前连通分支数目</span></span><br><span class="line">    <span class="type">int</span> branchCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.branchCount = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> parent[x] == x ? x : (parent[x] = find(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按秩合并</span></span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        --branchCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">branchCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> branchCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="差分数组和前缀和">差分数组和前缀和</h2><h3 id="一维前缀和">一维前缀和</h3><hr><h3 id="一维差分">一维差分</h3><hr><h3 id="二维前缀和">二维前缀和</h3><h3 id="二维差分">二维差分</h3><hr>]]></content>
    
    
    <summary type="html">一些常用的算法模版</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>周赛复盘</title>
    <link href="https://wuwawawa.github.io/posts/e7135cd3.html"/>
    <id>https://wuwawawa.github.io/posts/e7135cd3.html</id>
    <published>2023-10-01T06:13:22.000Z</published>
    <updated>2023-10-01T12:38:45.257Z</updated>
    
    <content type="html"><![CDATA[<h1>2023.10.1</h1><h2 id="前缀最大值-后缀最大值">前缀最大值+后缀最大值</h2><p><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/">有序三元组中的最大值</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>请你从所有满足 <code>i &lt; j &lt; k</code> 的下标三元组 <code>(i, j, k)</code> 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 <code>0</code> 。</p><p><strong>下标三元组</strong> <code>(i, j, k)</code> 的值等于 <code>(nums[i] - nums[j]) * nums[k]</code> 。</p><div class="tabs" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-1"><i class="fas fa-seedling"></i>示例1</button></li><li class="tab"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-2"><i class="fas fa-leaf"></i>示例2</button></li><li class="tab"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-3"><i class="fab fa-apple"></i>示例3</button></li><li class="tab"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-4"><i class="fas fa-tree"></i>数据范围</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-1"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[12,6,1,2,7]</span></span><br><span class="line">输出：77</span><br><span class="line">解释：下标三元组 (0, 2, 4) 的值是 (nums<span class="comment">[0]</span> - nums<span class="comment">[2]</span>) * nums<span class="comment">[4]</span> = 77 。</span><br><span class="line">可以证明不存在值大于 77 的有序下标三元组。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-2"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,10,3,4,19]</span></span><br><span class="line">输出：133</span><br><span class="line">解释：下标三元组 (1, 2, 4) 的值是 (nums<span class="comment">[1]</span> - nums<span class="comment">[2]</span>) * nums<span class="comment">[4]</span> = 133 。</span><br><span class="line">可以证明不存在值大于 133 的有序下标三元组。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-3"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：0</span><br><span class="line">解释：唯一的下标三元组 (0, 1, 2) 的值是一个负数，(nums<span class="comment">[0]</span> - nums<span class="comment">[1]</span>) * nums<span class="comment">[2]</span> = -3 。因此，答案是 0 。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-4"><p>两题的数据只是数据范围存在不同</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="枚举J">枚举J</h3><p>在枚举J的情况下，想要<code>(nums[i] - nums[j]) * nums[k]</code>尽量大，就是要让两个数都尽量大。</p><p>对于 <code>nums[j]</code> 来说，如果固定了 <code>j</code> 的位置，那我们需要知道</p><ul><li><code>nums[j + 1] ~ nums[n - 1]</code> 的最大值 即后缀最大值</li><li><code>nums[0] ~ nums[j - 1]</code> 的最大值 即前缀最大值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 后缀最大值</span></span><br><span class="line">    <span class="type">int</span>[] suf_max = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        suf_max[i] = Math.max(suf_max[i + <span class="number">1</span>] , nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前缀最大值</span></span><br><span class="line">    <span class="type">int</span>[] pre_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    pre_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        pre_max[i] = Math.max(pre_max[i - <span class="number">1</span>] , nums[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//枚举j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n - <span class="number">1</span>;j++)&#123;</span><br><span class="line">        ans = Math.max(ans,(<span class="type">long</span>)(pre_max[j - <span class="number">1</span>] - nums[j]) * suf_max[j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="枚举k">枚举k</h3><p>一次遍历，从左到右遍历所有的 <code>nums[k]</code></p><ul><li>那么就需要维护 <code>nums[i] - nums[j]</code>的最大值 max_diff</li><li>同时我们还需要知道左侧的最大值pre_max</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">max_diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre_max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">        <span class="comment">// 先把 x 当做 nums[k]</span></span><br><span class="line">        ans = Math.max(ans , max_diff * x);</span><br><span class="line">        <span class="comment">// 再把 x 当做 nums[j]</span></span><br><span class="line">        max_diff = Math.max(max_diff , pre_max - x);</span><br><span class="line">        <span class="comment">// 再把 x 当做 nums[i]</span></span><br><span class="line">        pre_max = Math.max(pre_max , x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三句话的顺序不能改变，因为题目严格要求<code>i &lt; j &lt; k</code></p><hr><h2 id="滑动窗口">滑动窗口</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/">无限数组的最短子数组</a></p><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>下标从 <strong>0</strong> 开始的数组 <code>infinite_nums</code> 是通过无限地将 nums 的元素追加到自己之后生成的。</p><p>请你从 <code>infinite_nums</code> 中找出满足 <strong>元素和</strong> 等于 <code>target</code> 的 <strong>最短</strong>子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 <code>-1</code> 。</p><div class="tabs" id="3c20ef88-8338-403a-abf5-62b17d741a18"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-1"><i class="fas fa-seedling"></i>示例1</button></li><li class="tab"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-2"><i class="fas fa-leaf"></i>示例2</button></li><li class="tab"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-3"><i class="fab fa-apple"></i>示例3</button></li><li class="tab"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-4"><i class="fas fa-tree"></i>数据范围</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3c20ef88-8338-403a-abf5-62b17d741a18-1"><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="keyword">target</span> = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：在这个例子中 infinite_nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,...] 。</span><br><span class="line">区间 [<span class="number">1</span>,<span class="number">2</span>] 内的子数组的元素和等于 <span class="keyword">target</span> = <span class="number">5</span> ，且长度 length = <span class="number">2</span> 。</span><br><span class="line">可以证明，当元素和等于目标值 <span class="keyword">target</span> = <span class="number">5</span> 时，<span class="number">2</span> 是子数组的最短长度。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c20ef88-8338-403a-abf5-62b17d741a18-2"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1,1,1,2</span>,<span class="number">3</span>], target = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：在这个例子中 infinite_nums = [<span class="number">1,1,1,2</span>,<span class="number">3,1,1,1</span>,<span class="number">2,3,1,1</span>,...].</span><br><span class="line">区间 [<span class="number">4</span>,<span class="number">5</span>] 内的子数组的元素和等于 target = <span class="number">4</span> ，且长度 length = <span class="number">2</span> 。</span><br><span class="line">可以证明，当元素和等于目标值 target = <span class="number">4</span> 时，<span class="number">2</span> 是子数组的最短长度。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c20ef88-8338-403a-abf5-62b17d741a18-3"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2,4,6,8</span>], target = <span class="number">3</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：在这个例子中 infinite_nums = [<span class="number">2,4,6,8</span>,<span class="number">2,4,6,8</span>,...] 。</span><br><span class="line">可以证明，不存在元素和等于目标值 target = <span class="number">3</span> 的子数组。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c20ef88-8338-403a-abf5-62b17d741a18-4"><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= target &lt;= 109</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1696131371-UYYmoV-w365c-c.png" alt="img" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSizeSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : nums) total += x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; <span class="number">2</span>*n)&#123;</span><br><span class="line">        sum += nums[right % n];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt; target % total)&#123;</span><br><span class="line">            sum -= nums[left % n];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target % total)&#123;</span><br><span class="line">            ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans + (<span class="type">int</span>)(target / total) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="位运算">位运算</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-collect-elements/">收集元素的最少操作次数</a></p><p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>一次操作中，你可以将数组的最后一个元素删除，将该元素添加到一个集合中。</p><p>请你返回收集元素 <code>1, 2, ..., k</code> 需要的 <strong>最少操作次数</strong> 。</p><div class="tabs" id="6a55aa92-f333-4d58-8119-bccb9431f404"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-1"><i class="fas fa-seedling"></i>示例1</button></li><li class="tab"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-2"><i class="fas fa-leaf"></i>示例2</button></li><li class="tab"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-3"><i class="fab fa-apple"></i>示例3</button></li><li class="tab"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-4"><i class="fas fa-tree"></i>数据范围</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6a55aa92-f333-4d58-8119-bccb9431f404-1"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,5,4,2], k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：4 次操作后，集合中的元素依次添加了<span class="number"> 2 </span>，4 ，5 和<span class="number"> 1 </span>。此时集合中包含元素<span class="number"> 1 </span>和<span class="number"> 2 </span>，所以答案为<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a55aa92-f333-4d58-8119-bccb9431f404-2"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,5,4,2], k = 5</span><br><span class="line">输出：5</span><br><span class="line">解释：5 次操作后，集合中的元素依次添加了<span class="number"> 2 </span>，4 ，5 ，1 和<span class="number"> 3 </span>。此时集合中包含元素<span class="number"> 1 </span>到<span class="number"> 5 </span>，所以答案为<span class="number"> 5 </span>。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a55aa92-f333-4d58-8119-bccb9431f404-3"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,5,3,1], k = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：4 次操作后，集合中的元素依次添加了<span class="number"> 1 </span>，3 ，5 和<span class="number"> 2 </span>。此时集合中包含元素<span class="number"> 1 </span>到<span class="number"> 3 </span> ，所以答案为<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a55aa92-f333-4d58-8119-bccb9431f404-4"><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= nums.length</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li><li>输入保证你可以收集到元素 <code>1, 2, ..., k</code> 。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>由于元素范围在[1,50]，我们可以用一个 64 位整数表示集合，只要集合中有 1 到 k 就立刻返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">    <span class="type">long</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 结束状态 mask 是 statsu 的子集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">// 更新status</span></span><br><span class="line">        status |= <span class="number">1L</span> &lt;&lt; nums.get(i);</span><br><span class="line">        <span class="keyword">if</span>((mask &amp; status) == mask)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - i;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">LeetCode周赛</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最短路算法</title>
    <link href="https://wuwawawa.github.io/posts/5697d1d5.html"/>
    <id>https://wuwawawa.github.io/posts/5697d1d5.html</id>
    <published>2023-09-26T06:13:22.000Z</published>
    <updated>2023-10-01T09:00:02.859Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230926155902091.png" alt="image-20230926155902091"></p><h2 id="Dijkstra算法">Dijkstra算法</h2><p>Dijkstra本质上是一种贪心算法，通过不断调整每个点的“当前距离”最终得到最优结果。</p><p>假设现在要求出从某一点s到其他所有点的最短距离，对于每个点v均维护一个“当前距离”（dist[v]）和“是否访问过”(visited[v])。首先将dist[s]初始化为0，将其他点的距离初始化为无穷，并将所有点初始化为未访问的。记u-&gt;v的边权为weight[u-&gt;v]。然后进行以下步骤：</p><ol><li>从所有未访问的点中，找出当前距离最小的，设为u，并将其标记为已访问的。</li><li>调整u的所有边（若是有向图则为出边）连接的并且<strong>未被访问过的</strong>点：若weight[u-&gt;v] + dist[u] &lt; dist[v], 则将dist[v]更新为dist[u]+weight[u-&gt;v]。</li><li>重复1和2步骤，直到所有点都被标记为已访问的，则dist[i]即s到i的最短距离。如果只想求从s到某一点的最短距离，那么当该点被标记为访问过之后可直接退出。</li><li>补充：如果除了最短距离之外还想求出具体的路径，只需建立一个pre数组，在步骤2后添加操作：pre[v] = u（前提是dist[v]被更新）。</li></ol><div class="tabs" id="e1220ca0-3a93-4dc3-aaa1-66a274d0966f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e1220ca0-3a93-4dc3-aaa1-66a274d0966f-1"><i class="fas fa-seedling"></i>邻接矩阵</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e1220ca0-3a93-4dc3-aaa1-66a274d0966f-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">110</span>, M = <span class="number">6010</span>;</span><br><span class="line">    <span class="comment">// 邻接矩阵数组：w[a][b] = c 代表从 a 到 b 有权重为 c 的边</span></span><br><span class="line">    <span class="type">int</span>[][] w = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">    <span class="comment">// dist[x] = y 代表从「源点/起点」到 x 的最短距离为 y</span></span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="comment">// 记录哪些点已经被更新过</span></span><br><span class="line">    <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line">    <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> n, src;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span>[][] conn)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                w[i][j] = w[j][i] = i == j ? <span class="number">0</span> : INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] t : conn) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> t[<span class="number">0</span>], v = t[<span class="number">1</span>], c = t[<span class="number">2</span>];</span><br><span class="line">            w[u][v] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最短路</span></span><br><span class="line">        dijkstra();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 起始先将所有的点标记为「未更新」和「距离为正无穷」</span></span><br><span class="line">        Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">        Arrays.fill(dist, INF);</span><br><span class="line">        <span class="comment">// 只有起点最短距离为 0</span></span><br><span class="line">        dist[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 迭代 n 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt;= n; p++) &#123;</span><br><span class="line">            <span class="comment">// 每次找到「最短距离最小」且「未被更新」的点 t</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i] &amp;&amp; (t == -<span class="number">1</span> || dist[i] &lt; dist[t])) t = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记点 t 为已更新</span></span><br><span class="line">            vis[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 用点 t 的「最小距离」更新其他点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                dist[i] = Math.min(dist[i], dist[t] + w[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Floyd算法">Floyd算法</h2><p>动态规划</p><p><code>dp[i][j]</code> 表示 <code>i-&gt;j</code> 的最短距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借用别的点求解</p>]]></content>
    
    
    <summary type="html">Dijkstra + SPFA + Bellman-Ford + Floyd</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>差分数组</title>
    <link href="https://wuwawawa.github.io/posts/f4bb8efc.html"/>
    <id>https://wuwawawa.github.io/posts/f4bb8efc.html</id>
    <published>2023-09-25T06:45:09.000Z</published>
    <updated>2023-09-25T09:37:30.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景">使用场景</h2><p>在介绍差分数组之前，先回顾一下「前缀和数组」</p><p>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</p><p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</p><p>使用场景：对于一个数组 <code>nums[]</code></p><ul><li>要求一：对 <code>num[2...4]</code> 全部 + 1</li><li>要求二：对 <code>num[1...3]</code> 全部 - 3</li><li>要求三：对 <code>num[0...4]</code> 全部 + 9</li></ul><p>看到上述情景，首先想到的肯定是遍历（bao li）。直接对数组循环 3 遍，每次在规定的区间上按要求进行操作，此时时间复杂度O(3n)</p><p>但是当这样的操作变得频繁后，时间复杂度也呈线性递增</p><p>所以针对这种场景，提出了「差分数组」的概念，举个简单的例子</p><p><img src="https://pic.leetcode-cn.com/1649302054-sjfBPU-1036101649298970IqiB0Himage-20220407103610070.png" alt="1036101649298970IqiB0Himage-20220407103610070.png"></p><p><code>diff[]</code> 和 <code>nums[]</code> 的关系：<code>diff[i] = nums[i] - nums[i - 1]</code>，<code>diff[0]</code> 除外</p><hr><h2 id="使用好处">使用好处</h2><p>当我们需要对 <code>nums[]</code> 进行上述三个要求时，不需要一次一次的遍历整个数组了，而只需要对 <code>diff[]</code> 进行一次 <code>O(1)</code> 的操作即可</p><ul><li>要求一：对 <code>num[2...4]</code> 全部 + 1  -&gt; <code>diff[2] += 1</code></li><li>要求二：对 <code>num[1...3]</code> 全部 - 3  -&gt; <code>diff[1] += (-3); diff[3 + 1] -= (-3)</code></li><li>要求三：对 <code>num[0...4]</code> 全部 + 9  -&gt; <code>diff[0] += 9</code></li></ul><p>总结：对于改变区间 <code>[i, j]</code> 的值，只需要进行如下操作 <code>diff[i] += val; diff[j + 1] -= val</code></p><p><strong>注</strong>：当 <code>j + 1 &gt;= diff.length</code> 时，不需要进行 <code>diff[j + 1] -= val</code> 操作</p><hr><h2 id="还原数据">还原数据</h2><p>怎么通过 <code>diff[]</code> 得到更新后的数组呢？？？？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复原操作</span></span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="comment">// 下标为 0 的元素相等</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res[i] = diff[i] + res[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="diff-原理">diff[] 原理</h2><p>还原数据就相当于对diff数组求一个前缀和。</p><p>当我们需要对区间 <code>[i, j]</code> 进行 <code>+ val</code> 操作时，我们对 <code>diff[i] += val; diff[j + 1] -= val;</code></p><p>在复原操作时，当我们求 <code>res[i]</code> 时，<code>res[i - 1]</code> 没有变，而 <code>diff[i]</code> 增加了 3，所以 <code>res[i]</code> 增加 3</p><p>当我们求 <code>res[i + 1]</code> 时，<code>res[i]</code> 增加了 3，而 <code>diff[i + 1]</code> 没有变，故 <code>res[i + 1] = diff[i + 1] + res[i]</code> 增加 3。即：虽然 <code>diff[i + 1]</code> 没有变，但是 <code>res[i]</code> 对后面的 <code>res[i + 1]</code> 有一个累积作用</p><p>当我们求 <code>res[j + 1]</code> 时，<code>res[j]</code> 增加了 3，而 <code>diff[j + 1]</code> 减少了 3，故 <code>res[j + 1] = diff[j + 1] + res[j]</code> 增加没有变。即：我们在 j + 1 的时候，把上述的累积作用去除了，所以 j + 1 后面的元素不受影响</p><hr><h2 id="完整模版">完整模版</h2><p>差分数组也可以不用原数组进行初始化，使用全为0的元素进行初始化，这样得到的结果数组就是偏移数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 差分数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化差分数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对区间 [i, j] 增加 val（val 可为负数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val val</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复原操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">差分数组</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>筛质数</title>
    <link href="https://wuwawawa.github.io/posts/996e4f07.html"/>
    <id>https://wuwawawa.github.io/posts/996e4f07.html</id>
    <published>2023-09-19T00:51:18.000Z</published>
    <updated>2023-09-19T06:53:52.404Z</updated>
    
    <content type="html"><![CDATA[<p>统计 [2,n] 中质数的数量是一个很常见的题目，也有很多巧妙高效的做法，接下来的部分只会讲述一些常见的做法。</p><h2 id="枚举">枚举</h2><p>很直观的思路是我们枚举每个数判断其是不是质数。</p><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x-1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。</p><p>考虑到如果 y 是 x 的因数，那么 x/y 也必然是x 的因数，因此我们只要校验 y 或者 x/y 。不难发现我们只需要枚举 [2,$\sqrt{x}$]即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li><p>时间复杂度O(n$\sqrt{n}$)。单个数检查的时间复杂度为O($\sqrt{n}$)，一共要检查n个数。</p></li><li><p>空间复杂度O(1)</p></li></ul><hr><hr><h2 id="埃氏筛">埃氏筛</h2><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。</p><p>我们创建一个数组 isPrime[n] , 其中 isPrime[i] 表示数 i 是不是质数。如果是质数则为 0 ，否则为 1 。</p><p>从小到大遍历每个数，如果这个数为质数，则将其所有倍数都标记为合数（除了该质数本身），这样在运行结束的时候我们就能知道质数的个数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,…这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) i * i &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= n; j += i) &#123;</span><br><span class="line">                    isPrime[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度O(nloglog n)。</li><li>空间复杂度O(n)</li></ul><hr><hr><h2 id="线性筛">线性筛</h2><p>埃氏筛其实还是存在冗余的标记操作，比如对于 45 这个数，它会同时被 3,5 两个数标记为合数，因此我们优化的目标是让每个合数只被标记一次，这样时间复杂度即能保证为 O(n)，这就是我们接下来要介绍的线性筛。</p><p>相较于埃氏筛，我们多维护一个 primes 数组表示当前得到的质数集合。我们从小到大遍历，如果当前的数 x 是质数，就将其加入 primes 数组。</p><p>另一点与埃氏筛不同的是，「标记过程」不再仅当 x 为质数时才进行，而是对每个整数 x 都进行。对于整数 x，我们不再标记其所有的倍数 x⋅x,x⋅(x+1),…，而是只标记质数集合中的数与 x 相乘的数，即 x⋅primes[0], x⋅primes[1] … ，且在发现 x mod primes[i] = 0 的时候结束当前标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> prime : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isPrime[i * prime] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primes.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="预处理质数">预处理质数</h2><p>在有些题目中，我们需要预处理质数，省去一些重复计算。</p><div class="tabs" id="c23a3bbc-d05e-4e05-abcf-62948c072c4e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c23a3bbc-d05e-4e05-abcf-62948c072c4e-1"><i class="fas fa-cat"></i>埃氏筛预处理</button></li><li class="tab"><button type="button" data-href="#c23a3bbc-d05e-4e05-abcf-62948c072c4e-2"><i class="fas fa-horse"></i>线性筛预处理</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c23a3bbc-d05e-4e05-abcf-62948c072c4e-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MX</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 0 表示是质数 1 表示是合数</span></span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[MX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= MX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) i * i &lt;= MX) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= MX; j += i) &#123;</span><br><span class="line">                    isPrime[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c23a3bbc-d05e-4e05-abcf-62948c072c4e-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MX</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 0 表示是质数 1 表示是合数</span></span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[MX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= MX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> prime : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime &gt; MX) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isPrime[i * prime] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">枚举、埃氏筛、线性筛</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://wuwawawa.github.io/posts/c517589e.html"/>
    <id>https://wuwawawa.github.io/posts/c517589e.html</id>
    <published>2023-09-14T01:33:46.000Z</published>
    <updated>2023-10-02T07:45:43.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原理">基本原理</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>顾名思义，并查集支持两种操作：</p><ul><li>合并(Union)：合并两个元素所属集合（合并对应的树）</li><li>查询(Find)：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li></ul><hr><hr><h2 id="函数模版">函数模版</h2><p>运用以下这三个函数可以构建并查集算法的基本框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] cnt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集的父节点数组，将每个元素的父节点都初始化为自己</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        N = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素x和元素y所在的集合合并成一个集合。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pra</span> <span class="operator">=</span> find(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">prb</span> <span class="operator">=</span> find(b);</span><br><span class="line">        <span class="keyword">if</span> (pra != prb) &#123;</span><br><span class="line">            parent[prb] = pra;</span><br><span class="line">            cnt[pra] += cnt[prb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素x的父节点，判断元素x属于哪个集合</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 连通块个数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getBlockNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == find(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">并查集</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>大数运算</title>
    <link href="https://wuwawawa.github.io/posts/8878d18a.html"/>
    <id>https://wuwawawa.github.io/posts/8878d18a.html</id>
    <published>2023-09-09T05:44:29.000Z</published>
    <updated>2023-09-14T01:35:39.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大数相加">大数相加</h2><p>算法流程： 设定 i，j 两指针分别指向 num1，num2 尾部，模拟人工加法；</p><p>计算进位： 计算 carry = tmp // 10，代表当前位相加是否产生进位；</p><p>添加当前位： 计算 tmp = n1 + n2 + carry，并将当前位 tmp % 10 添加至 res 头部；</p><p>索引溢出处理： 当指针 i或j 走过数字首部后，给 n1，n2 赋值为 0，相当于给 num1，num2 中长度较短的数字前面填 0，以便后续计算。</p><p>当遍历完 num1，num2 后跳出循环，并根据 carry 值决定是否在头部添加进位 1，最终返回 res 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1 + n2 + carry;</span><br><span class="line">        res.append(tmp % <span class="number">10</span>);</span><br><span class="line">        carry = tmp / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        res.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="大数相乘">大数相乘</h2><p>如果 <code>num1</code> 和 <code>num2</code> 之一是0 ，则直接将0作为结果返回即可。</p><p>如果 <code>num1</code> 和 <code>num2</code> 都不是0，则可以用过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果进行累加。</p><p>这道题中，被乘数是 <code>nums1</code> ,乘数是 <code>num2</code>。</p><p>需要注意的是，<code>num2</code> 除了最低位以外，其余的每一位的运算结果都需要补 0。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/sol1.png" alt="fig1" style="zoom:48%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> num1.length(), len2 = num2.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">curProduct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 补0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len2 - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            curProduct.append(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum2</span> <span class="operator">=</span> num2.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 curNum 去乘 num1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len1 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curNum1</span> <span class="operator">=</span> num1.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> curNum1 * curNum2 + carry;</span><br><span class="line"></span><br><span class="line">            curProduct.append(product % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = addStrings(ans,curProduct.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1 + n2 + carry;</span><br><span class="line">        res.append(tmp % <span class="number">10</span>);</span><br><span class="line">        carry = tmp / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        res.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="大数相减">大数相减</h2><p>1、执行计算前首先比较减数(num1)和被减数(num2)的大小，如果num1&gt;num2,那么就模拟num1-num2的过程，如果num1&lt;num2，那么结果就为-(num2-num1) 。当然可以为了稳定模拟时候一个大一个小，可将num1始终指向较大的那个数，少写一个if/else.</p><p>2、在比较两个数字大小的时候，因为是字符形式，首先比较两个字符串的长度，长的那个更大短的那个更小，如果两个字符串等大，那么就可以通过字典序从前往后进行比较(Java可直接使用compareTo方法)。</p><p>3、和加法不同的是，减法前面可能产生若干前缀0，这些0是需要你去掉的，例如&quot;1100&quot;-“1000&quot;计算得到的结果为&quot;0100”,你就要把前面的0去掉返回&quot;100&quot;。</p><p>4、具体实现的时候和加法相似，如果使用StringBuilder存储，需要逆置顺序，如果是个负数，前面还要加上’-'.</p><p>5、每个位置正常进行减法运算，如果值小于0，那么就需要向上借位(+10),那么处理上一位进行减法时候还要将借位的处理一下。</p><img src="https://ask.qcloudimg.com/http-save/yehe-4372098/mlwn6ygdwd.png" alt="img" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.length() &lt; num2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num1.length() &gt; num2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num1.compareTo(num2) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">subtractString</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="string">&#x27;+&#x27;</span>;<span class="comment">//正负号</span></span><br><span class="line">    <span class="comment">//让num1&gt;num2 如果num1&lt;num2 那么结果就是—(num2-num1)</span></span><br><span class="line">    <span class="comment">//可以先将num1和num2交换和前面情况统一</span></span><br><span class="line">    <span class="keyword">if</span> (!compare(num1, num2)) &#123;</span><br><span class="line">        sign = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">team</span> <span class="operator">=</span> num2;</span><br><span class="line">        num2 = num1;</span><br><span class="line">        num1 = team;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">borrow</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//借位</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? (num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? (num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> n1 - n2 - borrow;</span><br><span class="line">        borrow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)<span class="comment">//需要向前借位</span></span><br><span class="line">        &#123;</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">        sb.append(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sb = sb.reverse();<span class="comment">//需要先翻转</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//去掉前面没用的’0‘</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; sb.length() &amp;&amp; sb.charAt(index) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果两个数相同 直接返回&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (index == sb.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="string">&#x27;+&#x27;</span>)<span class="comment">//如果正数</span></span><br><span class="line">        <span class="keyword">return</span> sb.substring(index);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sign + sb.substring(index);<span class="comment">//负数需要返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="大数相除">大数相除</h2><p>对于大数a/b，一般最多要求求到其整数解或者余数，即a/b=c……d（a,b,c,d均为整）;也就是<strong>a里面有c个b</strong>，并且还剩下d。核心是先求c是多少，对于程序来说，可以通过枚举啊，将除法变成减法，从a中不断减d，一直到不能减为止。</p><p>但是有个问题，如果被除数a很大很大，可能有居多个b，那么这样时间复杂度太高了，不可能执行那么多次，那么需要怎么样去优化这个方法呢？</p><p>那就要加速寻找次数，减少这个减法的次数了，减法次数减小的一个最好方案就是能不能<strong>扩大除数b</strong>。如果b后面加个<code>'0'</code>，那么算出来的结果就乘以10，减法的次数变成原来十分之一。根据这个思想我们可以一直每次找到b的最大10的倍数(小于a)计算减的次数再换算成减b的总词数，将结果要以字符串方式保留，后面一直迭代到最后为止,这虽然是一道除法运算的题，但是也蕴含减法和加法(次数叠加到结果中)。</p>]]></content>
    
    
    <summary type="html">大数相加、大数相减、大数相乘、</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>限流算法</title>
    <link href="https://wuwawawa.github.io/posts/32609cb8.html"/>
    <id>https://wuwawawa.github.io/posts/32609cb8.html</id>
    <published>2023-09-02T05:04:36.000Z</published>
    <updated>2023-09-02T07:37:52.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="固定窗口算法">固定窗口算法</h2><h3 id="实现原理">实现原理</h3><p>固定窗口限流算法，也叫<span class='p green'>计数器限流算法</span>，是最简单的一种限流算法。</p><p><strong>实现原理是：</strong> 在一个固定长度的时间窗口内限制请求数量，每来一个请求，请求次数加一，如果请求数量超过最大限制，就拒绝该请求。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902132700830.png" alt="image-20230902132700830" style="zoom: 50%;" /><hr><h3 id="代码实现">代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定窗口限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixWindowLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10L</span>; <span class="comment">// 每个窗口的最大请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000L</span>; <span class="comment">// 窗口大小，单位ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">reqCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 窗口内的当前请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 窗口开始时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限流方法，返回true表示限流</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 判断是否在当前时间窗口内，如果不在就开启一个新的时间窗口</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastTime &gt; windowUnit) &#123;</span><br><span class="line">            <span class="comment">// 重置计数器</span></span><br><span class="line">            reqCount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 开启新窗口</span></span><br><span class="line">            lastTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// // 判断是否超过最大请求量</span></span><br><span class="line">        <span class="keyword">if</span> (reqCount &lt; threshold) &#123;</span><br><span class="line">            reqCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点">优缺点</h3><p><strong>优点：</strong> 实现简单，容易理解。</p><p><strong>缺点：</strong></p><ol><li>限流不够平滑。例如：限流是每秒3个，在第一毫秒发送了3个请求，达到限流，窗口剩余时间的请求都将会被拒绝，体验不好。</li><li>无法处理窗口边界问题。因为是在某个时间窗口内进行流量控制，所以可能会出现窗口边界效应，即在时间窗口的边界处可能会有大量的请求被允许通过，从而导致突发流量。</li></ol><p>例如：限流是每秒3个，在第一秒的最后一毫秒发送了3个请求，在第二秒的第一毫秒又发送了3个请求。在这两毫米内处理了6个请求，但是并没有触发限流。如果出现突发流量，可能会压垮服务器。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902134743416.png" alt="image-20230902134743416" style="zoom: 50%;" /><hr><hr><h2 id="滑动窗口算法">滑动窗口算法</h2><h3 id="实现原理-2">实现原理</h3><p>为了解决固定窗口算法统计精度太低的问题，引入了滑动窗口算法。在滑动窗口算法中，窗口的起止时间是动态的，窗口的大小固定。这种算法能够较好地处理窗口边界问题，但是实现相对复杂，需要记录每个请求的时间戳。</p><p><strong>实现原理是：</strong> 每来一个请求，就向后推一个时间窗口，计算这个窗口内的请求数量。如果请求数量超过限制就拒绝请求，否则就处理请求，并记录请求的时间戳。另外还需要一个任务清理过期的时间戳。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902135306151.png" alt="image-20230902135306151" style="zoom:50%;" /><hr><h3 id="代码实现-2">代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 每个窗口的最大请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 窗口大小，1000ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Long&gt; requestList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//  请求集合，用来存储窗口内的请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限流方法，返回true表示拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 统计当前窗口内，有效的请求数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeOfValid</span> <span class="operator">=</span> <span class="built_in">this</span>.sizeOfValid(currentTime);</span><br><span class="line">        <span class="comment">// 判断是否超过最大请求数量</span></span><br><span class="line">        <span class="keyword">if</span> (sizeOfValid &lt; threshold) &#123;</span><br><span class="line">            <span class="comment">// 把当前请求添加到请求集合里</span></span><br><span class="line">            requestList.add(currentTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计当前窗口内，有效的请求数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sizeOfValid</span><span class="params">(<span class="type">long</span> currentTime)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeOfValid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long requestTime : requestList) &#123;</span><br><span class="line">            <span class="comment">// 判断是否在当前时间窗口内</span></span><br><span class="line">            <span class="keyword">if</span> (currentTime - requestTime &lt;= windowUnit) &#123;</span><br><span class="line">                sizeOfValid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sizeOfValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理过期的请求（单独启动一个线程处理）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否超出当前时间窗口内</span></span><br><span class="line">        requestList.removeIf(requestTime -&gt; System.currentTimeMillis() - requestTime &gt; windowUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点-2">优缺点</h3><p><strong>优点：</strong> 解决了固定窗口算法的窗口边界问题，避免突发流量压垮服务器。</p><p><strong>缺点：</strong> 还是存在限流不够平滑的问题。例如：限流是每秒3个，在第一毫秒发送了3个请求，达到限流，剩余窗口时间的请求都将会被拒绝，体验不好。</p><hr><hr><h2 id="漏桶算法">漏桶算法</h2><h3 id="实现原理-3">实现原理</h3><p>漏桶限流算法是一种常用的流量整形（Traffic Shaping）和流量控制（Traffic Policing）的算法，它可以有效地控制数据的传输速率以及防止网络拥塞。</p><p>实现原理是：</p><ol><li>一个固定容量的漏桶，按照固定速率出水（处理请求）；</li><li>当流入水（请求数量）的速度过大会直接溢出（请求数量超过限制则直接拒绝）。</li><li>桶里的水（请求）不够则无法出水（桶内没有请求则不处理）。</li></ol><p>当请求流量正常或者较小的时候，请求能够得到正常的处理。当请求流量过大时，漏桶限流算法可以通过丢弃部分请求来防止系统过载。</p><p>这种算法的一个重要特性是，输出数据的速率始终是稳定的，无论输入的数据流量如何变化。这就确保了系统的负载不会超过预设的阈值。但是，由于漏桶的出口速度是固定的，所以无法处理突发流量。此外，如果入口流量过大，漏桶可能会溢出，导致数据丢失。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902144242297.png" alt="image-20230902144242297" style="zoom:50%;" /><hr><h3 id="算法实现">算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucketLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 桶的最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 桶内当前水量(当前累计的请求数)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">leakRate</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 漏水速率(每秒系统能处理的请求数)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastLeakTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 上次漏水时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true，表示限流</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用漏水方法</span></span><br><span class="line">        <span class="built_in">this</span>.leak();</span><br><span class="line">        <span class="comment">// 判断是否超过最大请求数量</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; threshold) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 漏水方法，计算并更新这段时间内漏水量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leak</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 计算这段时间内，需要流出的水量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">leakWater</span> <span class="operator">=</span> (currentTime - lastLeakTime) * leakRate / <span class="number">1000</span>;</span><br><span class="line">        count = Math.max(count - leakWater, <span class="number">0</span>);</span><br><span class="line">        lastLeakTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点-3">优缺点</h3><p><strong>优点：</strong></p><ol><li>**平滑流量。**由于漏桶算法以固定的速率处理请求，可以有效地平滑和整形流量，避免流量的突发和波动（类似于消息队列的削峰填谷的作用）。</li><li>**防止过载。**当流入的请求超过桶的容量时，可以直接丢弃请求，防止系统过载。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>无法处理突发流量</strong>：由于漏桶的出口速度是固定的，无法处理突发流量。面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这不是我们想看到的。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验。</li><li><strong>可能会丢失数据</strong>：如果入口流量过大，超过了桶的容量，那么就需要丢弃部分请求。在一些不能接受丢失请求的场景中，这可能是一个问题。</li><li><strong>不适合速率变化大的场景</strong>：如果速率变化大，或者需要动态调整速率，那么漏桶算法就无法满足需求。</li></ol><hr><hr><h2 id="令牌桶算法">令牌桶算法</h2><h3 id="实现原理-4">实现原理</h3><p>令牌桶限流算法是一种常用的流量整形和速率限制算法。与漏桶算法一样，令牌桶算法也是用来控制发送到网络上的数据的数量。</p><p>实现原理：</p><ol><li>系统以固定的速率向桶中添加令牌；</li><li>当有请求到来时，会尝试从桶中移除一个令牌，如果桶中有足够的令牌，则请求可以被处理或数据包可以被发送；</li><li>如果桶中没有令牌，那么请求将被拒绝；</li><li>桶中的令牌数不能超过桶的容量，如果新生成的令牌超过了桶的容量，那么新的令牌会被丢弃。</li></ol><p>令牌桶算法的一个重要特性是，它能够应对突发流量。当桶中有足够的令牌时，可以一次性处理多个请求，这对于需要处理突发流量的应用场景非常有用。但是又不会无限制的增加处理速率导致压垮服务器，因为桶内令牌数量是有限制的。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902150018034.png" alt="image-20230902150018034" style="zoom:50%;" /><hr><h3 id="代码实现-3">代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucketLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 桶的最大容量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 桶内当前的令牌数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">tokenRate</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 令牌生成速率（每秒5次）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastRefillTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 上次生成令牌的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true表示限流</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用生成令牌方法</span></span><br><span class="line">        <span class="built_in">this</span>.refillTokens();</span><br><span class="line">        <span class="comment">// 判断桶内是否还有令牌</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成令牌方法，计算并更新这段时间内生成的令牌数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refillTokens</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 计算这段时间内，需要生成的令牌数量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">refillTokens</span> <span class="operator">=</span> (currentTime - lastRefillTime) * tokenRate / <span class="number">1000</span>;</span><br><span class="line">        count = Math.min(count + refillTokens, threshold);</span><br><span class="line">        lastRefillTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点-4">优缺点</h3><p><strong>优点：</strong></p><ol><li><strong>可以处理突发流量</strong>：令牌桶算法可以处理突发流量。当桶满时，能够以最大速度处理请求。这对于需要处理突发流量的应用场景非常有用。</li><li><strong>限制平均速率</strong>：在长期运行中，数据的传输率会被限制在预定义的平均速率（即生成令牌的速率）。</li><li><strong>灵活性</strong>：与漏桶算法相比，令牌桶算法提供了更大的灵活性。例如，可以动态地调整生成令牌的速率。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>可能导致过载</strong>：如果令牌产生的速度过快，可能会导致大量的突发流量，这可能会使网络或服务过载。</li><li><strong>需要存储空间</strong>：令牌桶需要一定的存储空间来保存令牌，可能会导致内存资源的浪费。</li><li><strong>实现稍复杂</strong>：相比于计数器算法，令牌桶算法的实现稍微复杂一些。</li></ol><hr><hr><h2 id="总结">总结</h2><p><strong>固定窗口算法</strong>实现简单，但是限流不够平滑，存在窗口边界问题，适用于需要简单实现限流的场景。</p><p><strong>滑动窗口算法</strong>解决了窗口边界问题，但是还是存在限流不够平滑的问题，适用于需要控制平均请求速率的场景。</p><p><strong>漏桶算法</strong>的优点是流量处理更平滑，但是无法应对突发流量，适用于需要平滑流量的场景。</p><p><strong>令牌桶算法</strong>既能平滑流量，又能处理突发流量，适用于需要处理突发流量的场景。</p>]]></content>
    
    
    <summary type="html">固定窗口、滑动窗口、漏桶和令牌桶限流</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="限流算法" scheme="https://wuwawawa.github.io/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找-红蓝边界法</title>
    <link href="https://wuwawawa.github.io/posts/c1110203.html"/>
    <id>https://wuwawawa.github.io/posts/c1110203.html</id>
    <published>2023-08-11T06:49:12.000Z</published>
    <updated>2023-09-14T13:32:08.638Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是一种在有序数组中查找某一特定元素的搜索算法。在很多人的印象里，二分查找是一种比较简单的算法。然而在实际中，二分查找经常容易写错，特别是在处理边界条件的时候。算法大神高德纳曾经说过，“虽然二分查找的基本思想相对简单直白，但是细节上却惊人的tricky”。</p><h2 id="问题">问题</h2><p>给定有序数组<code>1 2 3 5 5 5 8 9</code>，有4个小问题分别是：</p><ol><li><p>找到第一个<code>&gt;=5</code>的元素</p></li><li><p>找到最后一个<code>&lt;5</code>的元素</p></li><li><p>找到第一个<code>&gt;5</code>的元素</p></li><li><p>找到最后一个<code>&lt;=5</code>的元素</p></li></ol><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230715195248912.png" alt="image-20230715195248912" style="zoom: 50%;" /><p>大家可以看到，对于这四个问题来说，它们表面上是比较相似的，但是细节上却有些微的不同，它们的答案也是完全不同的。</p><p>可想而知，如果我们用二分查找来解决这个问题，细节处理并不容易，一不小心可能就会出错。</p><hr><hr><h2 id="新的角度">新的角度</h2><p>让我们暂时忘掉刚才的问题，从一个全新的角度来审视二分查找。</p><p>大家可以看到，这里有一个数组，里面一共有N个元素，这些元素的编号是0到N-1。在这N个元素里面，前K个元素颜色是蓝色，后面的元素是红色。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716093005464.png" alt="image-20230716093005464" style="zoom:80%;" /><p>然而，在这个问题中，蓝红边界的位置是未知的，即K是未知的。换句话说，在我们一开始拿到数组的时候，整个数组都是灰色的。这个问题的最终目标，是把蓝红边界找出来，即求出未知数K。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716093139742.png" alt="image-20230716093139742" style="zoom:80%;" /><hr><h2 id="朴素算法">朴素算法</h2><p>在这里，我们假设一共有9个元素，前面5个元素是蓝色，后面4个元素是红色</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716093644294.png" alt="image-20230716093644294"></p><p>在我们一开始拿到数组的时候，整个数组都是灰色的。</p><p>我们可以设计一个蓝色指针，一开始指向最左面，随后不断向右移动，直到移动到蓝红边界。或者设计一个红色指针，一开始指向最右面，然后不断向左移动，直到移动到蓝红边界。</p><p>这样就求得了蓝红边界所在的位置。</p><p>当然，这种算法是非常低效的，它的算法复杂度是O(n）</p><hr><h2 id="二分查找">二分查找</h2><p>接下来我们看一下如何通过二分查找高效的寻找到蓝红边界，在刚才的朴素算法中，我们持续不断的将蓝色指针向右移动。对于这个过程，我们可以把它理解为蓝色区域不断被拓展。同理，红色指针不断向左移动，我们可以把这个过程理解为红色区域不断被拓展。</p><p>朴素算法之所以效率低下，是因为蓝色区域和红色区域的拓展是缓慢进行的，每次只能拓展一个元素。</p><hr><h3 id="基本步骤">基本步骤</h3><blockquote><p>那么，我们有没有什么办法来加速两个区域的拓展过程呢？</p></blockquote><div class="tabs" id="c747378e-3702-44cf-8e98-a9f5063d2056"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c747378e-3702-44cf-8e98-a9f5063d2056-1"><i class="fas fa-seedling"></i>循环次数1</button></li><li class="tab"><button type="button" data-href="#c747378e-3702-44cf-8e98-a9f5063d2056-2"><i class="fas fa-leaf"></i>循环次数2</button></li><li class="tab"><button type="button" data-href="#c747378e-3702-44cf-8e98-a9f5063d2056-3"><i class="fab fa-apple"></i>循环次数3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c747378e-3702-44cf-8e98-a9f5063d2056-1"><p>我们可以这样做，我们可以直接看一下灰色区域最中间的那个元素颜色。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094245363.png" alt="image-20230716094245363"></p><p>在这里，我们发现这个元素颜色为蓝色。它就意味着，这个元素，以及这个元素之前所有的元素都是蓝色。这样的话，我们便可以直援将蓝色区域拓展到这个元素所在位置。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094329526.png" alt="image-20230716094329526"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c747378e-3702-44cf-8e98-a9f5063d2056-2"><p>让我们继续这样的操作。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094455062.png" alt="image-20230716094455062"></p><p>观察灰色区域中最中间的那个元素颜色，我们发现它是红色，这也就说明了，这个元素以及这个元素后面的元素都是红色。这样的话，我们便可以直接将红色区域拓展到这个元素所在的位置。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094652765.png" alt="image-20230716094652765"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c747378e-3702-44cf-8e98-a9f5063d2056-3"><p>接下来，我们不断的重复这种操作</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094835833.png" alt="image-20230716094835833"></p><p>直到最后，我们便找到了蓝红边界</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094859442.png" alt="image-20230716094859442"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="伪代码实现">伪代码实现</h3><div class="tabs" id="33539071-8bba-4bca-a801-0931002f5bff"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-4"><i class="fas fa-tree"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="33539071-8bba-4bca-a801-0931002f5bff-1"><p>一开始，我们设计L，R两个指针，L指向-1,R指向N</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095333538.png" alt="image-20230716095333538"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="33539071-8bba-4bca-a801-0931002f5bff-2"><p>当L+1！=R的时候，就会进入循环体。</p><p>然后，我们求得灰色区域中间的那个元素位置M，M=(L+R) /2并且向下取整。如果M的颜色是蓝色，我们就将L赋值为M，也就是将蓝色区域拓展到M。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095536554.png" alt="image-20230716095536554"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="33539071-8bba-4bca-a801-0931002f5bff-3"><p>如果M的颜色是红色，我们便将R赋值为M，也就是将红色区域拓展到M</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095650860.png" alt="image-20230716095650860"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="33539071-8bba-4bca-a801-0931002f5bff-4"><p>我们持续不断的重复这个过程，直到达成L+1=R这个条件，便退出循环。</p><p>此时，我们可以发现，L和R刚刚好指向蓝红边界，我们可以根据实际情况来决定返回L还是R。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095837237.png" alt="image-20230716095837237"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="细节问题">细节问题</h3><p>刚刚我绍的二分查找伪代码，可能和大家在其他地方所看到的版本有所不同。为了进一步证明算法的正确性，让我们看几个细节问题。</p><blockquote><p>为什么<span class='p blue'>L</span>的初始值为-1，<span class='p red'>R</span>的初始值为N?</p></blockquote><p>难道我们不能将L初始化为0，或者让R初始化为N-1么?</p><p>答案是不可以</p><p>试想一下，假如整个数组都是红色,那么如果让L初始化为0，L一开始便处于红色区域内，这也便会造成错误。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100233717.png" alt="image-20230716100233717"></p><p>同理，如果整个数组都是蓝色，那么如果让R初始化为N-1，R一开始便处于蓝色区域，也就造成了错误。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100344067.png" alt="image-20230716100344067"></p><p>所以，我们需要让L初始化为-1，R初始化为N。</p><hr><blockquote><p>更新指针时，能不能写成L=m+1，或者R=m-1?</p></blockquote><p>比如说，对于这样一种情况，在某次循环中，M刚刚好指向蓝色区域的最后一个元素。那么，如果我们让L变成M+1，就会让L指向红色区域，这样就造成了错误。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100809314.png" alt="image-20230716100809314"></p><hr><h2 id="问题答案">问题答案</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100920458.png" alt="image-20230716100920458"></p><hr><h2 id="一般流程">一般流程</h2><ul><li>建模：划分<span class='p blue'>蓝</span><span class='p red'>红</span>区域，确定<code>isBlue()</code>函数</li><li>确定返回<span class='p blue'>L</span>还是<span class='p red'>R</span></li><li>套用算法模版</li><li>后处理逻辑</li></ul>]]></content>
    
    
    <summary type="html">二分查找</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://wuwawawa.github.io/posts/e8eb0480.html"/>
    <id>https://wuwawawa.github.io/posts/e8eb0480.html</id>
    <published>2023-08-10T02:28:21.000Z</published>
    <updated>2023-09-14T13:32:14.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寻找一个数-基本的二分查找">寻找一个数(基本的二分查找)</h2><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意点分析</p></blockquote><div class="tabs" id="5c9537ee-7214-4745-8b2a-37749be89f75"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5c9537ee-7214-4745-8b2a-37749be89f75-1"><i class="fas fa-seedling"></i>while循环退出条件</button></li><li class="tab"><button type="button" data-href="#5c9537ee-7214-4745-8b2a-37749be89f75-2"><i class="fas fa-leaf"></i>l和r更新</button></li><li class="tab"><button type="button" data-href="#5c9537ee-7214-4745-8b2a-37749be89f75-3"><i class="fab fa-apple"></i>缺陷</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5c9537ee-7214-4745-8b2a-37749be89f75-1"><p><mark class="hl-label blue">为什么while循环的条件中是&lt;=而不是&lt;</mark></p><p>因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code></p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p><p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。</p><p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有索引既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[left, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5c9537ee-7214-4745-8b2a-37749be89f75-2"><p>什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断？</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？</p><p>当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> 对不对？因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5c9537ee-7214-4745-8b2a-37749be89f75-3"><p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="寻找第一个满足该条件的值">寻找第一个满足该条件的值</h2><p>当 check(mid) == true 调整的是 r 时：计算 mid 的方式应该为 mid = l + r &gt;&gt; 1</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">int</span> l = <span class="number">0</span>, r = <span class="built_in">n</span> - <span class="number">1</span>;</span><br><span class="line">while (l &lt; r) &#123;</span><br><span class="line">       <span class="built_in">int</span> <span class="built_in">mid</span> = l + r &gt;&gt; <span class="number">1</span>; //推荐写法 <span class="built_in">int</span> <span class="built_in">mid</span> = l +( r - l) / <span class="number">2</span>;</span><br><span class="line">       <span class="built_in">if</span> (check(<span class="built_in">mid</span>)) &#123;</span><br><span class="line">           //偏移r, 求第一个满足该条件的值</span><br><span class="line">           r = <span class="built_in">mid</span>;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           l = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="寻找最后一个满足该条件的值">寻找最后一个满足该条件的值</h2><p>当 check(mid) == true 调整的是 l 时：计算 mid 的方式应该为 mid = l + r + 1 &gt;&gt; 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//向上取整， +1 操作主要是为了避免发生「死循环」</span></span><br><span class="line">       <span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">           <span class="comment">//偏移l, 求最后一个满足该条件的值</span></span><br><span class="line">           l = mid;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           r = mid - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二分查找</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="https://wuwawawa.github.io/posts/f92eff5d.html"/>
    <id>https://wuwawawa.github.io/posts/f92eff5d.html</id>
    <published>2023-08-02T04:06:11.000Z</published>
    <updated>2023-09-14T01:35:44.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="划分k个相等的子集">划分k个相等的子集</h2><div class="tabs" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-1"><i class="fas fa-seedling"></i>火柴拼正方形</button></li><li class="tab"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-2"><i class="fas fa-leaf"></i>划分为k个相等的子集</button></li><li class="tab"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-4"><i class="fas fa-tree"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-1"><div class="tag link"><a class="link-card" title="473. 火柴拼正方形" href="https://leetcode.cn/problems/matchsticks-to-square/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">473. 火柴拼正方形</p><p class="url">https://leetcode.cn/problems/matchsticks-to-square/</p></div></a></div><p>你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。</p><p>如果你能使这个正方形，则返回 true ，否则返回 false 。</p><div class="tabs" id="10b05bf4-7acc-4492-a4d8-1a859f0abe58"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#10b05bf4-7acc-4492-a4d8-1a859f0abe58-1"><i class="fas fa-cat"></i>解法一</button></li><li class="tab"><button type="button" data-href="#10b05bf4-7acc-4492-a4d8-1a859f0abe58-2"><i class="fas fa-horse"></i>解法二</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="10b05bf4-7acc-4492-a4d8-1a859f0abe58-1"><p>边界条件时不需要对每个桶是否都达到target进行判断。</p><p>若某个桶的长度小于target，那达到末尾时，就必然会有桶长度大于target。而这种情况不会进入下一次递归的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] matchsticks;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makesquare</span><span class="params">(<span class="type">int</span>[] _matchsticks)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(_matchsticks).sum();</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    target = sum/<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    matchsticks = Arrays.stream(_matchsticks).boxed().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span> , <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> idx ,<span class="type">int</span>[] edges)</span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(idx == matchsticks.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前的木棍放置到4个桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">        edges[i] += matchsticks[idx];</span><br><span class="line">        <span class="keyword">if</span>(edges[i] &lt;= target &amp;&amp; dfs(idx + <span class="number">1</span>,edges))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edges[i] -= matchsticks[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="10b05bf4-7acc-4492-a4d8-1a859f0abe58-2"><p>状态压缩+记忆化</p><p>使用<code>curSum + matchsticks[i] &lt;= side</code>和<code>int newSum = (curSum + matchsticks[i]) % side;</code></p><p>两种方式巧妙实现单边的增长以及当达到side时进行下一条边的选择。</p><p>当sum&lt;side时，sum会一直累积。当刚好达到side时，清0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> side; <span class="comment">// 边长</span></span><br><span class="line"><span class="type">int</span>[] cache;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] matchsticks;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makesquare</span><span class="params">(<span class="type">int</span>[] _matchsticks)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(_matchsticks).sum();</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    side = sum / <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    matchsticks = Arrays.stream(_matchsticks).boxed().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    n = _matchsticks.length;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">    cache[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> curSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[state] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[state] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((state &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; curSum + matchsticks[i] &lt;= side) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newSum</span> <span class="operator">=</span> (curSum + matchsticks[i]) % side;</span><br><span class="line">            <span class="keyword">if</span> (dfs(state | (<span class="number">1</span> &lt;&lt; i), newSum)) &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache[state] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-2"><div class="tag link"><a class="link-card" title="698. 火柴拼正方形" href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">698. 火柴拼正方形</p><p class="url">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</p></div></a></div><p>给定一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p><p>同上一题写法</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">回溯</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从暴力递归到动态规划</title>
    <link href="https://wuwawawa.github.io/posts/1d80917d.html"/>
    <id>https://wuwawawa.github.io/posts/1d80917d.html</id>
    <published>2023-07-05T13:11:40.000Z</published>
    <updated>2023-09-14T01:35:54.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><h3 id="什么暴力递归可以继续优化？">什么暴力递归可以继续优化？</h3><p>有重复调用同一个子问题的解，这种递归可以优化</p><p>如果每一个子问题都是不同的解，无法优化也不用优化</p><hr><h3 id="暴力递归和动态规划的关系">暴力递归和动态规划的关系</h3><p>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划</p><p>任何动态规划问题，都一定对应着某一个有重复过程的暴力递归</p><p>但不是所有的暴力递归，都一定对应着动态规划</p><hr><h3 id="如何找到问题的动态规划方式？">如何找到问题的动态规划方式？</h3><ul><li>设计暴力递归：原则+4种常见尝试模型！</li><li>分析有没有重复解</li><li>用记忆化搜索-&gt;用严格表结构实现动态规划</li><li>看看能否继续优化</li></ul><hr><h3 id="设计暴力递归过程的原则">设计暴力递归过程的原则</h3><p>1）每一个可变参数的类型，一定不要比int类型更加复杂</p><p>2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数（贴纸问题）</p><p>3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可</p><p>4）可变参数的个数，能少则少</p><p>一定要逼自己找到不违反原则情况下的暴力尝试！</p><p>如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！</p><p>如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！</p><hr><h3 id="常见的4种尝试模型">常见的4种尝试模型</h3><p>1）从左往右的尝试模型：关注i位置结尾，或者i位置开头的情况，或者看i联合i+1,i+2的情况，填表往往是上到下，或者下到上，左到右，右到左。</p><p>2）范围上的尝试模型：关注L和R的情况，填表格式非常固定，主对角，副对角，倒回来填</p><p>3）多样本位置全对应的尝试模型：2个样本，一个样本做行，一个样本做列，关注i和j对应位置的情况，先填边界，再填中间</p><p>4）寻找业务限制的尝试模型：比如走棋盘，固定的几个方向可以走，先填边界，再填中间。</p><hr><h3 id="暴力递归到动态规划的套路">暴力递归到动态规划的套路</h3><p>1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用<br>2）找到哪些参数的变化会影响返回值，对每一个列出变化范围<br>3）参数间的所有的组合数量，意味着表大小<br>4）记忆化搜索的方法就是傻缓存，非常容易得到<br>5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解<br>6）对于有枚举行为的决策过程，进一步优化</p><hr><h3 id="动态规划的进一步优化">动态规划的进一步优化</h3><p>1）空间压缩<br>2）状态化简<br>3）四边形不等式</p><p>4）其他优化技巧</p><hr><hr><h2 id="从左往右的尝试模型">从左往右的尝试模型</h2><p>关注i位置结尾，或者i位置开头的情况，或者看i联合i+1,i+2的情况，填表往往是上到下，或者下到上，左到右，右到左。</p><h3 id="题目一">题目一</h3><p>假设有排成一行的N个位置，记为1~N，N 一定大于或等于2</p><p>开始时机器人在其中的M位置上(M 一定是1~N 中的一个）</p><p>如果机器人来到1位置，那么下一步只能往右来到2位置；</p><p>如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；</p><p>如果机器人来到中间位置，那么下一步可以往左走或者往右走；</p><p>规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个）的方法有多少种</p><p>给定四个参数N、M、K、P，返回方法数。</p><div class="tabs" id="6fc3a967-8198-4bf8-900f-bd039c7f5726"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-1"><i class="fas fa-seedling"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-2"><i class="fas fa-leaf"></i>重复解分析</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-3"><i class="fab fa-apple"></i>傻缓存法</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-4"><i class="fas fa-heartbeat"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-5"><i class="fas fa-tree"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways1</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process1(start, K, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 机器人当前来到的位置是cur，</span></span><br><span class="line"><span class="comment">// 机器人还有rest步需要去走，</span></span><br><span class="line"><span class="comment">// 最终的目标是aim，</span></span><br><span class="line"><span class="comment">// 有哪些位置？1~N</span></span><br><span class="line"><span class="comment">// 返回：机器人从cur出发，走过rest步之后，最终停在aim的方法数，是多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> aim, <span class="type">int</span> N)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123; <span class="comment">// 如果已经不需要走了，走完了！</span></span><br><span class="line"><span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line"><span class="keyword">if</span> (cur == <span class="number">1</span>) &#123; <span class="comment">// 1 -&gt; 2</span></span><br><span class="line"><span class="keyword">return</span> process1(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line"><span class="keyword">if</span> (cur == N) &#123; <span class="comment">// N-1 &lt;- N</span></span><br><span class="line"><span class="keyword">return</span> process1(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line"><span class="keyword">return</span> process1(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N) + process1(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-2"><p>假如从7位置出发走到13，还有10步需要走，存在重复解。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230706110749520.png" alt="image-20230706110749520" style="zoom:67%;" /><p>cur和rest是决定返回值的key</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-3"><p>记忆化搜索（从顶向下的动态规划）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways2</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp就是缓存表</span></span><br><span class="line"><span class="comment">// dp[cur][rest] == -1 -&gt; process1(cur, rest)之前没算过！</span></span><br><span class="line"><span class="comment">// dp[cur][rest] != -1 -&gt; process1(cur, rest)之前算过！返回值，dp[cur][rest]</span></span><br><span class="line"><span class="comment">// N+1 * K+1</span></span><br><span class="line"><span class="keyword">return</span> process2(start, K, aim, N, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cur 范: 1 ~ N</span></span><br><span class="line"><span class="comment">// rest 范：0 ~ K</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> aim, <span class="type">int</span> N, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[cur][rest] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之前没算过！</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">ans = cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">ans = process2(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">ans = process2(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans = process2(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp) + process2(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">&#125;</span><br><span class="line">dp[cur][rest] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-4"><p>假设现在有5个位置，机器人当前在2位置，要前往4位置，有6步需要走</p><p>即N = 5，cur=2，aim=4，rest=6</p><div class="tabs" id="ada86bca-98db-41ea-ad53-a4296606c901"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ada86bca-98db-41ea-ad53-a4296606c901-1"><i class="fas fa-cat"></i>初始情况</button></li><li class="tab"><button type="button" data-href="#ada86bca-98db-41ea-ad53-a4296606c901-2"><i class="fas fa-horse"></i>basecase和ans</button></li><li class="tab"><button type="button" data-href="#ada86bca-98db-41ea-ad53-a4296606c901-3"><i class="fas fa-dove"></i>普遍位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ada86bca-98db-41ea-ad53-a4296606c901-1"><p>cur = 0位置是弃用的，cur只能是1-N</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E5%88%9D%E5%A7%8B%E6%83%85%E5%86%B51.png" alt="初始情况1"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ada86bca-98db-41ea-ad53-a4296606c901-2"><p>主函数中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">process1</span><span class="params">(start, K, aim, N)</span></span>;</span><br></pre></td></tr></table></figure><p>暴力递归函数中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123; <span class="comment">// 如果已经不需要走了，走完了！</span></span><br><span class="line"><span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当rest等于0时，只有cur==aim是，才是1，最终需要process(2,6)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/baseCase%E5%92%8Cans1.png" alt="baseCase和ans1"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ada86bca-98db-41ea-ad53-a4296606c901-3"><p>暴力递归中</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line">if (cur == <span class="number">1</span>) &#123; <span class="comment">// 1 -&gt; 2</span></span><br><span class="line">return <span class="built_in">process1</span>(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line">if (cur == N) &#123; <span class="comment">// N-1 &lt;- N</span></span><br><span class="line">return <span class="built_in">process1</span>(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line">return <span class="built_in">process1</span>(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N) + <span class="built_in">process1</span>(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br></pre></td></tr></table></figure><p>既不是第一行，也不最后一行，普遍位置依赖坐上角的值和坐下角的值</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%99%AE%E9%81%8D%E4%BD%8D%E7%BD%AE1.png" alt="普遍位置1"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways3</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">dp[aim][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= K; rest++) &#123;</span><br><span class="line">dp[<span class="number">1</span>][rest] = dp[<span class="number">2</span>][rest - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">2</span>; cur &lt; N; cur++) &#123;</span><br><span class="line">dp[cur][rest] = dp[cur - <span class="number">1</span>][rest - <span class="number">1</span>] + dp[cur + <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[N][rest] = dp[N - <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[start][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="题目二">题目二</h3><p>规定1和A对应、2和B对应、3和C对应…</p><p>那么一个数字字符串比如&quot;111&quot;就可以转化为：“AAA”、“KA&quot;和&quot;AK”</p><p>给定一个只有数字字符组成的字符串str，返回有多少种转化结果</p><div class="tabs" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2b7683cc-3522-45ca-9ef3-7374aaed0b7a-1"><i class="fas fa-cat"></i>暴力尝试</button></li><li class="tab"><button type="button" data-href="#2b7683cc-3522-45ca-9ef3-7374aaed0b7a-2"><i class="fas fa-horse"></i>重复问题分析</button></li><li class="tab"><button type="button" data-href="#2b7683cc-3522-45ca-9ef3-7374aaed0b7a-3"><i class="fas fa-dragon"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str只含有数字字符0~9</span></span><br><span class="line"><span class="comment">// 返回多少种转化方案</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">number</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[0..i-1]转化无需过问</span></span><br><span class="line"><span class="comment">// str[i.....]去转化，返回有多少种转化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i没到最后，说明有字符</span></span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 之前的决定有问题</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// str[i] != &#x27;0&#x27;</span></span><br><span class="line"><span class="comment">// 可能性一，i单转</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> process(str, i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">ways += process(str, i + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a-2"><p>假如str = “111”</p><p>两个1 解读为两个字符  p(0)-&gt;p(2)</p><p>两个1 解读为一个字符  p(0)-&gt;p(2)</p><p>存在重复问题</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">dp[N] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> dp[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">ways += dp[i + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="背包问题">背包问题</h3><div class="tabs" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-1"><i class="fas fa-bug"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-2"><i class="fas fa-cannabis"></i>重复解分析</button></li><li class="tab"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-3"><i class="fas fa-candy-cane"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-4"><i class="fas fa-child"></i>严格位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的货，重量和价值，都在w和v数组里</span></span><br><span class="line"><span class="comment">// 为了方便，其中没有负数</span></span><br><span class="line"><span class="comment">// bag背包容量，不能超过这个载重</span></span><br><span class="line"><span class="comment">// 返回：不超重的情况下，能够得到的最大价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length != v.length || w.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试函数！</span></span><br><span class="line"><span class="keyword">return</span> process(w, v, <span class="number">0</span>, bag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前考虑到了index号货物，index...所有的货物可以自由选择</span></span><br><span class="line"><span class="comment">// 做的选择不能超过背包容量</span></span><br><span class="line"><span class="comment">// 返回最大价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 不要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest);</span><br><span class="line">  <span class="comment">// 要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest - w[index]);</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = v[index] + next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-2"><p>w = [3,2,5…]</p><p>v = [7,4,6…]</p><p>bag = 15</p><p>要了0，1号货，没要2号货调用过程  p(0,15)-&gt;p(1,12)-p(2,10)-&gt;p(3,10)</p><p>没要0，1，但是要了2号货调用过程 p(0,15)-&gt;p(1,15)-&gt;p(2,15)-&gt;p(3,10)</p><p>存在重复调用</p><p>index rest 即为变量</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-3"><p>假设背包大小为10，共有4件物品</p><div class="tabs" id="e59b06c7-c7b9-4440-bffd-7640af43b5de"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e59b06c7-c7b9-4440-bffd-7640af43b5de-1"><i class="fas fa-seedling"></i>basecase和ans</button></li><li class="tab"><button type="button" data-href="#e59b06c7-c7b9-4440-bffd-7640af43b5de-2"><i class="fas fa-leaf"></i>普遍位置分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e59b06c7-c7b9-4440-bffd-7640af43b5de-1"><p>index 在递归中是可以到w.length的</p><p>最终需要process(0,bag)状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98basecase.png" alt="背包问题basecase"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e59b06c7-c7b9-4440-bffd-7640af43b5de-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 不要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest);</span><br><span class="line"> <span class="comment">// 要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest - w[index]);</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = v[index] + next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设</p><p>w[1] = 2 v[1] = 4，则普遍位置？依赖如图所示</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%99%AE%E9%81%8D%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%96.png" alt="背包问题普遍位置依赖"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length != v.length || w.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> w.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][bag + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= bag; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> rest - w[index] &lt; <span class="number">0</span> ? -<span class="number">1</span> : dp[index + <span class="number">1</span>][rest - w[index]];</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = v[index] + next;</span><br><span class="line">&#125;</span><br><span class="line">dp[index][rest] = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="零钱兑换问题">零钱兑换问题</h3><h4 id="零钱兑换问题Ⅰ">零钱兑换问题Ⅰ</h4><p>arr是货币数组，其中的值都是正数。再给定一个正数aim。</p><p>每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的。</p><p>返回组成aim的方法数</p><p>例如：art ={1,1,1} aim = 2</p><p>第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2 一共就3种方法，所以返回3</p><div class="tabs" id="183f6f4e-28dc-487b-81f9-db439f37ab9c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#183f6f4e-28dc-487b-81f9-db439f37ab9c-1"><i class="fas fa-atom"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#183f6f4e-28dc-487b-81f9-db439f37ab9c-2"><i class="far fa-sun"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="183f6f4e-28dc-487b-81f9-db439f37ab9c-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinWays</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index....] 组成正好rest这么多的钱，有几种方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 没钱了！</span></span><br><span class="line"><span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, index + <span class="number">1</span>, rest) + process(arr, index + <span class="number">1</span>, rest - arr[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="183f6f4e-28dc-487b-81f9-db439f37ab9c-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest] + (rest - arr[index] &gt;= <span class="number">0</span> ? dp[index + <span class="number">1</span>][rest - arr[index]] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h4 id="零钱兑换问题Ⅱ-斜率优化">零钱兑换问题Ⅱ(斜率优化)</h4><p>arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。</p><p>每个值都认为是一种面值，且认为张数是无限的，返回组成aim的方法数。</p><p>例如：arr ={1,2)， aim = 4</p><p>方法如下：1+1+1+1、1+1+2、2+2一共就3种方法，所以返回3</p><div class="tabs" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-1"><i class="fas fa-bug"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-2"><i class="fas fa-cannabis"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-3"><i class="fas fa-candy-cane"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-4"><i class="fas fa-child"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinsWay</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 没钱了</span></span><br><span class="line"><span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">ways += process(arr, index + <span class="number">1</span>, rest - (zhang * arr[index]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-2"><p>index = 2 时   面值为3</p><p>f(2,10) -&gt; f(3,10)  f(3,7)  f(3,4)  f(3,1)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A21111.png" alt="零钱兑换1111"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">ways += dp[index + <span class="number">1</span>][rest - (zhang * arr[index])];</span><br><span class="line">&#125;</span><br><span class="line">dp[index][rest] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-4"><p>当一个格子没有枚举行为，只依赖有限的格子时，记忆化搜索和严格表结构一样的好</p><p>当一个格子有枚举行为，可以根据位置依赖严格表结构进行分析，进一步优化</p><p>index = 2 时   面值为3</p><p>p(2,10) = p(3,10) +p(3,7)+p(3,4) +p(3,1)</p><p>注意看</p><p>p(2,7) = p(3,7)+p(3,4) +p(3,1)</p><p>所以</p><p>p(2,10) = p(3,10) +p(2,7)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2222.png" alt="零钱兑换222"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[index][rest] += dp[index][rest - arr[index]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="零钱兑换问题Ⅲ-斜率优化">零钱兑换问题Ⅲ(斜率优化)</h4><p>arr是货币数组，其中的值都是正数。再给定一个正数aim。</p><p>每个值都认为是一张货币，认为值相同的货币没有任何不同，</p><p>返回组成aim的方法数</p><p>例如：arr={1,2,1,1,2,1,2)， aim = 4</p><p>方法：1+1+1+1、 1+1+2、 2+2 一共就3种方法，所以返回3</p><div class="tabs" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-1"><i class="fas fa-cat"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-2"><i class="fas fa-horse"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-3"><i class="fas fa-dove"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-4"><i class="fas fa-dragon"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinsWay</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(value)) &#123;</span><br><span class="line">            counts.put(value, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counts.put(value, counts.get(value) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> counts.size();</span><br><span class="line">    <span class="type">int</span>[] coins = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span>[] zhangs = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">        coins[index] = entry.getKey();</span><br><span class="line">        zhangs[index++] = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(coins, zhangs, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// coins 面值数组，正数且去重</span></span><br><span class="line"><span class="comment">// zhangs 每种面值对应的张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span>[] zhangs, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == coins.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * coins[index] &lt;= rest &amp;&amp; zhang &lt;= zhangs[index]; zhang++) &#123;</span><br><span class="line">        ways += process(coins, zhangs, index + <span class="number">1</span>, rest - (zhang * coins[index]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-2"><p>假设aim = 13</p><p>货币数设处理后为</p><p>coins = [1,3,4]</p><p>zhangs = [1,2,3]</p><p>p(2,10) = a +b+c</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2444.png" alt="零钱兑换444"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-3"><pre><code>public static int dp1(int[] arr, int aim) {if (arr == null || arr.length == 0 || aim &lt; 0) {return 0;}Info info = getInfo(arr);int[] coins = info.coins;int[] zhangs = info.zhangs;int N = coins.length;int[][] dp = new int[N + 1][aim + 1];dp[N][0] = 1;for (int index = N - 1; index &gt;= 0; index--) {for (int rest = 0; rest &lt;= aim; rest++) {int ways = 0;for (int zhang = 0; zhang * coins[index] &lt;= rest &amp;&amp; zhang &lt;= zhangs[index]; zhang++) {ways += dp[index + 1][rest - (zhang * coins[index])];}dp[index][rest] = ways;}}return dp[0][aim];}</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-4"><p>p(2,10) = a+b+c</p><p>p(2,7) = b+c+d</p><p>p(2,10) = a+p(2,7)-d</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%A2%86%E5%8F%96%E5%85%91%E6%8D%A2333.png" alt="领取兑换333"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> getInfo(arr);</span><br><span class="line"><span class="type">int</span>[] coins = info.coins;</span><br><span class="line"><span class="type">int</span>[] zhangs = info.zhangs;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> coins.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - coins[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[index][rest] += dp[index][rest - coins[index]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rest - coins[index] * (zhangs[index] + <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[index][rest] -= dp[index + <span class="number">1</span>][rest - coins[index] * (zhangs[index] + <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="零钱兑换问题Ⅳ-斜率优化">零钱兑换问题Ⅳ(斜率优化)</h4><p>ar是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。</p><p>每个值都认为是一种面值，且认为张数是无限的。</p><p>返回组成aim的最少货币数</p><div class="tabs" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-1"><i class="fas fa-cat"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-2"><i class="fas fa-horse"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-3"><i class="fas fa-dove"></i>严格表依赖</button></li><li class="tab"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-4"><i class="fas fa-dragon"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCoins</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index...]面值，每种面值张数自由选择，</span></span><br><span class="line"><span class="comment">// 搞出rest正好这么多钱，返回最小张数</span></span><br><span class="line"><span class="comment">// 拿Integer.MAX_VALUE标记怎么都搞定不了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(arr, index + <span class="number">1</span>, rest - zhang * arr[index]);</span><br><span class="line"><span class="keyword">if</span> (next != Integer.MAX_VALUE) &#123;</span><br><span class="line">ans = Math.min(ans, zhang + next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-2"><p>p(2,10) = min (a,b,c,d)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1666.png" alt="零钱666"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">dp[N][j] = Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][rest - zhang * arr[index]];</span><br><span class="line"><span class="keyword">if</span> (next != Integer.MAX_VALUE) &#123;</span><br><span class="line">ans = Math.min(ans, zhang + next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[index][rest] = ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-4"><p>p(2,10) = min (a,b+1,c+2,d+3)</p><p>p(2,7) = min(b,c+1,d+2)</p><p>p(2,10) = min(a,p(2,7)+1)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6777.png" alt="零777"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">dp[N][j] = Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span> </span><br><span class="line">&amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="数字分割问题">数字分割问题</h3><h4 id="数字分割问题Ⅰ-斜率优化">数字分割问题Ⅰ(斜率优化)</h4><p>将数num进行裂开，要求后面的数不能小于前面的数，返回裂开的方式数</p><p>例如</p><p>3 = 1+1+1 = 1+2  = 3</p><p>不能 2+1这样裂开</p><p>返回 3</p><div class="tabs" id="0ffe2f89-db64-4548-8e41-67e6895903cc"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-2"><i class="fas fa-baseball-ball"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-3"><i class="fas fa-bone"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-4"><i class="fas fa-anchor"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0ffe2f89-db64-4548-8e41-67e6895903cc-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n为正数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一个拆出来的数是pre</span></span><br><span class="line"><span class="comment">// 还剩rest需要去拆</span></span><br><span class="line"><span class="comment">// 返回拆解的方法数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre &gt; rest) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> pre; first &lt;= rest; first++) &#123;</span><br><span class="line">ways += process(first, rest - first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ffe2f89-db64-4548-8e41-67e6895903cc-2"><p>假设 num = 8</p><p>p(3,6) = p(3,3)+p(4,2)+p(5,1)+p(6,0)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E5%88%86%E5%89%B2%E6%95%B0%E5%AD%974.png" alt="分割数字4"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ffe2f89-db64-4548-8e41-67e6895903cc-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>; pre &lt;= n; pre++) &#123;</span><br><span class="line">dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[pre][pre] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> n - <span class="number">1</span>; pre &gt;= <span class="number">1</span>; pre--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> pre + <span class="number">1</span>; rest &lt;= n; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> pre; first &lt;= rest; first++) &#123;</span><br><span class="line">ways += dp[first][rest - first];</span><br><span class="line">&#125;</span><br><span class="line">dp[pre][rest] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ffe2f89-db64-4548-8e41-67e6895903cc-4"><p>p(3,6) = p(3,3)+p(4,2)+p(5,1)+p(6,0)</p><p>p(4,6) = p(4,2)+p(5,1)+p(6,0)</p><p>p(3,6) = p(3,3)+p(4,6)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E5%88%86%E5%89%B2%E6%95%B0%E5%AD%975.png" alt="分割数字5"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>; pre &lt;= n; pre++) &#123;</span><br><span class="line">dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[pre][pre] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> n - <span class="number">1</span>; pre &gt;= <span class="number">1</span>; pre--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> pre + <span class="number">1</span>; rest &lt;= n; rest++) &#123;</span><br><span class="line">dp[pre][rest] = dp[pre + <span class="number">1</span>][rest];</span><br><span class="line">dp[pre][rest] += dp[pre][rest - pre];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h4 id="数字分割问题Ⅱ">数字分割问题Ⅱ</h4><p>给定一个正数数组arr,请把arr中所有数分成两个集合，尽量让两个集合的累加和接近</p><p>返回：</p><p>最接近的情况下，较小集合的累加和</p><div class="tabs" id="0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-1"><i class="fas fa-seedling"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-2"><i class="fab fa-apple"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, sum / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[i...]可以自由选择，请返回累加和尽量接近rest，但不能超过rest的情况下，最接近的累加和是多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 还有数，arr[i]这个数</span></span><br><span class="line"><span class="comment">// 可能性1，不使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(arr, i + <span class="number">1</span>, rest);</span><br><span class="line"><span class="comment">// 可能性2，要使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= rest) &#123;</span><br><span class="line">p2 = arr[i] + process(arr, i + <span class="number">1</span>, rest - arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= sum; rest++) &#123;</span><br><span class="line"><span class="comment">// 可能性1，不使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i + <span class="number">1</span>][rest];</span><br><span class="line"><span class="comment">// 可能性2，要使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= rest) &#123;</span><br><span class="line">p2 = arr[i] + dp[i + <span class="number">1</span>][rest - arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">dp[i][rest] = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="数字分割问题Ⅲ">数字分割问题Ⅲ</h4><p>给定一个正数数组arr，请把arr中所有的数分成两个集合</p><p>如果arr长度为偶数，两个集合包含数的个数要一样多</p><p>如果ar长度为奇数，两个集合包含数的个数必须只差一个</p><p>请尽量让两个集合的累加和接近。</p><p>返回：</p><p>最接近的情况下，较小集合的累加和</p><div class="tabs" id="141151c9-b391-4995-af55-9e30d6dfa3c4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#141151c9-b391-4995-af55-9e30d6dfa3c4-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#141151c9-b391-4995-af55-9e30d6dfa3c4-2"><i class="fas fa-baseball-ball"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="141151c9-b391-4995-af55-9e30d6dfa3c4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>, sum / <span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>, sum / <span class="number">2</span>), process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span> + <span class="number">1</span>, sum / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[i....]自由选择，挑选的个数一定要是picks个，累加和&lt;=rest, 离rest最近的返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> picks, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> picks == <span class="number">0</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(arr, i + <span class="number">1</span>, picks, rest);</span><br><span class="line"><span class="comment">// 就是要使用arr[i]这个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= rest) &#123;</span><br><span class="line">next = process(arr, i + <span class="number">1</span>, picks - <span class="number">1</span>, rest - arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = arr[i] + next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="141151c9-b391-4995-af55-9e30d6dfa3c4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> (N + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][M + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= M; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= sum; k++) &#123;</span><br><span class="line">dp[i][j][k] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= sum; rest++) &#123;</span><br><span class="line">dp[N][<span class="number">0</span>][rest] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">picks</span> <span class="operator">=</span> <span class="number">0</span>; picks &lt;= M; picks++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= sum; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i + <span class="number">1</span>][picks][rest];</span><br><span class="line"><span class="comment">// 就是要使用arr[i]这个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (picks - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[i] &lt;= rest) &#123;</span><br><span class="line">next = dp[i + <span class="number">1</span>][picks - <span class="number">1</span>][rest - arr[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = arr[i] + next;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][picks][rest] = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][arr.length / <span class="number">2</span>][sum];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(dp[<span class="number">0</span>][arr.length / <span class="number">2</span>][sum], dp[<span class="number">0</span>][(arr.length / <span class="number">2</span>) + <span class="number">1</span>][sum]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><hr><h2 id="范围上的尝试模型">范围上的尝试模型</h2><p>关注L和R的情况，填表格式非常固定，主对角，副对角，倒回来填</p><h3 id="题目一-2">题目一</h3><p>给定一个整型数组arr，代表数值不同的纸牌排成一条线</p><p>玩家A和玩家B依次拿走每张纸牌</p><p>规定玩家A先拿，玩家B后拿</p><p>但是每个玩家每次只能拿走最左或最右的纸牌</p><p>玩家A和玩家B都绝顶聪明</p><p>请返回最后获胜者的分数。</p><div class="tabs" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-1"><i class="fas fa-atom"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-2"><i class="far fa-sun"></i>重复解分析</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-3"><i class="fas fa-wind"></i>傻缓存法</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-4"><i class="fas fa-heartbeat"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-5"><i class="fas fa-fire-alt"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据规则，返回获胜者的分数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> f1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> g1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Math.max(first, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，先手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> arr[L] + g1(arr, L + <span class="number">1</span>, R);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> arr[R] + g1(arr, L, R - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // arr[L..R]，后手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">g1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f1(arr, L + <span class="number">1</span>, R); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f1(arr, L, R - <span class="number">1</span>); <span class="comment">// 对手拿走了R位置的数</span></span><br><span class="line"><span class="keyword">return</span> Math.min(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-2"><p>0-7号纸牌</p><p>对于先手来说，在f(0,7)做最优选择</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230706120741650.png" alt="image-20230706120741650" style="zoom:67%;" /><p>出现重叠</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] fmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="type">int</span>[][] gmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">fmap[i][j] = -<span class="number">1</span>;</span><br><span class="line">gmap[i][j] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> f2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, fmap, gmap);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> g2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, fmap, gmap);</span><br><span class="line"><span class="keyword">return</span> Math.max(first, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，先手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>[][] fmap, <span class="type">int</span>[][] gmap)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fmap[L][R] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> fmap[L][R];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">ans = arr[L];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> arr[L] + g2(arr, L + <span class="number">1</span>, R, fmap, gmap);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> arr[R] + g2(arr, L, R - <span class="number">1</span>, fmap, gmap);</span><br><span class="line">ans = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">fmap[L][R] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // arr[L..R]，后手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">g2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>[][] fmap, <span class="type">int</span>[][] gmap)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (gmap[L][R] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> gmap[L][R];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L != R) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f2(arr, L + <span class="number">1</span>, R, fmap, gmap); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f2(arr, L, R - <span class="number">1</span>, fmap, gmap); <span class="comment">// 对手拿走了R位置的数</span></span><br><span class="line">ans = Math.min(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">gmap[L][R] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-4"><p>假如arr = [7,4,16,15,1]</p><div class="tabs" id="d26e497e-188d-4de1-9c81-a51e2769de01"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d26e497e-188d-4de1-9c81-a51e2769de01-1"><i class="fas fa-award"></i>basease和ans</button></li><li class="tab"><button type="button" data-href="#d26e497e-188d-4de1-9c81-a51e2769de01-2"><i class="fas fa-baseball-ball"></i>普遍位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d26e497e-188d-4de1-9c81-a51e2769de01-1"><p>f的basecase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>g的basecase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终需要的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> f1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> g1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Math.max(first, second);</span><br></pre></td></tr></table></figure><p>即<code>Math.max(fmap[0][4],gmap[0][4]);</code></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/basecase%E5%92%8Cans2.png" alt="basecase和ans2"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d26e497e-188d-4de1-9c81-a51e2769de01-2"><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int p1 = arr[L] + g1(arr, <span class="class">L + 1, R);</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">int </span>p2 = arr[R] + g1(arr, <span class="class">L, R - 1);</span></span><br></pre></td></tr></table></figure><p>fmap ？位置依赖</p><p>作gmap中？位置对称点？'，？位置依赖gmap中△ 位置。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%962-1.png" alt="位置依赖2-1"></p><p>同理分析gmap中？位置的依赖</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> p1 = f1(arr, L + <span class="number">1</span>, R); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line"><span class="built_in">int</span> p2 = f1(arr, L, R - <span class="number">1</span>); <span class="comment">// 对手拿走了R位置的数</span></span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%962-2.png" alt="位置依赖2-2"></p><p>互推对角线</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win3</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] fmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="type">int</span>[][] gmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">fmap[i][i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> <span class="number">1</span>; startCol &lt; N; startCol++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> startCol;</span><br><span class="line"><span class="keyword">while</span> (R &lt; N) &#123;</span><br><span class="line">fmap[L][R] = Math.max(arr[L] + gmap[L + <span class="number">1</span>][R], arr[R] + gmap[L][R - <span class="number">1</span>]);</span><br><span class="line">gmap[L][R] = Math.min(fmap[L + <span class="number">1</span>][R], fmap[L][R - <span class="number">1</span>]);</span><br><span class="line">L++;</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(fmap[<span class="number">0</span>][N - <span class="number">1</span>], gmap[<span class="number">0</span>][N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="最长回文子序列长度-带优化">最长回文子序列长度(带优化)</h3><p>给定一个字符串str，返回这个字符串的最长回文子序列长度</p><p>比如：str = “a12b3c43def2ghi1kpm”</p><p>最长回文子序列是 “1234321” 或者 “123c321”，返回长度7</p><blockquote><p>解法1</p></blockquote><p>生成str的逆序串</p><p>str逆 = “mpk1ihg2fed34cb21a”</p><p>原串和逆序串的最长公共子序列即为原串的最长回文子序列</p><blockquote><p>解法2：范围尝试模型</p></blockquote><div class="tabs" id="bd07aba8-9097-4e19-bd74-af70a8555478"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-1"><i class="fas fa-seedling"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-2"><i class="fab fa-apple"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-3"><i class="fas fa-leaf"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-4"><i class="fas fa-heartbeat"></i>继续优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="bd07aba8-9097-4e19-bd74-af70a8555478-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl1</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">return</span> f(str, <span class="number">0</span>, str.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[L..R]最长回文子序列长度返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L == R - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str[L] == str[R] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f(str, L + <span class="number">1</span>, R - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f(str, L, R - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> f(str, L + <span class="number">1</span>, R);</span><br><span class="line"><span class="type">int</span> <span class="variable">p4</span> <span class="operator">=</span> str[L] != str[R] ? <span class="number">0</span> : (<span class="number">2</span> + f(str, L + <span class="number">1</span>, R - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> Math.max(Math.max(p1, p2), Math.max(p3, p4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd07aba8-9097-4e19-bd74-af70a8555478-2"><p>basecase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L == R - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str[L] == str[R] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ans</p><p>f(0,str.length - 1)</p><p>从底往上填</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97222.png" alt="最长回文子序列222"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd07aba8-9097-4e19-bd74-af70a8555478-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl2</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">dp[N - <span class="number">1</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i] = <span class="number">1</span>;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> N - <span class="number">3</span>; L &gt;= <span class="number">0</span>; L--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + <span class="number">2</span>; R &lt; N; R++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[L+<span class="number">1</span>][R-<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[L][R-<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> dp[L+<span class="number">1</span>][R];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p4</span> <span class="operator">=</span> str[L] == stl[R] ? <span class="number">2</span> + dp[L + <span class="number">1</span>][R - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">dp[L][R] = Math.max(Math.max(p1,p2),Math.max(p3,p4));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd07aba8-9097-4e19-bd74-af70a8555478-4"><p>?格子要求出来依赖左、左下和下。并是取最大值。</p><p>那么？格子绝不比坐下和下格子小</p><p>在之前求左格子时，依赖它的左、左下和下</p><p>那么在图中，左格子不可能比左下格子小。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230706170257845.png" alt="image-20230706170257845"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl2</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">dp[N - <span class="number">1</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i] = <span class="number">1</span>;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> N - <span class="number">3</span>; L &gt;= <span class="number">0</span>; L--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + <span class="number">2</span>; R &lt; N; R++) &#123;</span><br><span class="line">dp[L][R] = Math.max(dp[L][R - <span class="number">1</span>], dp[L + <span class="number">1</span>][R]);</span><br><span class="line"><span class="keyword">if</span> (str[L] == str[R]) &#123;</span><br><span class="line">dp[L][R] = Math.max(dp[L][R], <span class="number">2</span> + dp[L + <span class="number">1</span>][R - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="多样本位置全对应的尝试模型">多样本位置全对应的尝试模型</h2><p>多个样本，一个样本做行，一个样本做列，关注i和j对应位置的情况，先填边界，再填中间</p><h3 id="最长公共子序列">最长公共子序列</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p><div class="tabs" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2ce89215-5f65-4349-8cf3-c2ca8eb27f51-1"><i class="fas fa-bug"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#2ce89215-5f65-4349-8cf3-c2ca8eb27f51-2"><i class="fas fa-cannabis"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#2ce89215-5f65-4349-8cf3-c2ca8eb27f51-3"><i class="fas fa-candy-cane"></i>严格位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence1</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line"><span class="comment">// 尝试</span></span><br><span class="line"><span class="keyword">return</span> process1(str1, str2, str1.length - <span class="number">1</span>, str2.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// str1[0...i]与str2[0...j]最长公共子序列多长？</span></span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str1[i] == str2[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// i != 0 &amp;&amp; j != 0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> str1[i] == str2[j] ? (<span class="number">1</span> + process1(str1, str2, i - <span class="number">1</span>, j - <span class="number">1</span>)) : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, Math.max(p2, p3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51-2"><p>假设str1 = “a12c3d”,str2 = “efg123xy”</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%9711.png" alt="最长公共子序列11"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence2</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> str2.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][M];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = str1[<span class="number">0</span>] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = str1[<span class="number">0</span>] == str2[j] ? <span class="number">1</span> : dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = str1[i] == str2[<span class="number">0</span>] ? <span class="number">1</span> : dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> str1[i] == str2[j] ? (<span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">dp[i][j] = Math.max(p1, Math.max(p2, p3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N - <span class="number">1</span>][M - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="表达式匹配TODO">表达式匹配TODO</h3><hr><hr><hr><h2 id="寻找业务限制的尝试模型">寻找业务限制的尝试模型</h2><p>比如走棋盘，固定的几个方向可以走，先填边界，再填中间。</p><h3 id="题目一-3">题目一</h3><p>请同学们自行搜索或者想象一个象棋的棋盘，</p><p>然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置</p><p>那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域给你三个参数x，y，k</p><p>返回马从(0,0)位置出发，必须走k步</p><p>最后落在(x,y)上的方法数有多少种？</p><div class="tabs" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-2"><i class="fas fa-baseball-ball"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-3"><i class="fas fa-bone"></i>严格位置分析</button></li><li class="tab"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-4"><i class="fas fa-anchor"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前来到的位置是（x,y）</span></span><br><span class="line"><span class="comment">// 还剩下rest步需要跳</span></span><br><span class="line"><span class="comment">// 跳完rest步，正好跳到a，b的方法数是多少？</span></span><br><span class="line"><span class="comment">// 10 * 9</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(<span class="number">0</span>, <span class="number">0</span>, k, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rest, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (x == a &amp;&amp; y == b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> process(x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-2"><p>以xy为xy轴，rest为轴</p><p>以不同rest为不同层，同一层之间是不相互依赖的</p><p>从第0层推第一层。。。。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-3"><p>在递归时越界时，我们还能返回0。在数组中越界了可就报错了，所以写一个函数从数组中取出来。</p><p>越界了就返回0，没越界才给你去拿</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">9</span>][k + <span class="number">1</span>];</span><br><span class="line">dp[a][b][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= k; rest++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; <span class="number">9</span>; y++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> pick(dp, x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">dp[x][y][rest] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pick</span><span class="params">(<span class="type">int</span>[][][] dp, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[x][y][rest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="题目二-空间优化">题目二(空间优化)</h3><p>给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和返回最小距离累加和</p><p>若<code>dp[i][j]</code>的意思表示为 从(i , j)点走到右下角，最省的路径和是多少。则<code>dp[0][0]</code>为最终答案</p><p>若<code>dp[i][j]</code>的意思表示为 从(0 , 0)点到(i , j)点，最省的路径和是多少。则<code>dp[row - 1][col - 1]</code>为最终答案</p><p>两种写法都可以</p><div class="tabs" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-1"><i class="fas fa-seedling"></i>空间依赖分析</button></li><li class="tab"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-2"><i class="fas fa-leaf"></i>严格表依赖</button></li><li class="tab"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-3"><i class="fab fa-apple"></i>空间优化分析</button></li><li class="tab"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-4"><i class="fas fa-tree"></i>优化代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-1"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84111.png" alt="最短路径111"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathSum1</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> m.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + m[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + m[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-3"><p>在我们推第17行的值时只需要16行的值，之前行的值已经不需要了。</p><p>在更新c的时候，左边已经是更新好的，当前位置还未跟新。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96111.png" alt="空间优化111"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathSum2</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> m.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[col];</span><br><span class="line">dp[<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[j] = dp[j - <span class="number">1</span>] + m[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>] += m[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="贴纸问题">贴纸问题</h3><p>给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文</p><p>arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来</p><p>返回需要至少多少张贴纸可以完成这个任务</p><p>例子：str = “babac” ,arr={“ba”,“c”,“abcd”}</p><p>至少需要两张贴纸&quot;ba&quot;和&quot;abcd&quot;,因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2。</p><div class="tabs" id="c5e51d73-18c3-429e-bba5-5f04a785aca8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c5e51d73-18c3-429e-bba5-5f04a785aca8-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#c5e51d73-18c3-429e-bba5-5f04a785aca8-2"><i class="fas fa-baseball-ball"></i>词频表优化</button></li><li class="tab"><button type="button" data-href="#c5e51d73-18c3-429e-bba5-5f04a785aca8-3"><i class="fas fa-bone"></i>哈希表优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c5e51d73-18c3-429e-bba5-5f04a785aca8-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers1</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process1(stickers, target);</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有贴纸stickers，每一种贴纸都有无穷张</span></span><br><span class="line"><span class="comment">// target</span></span><br><span class="line"><span class="comment">// 最少张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (String first : stickers) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> minus(target, first);</span><br><span class="line"><span class="keyword">if</span> (rest.length() != target.length()) &#123;</span><br><span class="line">min = Math.min(min, process1(stickers, rest));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minus</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line"><span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str1) &#123;</span><br><span class="line">count[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str2) &#123;</span><br><span class="line">count[cha - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count[i]; j++) &#123;</span><br><span class="line">builder.append((<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c5e51d73-18c3-429e-bba5-5f04a785aca8-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers2</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="comment">// 关键优化(用词频表替代贴纸数组)</span></span><br><span class="line"><span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">counts[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process2(counts, target);</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stickers[i] 数组，当初i号贴纸的字符统计 int[][] stickers -&gt; 所有的贴纸</span></span><br><span class="line"><span class="comment">// 每一种贴纸都有无穷张</span></span><br><span class="line"><span class="comment">// 返回搞定target的最少张数</span></span><br><span class="line"><span class="comment">// 最少张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[][] stickers, String t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target做出词频统计</span></span><br><span class="line"><span class="comment">// target  aabbc  2 2 1..</span></span><br><span class="line"><span class="comment">//                0 1 2..</span></span><br><span class="line"><span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line"><span class="type">int</span>[] tcounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : target) &#123;</span><br><span class="line">tcounts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="comment">// 尝试第一张贴纸是谁</span></span><br><span class="line"><span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line"><span class="comment">// 最关键的优化(重要的剪枝!这一步也是贪心!)</span></span><br><span class="line"><span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> tcounts[j] - sticker[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums; k++) &#123;</span><br><span class="line">builder.append((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">min = Math.min(min, process2(stickers, rest));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c5e51d73-18c3-429e-bba5-5f04a785aca8-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers3</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">counts[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HashMap&lt;String, Integer&gt; dp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">dp.put(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process3(counts, target, dp);</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process3</span><span class="params">(<span class="type">int</span>[][] stickers, String t, HashMap&lt;String, Integer&gt; dp)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dp.containsKey(t)) &#123;</span><br><span class="line"><span class="keyword">return</span> dp.get(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line"><span class="type">int</span>[] tcounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : target) &#123;</span><br><span class="line">tcounts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line"><span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> tcounts[j] - sticker[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums; k++) &#123;</span><br><span class="line">builder.append((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">min = Math.min(min, process3(stickers, rest, dp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">dp.put(t, ans);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> ]]></content>
    
    
    <summary type="html">暴力递归、记忆化搜索、严格表结构、斜率优化</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>运行时数据区</title>
    <link href="https://wuwawawa.github.io/posts/11595de.html"/>
    <id>https://wuwawawa.github.io/posts/11595de.html</id>
    <published>2023-07-04T02:36:49.000Z</published>
    <updated>2023-07-11T13:18:23.708Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/b5d91ce04cfef9a681bbed216732511a.png" alt="image-20200705111640511" style="zoom:67%;" /><p>当我们通过前面的：<code>类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</code> 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区。</p><p>我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/bbf59f2544890b06cdb69b2d7719c060.png" alt="image-20210509174543026" style="zoom:67%;" /><hr><hr><h2 id="程序计数器">程序计数器</h2><h3 id="PC寄存器介绍">PC寄存器介绍</h3><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/pcRegister.png" alt="pcRegister"></p><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，<span class='p red'>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</span></li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是<span class='p blue'>通过改变这个计数器的值来选取下一条需要执行的字节码指令。</span></li><li>它是<span class='p red'>唯一一个</span>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><hr><h3 id="PC寄存器作用">PC寄存器作用</h3><p>PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230704110320570.png" alt="image-20230704110320570" style="zoom: 50%;" /><blockquote><p>使用 PC 寄存器存储字节码指令地址有什么用呢？</p><p>为什么使用 PC 寄存器记录当前线程的执行地址呢？</p></blockquote><ol><li><p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p></li><li><p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p></li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/68aa12d47725e4559e6b71489d91122e.png" alt="image-20200705161409533"></p><blockquote><p>PC 寄存器为什么被设定为私有的？</p></blockquote><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<span class='p green'>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器</span>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><mark class="hl-label blue">CPU时间片</mark> <p>CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/bbab7cdab74c493af70b423f06e6ff86.png" alt="image-20200705161849557"></p><hr><hr><h2 id="虚拟机栈">虚拟机栈</h2><h3 id="概述">概述</h3><blockquote><p>虚拟机栈出现背景</p></blockquote><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p><p>优点是跨平台，指令集小，编译器容易实现</p><p>缺点是性能下降，实现同样的功能需要更多的指令</p><blockquote><p>内存中的栈与堆</p></blockquote><span class='p red'>栈是运行时的单位，而堆是存储的单位</span><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/2d195f3aafd8b1f426efad75f0a52478.png" alt="image-20200705163928652"></p><hr><h3 id="基本内容">基本内容</h3><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的<code>栈帧（Stack Frame）</code>，对应着一次次的 Java 方法调用，是<code>线程私有</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackTest</span>();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230704112513940.png" alt="image-20230704112513940" style="zoom: 33%;" /><div class="tabs" id="b83445ba-2a3a-4d66-a332-642943ddda1f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b83445ba-2a3a-4d66-a332-642943ddda1f-1"><i class="fas fa-cat"></i>生命周期</button></li><li class="tab"><button type="button" data-href="#b83445ba-2a3a-4d66-a332-642943ddda1f-2"><i class="fas fa-horse"></i>作用</button></li><li class="tab"><button type="button" data-href="#b83445ba-2a3a-4d66-a332-642943ddda1f-3"><i class="fas fa-dove"></i>特点</button></li><li class="tab"><button type="button" data-href="#b83445ba-2a3a-4d66-a332-642943ddda1f-4"><i class="fas fa-dragon"></i>栈中可能出现的异常</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b83445ba-2a3a-4d66-a332-642943ddda1f-1"><p>生命周期和线程一致。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b83445ba-2a3a-4d66-a332-642943ddda1f-2"><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b83445ba-2a3a-4d66-a332-642943ddda1f-3"><ul><li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序序计数器。</p></li><li><p>JVM 直接对 Java 栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/d4e4445f4faee685dc98d54129344bb3.png" alt="image-20200705165025382"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b83445ba-2a3a-4d66-a332-642943ddda1f-4"><p>Java 虚拟机规范允许Java 栈的大小是动态的或者是固定不变的。</p><ul><li><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个<code>StackOverflowError异常</code>。</p></li><li><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<code>OutOfMemoryError异常</code>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抛出异常：Exception in thread&quot;main&quot;java.lang.StackoverflowError</span></span><br><span class="line"><span class="comment">//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</span></span><br></pre></td></tr></table></figure><p><mark class="hl-label blue">设置栈内存大小</mark></p><p>我们可以使用参数 <code>-Xss </code>选项来设置<code>线程的最大栈空间</code>，栈的大小直接决定了函数调用的最大可达深度</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="存储单位栈帧">存储单位栈帧</h3><mark class="hl-label blue">栈中存储什么？</mark> <p>每个线程都有自己的栈，栈中的数据都是以<code>栈帧（Stack Frame）</code>的格式存在。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><mark class="hl-label blue">栈运行原理</mark> <ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<span class='p green'>当前栈帧（Current Frame）</span>，与当前栈帧相对应的方法就是<span class='p green'>当前方法（Current Method）</span>，定义这个方法的类就是<span class='p green'>当前类（Current Class）</span></p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/893126a7a33507917e11377fd3e4b639.png" alt="image-20200705203142545"></p><ol start="5"><li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p></li><li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p></li><li><p>Java方法有两种返回函数的方式。一种是正常的函数返回，使用return指令；另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。但不管使用哪种方式，都会导致栈帧被弹出。</p></li></ol><mark class="hl-label blue">栈帧的内部结构</mark> <p>每个栈帧中存储着：</p><ul><li><span class='p red'>局部变量表（Local Variables）</span></li><li><span class='p red'>操作数栈（operand Stack）（或表达式栈）</span></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/0ed2029b435d547547f32540077bb082.png" alt="image-20200705204836977"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表和操作数栈决定的</p><hr><hr><h2 id="本地方法栈">本地方法栈</h2><h3 id="本地方法">本地方法</h3><p>简单地讲，一个 Native Method 是一个 Java 调用非 Java 代码的接囗。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++中，你可以用 extern “c” 告知 c++编译器去调用一个 c 的函数。</p><p>A native method is a Java method whose implementation is provided by non-java code.</p><p>在定义一个 native method 时，并不提供实现体（有些像定义一个 Java interface），因为其实现体是由非 java 语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/7b36a8321e4c955f06220775c9c2cf4c.png" alt="image-20200706164139252"></p><hr><h3 id="本地方法栈-2">本地方法栈</h3><p>Java 虚拟机栈于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li></ul><p>本地方法是使用 C 语言实现的。</p><p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/b4aea15cec874411f749e336c8b5d8fd.png" alt="image-20200706174708418"></p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p><p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</p><hr><hr><h2 id="堆">堆</h2><h3 id="概述-2">概述</h3><ol><li>堆针对一个JVM进程来说是唯一的。也就是<span class='p red'>一个进程只有一个JVM实例</span>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li><li>但是<span class='p blue'>进程包含多个线程，他们是共享同一堆空间的</span>。</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/0be60cad417bedd46d651f710ae585ce.png" alt="image-20200706195127740"></p><ol start="3"><li><p>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p></li><li><p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。<span class='p green'>是 JVM 管理的最大一块内存空间</span>，堆内存的大小是可以调节的。</p></li><li><p>《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p></li><li><p>所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p></li><li><p>《Java 虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p></li><li><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p></li><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul></li><li><p>堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/3ae9948d069bd58ccfcda730cc12bf0f.png" alt="image-20200706201904057"></p><hr><h3 id="堆内存细分">堆内存细分</h3><p>Java 7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space 永久区 Perm</li></ul><p>Java 8 及之后堆内存逻辑上分为三部分：新生区+养老区+元空间</p><ul><li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Meta Space 元空间 Meta</li></ul><p>约定：新生区（代）&lt;=&gt;年轻代 、 养老区&lt;=&gt;老年区（代）、 永久区&lt;=&gt;永久代</p><div class="tabs" id="821a3913-ff13-4e1a-9b3a-93dd49ed7d14"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#821a3913-ff13-4e1a-9b3a-93dd49ed7d14-1"><i class="fas fa-award"></i>堆空间内部结构（JDK7）</button></li><li class="tab"><button type="button" data-href="#821a3913-ff13-4e1a-9b3a-93dd49ed7d14-2"><i class="fas fa-baseball-ball"></i>堆空间内部结构（JDK8）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="821a3913-ff13-4e1a-9b3a-93dd49ed7d14-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/deafdcce7cf88a496bc231820bb5b007.png" alt="image-20200706203419496" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="821a3913-ff13-4e1a-9b3a-93dd49ed7d14-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/ee2836af2e1d5387b4ac58f5eacabbb6.png" alt="image-20200706203835403" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="设置堆内存大小">设置堆内存大小</h3><ol><li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项&quot;-Xms&quot;和&quot;-Xmx&quot;来进行设置，-X 是jvm的运行参数，-X 是jvm的运行参数。</p><ul><li><code>-Xms</code>用于表示堆区（年轻代+老年代）的起始内存，等价于<code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code>则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li></ul></li><li><p>一旦堆区中的内存大小超过“-Xmx&quot;所指定的最大内存时，将会抛出OutofMemoryError异常。</p></li><li><p>通常会将-Xms和-Xmx两个参数配置相同的值</p></li></ol><ul><li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li><li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li></ul><ol start="4"><li><p>默认情况下:</p><ul><li>初始内存大小：物理电脑内存大小/64</li><li>最大内存大小：物理电脑内存大小/4</li></ul></li></ol><hr><h3 id="年轻代与老年代">年轻代与老年代</h3><p>存储在 JVM 中的 Java 对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致</li></ul><p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/f3ee86daaf5076fe22265ffcaa831175.png" alt="image-20200707075847954"></p><p>新生代与老年代在堆结构的占比。</p><ul><li>默认<code>-XX:NewRatio=2</code>，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3</li><li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占 1，老年代占 4，新生代占整个堆的 1/5</li></ul><p>在 HotSpot 中，Eden 空间和另外两个 survivor 空间缺省所占的比例是 8：1：1</p><p>当然开发人员可以通过选项<code>-xx:SurvivorRatio</code>调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></p><p>几乎所有的 Java 对象都是在 Eden 区被 new 出来的。绝大部分的 Java 对象的销毁都在新生代进行了。</p><ul><li>IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的。</li></ul><p>可以使用选项<code>-Xmn</code>设置新生代最大内存大小，这个参数一般使用默认值就可以了。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/31fd90d99565ec8ce0682a4468076f94.png" alt="image-20210510105849497"></p><hr><h3 id="对象分配过程">对象分配过程</h3><p>​为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li><p>new 的对象先放伊甸园区。此区有大小限制。</p></li><li><p>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p></li><li><p>然后将伊甸园中的剩余对象移动到幸存者 0 区。</p></li><li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。</p></li><li><p>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</p></li><li><p>啥时候能去养老区呢？可以设置次数。默认是 15 次。</p><ul><li>可以设置参数：<code>-Xx:MaxTenuringThreshold= N</code>进行设置</li></ul></li><li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC：Major GC，进行养老区的内存清理</p></li><li><p>若养老区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常。</p></li></ol><mark class="hl-label blue">对象分配的特殊情况</mark> <ol><li>如果来了一个新对象，先看看 Eden 是否放的下？<ul><li>如果 Eden 放得下，则直接放到 Eden 区</li><li>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li></ul></li><li>将对象放到老年区又有两种情况：<ul><li>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</li><li>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM</li></ul></li><li>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/23b91eb543fc0072cb628365267f0089.png" alt="image-20200707091058346"></p><h3 id="GC分类">GC分类</h3><ol><li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></p></li><li><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p></li></ol><ul><li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li><strong>新生代收集</strong>（Minor GC/Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</li><li><strong>老年代收集</strong>（Major GC/Old GC）：只是老年代的垃圾收集。</li><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ul></li><li><p><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p></li></ul><p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p><hr><hr><h2 id="方法区">方法区</h2><h3 id="栈、堆、方法区的交互关系">栈、堆、方法区的交互关系</h3><ol><li>Person 类的 .class 信息存放在方法区中</li><li>person 变量存放在 Java 栈的局部变量表中</li><li>真正的 person 对象存放在 Java 堆中</li><li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/b9f11764ee47b28d37f7764dfd9c9f55.png" alt="image-20200708094747667"></p><hr><h3 id="方法区基本概述">方法区基本概述</h3><blockquote><p>方法区在哪里</p></blockquote><ol><li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>所以，<span class='p red'>方法区可以看作是一块独立于Java堆的内存空间</span></li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/6a7f2350e0f4e0cde0ac246225e2acdd.png" alt="image-20200708095853544"></p><blockquote><p>方法区基本理解</p></blockquote><span class='p green'>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</span><ol><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ol><hr><h3 id="设置方法区大小与OOM">设置方法区大小与OOM</h3><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><div class="tabs" id="19ef8671-1621-4661-a983-cba765878dba"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#19ef8671-1621-4661-a983-cba765878dba-1"><i class="fas fa-seedling"></i>jdk7及以前</button></li><li class="tab"><button type="button" data-href="#19ef8671-1621-4661-a983-cba765878dba-2"><i class="fas fa-leaf"></i>JDK8以后</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="19ef8671-1621-4661-a983-cba765878dba-1"><ul><li>通过<code>-XX:Permsize</code>来设置永久代初始分配空间。默认值是 20.75M</li><li>通过<code>-XX:MaxPermsize</code>来设定永久代最大可分配空间。32 位机器默认是 64M，64 位机器模式是 82M</li><li>当 JVM 加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code>。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="19ef8671-1621-4661-a983-cba765878dba-2"><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</li><li>默认值依赖于平台。windows 下，<code>-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制</code>。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的<code>-XX:MetaspaceSize</code>值为 21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="方法区内部结构">方法区内部结构</h3><p>《深入理解 Java 虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/fbe3915506e7979c7d591d17c216fbb1.png" alt="image-20200708161856504"></p><div class="tabs" id="2bff9740-807b-47eb-bb97-ef0e276019eb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-1"><i class="fas fa-award"></i>类型信息</button></li><li class="tab"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-2"><i class="fas fa-baseball-ball"></i>域（Field）信息</button></li><li class="tab"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-3"><i class="fas fa-bone"></i>方法（Method）信息</button></li><li class="tab"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-4"><i class="fas fa-anchor"></i>non-final的类变量</button></li><li class="tab"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-5"><i class="fas fa-heartbeat"></i>运行时常量池</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2bff9740-807b-47eb-bb97-ef0e276019eb-1"><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bff9740-807b-47eb-bb97-ef0e276019eb-2"><p>也就是我们常说的成员变量，域信息是比较官方的称呼</p><ol><li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p></li><li><p>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bff9740-807b-47eb-bb97-ef0e276019eb-3"><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称</li><li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bff9740-807b-47eb-bb97-ef0e276019eb-4"><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li></ul><p>补充说明：全局常量（static final）</p><p>被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bff9740-807b-47eb-bb97-ef0e276019eb-5"><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li><li>运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性。</li><li>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</li></ul><p>运行时常量池 VS 常量池</p><ol><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="方法区演进细节">方法区演进细节</h3><ol><li>首先明确：只有 Hotspot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java 虚拟机规范》管束，并不要求统一</li><li>Hotspot 中方法区的变化：</li></ol><table><thead><tr><th style="text-align:center">JDK版本</th><th style="text-align:center">方法区变化</th></tr></thead><tbody><tr><td style="text-align:center">JDK1.6 及之前</td><td style="text-align:center">有永久代（permanet），静态变量存储在永久代上</td></tr><tr><td style="text-align:center">JDK1.7</td><td style="text-align:center">有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td style="text-align:center">JDK1.8</td><td style="text-align:center">无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p>字符串常量池存的是字符串本身，运行时常量池存的是字符串引用，指向字符串常量池。</p><blockquote><p>字符串常量池 StringTable 为什么要调整位置？</p></blockquote><ul><li><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p></li><li><p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p></li></ul><div class="tabs" id="2b96576e-c020-4117-a205-5c2dfca56393"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2b96576e-c020-4117-a205-5c2dfca56393-1"><i class="fas fa-seedling"></i>JDK6</button></li><li class="tab"><button type="button" data-href="#2b96576e-c020-4117-a205-5c2dfca56393-2"><i class="fas fa-leaf"></i>JDK7</button></li><li class="tab"><button type="button" data-href="#2b96576e-c020-4117-a205-5c2dfca56393-3"><i class="fab fa-apple"></i>JDK8</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2b96576e-c020-4117-a205-5c2dfca56393-1"><p><img src="https://img-blog.csdnimg.cn/img_convert/1a3aa55257c3150d78327542e5ca230e.png" alt="image-20200708211541300"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b96576e-c020-4117-a205-5c2dfca56393-2"><p><img src="https://img-blog.csdnimg.cn/img_convert/e0f65fc4228d9b6573ae1b23d9a1558b.png" alt="image-20200708211609911"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b96576e-c020-4117-a205-5c2dfca56393-3"><p><img src="https://img-blog.csdnimg.cn/img_convert/c3ed969b0d2bad704c22481208e5dd10.png" alt="image-20200708211637952"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="方法区的垃圾回收">方法区的垃圾回收</h3><p>有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 zGC 收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收 Java 堆中的对象非常类似。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。</p></li><li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，<u>通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</u>。</p>]]></content>
    
    
    <summary type="html">程序计数器、虚拟机栈、本地方法栈、堆、方法区</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://wuwawawa.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>类加载子系统</title>
    <link href="https://wuwawawa.github.io/posts/13cb3a0e.html"/>
    <id>https://wuwawawa.github.io/posts/13cb3a0e.html</id>
    <published>2023-07-04T01:50:25.000Z</published>
    <updated>2023-07-04T02:32:49.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存结构概述图">内存结构概述图</h2><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/e4bc9ed374db7f35e68f23f4813205bd.png" alt="image-20200705080719531" style="zoom:67%;" /><hr><hr><h2 id="类加载器子系统">类加载器子系统</h2><mark class="hl-label blue">类加载器子系统作用</mark> <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/3569bfb903e80b66ee7e972a6b4a5036.png" alt="image-20200705081813409"></p><ul><li><p>类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件开头有特定的文件标识。</p></li><li><p>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。</p></li><li><span class='p blue'>加载的类信息存放于一块称为方法区的内存空间。</span>除了类的信息外，<span class='p green'>方法区中还会存放运行时常量池信息</span>，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li></ul><hr><hr><h2 id="类加载器">类加载器</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/e8172076eaa7a152408633a353f06b2c.png" alt="image-20200705081913538"></p><ul><li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例。</li><li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在<code>方法区</code>。</li><li>在.class 文件-&gt; JVM -&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li></ul><mark class="hl-label blue">ClassLoader类介绍</mark> <p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/a22114b608dffe484041b591d486a7fd.png" alt="image-20200705103636003"></p><hr><hr><h2 id="类加载过程">类加载过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *示例代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的加载过程是怎么样的呢?</p><ul><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li><li>加载失败则抛出异常</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/8cc54647114c456695ac352336c74600.png" alt="image-20200705082255746"></p><p>完整的流程图如下所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/image-20230223144619053.png" alt="image-20230223144619053"></p><hr><h3 id="加载阶段">加载阶段</h3><ol><li><p>通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p><code>在内存中生成一个代表这个类的java.lang.Class对象</code>，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>补充：加载class文件的方式</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><hr><h3 id="链接阶段">链接阶段</h3><p>链接分为三个子阶段：<code>验证 -&gt; 准备 -&gt; 解析</code></p><div class="tabs" id="b2447a71-06b7-461a-9870-39ae327efdc0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b2447a71-06b7-461a-9870-39ae327efdc0-1"><i class="fas fa-seedling"></i>验证</button></li><li class="tab"><button type="button" data-href="#b2447a71-06b7-461a-9870-39ae327efdc0-2"><i class="fas fa-leaf"></i>准备</button></li><li class="tab"><button type="button" data-href="#b2447a71-06b7-461a-9870-39ae327efdc0-3"><i class="fab fa-apple"></i>解析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b2447a71-06b7-461a-9870-39ae327efdc0-1"><p>确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，<span class='p green'>文件格式验证，元数据验证，字节码验证，符号引用验证</span>。</p><p><code>举例:</code></p><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b2447a71-06b7-461a-9870-39ae327efdc0-2"><p>为类变量<code>分配内存</code>并且设置该<code>类变量</code>的默认初始值，即零值，类常量的值在编译时就已经分配了</p><p><span class='p blue'>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化</span></p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中</p><p><code>举例：</code></p><p>代码：变量n2在准备阶段会赋初始值，但不是2，而是0，在初始化阶段会被赋值为 2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//实例属性，非静态变量，此阶段不分配内存 在&lt;init&gt; 阶段赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//静态变量，默认初始化为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">3</span>;<span class="comment">//static final 常量，为 3</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b2447a71-06b7-461a-9870-39ae327efdc0-3"><p>将常量池内的<span class='p red'>符号引用转换为直接引用</span>的过程。</p><p>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</p><p><code>符号引用:</code></p><p>反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/image-20230223145236317.png" alt="image-20230223145236317" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="初始化阶段">初始化阶段</h3><p>什么情况下需要开始类加载过程的第一个阶段：加载？ Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了下面的几种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前开始)：</p><p><strong>类初始化阶段时机:</strong></p><ol><li><code>创建类的实例</code></li><li><code>访问某个类或接口的静态变量</code>，或者对该静态变量赋值</li><li>调用<code>类的静态方法</code></li><li><code>反射</code>（比如：Class.forName(“com.atguigu.Test”)）</li><li><code>初始化一个类的子类</code></li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><p><strong>注意：</strong></p><p>1.通过子类调用父类的静态成员时，只会初始化父类而不会初始化子类。 因为没有调用子类的相关静态成员。</p><p>2.调用静态成员时，会加载静态成员真正所在的类及其父类。 这也好理解，因为本类的父类没有加载就会先去加载父类。</p><p>3.类的加载成功后，即静态成员都被加载后，是不会再加载第二次的。只有非静态成员，如非静态成员变量、非静态代码块、非静态方法(不调用不加载)、构造方法都会被多次实例化的时候多次加载。</p><p>4.如果静态属性有 final 修饰时，即类常量，则不会加载，当成常量使用。</p><blockquote><p>例如：子类调用父类的静态成员时，只会初始化父类而不会初始化子类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass Init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于静态字段，只有直接定义了这个字段的类才会被初始化</span></span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperClass Init!</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>从输出结果中可以得出通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。<br>但是触发了子类的加载。通过-XX:+TraceClassLoading参数可以观察。结果如下图：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/70.png" alt="在这里插入图片描述"></p><blockquote><p>例如：访问静态常量并不会导致类的初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Begin:&quot;</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;内部静态常量：&quot;</span> + Out.Inner.in_val);</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;外部静态常量：&quot;</span> + Out.out_val);</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">System.out.println(Out.Inner.in_var);</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">System.out.println(Out.out_var);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Out</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">out_var</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">out_val</span> <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Outter&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">in_var</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">in_val</span> <span class="operator">=</span> <span class="number">222</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Inner&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Begin</span><span class="operator">:</span><span class="number">1533821440864</span></span><br><span class="line">内部静态常量：<span class="number">222</span></span><br><span class="line">外部静态常量：<span class="number">111</span></span><br><span class="line"><span class="built_in">Inner</span></span><br><span class="line"><span class="number">1533821440884</span></span><br><span class="line"><span class="variable">Outter</span></span><br><span class="line"><span class="number">1533821440895</span></span><br></pre></td></tr></table></figure><p>由结果可见：常量（static final 修饰的）在编译阶段会存入调用类的常量池中，因此调用其常量本质上并没有直接引用到定义常量的类，因此不会触发常量的类的初始化。</p><p>但如果使用函数等运行时才能获得结果的代码，来初始化类的静态常量，则使用此静态常量时会导致类的加载和初始化：</p><p><code>public static final long out_val = System.currentTimeMillis();</code></p><p>当使用到内部类\外部类的静态变量时，内部类\外部类才开始时初始化。</p><p>内部类的初始化不会使外部类初始化，即内部类加载完成，外部类可能还没有初始化，加载静态内部类的时候不会加载外部类。</p><p><strong>clinit()</strong></p><ol><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是javac编译器自动收集类中的所有**<code>类变量</code>**（静态成员变量）的赋值动作和<code>静态代码块</code>中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li><li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器。</li><li>构造器是虚拟机视角下的<code>&lt;init&gt;()</code></li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁，保证一个类只加载一次。</li></ol><blockquote><p>例1:代码中有static变量</p></blockquote><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/image-20230223145612775.png" alt="image-20230223145612775"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitTest</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line"><span class="comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span></span><br><span class="line"><span class="comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&lt;clinit字节码&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> putstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">4</span> iconst_2</span><br><span class="line"> <span class="number">5</span> putstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">8</span> bipush <span class="number">20</span> <span class="comment">//先赋20</span></span><br><span class="line"><span class="number">10</span> putstatic #<span class="number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">13</span> getstatic #<span class="number">2</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">16</span> getstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> bipush <span class="number">10</span><span class="comment">//再赋10</span></span><br><span class="line"><span class="number">24</span> putstatic #<span class="number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当我们代码中包含static变量的时候，就会有clinit方法</p><p>没有static变量时，就不会有cinit方法，加上之后就有了</p><blockquote><p>第四点说明</p></blockquote><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/image-20230223145728185.png" alt="image-20230223145728185"></p><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><blockquote><p>第五点说明</p></blockquote><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><p>加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><blockquote><p>第六点说明</p></blockquote><p>必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            <span class="type">DeadThread</span> <span class="variable">dead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadThread</span>();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadThread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程2开始</span><br><span class="line">线程1开始</span><br><span class="line">线程2初始化当前类</span><br><span class="line"></span><br><span class="line">/然后程序卡死了</span><br></pre></td></tr></table></figure><p>程序卡死，分析原因：</p><ul><li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li><li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><hr><hr><h2 id="类加载器分类">类加载器分类</h2><p>JVM 支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有 3 个，如下所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1e553c6d5254f827d2dfab537bea3ab9.png" alt="image-20200705094149223"></p><p>这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p><blockquote><p>虚拟机自带的加载器</p></blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li>这个类加载使用 C/C++语言实现的，嵌套在 JVM 内部。</li><li>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li></ul><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。</li><li>派生于 ClassLoader 类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/1ib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li><p>java 语言编写，由 sun.misc.LaunchersAppClassLoader 实现</p></li><li><p>派生于 ClassLoader 类</p></li><li><p>父类加载器为扩展类加载器</p></li><li><p>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</p></li><li><p>该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载</p></li><li><p>通过 ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</p></li></ul><blockquote><p>用户自定义类加载器</p></blockquote><p><strong>什么时候需要自定义类加载器？</strong></p><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ol><li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li><li>修改类加载的方式</li><li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><p><strong>如何自定义类加载器？</strong></p><ol><li>开发人员可以通过继承抽象类 ava.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass() 方法，而是建议把自定义的类加载逻辑写在 findClass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p><code>代码示例</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">customClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="literal">true</span>, customClassLoader);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="双亲委派机制">双亲委派机制</h2><p>Java 虚拟机对 class 文件采用的是<code>按需加载</code>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<code>双亲委派模式</code>，即把请求交由父类处理，它是一种任务委派模式。</p><mark class="hl-label green">工作原理</mark> <ul><li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/05fa27fcc38eeaaa5babff55a00882a3.png" alt="image-20200705105151258"></p><mark class="hl-label blue">举例1</mark> <p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.lang.<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,atguigu<span class="selector-class">.com</span></span><br><span class="line">sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">18</span>b4aac2</span><br></pre></td></tr></table></figure><p>程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。</p><p>把刚刚的类改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，该加载器正好负责String的加载，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p><mark class="hl-label green">举例2</mark> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShkStart</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line">at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="number">142</span>)</span><br><span class="line">at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="number">467</span>)</span><br><span class="line">at java.net.URLClassLoader.access$<span class="number">100</span>(URLClassLoader.java:<span class="number">73</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">368</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">362</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">361</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="number">495</span>)</span><br><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> </span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p><p><code>举例3</code></p><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ol><p><strong>双亲委派机制优势</strong></p><p>通过上面的例子，我们可以知道，双亲机制可以</p><ol><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><blockquote><p><strong>沙箱安全机制</strong></p></blockquote><ol><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><hr><hr><h2 id="其他">其他</h2><blockquote><p>如何判断两个class对象是否相同？</p></blockquote><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名</li><li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li><li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li></ol><blockquote><p>对类加载器的引用</p></blockquote><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）</li></ol><blockquote><p><strong>new一个对象的过程？</strong></p></blockquote><p>当虚拟机遇见new关键字的时候，首先判断该类是否已经加载，如果类没有加载，那么先执行类的加载机制，加载完成后再为对象分配空间、初始化等。详细过程如下：</p><p>1、加载阶段：</p><p>1）首先检查当前类是否被加载，如果没有被加载，执行类的加载机制</p><p>2）加载：就是将类的字节码文件，即class文件读入内存，并为之创建一个Class对象</p><p>3）验证：校验class文件是否符合虚拟机规范</p><p>4）准备：为静态变量赋默认值</p><p>5）解析：虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>6）初始化：给静态变量赋定义的值、执行静态代码块，如果存在父类，先对父类进行初始化</p><p>2、创建对象分配内存空间</p><p>1）首先为对象在堆中分配大小合适的内存空间</p><p>2）接着为实例变量赋默认值</p><p>3）设置对象的头信息、对象hash码、GC分代年龄、元数据信息等</p><p>4）执行构造器</p>]]></content>
    
    
    <summary type="html">类加载过程、双亲委派机制</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://wuwawawa.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://wuwawawa.github.io/posts/2633a26.html"/>
    <id>https://wuwawawa.github.io/posts/2633a26.html</id>
    <published>2023-06-29T00:53:14.000Z</published>
    <updated>2023-10-05T07:08:01.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异或运算">异或运算</h2><h3 id="运算规则">运算规则</h3><p>相同取0，相异取1</p><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">P</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>异或算法有三个特征：<br>1、任何数和0做异或运算，结果仍然是原来的数，即a ⊕ 0 = a。<br>2、任何数和自身做异或运算时，结果是0，即a ⊕ a=0 。 注意a ⊕ a ⊕ a = a<br>3、异或运算满足交换律和结合律，即a ⊕ b ⊕ b = b ⊕ a ⊕ b = a ⊕ ( b ⊕ b ) = a ⊕ 0 = a</p><hr><h3 id="运用场景">运用场景</h3><p>如求一组数据中只有一个数字是奇数项其他都是偶数项，怎么找出它，用异或就很方便。</p><div class="tabs" id="e7ff58e0-e794-4c7c-8891-c48a79720b2c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e7ff58e0-e794-4c7c-8891-c48a79720b2c-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#e7ff58e0-e794-4c7c-8891-c48a79720b2c-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#e7ff58e0-e794-4c7c-8891-c48a79720b2c-3"><i class="fab fa-apple"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e7ff58e0-e794-4c7c-8891-c48a79720b2c-1"><blockquote><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">        eor ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e7ff58e0-e794-4c7c-8891-c48a79720b2c-2"><blockquote><p>进一步，有两个元素(两元素不同)出现了奇数次，其余元素均出现偶数次。找到这两个元素。</p></blockquote><p>假设这两个元素分别为a,b,其他元素为other。则最后异或的结果<code>eor = a^b</code>,且eor一定不等于0。</p><p>那么eor中肯定有某一位不等于0,为1。</p><p>假设eor在第三位上为1，说明a和b在第三位上一定是不一样的。</p><p>在准备一个变量eor1,这时候在让eor1去异或数组中第三位不是1的数。这时候的 eor1就等于a或者b了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">        eor ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">eor1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eor &amp; (~eor + <span class="number">1</span>); <span class="comment">// 提取出最右边的1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">        <span class="comment">// ==0 或者 ==rightOne</span></span><br><span class="line">        <span class="keyword">if</span>((num &amp; rightOne) == rightOne)&#123;</span><br><span class="line">            eor1 ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;eor1,eor1^eor&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e7ff58e0-e794-4c7c-8891-c48a79720b2c-3"><blockquote><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。</p></blockquote><p>对于出现3次的数字,各二进制出现的次数是3的倍数,统计所有数字二进制位中1出现的次数,并对3求余,结果则为出现一次的数字.</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1683774393-WZMBxV-image.png" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] counts=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)&#123;</span><br><span class="line">            counts[j] += (nums[i] &amp; <span class="number">1</span>);</span><br><span class="line">            nums[i] &gt;&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>, t=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        ans &lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        ans |= counts[<span class="number">31</span>-i] % t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>找缺失数</p><blockquote><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p></blockquote><p>我们可以先求得1-n的异或xor，再用xor对nums数组逐个异或，这样最终得到的异或和表达式中，只有缺失元素出现次数为 11 次，其余元素均出现两次，即最终答案xor为缺失元素。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.length;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans ^= i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) ans ^= i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Tip">Tip</h2><blockquote><p>对于一个整数<code>n</code>，<code>n&amp;(n-1)</code>可以将<code>n</code>的二进制最右边值为<code>1</code>的<code>bit</code>位置为<code>0</code>。</p></blockquote><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E4%BD%8D%E8%BF%90%E7%AE%97tip1.png" alt="位运算tip1"></p><p>状态转移的时候可用</p><blockquote><p>字母大小写转化</p></blockquote><p>小写变大写</p><p>大写变小写</p><p>字符 ^= 32</p><p>(char) (ch ^ 32)</p>]]></content>
    
    
    <summary type="html">位运算、二进制枚举</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ高级特性</title>
    <link href="https://wuwawawa.github.io/posts/e42a309a.html"/>
    <id>https://wuwawawa.github.io/posts/e42a309a.html</id>
    <published>2023-06-28T02:08:41.000Z</published>
    <updated>2023-06-29T00:54:17.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息可靠性投递">消息可靠性投递</h2><p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了两种方式用来控制消息的投递可靠性模式。</p><ul><li>confirm 确认模式</li><li>return  退回模式</li></ul><p>rabbitmq 整个消息投递的路径为：<br>producer—&gt;rabbitmq broker—&gt;exchange—&gt;queue—&gt;consumer</p><p>消息从 producer 到 exchange 则会返回一个 confirmCallback 。</p><p>消息从 exchange–&gt;queue 投递失败则会返回一个 returnCallback 。</p><p>我们将利用这两个 callback 控制消息的可靠性投递</p><hr><h3 id="confirm-模式">confirm 模式</h3><p>1、配置文件 publisher-confirm-type: correlated</p><p>2、在rabbitTemplate上定义ConfirmCallBack回调函数</p><div class="tabs" id="6aa50741-31d0-421f-a6b5-56fcd2cf18ef"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6aa50741-31d0-421f-a6b5-56fcd2cf18ef-1"><i class="fas fa-seedling"></i>配置文件</button></li><li class="tab"><button type="button" data-href="#6aa50741-31d0-421f-a6b5-56fcd2cf18ef-2"><i class="fas fa-leaf"></i>生产者配置</button></li><li class="tab"><button type="button" data-href="#6aa50741-31d0-421f-a6b5-56fcd2cf18ef-3"><i class="fab fa-apple"></i>生产者测试模块</button></li><li class="tab"><button type="button" data-href="#6aa50741-31d0-421f-a6b5-56fcd2cf18ef-4"><i class="fas fa-tree"></i>运行结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6aa50741-31d0-421f-a6b5-56fcd2cf18ef-1"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">my_vhost</span></span><br><span class="line">    <span class="comment"># Add this sentence</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6aa50741-31d0-421f-a6b5-56fcd2cf18ef-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_queue_confirm&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;boot_exchange_confirm&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、交换机的配置</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//durable(true) 持久化，mq重启之后交换机还在</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、队列的配置</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、绑定关系  Binging</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、知道哪个队列</span></span><br><span class="line"><span class="comment">     * 2、知道哪个交换机</span></span><br><span class="line"><span class="comment">     * 3、设置对应的 routing key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;bootQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;boot.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6aa50741-31d0-421f-a6b5-56fcd2cf18ef-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConfirm</span><span class="params">()</span>&#123;</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> correlationData 相关的配置信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> ack  交换机是否成功收到消息 true：成功</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cause 失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;confirm方法被执行了....&quot;</span>);</span><br><span class="line">            <span class="comment">// 接收成功</span></span><br><span class="line">            <span class="keyword">if</span> (ack)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息接收成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 接收失败（把交换机的名字，改成不存在的，然后在运行）</span></span><br><span class="line">                System.out.println(<span class="string">&quot;接收失败，原因：&quot;</span>+cause );</span><br><span class="line">                <span class="comment">// 对于失败，做一些处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// EXCHANGE_NAME</span></span><br><span class="line">    rabbitTemplate.convertAndSend(EXCHANGE_NAME,<span class="string">&quot;boot.confirm&quot;</span>,<span class="string">&quot;传的信息:message confirm&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;exchange_not_exist&quot;</span>,<span class="string">&quot;boot.confirm&quot;</span>,<span class="string">&quot;message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6aa50741-31d0-421f-a6b5-56fcd2cf18ef-4"><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">confirm方法被执行了....</span><br><span class="line">消息接收成功</span><br><span class="line">confirm方法被执行了....</span><br><span class="line">接收失败，原因：channel error<span class="punctuation">;</span> protocol <span class="keyword">method</span>: #<span class="keyword">method</span>&lt;<span class="title function_">channel</span>.<span class="title function_">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;exchange_not_exist&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;my_vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="return模式">return模式</h3><p>回退模式：当消息发送给Exchange后，路由器路由到Queue失败之后，才会执行ReruenCallBack</p><ol><li><p>开启回退模式</p><p>publisher-returns: true</p></li><li><p>设置ReturnCallBack</p></li><li><p>设置Exchange处理消息的模式</p><p>3.1 如果消息没有路由到Queue，则丢弃(默认)</p><p>3.2 如果消息没有路由到Queue，返回给消息发送</p><p>​rabbitTemplate.setMandatory(true);</p></li></ol><mark class="hl-label blue">生产者测试模块</mark> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReturn</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 设置交换机处理失败消息模式</span></span><br><span class="line">    rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line">    rabbitTemplate.setReturnCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnCallback()&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息失败了，会调用这个方法</span></span><br><span class="line"><span class="comment">         * 注意：要进行处理失败的处理  rabbitTemplate.setMandatory(true);</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message 消息对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyCode 错误码</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyText 错误信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> exchange 交换机</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;return 执行了&quot;</span>);</span><br><span class="line">            System.out.println(message);</span><br><span class="line">            System.out.println(replyCode);</span><br><span class="line">            System.out.println(replyText);</span><br><span class="line">            System.out.println(exchange);</span><br><span class="line">            System.out.println(routingKey);</span><br><span class="line">            <span class="comment">// 失败的话，就要进行想对应的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 这里的key填的是错误的，这样就不能到Queue</span></span><br><span class="line">    rabbitTemplate.convertAndSend(EXCHANGE_NAME,<span class="string">&quot;boot1.confirm&quot;</span>,<span class="string">&quot;传的信息:message confirm&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label red">输出</mark> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">return 执行了</span><br><span class="line">(Body:<span class="string">&#x27;传的信息:message confirm&#x27;</span> MessageProperties [headers=&#123;&#125;, <span class="attribute">contentType</span>=text/plain, <span class="attribute">contentEncoding</span>=UTF-8, <span class="attribute">contentLength</span>=0, <span class="attribute">receivedDeliveryMode</span>=PERSISTENT, <span class="attribute">priority</span>=0, <span class="attribute">deliveryTag</span>=0])</span><br><span class="line">312</span><br><span class="line">NO_ROUTE</span><br><span class="line">boot_exchange_confirm</span><br><span class="line">boot1.confirm</span><br></pre></td></tr></table></figure><hr><h2 id="Consumer-ACK">Consumer ACK</h2><p>ack指Acknowledge，确认。 表示消费端收到消息后的确认方式。有三种确认方式：</p><ul><li>自动确认：acknowledge=“none”</li><li>手动确认：acknowledge=“manual”</li><li>根据异常情况确认：acknowledge=“auto”</li></ul><p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。</p><mark class="hl-label blue">实现步骤</mark> <p>1、设置手动签收。修改配置文件<br>2、@RabbitListener注解中，要进行ackMode = &quot;MANUAL&quot;的设置<br>3、监听器类实现： ChannelAwareMessageListener接口<br>4、处理成功，调用channel的basicNack()签收<br>5、如果消息处理失败，调用channel的basicNack()拒绝签收</p><div class="tabs" id="2e047fe7-9461-4f2a-9a1d-de7b5111b398"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2e047fe7-9461-4f2a-9a1d-de7b5111b398-1"><i class="fas fa-award"></i>配置文件</button></li><li class="tab"><button type="button" data-href="#2e047fe7-9461-4f2a-9a1d-de7b5111b398-2"><i class="fas fa-baseball-ball"></i>消费者类</button></li><li class="tab"><button type="button" data-href="#2e047fe7-9461-4f2a-9a1d-de7b5111b398-3"><i class="fas fa-bone"></i>运行结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2e047fe7-9461-4f2a-9a1d-de7b5111b398-1"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">my_vhost</span></span><br><span class="line">    <span class="comment"># Add this sentence</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">direct:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2e047fe7-9461-4f2a-9a1d-de7b5111b398-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有出现异常就使用basicAck来进行手动签收</span></span><br><span class="line"><span class="comment"> * 出现异常就进行basicNack来进行重新尝试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AckListener</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ackMode = &quot;MANUAL&quot;要进行这个的设置，不然就还是自动的，那么就会有冲突，会出现错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;boot_queue_confirm&quot;,ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、接收消息</span></span><br><span class="line">            System.out.println(message.getBody().toString());</span><br><span class="line">            <span class="comment">// 2、处理业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;处理业务逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// 失败的处理</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 手动签收</span></span><br><span class="line">            channel.basicAck(deliveryTag,<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 拒接签收 第三个参数：requeue：重回队列，设置成true，那么消息会回到queue，会重新发送消息给消费端。</span></span><br><span class="line">            <span class="comment">// 出错的话，就会一直进行执行，重新尝试</span></span><br><span class="line">            channel.basicNack(deliveryTag,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2e047fe7-9461-4f2a-9a1d-de7b5111b398-3"><p>运行int i = 3/0; 会一直出错，然后就会进行报错的处理</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[B<span class="title">@4</span>a<span class="number">8688</span>bc</span><br><span class="line">处理业务逻辑</span><br><span class="line">[B<span class="title">@1843</span><span class="keyword">c</span><span class="number">046</span></span><br><span class="line">处理业务逻辑</span><br><span class="line">[B<span class="title">@7628</span><span class="keyword">c</span><span class="number">07</span></span><br><span class="line">处理业务逻辑</span><br><span class="line">[B<span class="title">@63</span>bc<span class="number">4756</span></span><br><span class="line">处理业务逻辑</span><br><span class="line">[B<span class="title">@1</span>d<span class="number">01e0</span>f<span class="number">5</span></span><br><span class="line">处理业务逻辑</span><br><span class="line">[B<span class="title">@1</span>b<span class="number">4652e3</span></span><br><span class="line">处理业务逻辑</span><br><span class="line">[B<span class="title">@857</span>e<span class="number">738</span></span><br><span class="line">处理业务逻辑</span><br><span class="line">[B<span class="title">@9509793</span></span><br><span class="line">处理业务逻辑</span><br><span class="line">[B<span class="title">@1</span>b<span class="number">44</span><span class="keyword">c</span><span class="number">804</span></span><br><span class="line">处理业务逻辑</span><br><span class="line">[B<span class="title">@32</span>bc<span class="number">40</span><span class="keyword">c</span><span class="number">5</span></span><br><span class="line">处理业务逻辑</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h2 id="消息可靠性总结">消息可靠性总结</h2><ol><li>持久化<ul><li>exchange要持久化</li><li>queue要持久化</li><li>message要持久化</li></ul></li><li>生产方确认Confirm</li><li>消费方确认Ack</li><li>Broker高可用</li></ol><hr><h2 id="消费端限流">消费端限流</h2><p>当我们处理信息的A系统每秒只能处理1000个请求，但是用户真正的请求每秒可以达到5000次，为了防止A系统宕机，我们先把数据存放在MQ中，然后A系统每秒从MQ中拉取1000个来进行处理。</p><mark class="hl-label blue">实现步骤</mark> <p>1、配置文件中要设置成手动： acknowledge-mode: manual<br>2、配置文件中要设置拉取条数： prefetch: 1<br>3、消费者进行签收处理：channel.basicAck</p><div class="tabs" id="218eee53-a59f-4896-958e-d12b3633ca8b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#218eee53-a59f-4896-958e-d12b3633ca8b-1"><i class="fas fa-cat"></i>配置文件</button></li><li class="tab"><button type="button" data-href="#218eee53-a59f-4896-958e-d12b3633ca8b-2"><i class="fas fa-horse"></i>生产者发送10条数据</button></li><li class="tab"><button type="button" data-href="#218eee53-a59f-4896-958e-d12b3633ca8b-3"><i class="fas fa-dove"></i>消费者</button></li><li class="tab"><button type="button" data-href="#218eee53-a59f-4896-958e-d12b3633ca8b-4"><i class="fas fa-dragon"></i>结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="218eee53-a59f-4896-958e-d12b3633ca8b-1"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">my_vhost</span></span><br><span class="line">    <span class="comment"># Add this sentence</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">direct:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="218eee53-a59f-4896-958e-d12b3633ca8b-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLimit</span><span class="params">()</span>&#123;</span><br><span class="line">    rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 10条消息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(EXCHANGE_NAME,<span class="string">&quot;boot.confirm&quot;</span>,<span class="string">&quot;传的信息:message confirm，第&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="218eee53-a59f-4896-958e-d12b3633ca8b-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务质量保证</span></span><br><span class="line"><span class="comment"> * 限流机制： Consumer</span></span><br><span class="line"><span class="comment"> * 1、ack设置为手动确认</span></span><br><span class="line"><span class="comment"> * 2、listener-container配置属性</span></span><br><span class="line"><span class="comment"> * prefetch = 2，表示消费端每次从mq拉取2条消息进行消费，消费完毕之后，在拉取2条</span></span><br><span class="line"><span class="comment"> * prefetch: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QosListener</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ackMode = &quot;MANUAL&quot;要进行这个的设置，不然就还是自动的，那么就会有冲突，会出现错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;boot_queue_confirm&quot;,ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用prefetch获取消息为: &quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        <span class="comment">// 签收处理(如果没有签收，那么就只能消费prefetch条信息)</span></span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="218eee53-a59f-4896-958e-d12b3633ca8b-4"><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用prefetch获取消息为: 传的信息:<span class="keyword">message</span> confirm，第<span class="number">1</span></span><br><span class="line">使用prefetch获取消息为: 传的信息:<span class="keyword">message</span> confirm，第<span class="number">3</span></span><br><span class="line">使用prefetch获取消息为: 传的信息:<span class="keyword">message</span> confirm，第<span class="number">5</span></span><br><span class="line">使用prefetch获取消息为: 传的信息:<span class="keyword">message</span> confirm，第<span class="number">7</span></span><br><span class="line">使用prefetch获取消息为: 传的信息:<span class="keyword">message</span> confirm，第<span class="number">9</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="TTL">TTL</h2><p>TTL 全称 Time To Live（存活时间/过期时间）。</p><p>当消息到达存活时间后，还没有被消费，会被自动清除。</p><p>RabbitMQ可以对消息设置过期时间，也可以对整个队列（Queue）设置过期时间。</p><mark class="hl-label blue">实现步骤</mark> <p>1、把队列设置成带有ttl时间的队列，对整个队列消息统一过期<br>2、消息的单独过期处理，当消息在队列头部时，会单独判断这一消息是否过期<br>3、如果两者都进行设置了，会选择时间短的那个</p><div class="tabs" id="ccf40020-d097-43b5-bea0-9b3ece411ec9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ccf40020-d097-43b5-bea0-9b3ece411ec9-1"><i class="fas fa-seedling"></i>配置类</button></li><li class="tab"><button type="button" data-href="#ccf40020-d097-43b5-bea0-9b3ece411ec9-2"><i class="fas fa-leaf"></i>生产者无单独过期处理</button></li><li class="tab"><button type="button" data-href="#ccf40020-d097-43b5-bea0-9b3ece411ec9-3"><i class="fab fa-apple"></i>生产者队列过期处理</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ccf40020-d097-43b5-bea0-9b3ece411ec9-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_queue_confirm&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;boot_exchange_confirm&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、交换机的配置</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//durable(true) 持久化，mq重启之后交换机还在</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、队列的配置</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//# Modify this sentence</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).ttl(<span class="number">10000</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、绑定关系  Binging</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、知道哪个队列</span></span><br><span class="line"><span class="comment">     * 2、知道哪个交换机</span></span><br><span class="line"><span class="comment">     * 3、设置对应的 routing key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;bootQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;bootExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;boot.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ccf40020-d097-43b5-bea0-9b3ece411ec9-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReturnttl1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(EXCHANGE_NAME,<span class="string">&quot;boot.confirm&quot;</span>,<span class="string">&quot;ttl的处理：&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ccf40020-d097-43b5-bea0-9b3ece411ec9-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReturnttl2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 消息后处理对象，设置一些消息的参数信息</span></span><br><span class="line">    <span class="type">MessagePostProcessor</span> <span class="variable">messagePostProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 1、设置message的信息(消息的过期时间)</span></span><br><span class="line">            message.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">            <span class="comment">// 2、返回该消息</span></span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 消息单独过期</span></span><br><span class="line">    rabbitTemplate.convertAndSend(EXCHANGE_NAME,<span class="string">&quot;boot.confirm&quot;</span>,<span class="string">&quot;ttl的处理：&quot;</span>,messagePostProcessor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="死信队列">死信队列</h2><p>死信队列，英文缩写：DLX  。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627200803362.png" alt="image-20230627200803362"></p><p>消息成为死信的三种情况：</p><ol><li>队列消息长度到达限制</li><li>消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false</li><li>原队列存在消息过期设置，消息到达超时时间未被消费</li></ol><p>生产者 --&gt; 正常交换机 --&gt;正常队列–&gt;消息死信后----&gt;死信交换机----&gt;死信队列 ----&gt;消费者</p><div class="tabs" id="0249cde2-f058-4100-9b70-fbee81d0e1f6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0249cde2-f058-4100-9b70-fbee81d0e1f6-1"><i class="fas fa-cat"></i>配置文件</button></li><li class="tab"><button type="button" data-href="#0249cde2-f058-4100-9b70-fbee81d0e1f6-2"><i class="fas fa-horse"></i>配置类</button></li><li class="tab"><button type="button" data-href="#0249cde2-f058-4100-9b70-fbee81d0e1f6-3"><i class="fas fa-dragon"></i>测试1</button></li><li class="tab"><button type="button" data-href="#0249cde2-f058-4100-9b70-fbee81d0e1f6-4"><i class="fas fa-heartbeat"></i>测试2</button></li><li class="tab"><button type="button" data-href="#0249cde2-f058-4100-9b70-fbee81d0e1f6-5"><i class="fas fa-cookie-bite"></i>测试3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0249cde2-f058-4100-9b70-fbee81d0e1f6-1"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">my_vhost</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">direct:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0249cde2-f058-4100-9b70-fbee81d0e1f6-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfigDLX</span> &#123;</span><br><span class="line">    <span class="comment">// 正常队列和交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;boot_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置死信队列和死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_DLX</span> <span class="operator">=</span> <span class="string">&quot;boot_queue_dlx&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME_DLX=<span class="string">&quot;boot_exchange_dlx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、交换机的配置</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//durable(true) 持久化，mq重启之后交换机还在</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;ExchangeDLX&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchangeDlx</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME_DLX).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、正常队列和死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 1、死信交换机名称</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, EXCHANGE_NAME_DLX);</span><br><span class="line">        <span class="comment">// 2、死信交换机的key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;boot.dlx.hh&quot;</span>);</span><br><span class="line">        <span class="comment">// 3、设置队列的过期时间</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 4、设置队列的长度限制</span></span><br><span class="line">        args.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信队列配置</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootQueueDLX&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootQueueDLX</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_DLX).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常交换机绑定正常队列</span></span><br><span class="line"><span class="comment">     * 1、知道哪个队列</span></span><br><span class="line"><span class="comment">     * 2、知道哪个交换机</span></span><br><span class="line"><span class="comment">     * 3、设置对应的 routing key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;bootQueue&quot;)</span> Queue queue,<span class="meta">@Qualifier(&quot;bootExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;boot.dlx.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信交换机，和死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindQueueExchangeDlx</span><span class="params">(<span class="meta">@Qualifier(&quot;bootQueueDLX&quot;)</span> Queue queue,<span class="meta">@Qualifier(&quot;ExchangeDLX&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;boot.dlx.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0249cde2-f058-4100-9b70-fbee81d0e1f6-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1、不开启消费者，测试过期时间 (10s，之后会跑到死信队列中)</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;boot_exchange&quot;</span>,<span class="string">&quot;boot.dlx.hh&quot;</span>,<span class="string">&quot;死信测试：&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10s之后(死信队列中多一条)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627202313086.png" alt="image-20230627202313086"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0249cde2-f058-4100-9b70-fbee81d0e1f6-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 2、不开启消费者，测试长度，有10个消息在正常队列，有10个在死信队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;boot_exchange&quot;</span>,<span class="string">&quot;boot.dlx.hh&quot;</span>,<span class="string">&quot;死信测试：&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有10个消息在正常队列，有10个在死信队列</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627202546934.png" alt="image-20230627202546934"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0249cde2-f058-4100-9b70-fbee81d0e1f6-5"><p>消息拒收 (让消费者不接受,消费者出现错误然后不重回队列)</p><div class="tabs" id="d5b0d24e-8f0e-4b32-94c2-f8f9ffcdff31"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d5b0d24e-8f0e-4b32-94c2-f8f9ffcdff31-1"><i class="fas fa-dove"></i>消费者拒收</button></li><li class="tab"><button type="button" data-href="#d5b0d24e-8f0e-4b32-94c2-f8f9ffcdff31-2"><i class="fas fa-anchor"></i>发送消息</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d5b0d24e-8f0e-4b32-94c2-f8f9ffcdff31-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DLXListener</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ackMode = &quot;MANUAL&quot;要进行这个的设置，不然就还是自动的，那么就会有冲突，会出现错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;boot_queue_dlx&quot;,ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、接收消息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;获取到： &quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">            <span class="comment">// 2、处理业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;处理业务逻辑&quot;</span>);</span><br><span class="line">            <span class="comment">// add this sentence</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 手动签收</span></span><br><span class="line">            channel.basicAck(deliveryTag,<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 拒接签收 第三个参数：requeue：重回队列，设置成true，那么消息会回到queue，会重新发送消息给消费端。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常，拒绝接收。。不重回队列&quot;</span>);</span><br><span class="line">            <span class="comment">// 出错的话，就会一直进行执行，重新尝试</span></span><br><span class="line">            channel.basicNack(deliveryTag,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d5b0d24e-8f0e-4b32-94c2-f8f9ffcdff31-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 3、消息拒收 </span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;boot_exchange&quot;</span>,<span class="string">&quot;boot.dlx.hh&quot;</span>,<span class="string">&quot;死信测试：&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="延迟队列">延迟队列</h2><p>延迟队列：消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费(TTL + 死信队列)</p><p>需求：</p><ol><li>下单后，30分钟未支付，取消订单，回滚库存。</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627203537136.png" alt="image-20230627203537136"></p><p>流程： 订单系统-&gt;MQ延迟队列(30min后消费)-&gt;库存系统-&gt;判断订单状态-&gt;支付，未支付</p><p>MQ延迟队列：<br>交换机 -&gt;TTL队列-&gt;死信交换机-&gt;死信队列-&gt;库存系统</p><mark class="hl-label blue">实现</mark> <div class="tabs" id="b3eb00f1-d8cf-4d88-88f9-0e50f8975463"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b3eb00f1-d8cf-4d88-88f9-0e50f8975463-1"><i class="fas fa-seedling"></i>配置类</button></li><li class="tab"><button type="button" data-href="#b3eb00f1-d8cf-4d88-88f9-0e50f8975463-2"><i class="fas fa-leaf"></i>消费者</button></li><li class="tab"><button type="button" data-href="#b3eb00f1-d8cf-4d88-88f9-0e50f8975463-3"><i class="fab fa-apple"></i>生产者测试类</button></li><li class="tab"><button type="button" data-href="#b3eb00f1-d8cf-4d88-88f9-0e50f8975463-4"><i class="fas fa-tree"></i>运行结果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b3eb00f1-d8cf-4d88-88f9-0e50f8975463-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟队列：</span></span><br><span class="line"><span class="comment"> * 1、正常交换机和正常队列</span></span><br><span class="line"><span class="comment"> * 2、死信交换机和死信队列</span></span><br><span class="line"><span class="comment"> * 3、正常队列和死信交换机（核心配置）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfigDLXTTL</span> &#123;</span><br><span class="line">    <span class="comment">// 正常队列和交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;order_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;order_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置死信队列和死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME_DLX</span> <span class="operator">=</span> <span class="string">&quot;order_queue_dlx&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME_DLX=<span class="string">&quot;order_exchange_dlx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、交换机的配置</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;ExchangeDLX&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">exchangeDlx</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME_DLX).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、正常队列和死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 1、死信交换机名称</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, EXCHANGE_NAME_DLX);</span><br><span class="line">        <span class="comment">// 2、死信交换机的key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlx.order.cancel&quot;</span>);</span><br><span class="line">        <span class="comment">// 3、设置队列的过期时间</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 4、设置队列的长度限制</span></span><br><span class="line">        args.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信队列配置</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bootQueueDLX&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootQueueDLX</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME_DLX).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常交换机绑定正常队列</span></span><br><span class="line"><span class="comment">     * 1、知道哪个队列</span></span><br><span class="line"><span class="comment">     * 2、知道哪个交换机</span></span><br><span class="line"><span class="comment">     * 3、设置对应的 routing key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;bootQueue&quot;)</span> Queue queue,<span class="meta">@Qualifier(&quot;bootExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;order.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信交换机，和死信队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindQueueExchangeDlx</span><span class="params">(<span class="meta">@Qualifier(&quot;bootQueueDLX&quot;)</span> Queue queue,<span class="meta">@Qualifier(&quot;ExchangeDLX&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;dlx.order.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b3eb00f1-d8cf-4d88-88f9-0e50f8975463-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderListener</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ackMode = &quot;MANUAL&quot;要进行这个的设置，不然就还是自动的，那么就会有冲突，会出现错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;order_queue_dlx&quot;,ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、接收消息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;获取到： &quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">            <span class="comment">// 2、处理业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库处理&quot;</span>);</span><br><span class="line">            <span class="comment">// 手动签收</span></span><br><span class="line">            channel.basicAck(deliveryTag,<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 拒接签收 第三个参数：requeue：重回队列，设置成true，那么消息会回到queue，会重新发送消息给消费端。</span></span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常，拒绝接收。。不重回队列&quot;</span>);</span><br><span class="line">            <span class="comment">// 出错的话，就会一直进行执行，重新尝试</span></span><br><span class="line">            channel.basicNack(deliveryTag,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b3eb00f1-d8cf-4d88-88f9-0e50f8975463-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 延迟队列，10s之后，才会进行接收处理</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;order_exchange&quot;</span>,<span class="string">&quot;order.message&quot;</span>,<span class="string">&quot;延迟队列信息：id=1&quot;</span>);</span><br><span class="line">    <span class="comment">//2.打印倒计时10s</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; i &gt;<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        System.out.println(i+<span class="string">&quot;.........&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b3eb00f1-d8cf-4d88-88f9-0e50f8975463-4"><p>10s后会进行消费处理</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line"><span class="number">9.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line"><span class="number">8.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line"><span class="number">7.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line"><span class="number">6.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line"><span class="number">5.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line"><span class="number">4.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line"><span class="number">3.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line"><span class="number">2.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line"><span class="number">1.</span><span class="params">...</span><span class="params">...</span>..</span><br><span class="line">获取到： 延迟队列信息：id=<span class="number">1</span></span><br><span class="line">数据库处理</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label blue">小结</mark> <p>延迟队列指消息进入队列后，可以被延迟一定时间，再进行消费。</p><p>RabbitMQ没有提供延迟队列功能，但是可以使用：TTL + DLX 来实现延迟队列效果。</p><hr><h2 id="消息可靠性保障">消息可靠性保障</h2><mark class="hl-label green">消息补偿</mark> <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627211647066.png" alt="image-20230627211647066"></p><p>步骤2和步骤3发送的消息是一样的，只不过队列不一样</p><hr><h2 id="消息幂等性保障">消息幂等性保障</h2><p>幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p><p>在MQ中指，消费多条相同的消息，得到与消费该消息一次相同的结果。</p><mark class="hl-label green">乐观锁机制</mark> <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627212634855.png" alt="image-20230627212634855"></p>]]></content>
    
    
    <summary type="html">RabbitMQ高级特性</summary>
    
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://wuwawawa.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ交换机和工作模式</title>
    <link href="https://wuwawawa.github.io/posts/4e86ee1.html"/>
    <id>https://wuwawawa.github.io/posts/4e86ee1.html</id>
    <published>2023-06-28T01:54:34.000Z</published>
    <updated>2023-06-28T03:25:35.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Exchanges">Exchanges</h2><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。</p><p>相反，<strong>生产者只能将消息发送到交换机(exchange)</strong>，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image.54tzwxwrqco.webp" alt="image" style="zoom: 50%;" /><hr><h3 id="Exchanges的类型">Exchanges的类型</h3><ul><li><p><strong>直接(direct)</strong>：处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 abc ，则只有被标记为 abc 的消息才被转发，不会转发 abc.def，也不会转发 dog.ghi，只会转发 abc。</p></li><li><p><strong>主题(topic)</strong>：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号 * 匹配不多不少一个词。因此 abc.# 能够匹配到 abc.def.ghi，但是 abc.* 只会匹配到 abc.def。</p></li><li><p><strong>标题(headers)</strong>：不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要要字符串形式的。</p><p>匹配规则 x-match 有下列两种类型：</p><p>x-match = all ：表示所有的键值对都匹配才能接受到消息</p><p>x-match = any ：表示只要有键值对匹配就能接受到消息</p></li><li><p><strong>扇出(fanout)</strong>：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。</p></li></ul><hr><h3 id="默认exchange">默认exchange</h3><p>通过空字符串(“”)进行标识的交换机是默认交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure><p>第一个参数是交换机的名称。空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey) 绑定指定的 key</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image.2nq1gc53kik.webp" alt="image"></p><hr><p>RabbitMQ提供了6种工作模式：简单模式、workqueues、Publish/Subscribe发布与订阅模式、Routing路由模式、Topics主题模式、RPC远程调用模式(不介绍)。</p><p>不同的工作模式其实指的就是消息的路由策略和方式不一样</p><h2 id="简单模式">简单模式</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230620194916643.png" alt="image-20230620194916643"></p><p>在上图的模型中，有以下概念：</p><p>P：生产者，也就是要发送消息的程序</p><p>C：消费者：消息的接收者，会一直等待消息到来</p><p>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息</p><mark class="hl-label blue">步骤</mark> <p>流程：<br>1、建立生产者与服务器的TCP长连接。<br>2、在TCP连接中再建立独立的轻量级的虚拟连接Channel。<br>3、通过Channel连接去声明一个队列，如果队列已存在则直接使用存在的队列。<br>4、生产者通过Channel往队列中发送消息。<br>5、消费者同生产者一样建立与服务器的连接。<br>6、消费者声明虚拟连接Channel.<br>7、消费者通过Channel声明一个队列（和生产者声明的队列同名）<br>8、消费者从该队列中获取消息，并且返回确认。收到确认后，队列删除已读消息。</p><div class="tabs" id="d94d2eb8-be41-462b-a1f4-08e146d79702"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d94d2eb8-be41-462b-a1f4-08e146d79702-1"><i class="fas fa-heartbeat"></i>添加依赖</button></li><li class="tab"><button type="button" data-href="#d94d2eb8-be41-462b-a1f4-08e146d79702-2"><i class="fas fa-anchor"></i>创建连接</button></li><li class="tab"><button type="button" data-href="#d94d2eb8-be41-462b-a1f4-08e146d79702-3"><i class="fas fa-seedling"></i>创建消费者</button></li><li class="tab"><button type="button" data-href="#d94d2eb8-be41-462b-a1f4-08e146d79702-4"><i class="fas fa-leaf"></i>发送消息</button></li><li class="tab"><button type="button" data-href="#d94d2eb8-be41-462b-a1f4-08e146d79702-5"><i class="fab fa-apple"></i>接收消息</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d94d2eb8-be41-462b-a1f4-08e146d79702-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d94d2eb8-be41-462b-a1f4-08e146d79702-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">rabbitConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//5672是RabbitMQ的默认端口号</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;my_vhost&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> connectionFactory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getRabbitConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">connectionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//5672是RabbitMQ的默认端口号</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;my_vhost&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> connectionFactory.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d94d2eb8-be41-462b-a1f4-08e146d79702-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleConsumer</span> <span class="keyword">extends</span> <span class="title class_">DefaultConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//重写构造函数,Channel通道对象需要从外层传入，在handleDelivery中要用到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleConsumer</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(channel);</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者接收到的消息：&quot;</span>+message);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息的TagId：&quot;</span>+envelope.getDeliveryTag());</span><br><span class="line">        <span class="comment">//false只确认签收当前的消息，设置为true的时候则代表签收该消费者所有未签收的消息</span></span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d94d2eb8-be41-462b-a1f4-08e146d79702-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Connection rabbitConnection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2SimpleQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> rabbitConnection.createChannel();</span><br><span class="line">    <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">    <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">    <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">    <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">    <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">    <span class="comment">//其他额外的参数, null</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;QUEUE-HELLO-WORLD&quot;</span>,<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello666&quot;</span>;</span><br><span class="line">    <span class="comment">//四个参数</span></span><br><span class="line">    <span class="comment">//exchange 交换机，暂时用不到，在后面进行发布订阅时才会用到</span></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="comment">//额外的设置属性</span></span><br><span class="line">    <span class="comment">//最后一个参数是要传递的消息字节数组</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;QUEUE-HELLO-WORLD&quot;</span>, <span class="literal">null</span>,message.getBytes());</span><br><span class="line">    channel.close();</span><br><span class="line">    rabbitConnection.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;===发送成功===&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d94d2eb8-be41-462b-a1f4-08e146d79702-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testReceiveMessageFromSimpleQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> rabbitConnection.createChannel();</span><br><span class="line">    <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">    <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">    <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">    <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">    <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">    <span class="comment">//其他额外的参数, null</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;QUEUE-HELLO-WORLD&quot;</span>,<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//从MQ服务器中获取数据</span></span><br><span class="line">    <span class="comment">//创建一个消息消费者</span></span><br><span class="line">    <span class="comment">//第一个参数：队列名</span></span><br><span class="line">    <span class="comment">//第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法</span></span><br><span class="line">    <span class="comment">//第三个参数要传入DefaultConsumer的实现类</span></span><br><span class="line">    channel.basicConsume(<span class="string">&quot;QUEUE-HELLO-WORLD&quot;</span>, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">SimpleConsumer</span>(channel));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="Work-queues工作队列模式">Work queues工作队列模式</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627102745413.png" alt="image-20230627102745413"></p><p></p><p>Work Queues：与入门程序的简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。</p><p>应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。</p><span class='p red'>两个消费者属于竞争的关系，只有一个消费者可以取到消息。</span><mark class="hl-label blue">示例</mark> <div class="tabs" id="d8caf33f-f175-4fba-b9b9-c7a9ad9e28c2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d8caf33f-f175-4fba-b9b9-c7a9ad9e28c2-1"><i class="fas fa-horse"></i>创建多消费者</button></li><li class="tab"><button type="button" data-href="#d8caf33f-f175-4fba-b9b9-c7a9ad9e28c2-2"><i class="fas fa-cat"></i>发送消息</button></li><li class="tab"><button type="button" data-href="#d8caf33f-f175-4fba-b9b9-c7a9ad9e28c2-3"><i class="fas fa-dragon"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d8caf33f-f175-4fba-b9b9-c7a9ad9e28c2-1"><p>分别启动两个消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkConsumer1</span> <span class="keyword">extends</span> <span class="title class_">DefaultConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//重写构造函数,Channel通道对象需要从外层传入，在handleDelivery中要用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WorkConsumer1</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(channel);</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1接收到的消息：&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息的TagId：&quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">        <span class="comment">//false只确认签收当前的消息，设置为true的时候则代表签收该消费者所有未签收的消息</span></span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitConfig.getRabbitConnection().createChannel();</span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>,<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从MQ服务器中获取数据</span></span><br><span class="line">        <span class="comment">//创建一个消息消费者</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名</span></span><br><span class="line">        <span class="comment">//第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法</span></span><br><span class="line">        <span class="comment">//第三个参数要传入DefaultConsumer的实现类</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">WorkConsumer1</span>(channel));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkConsumer1</span> <span class="keyword">extends</span> <span class="title class_">DefaultConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//重写构造函数,Channel通道对象需要从外层传入，在handleDelivery中要用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WorkConsumer1</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(channel);</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(body);</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者1接收到的消息：&quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息的TagId：&quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">        <span class="comment">//false只确认签收当前的消息，设置为true的时候则代表签收该消费者所有未签收的消息</span></span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitConfig.getRabbitConnection().createChannel();</span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>,<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从MQ服务器中获取数据</span></span><br><span class="line">        <span class="comment">//创建一个消息消费者</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名</span></span><br><span class="line">        <span class="comment">//第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法</span></span><br><span class="line">        <span class="comment">//第三个参数要传入DefaultConsumer的实现类</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">WorkConsumer1</span>(channel));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d8caf33f-f175-4fba-b9b9-c7a9ad9e28c2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2WorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> rabbitConnection.createChannel();</span><br><span class="line">    <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">    <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">    <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">    <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">    <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">    <span class="comment">//其他额外的参数, null</span></span><br><span class="line">    channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>,<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;hello rabbitmq~~~&quot;</span>;</span><br><span class="line">        <span class="comment">//四个参数</span></span><br><span class="line">        <span class="comment">//exchange 交换机，暂时用不到，在后面进行发布订阅时才会用到</span></span><br><span class="line">        <span class="comment">//队列名称</span></span><br><span class="line">        <span class="comment">//额外的设置属性</span></span><br><span class="line">        <span class="comment">//最后一个参数是要传递的消息字节数组</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;work_queues&quot;</span>, <span class="literal">null</span>,message.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close();</span><br><span class="line">    rabbitConnection.close();</span><br><span class="line">    System.out.println(<span class="string">&quot;===发送成功===&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d8caf33f-f175-4fba-b9b9-c7a9ad9e28c2-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">消费者1接收到的消息：0hello rabbitmq<span class="code">~~~</span></span><br><span class="line"><span class="code">消息的TagId：1</span></span><br><span class="line"><span class="code">消费者1接收到的消息：2hello rabbitmq~~~</span></span><br><span class="line">消息的TagId：2</span><br><span class="line">消费者1接收到的消息：4hello rabbitmq<span class="code">~~~</span></span><br><span class="line"><span class="code">消息的TagId：3</span></span><br><span class="line"><span class="code">消费者1接收到的消息：6hello rabbitmq~~~</span></span><br><span class="line">消息的TagId：4</span><br><span class="line">消费者1接收到的消息：8hello rabbitmq<span class="code">~~~</span></span><br><span class="line"><span class="code">消息的TagId：5</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">消费者2接收到的消息：1hello rabbitmq<span class="code">~~~</span></span><br><span class="line"><span class="code">消息的TagId：1</span></span><br><span class="line"><span class="code">消费者2接收到的消息：3hello rabbitmq~~~</span></span><br><span class="line">消息的TagId：2</span><br><span class="line">消费者2接收到的消息：5hello rabbitmq<span class="code">~~~</span></span><br><span class="line"><span class="code">消息的TagId：3</span></span><br><span class="line"><span class="code">消费者2接收到的消息：7hello rabbitmq~~~</span></span><br><span class="line">消息的TagId：4</span><br><span class="line">消费者2接收到的消息：9hello rabbitmq<span class="code">~~~</span></span><br><span class="line"><span class="code">消息的TagId：5</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label green">小结</mark> <ol><li>在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是<span class='p red'>竞争</span>的关系。</li><li>Work Queues对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。例如：短信服务部署多个，只需要有一个节点成功发送即可。</li></ol><hr><h2 id="Pub-Sub发布订阅模式-fanout">Pub/Sub发布订阅模式(fanout)</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627105706546.png" alt="image-20230627105706546"></p><p>在订阅模型中，多了一个Exchange 角色，而且过程略有变化：</p><p>P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</p><p>C：消费者，消息的接收者，会一直等待消息到来</p><p>Queue：消息队列，接收消息、缓存消息</p><p>X：交换机（Exchange）。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：</p><ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式）的队列</li></ul><p>交换机只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange 绑定，或者没有符合路由规则的队列，那么<span class='p red'>消息会丢失</span>！</p><p>需求：</p><mark class="hl-label blue">示例</mark> <div class="tabs" id="bd4946ed-095a-4851-8c36-886910201d08"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#bd4946ed-095a-4851-8c36-886910201d08-1"><i class="far fa-sun"></i>发送消息</button></li><li class="tab"><button type="button" data-href="#bd4946ed-095a-4851-8c36-886910201d08-2"><i class="fas fa-wind"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="bd4946ed-095a-4851-8c36-886910201d08-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Connection rabbitConnection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2PubSubQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> rabbitConnection.createChannel();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建交换机</span></span><br><span class="line"><span class="comment">    exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        1. exchange:交换机名称</span></span><br><span class="line"><span class="comment">        2. type:交换机类型</span></span><br><span class="line"><span class="comment">            DIRECT(&quot;direct&quot;),：定向</span></span><br><span class="line"><span class="comment">            FANOUT(&quot;fanout&quot;),：扇形（广播），发送消息到每一个与之绑定队列。</span></span><br><span class="line"><span class="comment">            TOPIC(&quot;topic&quot;),通配符的方式</span></span><br><span class="line"><span class="comment">            HEADERS(&quot;headers&quot;);参数匹配</span></span><br><span class="line"><span class="comment">         3. durable:是否持久化</span></span><br><span class="line"><span class="comment">        4. autoDelete:自动删除</span></span><br><span class="line"><span class="comment">        5. internal：内部使用。 一般false</span></span><br><span class="line"><span class="comment">        6. arguments：参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_fanout&quot;</span>;</span><br><span class="line">    channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_fanout_queue2&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queue1Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    channel.queueDeclare(queue2Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//绑定队列和交换机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    queueBind(String queue, String exchange, String routingKey)</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        1. queue：队列名称</span></span><br><span class="line"><span class="comment">        2. exchange：交换机名称</span></span><br><span class="line"><span class="comment">        3. routingKey：路由键，绑定规则</span></span><br><span class="line"><span class="comment">            如果交换机的类型为fanout ，routingKey设置为&quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;日志信息：张三调用了findAll方法...日志级别：info...&quot;</span>;</span><br><span class="line">    channel.basicPublish(exchangeName,<span class="string">&quot;&quot;</span>,<span class="literal">null</span>,body.getBytes());</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    channel.close();</span><br><span class="line">    rabbitConnection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd4946ed-095a-4851-8c36-886910201d08-2"><p>C1</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body：日志信息：张三调用了findAll方法<span class="string">...</span>日志级别：info.<span class="string">..</span></span><br><span class="line">将日志信息打印到控制台<span class="string">.....</span></span><br></pre></td></tr></table></figure><p>C2</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body：日志信息：张三调用了findAll方法<span class="string">...</span>日志级别：info.<span class="string">..</span></span><br><span class="line">将日志信息保存数据库<span class="string">.....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <mark class="hl-label green">小结</mark> <ol><li><p>交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者都收到。</p></li><li><p>发布订阅模式与工作队列模式的区别：</p><ul><li>工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机</li><li>发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)</li><li>发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑定到默认的交换机</li></ul></li></ol><hr><h2 id="Routing路由模式-Direct">Routing路由模式(Direct)</h2><p>模式说明：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个 RoutingKey（路由key）</li><li>消息的发送方在向 Exchange 发送消息时，也必须指定消息的 RoutingKey</li><li>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的 Routing Key 进行判断，只有队列的Routingkey 与消息的 Routing key 完全一致，才会接收到消息</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627130017285.png" alt="image-20230627130017285"></p><p>P：生产者，向 Exchange 发送消息，发送消息时，会指定一个routing key</p><p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给与 routing key 完全匹配的队列</p><p>C1：消费者，其所在队列指定了需要 routing key 为 error 的消息</p><p>C2：消费者，其所在队列指定了需要 routing key 为 info、error、warning 的消息</p><mark class="hl-label blue">示例</mark> <div class="tabs" id="6cf7bbdd-8671-4d97-9a8a-e5c570e3becc"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6cf7bbdd-8671-4d97-9a8a-e5c570e3becc-1"><i class="fas fa-award"></i>创建消费者</button></li><li class="tab"><button type="button" data-href="#6cf7bbdd-8671-4d97-9a8a-e5c570e3becc-2"><i class="fas fa-baseball-ball"></i>发送消息</button></li><li class="tab"><button type="button" data-href="#6cf7bbdd-8671-4d97-9a8a-e5c570e3becc-3"><i class="fas fa-bone"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6cf7bbdd-8671-4d97-9a8a-e5c570e3becc-1"><p>分别启动两个消费者</p><div class="tabs" id="e8ac1bea-fb46-4d2c-b929-b55f58ed3b99"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e8ac1bea-fb46-4d2c-b929-b55f58ed3b99-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#e8ac1bea-fb46-4d2c-b929-b55f58ed3b99-2"><i class="fas fa-leaf"></i>2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e8ac1bea-fb46-4d2c-b929-b55f58ed3b99-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteConsumer1</span> <span class="keyword">extends</span> <span class="title class_">DefaultConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//重写构造函数,Channel通道对象需要从外层传入，在handleDelivery中要用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RouteConsumer1</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(channel);</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;body：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">        System.out.println(<span class="string">&quot;将日志信息打印到控制台.....&quot;</span>);</span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitConfig.getRabbitConnection().createChannel();</span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_direct_queue1&quot;</span>,<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从MQ服务器中获取数据</span></span><br><span class="line">        <span class="comment">//创建一个消息消费者</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名</span></span><br><span class="line">        <span class="comment">//第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法</span></span><br><span class="line">        <span class="comment">//第三个参数要传入DefaultConsumer的实现类</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_direct_queue1&quot;</span>, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">RouteConsumer1</span>(channel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e8ac1bea-fb46-4d2c-b929-b55f58ed3b99-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteConsumer2</span> <span class="keyword">extends</span> <span class="title class_">DefaultConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//重写构造函数,Channel通道对象需要从外层传入，在handleDelivery中要用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RouteConsumer2</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(channel);</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;body：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">        System.out.println(<span class="string">&quot;将日志信息存储到数据库.....&quot;</span>);</span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitConfig.getRabbitConnection().createChannel();</span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_direct_queue2&quot;</span>,<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从MQ服务器中获取数据</span></span><br><span class="line">        <span class="comment">//创建一个消息消费者</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名</span></span><br><span class="line">        <span class="comment">//第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法</span></span><br><span class="line">        <span class="comment">//第三个参数要传入DefaultConsumer的实现类</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_direct_queue2&quot;</span>, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">RouteConsumer2</span>(channel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6cf7bbdd-8671-4d97-9a8a-e5c570e3becc-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Connection rabbitConnection;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2RouteQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> rabbitConnection.createChannel();</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">   参数：</span></span><br><span class="line"><span class="comment">    1. exchange:交换机名称</span></span><br><span class="line"><span class="comment">    2. type:交换机类型</span></span><br><span class="line"><span class="comment">        DIRECT(&quot;direct&quot;),：定向</span></span><br><span class="line"><span class="comment">        FANOUT(&quot;fanout&quot;),：扇形（广播），发送消息到每一个与之绑定队列。</span></span><br><span class="line"><span class="comment">        TOPIC(&quot;topic&quot;),通配符的方式</span></span><br><span class="line"><span class="comment">        HEADERS(&quot;headers&quot;);参数匹配</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3. durable:是否持久化</span></span><br><span class="line"><span class="comment">    4. autoDelete:自动删除</span></span><br><span class="line"><span class="comment">    5. internal：内部使用。 一般false</span></span><br><span class="line"><span class="comment">    6. arguments：参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_direct&quot;</span>;</span><br><span class="line">    <span class="comment">//创建交换机</span></span><br><span class="line">    channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(queue1Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    channel.queueDeclare(queue2Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//绑定队列和交换机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    queueBind(String queue, String exchange, String routingKey)</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        1. queue：队列名称</span></span><br><span class="line"><span class="comment">        2. exchange：交换机名称</span></span><br><span class="line"><span class="comment">        3. routingKey：路由键，绑定规则</span></span><br><span class="line"><span class="comment">            如果交换机的类型为fanout ，routingKey设置为&quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//队列1绑定 error</span></span><br><span class="line">    channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    <span class="comment">//队列2绑定 info  error  warning</span></span><br><span class="line">    channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">    channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;日志信息：张三调用了delete方法...出错误了。。。日志级别：error...&quot;</span>;</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    channel.basicPublish(exchangeName,<span class="string">&quot;warning&quot;</span>,<span class="literal">null</span>,body.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    channel.close();</span><br><span class="line">    rabbitConnection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6cf7bbdd-8671-4d97-9a8a-e5c570e3becc-3"><p>C2</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body：日志信息：张三调用了delete方法<span class="string">...</span>出错误了。。。日志级别：error.<span class="string">..</span></span><br><span class="line">将日志信息存储到数据库<span class="string">.....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <mark class="hl-label green">小结</mark> <p>Routing 模式要求队列在绑定交换机时要指定 routing key，消息会转发到符合 routing key 的队列。</p><hr><h2 id="Topics主题模式-Topic">Topics主题模式(Topic)</h2><p>模式说明：</p><ul><li>Topic 类型与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。</li><li>只不过 Topic 类型Exchange 可以让队列在绑定 Routing key 的时候使用通配符！</li><li>Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert</li><li>通配符规则：# 匹配一个或多个词，* 匹配不多不少恰好1个词，例如：item.# 能够匹配 item.insert.abc或者 item.insert，item.* 只能匹配 item.insert</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230627143522395.png" alt="image-20230627143522395"></p><mark class="hl-label blue">示例</mark> <div class="tabs" id="4057a61c-cdcf-415e-ac49-9e8d69c468dd"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4057a61c-cdcf-415e-ac49-9e8d69c468dd-1"><i class="fas fa-bug"></i>创建消费者</button></li><li class="tab"><button type="button" data-href="#4057a61c-cdcf-415e-ac49-9e8d69c468dd-2"><i class="fas fa-cannabis"></i>发送消息</button></li><li class="tab"><button type="button" data-href="#4057a61c-cdcf-415e-ac49-9e8d69c468dd-3"><i class="fas fa-candy-cane"></i>输出</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4057a61c-cdcf-415e-ac49-9e8d69c468dd-1"><div class="tabs" id="c2d5c0c1-1bd9-485b-b822-9b2852a455a3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c2d5c0c1-1bd9-485b-b822-9b2852a455a3-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#c2d5c0c1-1bd9-485b-b822-9b2852a455a3-2"><i class="fas fa-leaf"></i>2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c2d5c0c1-1bd9-485b-b822-9b2852a455a3-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicConsumer1</span> <span class="keyword">extends</span> <span class="title class_">DefaultConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//重写构造函数,Channel通道对象需要从外层传入，在handleDelivery中要用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopicConsumer1</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(channel);</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;body：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">        System.out.println(<span class="string">&quot;将日志信息存入数据库.......&quot;</span>);</span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitConfig.getRabbitConnection().createChannel();</span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_topic_queue1&quot;</span>,<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从MQ服务器中获取数据</span></span><br><span class="line">        <span class="comment">//创建一个消息消费者</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名</span></span><br><span class="line">        <span class="comment">//第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法</span></span><br><span class="line">        <span class="comment">//第三个参数要传入DefaultConsumer的实现类</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_topic_queue1&quot;</span>, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">TopicConsumer1</span>(channel));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c2d5c0c1-1bd9-485b-b822-9b2852a455a3-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicConsumer2</span> <span class="keyword">extends</span> <span class="title class_">DefaultConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">//重写构造函数,Channel通道对象需要从外层传入，在handleDelivery中要用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopicConsumer2</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(channel);</span><br><span class="line">        <span class="built_in">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;body：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">        System.out.println(<span class="string">&quot;将日志信息打印控制台.......&quot;</span>);</span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitConfig.getRabbitConnection().createChannel();</span><br><span class="line">        <span class="comment">//创建队列,声明并创建一个队列，如果队列已存在，则使用这个队列</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名称ID</span></span><br><span class="line">        <span class="comment">//第二个参数：是否持久化，false对应不持久化数据，MQ停掉数据就会丢失</span></span><br><span class="line">        <span class="comment">//第三个参数：是否队列私有化，false则代表所有消费者都可以访问，true代表只有第一次拥有它的消费者才能一直使用，其他消费者不让访问</span></span><br><span class="line">        <span class="comment">//第四个：是否自动删除,false代表连接停掉后不自动删除掉这个队列</span></span><br><span class="line">        <span class="comment">//其他额外的参数, null</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_topic_queue2&quot;</span>,<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//从MQ服务器中获取数据</span></span><br><span class="line">        <span class="comment">//创建一个消息消费者</span></span><br><span class="line">        <span class="comment">//第一个参数：队列名</span></span><br><span class="line">        <span class="comment">//第二个参数代表是否自动确认收到消息，false代表手动编程来确认消息，这是MQ的推荐做法</span></span><br><span class="line">        <span class="comment">//第三个参数要传入DefaultConsumer的实现类</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_topic_queue2&quot;</span>, <span class="literal">false</span>, <span class="keyword">new</span> <span class="title class_">TopicConsumer2</span>(channel));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4057a61c-cdcf-415e-ac49-9e8d69c468dd-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2TopicQueue</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">//创建通信“通道”，相当于TCP中的虚拟连接</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> rabbitConnection.createChannel();</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments)</span></span><br><span class="line"><span class="comment">   参数：</span></span><br><span class="line"><span class="comment">    1. exchange:交换机名称</span></span><br><span class="line"><span class="comment">    2. type:交换机类型</span></span><br><span class="line"><span class="comment">        DIRECT(&quot;direct&quot;),：定向</span></span><br><span class="line"><span class="comment">        FANOUT(&quot;fanout&quot;),：扇形（广播），发送消息到每一个与之绑定队列。</span></span><br><span class="line"><span class="comment">        TOPIC(&quot;topic&quot;),通配符的方式</span></span><br><span class="line"><span class="comment">        HEADERS(&quot;headers&quot;);参数匹配</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    3. durable:是否持久化</span></span><br><span class="line"><span class="comment">    4. autoDelete:自动删除</span></span><br><span class="line"><span class="comment">    5. internal：内部使用。 一般false</span></span><br><span class="line"><span class="comment">    6. arguments：参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_topic&quot;</span>;</span><br><span class="line">    <span class="comment">//创建交换机</span></span><br><span class="line">    channel.exchangeDeclare(exchangeName, BuiltinExchangeType.TOPIC,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//创建队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line">    channel.queueDeclare(queue1Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    channel.queueDeclare(queue2Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//7. 绑定队列和交换机</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    queueBind(String queue, String exchange, String routingKey)</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        1. queue：队列名称</span></span><br><span class="line"><span class="comment">        2. exchange：交换机名称</span></span><br><span class="line"><span class="comment">        3. routingKey：路由键，绑定规则</span></span><br><span class="line"><span class="comment">            如果交换机的类型为fanout ，routingKey设置为&quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// routing key  系统的名称.日志的级别。</span></span><br><span class="line">    <span class="comment">//=需求： 所有error级别的日志存入数据库，所有order系统的日志存入数据库</span></span><br><span class="line">    channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;#.error&quot;</span>);</span><br><span class="line">    channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;order.*&quot;</span>);</span><br><span class="line">    channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;*.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;日志信息：张三调用了findAll方法...日志级别：info...&quot;</span>;</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    channel.basicPublish(exchangeName,<span class="string">&quot;goods.error&quot;</span>,<span class="literal">null</span>,body.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    channel.close();</span><br><span class="line">    rabbitConnection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4057a61c-cdcf-415e-ac49-9e8d69c468dd-3"><p>C1</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body：日志信息：张三调用了findAll方法<span class="params">...</span>日志级别：info<span class="params">...</span></span><br><span class="line">将日志信息存入数据库<span class="params">...</span><span class="params">...</span>.</span><br></pre></td></tr></table></figure><p>C2</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">body：日志信息：张三调用了findAll方法<span class="params">...</span>日志级别：info<span class="params">...</span></span><br><span class="line">将日志信息打印控制台<span class="params">...</span><span class="params">...</span>.</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label green">小结</mark> <p>Topic 主题模式可以实现Pub/Sub 发布与订阅模式和Routing 路由模式的功能，只是Topic 在配置routing key 的时候可以使用通配符，显得更加灵活。</p><hr><h2 id="工作模式总结">工作模式总结</h2><ol><li><p>简单模式<br>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）。</p></li><li><p>工作队列模式 Work Queue<br>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）。</p></li><li><p>发布订阅模式 Publish/subscribe<br>需要设置类型为<code>fanout</code>的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。</p></li><li><p>路由模式</p><p>Routing需要设置类型为<code>direct</code>的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列。</p></li><li><p>通配符模式 Topic</p><p>需要设置类型为<code>topic</code>的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列。</p></li></ol><hr><hr><h2 id="SpringBoot整合RabbitMQ">SpringBoot整合RabbitMQ</h2><div class="tabs" id="cfaca039-d38c-4b22-81b6-42a79b6d5668"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#cfaca039-d38c-4b22-81b6-42a79b6d5668-1"><i class="fas fa-award"></i>引入依赖</button></li><li class="tab"><button type="button" data-href="#cfaca039-d38c-4b22-81b6-42a79b6d5668-2"><i class="fas fa-baseball-ball"></i>创建配置文件</button></li><li class="tab"><button type="button" data-href="#cfaca039-d38c-4b22-81b6-42a79b6d5668-3"><i class="fas fa-bone"></i>初级用法</button></li><li class="tab"><button type="button" data-href="#cfaca039-d38c-4b22-81b6-42a79b6d5668-4"><i class="fas fa-anchor"></i>高级用法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="cfaca039-d38c-4b22-81b6-42a79b6d5668-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cfaca039-d38c-4b22-81b6-42a79b6d5668-2"><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">my_vhost</span></span><br></pre></td></tr></table></figure><p>使用注解<code>@EnableRabbit</code>来声明开启，其可放在启动类上，也可以放在你自己写的rabbit配置类上。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cfaca039-d38c-4b22-81b6-42a79b6d5668-3"><div class="tabs" id="5364ad95-30a3-4ad0-b94d-b4c5badc237c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5364ad95-30a3-4ad0-b94d-b4c5badc237c-1"><i class="fas fa-seedling"></i>开启rabbitmq</button></li><li class="tab"><button type="button" data-href="#5364ad95-30a3-4ad0-b94d-b4c5badc237c-2"><i class="fas fa-leaf"></i>监听消费消息</button></li><li class="tab"><button type="button" data-href="#5364ad95-30a3-4ad0-b94d-b4c5badc237c-3"><i class="fab fa-apple"></i>发送消息</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5364ad95-30a3-4ad0-b94d-b4c5badc237c-1"><p>使用注解<code>@EnableRabbit</code>来声明开启，其可放在启动类上，也可以放在你自己写的rabbit配置类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableRabbit</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitmqIntegrateApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RabbitmqIntegrateApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5364ad95-30a3-4ad0-b94d-b4c5badc237c-2"><p>使用<code>@RabbitListener</code>注解即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueConsumer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;ss007&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(<span class="meta">@Payload</span> String messageBody)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;ss007队列：&quot;</span>+messageBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的代码在监听<code>ss007</code>队列，只要这个队列里面存在消息，它就会消费。</p><p>值得注意的一点是，这样写要求<code>ss007</code>这个队列提前创建好了，不然会报错。</p><p>在rabbitmq的管理后台，只填写名称<code>ss007</code>其他的都使用默认值即可。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5364ad95-30a3-4ad0-b94d-b4c5badc237c-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;发配到提瓦特大陆吃五分熟猪排，和植物抢空气，乘坐浮力大于重力的船躲避剧毒的蟒蛇。&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;ss007&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下我们程序的输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2023</span>-<span class="number">06</span>-<span class="number">27</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">39</span>.<span class="number">031</span>  INFO <span class="number">74710</span> ---<span class="meta"> [ntContainer#0-1] c.e.r.Consumer.QueueConsumer             : ss007队列:发配到提瓦特大陆吃五分熟猪排，和植物抢空气，乘坐浮力大于重力的船躲避剧毒的蟒蛇。</span></span><br></pre></td></tr></table></figure><p>可见，我们刚向<code>ss007</code>队列发送了一条消息，这条消息就被我们刚才写的消费者给消费了。</p><p>前面我们介绍Rabbitmq的时候说每个队列需要绑定到一个交换器上才能正常接收消息，但是我们好像没有定义交换器，也没有绑定任何交换器，这是怎么回事呢？</p><p>其实是因为，rabbitmq有一个默认的Exchange，而每个队列都会默认绑定它。所以我们前面的演示使用的是默认Exchange，它是一个direct类型的交换器。</p><p>那routing key我们也没指定啊，默认Exchange使用哪个路由key呢？ 默认队列名称作为路由key，也就是<code>ss007</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cfaca039-d38c-4b22-81b6-42a79b6d5668-4"><div class="tabs" id="a7ab3680-b4b7-42fc-9328-a5912b1dc73f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a7ab3680-b4b7-42fc-9328-a5912b1dc73f-1"><i class="fas fa-cat"></i>配置交换器与队列</button></li><li class="tab"><button type="button" data-href="#a7ab3680-b4b7-42fc-9328-a5912b1dc73f-2"><i class="fas fa-horse"></i>监听消费消息</button></li><li class="tab"><button type="button" data-href="#a7ab3680-b4b7-42fc-9328-a5912b1dc73f-3"><i class="fas fa-dove"></i>发送消息</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a7ab3680-b4b7-42fc-9328-a5912b1dc73f-1"><p>创建了一个Exchange，两个队列，并将这两个队列绑定到了那个Exchange上。注意两个绑定使用的routingkey是不一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topicQueue1&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">topicQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;topicQueue2&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;topicExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">topicBinding1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue1()).to(topicExchange())</span><br><span class="line">                .with(<span class="string">&quot;ss007.王二狗.觉醒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">topicBinding2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(topicQueue2()).to(topicExchange())</span><br><span class="line">                .with(<span class="string">&quot;ss007.*.觉醒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a7ab3680-b4b7-42fc-9328-a5912b1dc73f-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueConsumer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;topicQueue1&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveTopic1</span><span class="params">(<span class="meta">@Payload</span> String messageBody)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;topic1队列：&quot;</span> + messageBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;topicQueue2&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveTopic2</span><span class="params">(<span class="meta">@Payload</span> String messageBody)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;topic2队列：&quot;</span> + messageBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a7ab3680-b4b7-42fc-9328-a5912b1dc73f-3"><p>第一个参数是我们上一步配置的交换器，第二个参数是routingkey，第三个参数是消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTopicMsg</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> <span class="string">&quot;ss007.牛翠花.觉醒&quot;</span> ;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;发配到提瓦特大陆吃五分熟猪排，和植物抢空气，乘坐浮力大于重力的船躲避剧毒的蟒蛇。&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;topicExchange&quot;</span>,routingKey,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看程序输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topic2队列：发配到提瓦特大陆吃五分熟猪排，和植物抢空气，乘坐浮力大于重力的船躲避剧毒的蟒蛇。</span><br></pre></td></tr></table></figure><p>我们向交换器发送了一条消息，路由key是<code>ss007.牛翠花.觉醒</code>，它匹配到了我们topicBinding2的路由key：<code>ss007.*.觉醒</code>，而没有匹配到topicBinding1的路由key：<code>ss007.王二狗.觉醒</code>，所以只有topicQueue2里丢入了消息。</p><p>这次使用路由字段为<code>ss007.王二狗.觉醒</code></p><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">topic1队列：发配到提瓦特大陆吃五分熟猪排，和植物抢空气，乘坐浮力大于重力的船躲避剧毒的蟒蛇。</span><br><span class="line">topic2队列：发配到提瓦特大陆吃五分熟猪排，和植物抢空气，乘坐浮力大于重力的船躲避剧毒的蟒蛇。</span><br></pre></td></tr></table></figure><p>可见，两个队列里面都被丢入了同样的消息。这是为什么呢？这是由于我们使用的是Topic类型的交换器，而且路由key可以匹配到两个队列的绑定。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> ]]></content>
    
    
    <summary type="html">RabbitMQ交换机(工作模式)、SpringBoot整合RabbitMQ</summary>
    
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://wuwawawa.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息应答与分发</title>
    <link href="https://wuwawawa.github.io/posts/203330d3.html"/>
    <id>https://wuwawawa.github.io/posts/203330d3.html</id>
    <published>2023-06-28T00:57:49.000Z</published>
    <updated>2023-06-28T01:53:49.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息应答">消息应答</h2><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ 一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息，因为它无法接收到。</p><p>为了保证消息在发送过程中不丢失，引入消息应答机制，消息应答就是：<span class='p green'>消费者在接收到消息并且处理该消息之后，告诉rabbitmq它已经处理了，rabbitmq可以把该消息删除了。</span></p><hr><h3 id="自动应答">自动应答</h3><p>消息发送后立即被认为已经传送成功，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递的消息数量进行限制</strong>，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，<strong>所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</strong></p><hr><h3 id="手动应答">手动应答</h3><p>当一个消费者收到一个快递，但是这个包裹是破损的，这时候一般会有以下选择</p><blockquote><p>拒收快递，让快递员把快递寄回。 （如果有多个consumer可能这条消息会到其它的consumer中，如果只有一个，那么下次获取还是可以拿到）</p><p>签收快递，然后偷偷的扔了（钱多任性）</p><p>拒收快递，联系商家再给我补发一个</p></blockquote><p>下面是具体的方法，BasicReject同时承担了扔掉消息与退回。区别在第二个参数。BasicNack则是批量进行上面两个操作，DeliveryTag小于或等于当前消息的都会进行该操作，当然是否批量是由第二个参数来决定的。</p><p>BasicRecover方法则是进行补发操作，其中的参数如果为true是把消息退回到queue但是有可能被其它的consumer接收到，设置为false是只补发给当前的consumer</p><mark class="hl-label blue">手动消息应答的方法</mark> <div class="tabs" id="a0f6f907-57ca-41b6-be17-62b82578e0f2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a0f6f907-57ca-41b6-be17-62b82578e0f2-1"><i class="fas fa-seedling"></i>肯定确认应答basicAck</button></li><li class="tab"><button type="button" data-href="#a0f6f907-57ca-41b6-be17-62b82578e0f2-2"><i class="fas fa-leaf"></i>否定确认应答basicReject</button></li><li class="tab"><button type="button" data-href="#a0f6f907-57ca-41b6-be17-62b82578e0f2-3"><i class="fab fa-apple"></i>否定确认basicNack</button></li><li class="tab"><button type="button" data-href="#a0f6f907-57ca-41b6-be17-62b82578e0f2-4"><i class="fas fa-tree"></i>补发消息basicRecover</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a0f6f907-57ca-41b6-be17-62b82578e0f2-1"><p><code>Channel.basicAck</code> ：</p><p><code>basicAck(long deliveryTag, boolean multiple);</code></p><p>第一个参数是消息的标记，第二个参数表示是否应用于多消息，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了</p><p>Multiple 的解释：</p><p>手动应答的好处是可以批量应答并且减少网络拥堵</p><ul><li><p>true 代表批量应答 channel 上未应答的消息</p><p>比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答</p></li><li><p>false 同上面相比只会应答 tag=8 的消息 5,6,7 这三个消息依然不会被确认收到消息应答</p></li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image.3vspi8fu4v20.webp" alt="image" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a0f6f907-57ca-41b6-be17-62b82578e0f2-2"><p><code>Channel.basicReject</code></p><p><code>basicReject(long deliveryTag, boolean requeue);</code></p><p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数表示是否 <code>requeue</code>：true 则重新入队列，false 则丢弃或者进入死信队列。</p><p>该方法 reject 后，该消费者还是会消费到该条被 reject 的消息。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a0f6f907-57ca-41b6-be17-62b82578e0f2-3"><p><code>Channel.basicNack</code> ：表示己拒绝处理该消息，可以将其丢弃了</p><p><code>basicNack(long deliveryTag, boolean multiple, boolean requeue);</code></p><p>第一个参数表示拒绝 <code>deliveryTag</code> 对应的消息，第二个参数是表示否应用于多消息，第三个参数表示是否 <code>requeue</code>，与 basicReject 区别就是同时支持多个消息，可以 拒绝签收 该消费者先前接收未 ack 的所有消息。拒绝签收后的消息也会被自己消费到。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a0f6f907-57ca-41b6-be17-62b82578e0f2-4"><p><code>Channel.basicRecover</code></p><p><code>basicRecover(boolean requeue);</code></p><p>是否恢复消息到队列，参数是是否 <code>requeue</code>，true 则重新入队列，并且尽可能的将之前 <code>recover</code> 的消息投递给其他消费者消费，而不是自己再次消费。false 则消息会重新被投递给自己。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="消息自动重新入队">消息自动重新入队</h3><p>如果消费者由于某些原因失去连接(其通道已关闭，连接已关闭或 TCP 连接丢失)，导致消息未发送 ACK 确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image.4hplocbhsdk0.webp" alt="image" style="zoom:80%;" /><hr><hr><h2 id="RabbitMQ持久化">RabbitMQ持久化</h2><p>当 RabbitMQ 服务停掉以后，消息生产者发送过来的消息不丢失要如何保障？默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<span class='p green'>我们需要将队列和消息都标记为持久化。</span></p><h3 id="队列持久化">队列持久化</h3><p>之前我们创建的队列都是非持久化的，RabbitMQ 如果重启的化，该队列就会被删除掉，如果要队列实现持久化需要在声明队列的时候把 durable 参数设置为true，代表开启持久化</p><p>在<strong>消息生产者</strong>开启持久化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ACK_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启持久化</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//在控制台中输入信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入信息：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME,<span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span>+ message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><blockquote><p>如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列</p></blockquote><p>不然就会出现如下错误：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image.4nf70nwh0j60.webp" alt="image"></p><p>持久化前后对比：D表示Durable</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image.5tlb9m3bfh00.webp" alt="image"></p><hr><h3 id="消息持久化">消息持久化</h3><p>需要在<strong>消息生产者</strong>发布消息的时候，开启消息的持久化</p><p>在 basicPublish 方法的第二个参数添加这个属性： <code>MessageProperties.PERSISTENT_TEXT_PLAIN</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task02</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ACK_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列持久化</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//在控制台中输入信息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入信息：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="comment">//设置生产者发送消息为持久化消息(要求保存到磁盘上)</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span>+ message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。</p><hr><hr><h2 id="不公平分发">不公平分发</h2><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个<strong>消费者 1</strong> 处理任务的速度非常快，而另外一个<strong>消费者 2</strong> 处理速度却很慢，这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是 RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p><p>为了避免这种情况，<strong>在消费者中消费消息之前</strong>，设置参数 <code>channel.basicQos(1);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ACK_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接受消息处理时间较短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span>(consumerTag,message) -&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//沉睡1S</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接受到的消息:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//手动应答</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.消息的标记Tag</span></span><br><span class="line"><span class="comment">             * 2.是否批量应答 false表示不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置不公平分发</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启成功，会看到如下结果：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230628094736710.png" alt="image-20230628094736710"></p><p>不公平分发思想：如果一个工作队列还没有处理完或者没有应答签收一个消息，则不拒绝 RabbitMQ 分配新的消息到该工作队列。此时 RabbitMQ 会优先分配给其他已经处理完消息或者空闲的工作队列。如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker (工作队列)或者改变其他存储任务的策略。</p><hr><h2 id="预取值分发">预取值分发</h2><p>带权的消息分发</p><p>默认消息的发送是异步发送的，所以在任何时候，channel 上不止只有一个消息来自消费者的手动确认，所以本质上是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小</strong>，<strong>以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 <code>basic.qos</code> 方法设置「预取计数」值来完成的。</p><p>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag=6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。</p><p>通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。</p><p>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image.2anljpf3y134.webp" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ACK_QUEUE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMQUtils.getChannel();</span><br><span class="line">        System.out.println(<span class="string">&quot;C1等待接受消息处理时间较短&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span>(consumerTag,message) -&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//沉睡1S</span></span><br><span class="line">            SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;接受到的消息:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="comment">//手动应答</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1.消息的标记Tag</span></span><br><span class="line"><span class="comment">             * 2.是否批量应答 false表示不批量应答信道中的消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">CancelCallback</span> <span class="variable">cancelCallback</span> <span class="operator">=</span> (consumerTag -&gt; &#123;</span><br><span class="line">            System.out.println(consumerTag + <span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置不公平分发</span></span><br><span class="line">        <span class="comment">//int prefetchCount = 1;</span></span><br><span class="line">        <span class="comment">//值不等于 1，则代表预取值,预取值为4</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line">        <span class="comment">//采用手动应答</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        channel.basicConsume(TASK_QUEUE_NAME,autoAck,deliverCallback,cancelCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不公平分发和预取值分发都用到 <code>basic.qos</code> 方法，如果取值为 1，代表不公平分发，取值不为1，代表预取值分发</p></blockquote>]]></content>
    
    
    <summary type="html">消息应答与发布</summary>
    
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://wuwawawa.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ概述</title>
    <link href="https://wuwawawa.github.io/posts/b543ced0.html"/>
    <id>https://wuwawawa.github.io/posts/b543ced0.html</id>
    <published>2023-06-19T02:44:38.000Z</published>
    <updated>2023-06-28T02:09:21.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MQ概述">MQ概述</h2><h3 id="MQ基本概念">MQ基本概念</h3><p>MQ全称<span class='p red'>M</span>essage <span class='p red'>Q</span>ueue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。</p><p>分布式系统之间进行通信有两种方式。</p><ol><li>A通过远程调用的方式直接去访问B。</li><li>A系统还可以借助第三方来完成与B系统进行通信。比如A现将消息发给C，C再讲数据发给B。</li></ol><p>MQ，消息队列，存储消息的中间件</p><p>分布式系统通信两种方式：直接远程调用和借助第三方完成间接通信</p><p>发送方称为生产者，接收方称为消费者</p><hr><h3 id="MQ的优势和劣势">MQ的优势和劣势</h3><mark class="hl-label green">优势</mark> <div class="tabs" id="a1df0ae3-f522-4b3f-b592-8f6762871809"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a1df0ae3-f522-4b3f-b592-8f6762871809-1"><i class="fas fa-cat"></i>应用解耦</button></li><li class="tab"><button type="button" data-href="#a1df0ae3-f522-4b3f-b592-8f6762871809-2"><i class="fas fa-horse"></i>异步提速</button></li><li class="tab"><button type="button" data-href="#a1df0ae3-f522-4b3f-b592-8f6762871809-3"><i class="fas fa-dove"></i>削峰填谷</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a1df0ae3-f522-4b3f-b592-8f6762871809-1"><p>使用MQ 使得应用间解耦，提升容错性和可维护性。</p><p>当库存系统发生异常，也不会影响到订单系统。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230619105918146.png" alt="image-20230619105918146" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a1df0ae3-f522-4b3f-b592-8f6762871809-2"><p>一个下单操作耗时：20 + 300 + 300 + 300 = 920ms，用户点击完下单按钮后，需要等待920ms才能得到下单响应，太慢！</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230619105950643.png" alt="image-20230619105950643" style="zoom:50%;" /><p>用户点击完下单按钮后，只需等待25ms就能得到下单响应(20 + 5 = 25ms)。提升用户体验和系统吞吐量（单位时间内处理请求的数目）。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230619110057758.png" alt="image-20230619110057758" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a1df0ae3-f522-4b3f-b592-8f6762871809-3"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230619110217684.png" alt="image-20230619110217684" style="zoom:50%;" /><p>使用了MQ 之后，限制消费消息的速度为1000，这样一来，高峰期产生的数据势必会被积压在MQ 中，高峰就被“削”掉了，但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000，直到消费完积压的消息，这就叫做“填谷”。</p><p>使用MQ后，可以提高系统稳定性。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230619110350154.png" alt="image-20230619110350154"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label red">劣势</mark> <div class="tabs" id="f1df2770-2143-4f82-9257-fd6baccaeedf"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#f1df2770-2143-4f82-9257-fd6baccaeedf-1"><i class="fas fa-bug"></i>系统可用性降低</button></li><li class="tab"><button type="button" data-href="#f1df2770-2143-4f82-9257-fd6baccaeedf-2"><i class="fas fa-cannabis"></i>系统复杂度提高</button></li><li class="tab"><button type="button" data-href="#f1df2770-2143-4f82-9257-fd6baccaeedf-3"><i class="fas fa-candy-cane"></i>一致性问题</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="f1df2770-2143-4f82-9257-fd6baccaeedf-1"><p>系统引入的外部依赖越多，系统稳定性越差。一旦MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f1df2770-2143-4f82-9257-fd6baccaeedf-2"><p>MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f1df2770-2143-4f82-9257-fd6baccaeedf-3"><p>A 系统处理完业务，通过MQ 给B、C、D三个系统发消息数据，如果B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>既然 MQ 有优势也有劣势，那么使用 MQ 需要满足什么条件呢？</p></blockquote><p>①生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。</p><p>②容许短暂的不一致性。</p><p>③确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。</p><hr><h3 id="常见的MQ产品">常见的MQ产品</h3><p>目前业界有很多的 MQ 产品，例如 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等，也有直接使用Redis充当消息队列的案例，而这些消息队列产品，各有侧重，在实际选型时，需要结合自身需求及 MQ 产品特征，综合考虑。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">RabbitMQ</th><th style="text-align:center">ActiveMQ</th><th style="text-align:center">RocketMQ</th><th style="text-align:center">Kafka</th></tr></thead><tbody><tr><td style="text-align:center">公司/社区</td><td style="text-align:center">RabbitMQ</td><td style="text-align:center">Apache</td><td style="text-align:center">阿里</td><td style="text-align:center">Apache</td></tr><tr><td style="text-align:center">开发语言</td><td style="text-align:center">Erlang</td><td style="text-align:center">Java</td><td style="text-align:center">Java</td><td style="text-align:center">Scala&amp;Java</td></tr><tr><td style="text-align:center">单机吞吐量</td><td style="text-align:center">万级（其次）</td><td style="text-align:center">万级（最差）</td><td style="text-align:center">十万级（最好）</td><td style="text-align:center">十万级（次之）</td></tr><tr><td style="text-align:center">消息延迟</td><td style="text-align:center">微秒级</td><td style="text-align:center">毫秒级</td><td style="text-align:center">亳秒级s</td><td style="text-align:center">毫秒以内</td></tr><tr><td style="text-align:center">功能特性</td><td style="text-align:center">并发能力强，性能极其好， 延时低，社区活跃，管理界面丰富</td><td style="text-align:center">老牌产品，成熟度高， 文档较多</td><td style="text-align:center">MQ功能比较完备，扩展性佳</td><td style="text-align:center">只支持主要的MQ功能， 毕竟是为大数据领域准备的。</td></tr></tbody></table><hr><hr><h2 id="RabbitMQ的安装">RabbitMQ的安装</h2><div class="tabs" id="141ff293-273e-4e63-b8a7-0015358c616c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#141ff293-273e-4e63-b8a7-0015358c616c-1"><i class="fas fa-seedling"></i>拉取镜像</button></li><li class="tab"><button type="button" data-href="#141ff293-273e-4e63-b8a7-0015358c616c-2"><i class="fas fa-leaf"></i>创建挂载文件夹和配置文件</button></li><li class="tab"><button type="button" data-href="#141ff293-273e-4e63-b8a7-0015358c616c-3"><i class="fab fa-apple"></i>启动命令</button></li><li class="tab"><button type="button" data-href="#141ff293-273e-4e63-b8a7-0015358c616c-4"><i class="fas fa-tree"></i>访问</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="141ff293-273e-4e63-b8a7-0015358c616c-1"><p><code>docker pull rabbitmq:management</code></p><p>management：表示可以通过web页面管理</p><p>如果<code>docker pull rabbitmq</code> 后面不带management，启动rabbitmq后是无法打开管理界面的，需要启用插件</p><p><code>docker exec -it rabbitmq rabbitmq-plugins enable rabbitmq_management</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="141ff293-273e-4e63-b8a7-0015358c616c-2"><p>创建完成之后要对所创建文件授权权限，都设置成777 否则在启动容器的时候容易失败</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/soft</span><br><span class="line">❯ <span class="built_in">mkdir</span> -p ./rabbitmq/&#123;conf,data,<span class="built_in">log</span>&#125;</span><br><span class="line">❯ <span class="built_in">chmod</span> -R 777 ./rabbitmq</span><br></pre></td></tr></table></figure><p>创建临时容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rabbitmq1 --restart=always --hostname=rabbitmqhost \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin \</span><br><span class="line">-e RABBITMQ_DEFAULT_VHOST=my_vhost \</span><br><span class="line">-p 5672:5672 -p 15672:15672 \</span><br><span class="line">rabbitmq:management</span><br></pre></td></tr></table></figure><p>复制配置文件到宿主机</p><p><code>docker cp rabbitmq1:/etc/rabbitmq/ /Users/fortune/soft/rabbitmq/conf</code></p><p>删除临时容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop rabbitmq1 </span><br><span class="line">docker <span class="built_in">rm</span> rabbitmq1 </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="141ff293-273e-4e63-b8a7-0015358c616c-3"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rabbitmq --restart=always \</span><br><span class="line">--hostname=rabbitmqhost \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=admin \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=admin \</span><br><span class="line">-e RABBITMQ_DEFAULT_VHOST=my_vhost \</span><br><span class="line">-v /Users/fortune/soft/rabbitmq/data:/var/lib/rabbitmq \</span><br><span class="line">-v /Users/fortune/soft/rabbitmq/log:/var/log/rabbitmq \</span><br><span class="line">-v /Users/fortune/soft/rabbitmq/conf/rabbitmq:/etc/rabbitmq \</span><br><span class="line">-p 5672:5672 -p 15672:15672 \</span><br><span class="line">rabbitmq:management</span><br></pre></td></tr></table></figure><p>设置主机名的作用 （–hostname=rabbitmqhost）</p><p>RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="141ff293-273e-4e63-b8a7-0015358c616c-4"><p>访问localhost:15672输入用户名密码即可进入控制台</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="RabbitMQ简介">RabbitMQ简介</h2><p>AMQP，即Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年，AMQP规范发布。类比HTTP。</p><p>2007年，Rabbit技术公司基于AMQP标准开发的RabbitMQ 1.0 发布。RabbitMQ采用Erlang语言开发。Erlang语言由Ericson设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p><p>RabbitMQ 基础架构如下图：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230619112428501.png" alt="image-20230619112428501"></p><mark class="hl-label blue">RabbitMQ中相关概念</mark> <div class="tabs" id="a99bb2e0-fea1-4c75-afe2-adf03e47f7ed"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-1"><i class="fas fa-cat"></i>Broker</button></li><li class="tab"><button type="button" data-href="#a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-2"><i class="fas fa-horse"></i>Virtual host</button></li><li class="tab"><button type="button" data-href="#a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-3"><i class="fas fa-dove"></i>Connection</button></li><li class="tab"><button type="button" data-href="#a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-4"><i class="fas fa-dragon"></i>Channel</button></li><li class="tab"><button type="button" data-href="#a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-5"><i class="fas fa-seedling"></i>Exchange</button></li><li class="tab"><button type="button" data-href="#a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-6"><i class="fas fa-leaf"></i>Queue</button></li><li class="tab"><button type="button" data-href="#a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-7"><i class="fab fa-apple"></i>Binding</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-1"><p>接收和分发消息的应用，RabbitMQ Server就是Message Broker</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-2"><p>出于多租户和安全因素设计的，把AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的namespace 概念。当多个不同的用户使用同一个RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange／queue 等。</p><p>可以理解为像Mysql里数据库的概念</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-3"><p>publisher／consumer 和broker 之间的TCP 连接</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-4"><p>如果每一次访问RabbitMQ 都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel 是在connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别channel，所以channel 之间是完全隔离的。Channel 作为轻量级的Connection 极大减少了操作系统建立TCP connection 的开销</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-5"><p>message 到达broker 的第一站，根据分发规则，匹配查询表中的routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-6"><p>消息最终被送到这里等待consumer 取走</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a99bb2e0-fea1-4c75-afe2-adf03e47f7ed-7"><p>exchange 和queue 之间的虚拟连接，binding 中可以包含routing key。Binding 信息被保存到exchange 中的查询表中，用于message 的分发依据</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr>]]></content>
    
    
    <summary type="html">RabbitMQ基本概念、入门案例</summary>
    
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://wuwawawa.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理</title>
    <link href="https://wuwawawa.github.io/posts/1b7ba4a9.html"/>
    <id>https://wuwawawa.github.io/posts/1b7ba4a9.html</id>
    <published>2023-06-16T00:44:04.000Z</published>
    <updated>2023-06-17T13:33:10.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis数据结构">Redis数据结构</h2><h3 id="动态字符串">动态字符串</h3><p>我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。</p><p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：<br>获取字符串长度的需要通过运算<br>非二进制安全<br>不可修改<br>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。<br>例如，我们执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name admin</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>那么Redis将在底层创建两个SDS，其中一个是包含&quot;name&quot;的SDS，另一个是包含&quot;admin&quot;&quot;的SDS。</p><p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984624671.png" alt="1653984624671"></p><p>例如，一个包含字符串“name”的sds结构如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984648404.png" alt="1653984648404"></p><p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984787383.png" alt="1653984787383"></p><p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p><p>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</p><p>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984822363.png" alt="1653984822363"></p><mark class="hl-label red">优点</mark> <p>① 获取字符串长度的时间复杂度为O(1）</p><p>② 支持动态扩容</p><p>③ 减少内存分配次数</p><p>④ 二进制安全</p><hr><h3 id="IntSet">IntSet</h3><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。<br>结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> encoding;<span class="comment">/*编码方式，支持存放16位、32位、64位整数*/</span> </span><br><span class="line"><span class="type">uint32_t</span> length;<span class="comment">/*元素个数*/</span></span><br><span class="line"><span class="type">int8_t</span> contents[];<span class="comment">/*整数数组，保存集合数据*/</span> </span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16(sizeof(int16_t))<span class="comment">/*2字节整数，范围类似java的short*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32(sizeof(int32_t))<span class="comment">/*4字节整数，范围类似java的int*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64(sizeof(int64_t))<span class="comment">/*8字节整数，范围类似java的long*/</span></span></span><br></pre></td></tr></table></figure><p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985149557.png" alt="1653985149557"></p><p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：<br>encoding：4字节<br>length：4字节<br>contents：2字节 * 3  = 6字节</p><mark class="hl-label green">IntSet升级</mark> <p>现在，假设有一个intset，元素为{5,10，20}，采用的编码是INTSET_ENC_INT16，则每个整数占2字节：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616110642298.png" alt="image-20230616110642298"></p><p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p><ul><li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li><li>将待添加的元素放入数组末尾</li><li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985276621.png" alt="1653985276621"></p><mark class="hl-label blue">IntSet新增流程</mark> <p>源码如下</p><div class="tabs" id="b59a24b2-347a-4c61-a4ad-db89c7792c05"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b59a24b2-347a-4c61-a4ad-db89c7792c05-1"><i class="fas fa-seedling"></i>intsetAdd</button></li><li class="tab"><button type="button" data-href="#b59a24b2-347a-4c61-a4ad-db89c7792c05-2"><i class="fas fa-leaf"></i>intsetUpgradeAndAdd</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b59a24b2-347a-4c61-a4ad-db89c7792c05-1"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985304075.png" alt="1653985304075"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b59a24b2-347a-4c61-a4ad-db89c7792c05-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985327653.png" alt="1653985327653"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label green">小总结</mark> <p>Intset可以看做是特殊的整数数组，具备一些特点：</p><ul><li>Redis会确保Intset中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><hr><h3 id="Dict">Dict</h3><p>我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。<br>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      <span class="comment">// Entry数组，数组中保存的是指向Entry的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     <span class="comment">// 哈希表数组的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// 哈希表数组的掩码，用于计算索引值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;     <span class="comment">// Entry个数</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;              <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;          <span class="comment">// 值</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;       <span class="comment">// 64位无符号整数</span></span><br><span class="line">        <span class="type">int64_t</span> s64;        <span class="comment">// 64位有符号整数</span></span><br><span class="line">        <span class="type">double</span> d;           <span class="comment">// 双精度浮点数</span></span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个哈希表节点的指针</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;     <span class="comment">// dict类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;     <span class="comment">// 私有数据，在做特殊hash运算时用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];       <span class="comment">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx;     <span class="comment">// rehash进度标识符，-1表示没有进行rehash操作</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">// rehash是否暂停，1则暂停，0则继续</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1=v1，假设k1的哈希值h =1，则1&amp;3 =1，因此k1=v1要存储到数组角标1位置。再来一个k2=v2,hash值相等。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985497735.png" alt="1653985497735"></p><p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985640422.png" alt="1653985640422"></p><div class="tabs" id="30d4fd04-9ea3-400c-8733-b028dc42b438"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#30d4fd04-9ea3-400c-8733-b028dc42b438-1"><i class="fas fa-cat"></i>Dict的扩容</button></li><li class="tab"><button type="button" data-href="#30d4fd04-9ea3-400c-8733-b028dc42b438-2"><i class="fas fa-cookie-bite"></i>Dict的收缩</button></li><li class="tab"><button type="button" data-href="#30d4fd04-9ea3-400c-8733-b028dc42b438-3"><i class="fas fa-horse"></i>Dict的rehash</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="30d4fd04-9ea3-400c-8733-b028dc42b438-1"><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；</li><li>哈希表的 LoadFactor &gt; 5 ；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dicExpandIfNeeded</span><span class="params">(dict *d)</span>&#123;</span><br><span class="line">  <span class="comment">// 如果正在rehash，则返回ok</span></span><br><span class="line">  <span class="keyword">if</span>(dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line">  <span class="comment">// 如果哈希表为空，则初始化哈希表为默认大小：4</span></span><br><span class="line">  <span class="keyword">if</span>(d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d,DICT_HT_INITIAL_SIZE);</span><br><span class="line">  <span class="comment">// 当负载因子 (used/size）达到1以上，并且当前没有进行bgrewrite等子进程操作</span></span><br><span class="line">  <span class="comment">// 或者负载因子超过5，则进行 dictExpand，也就是扩容</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio) &amp;&amp;</span><br><span class="line">        dictTypeExpandAllowed(d))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 扩容大小为used+1，底层会对扩容大小做判断，实际上找的是第一个大于等于used+1的 2^n</span></span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="30d4fd04-9ea3-400c-8733-b028dc42b438-2"><p>Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor &lt; 0.1 时，会做哈希表收缩</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_hash.c # hashTypeDeleted() </span></span><br><span class="line"><span class="keyword">if</span> (dictDelete((dict*)o-&gt;ptr, field) == C_OK) &#123;</span><br><span class="line">    deleted = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 删除成功后，检查是否需要重置Dict大小，如果需要则调用dictResize重置</span></span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(o-&gt;ptr)) dictResize(o-&gt;ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// server.c 文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    <span class="comment">// entry数量</span></span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="comment">// size &gt; 4（哈希表初识大小）并且 负载因子低于0.1</span></span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp; (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> minimal;</span><br><span class="line">    <span class="comment">// 如果正在做bgsave或bgrewriteof或rehash，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) </span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 获取used，也就是entry个数</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="comment">// 如果used小于4，则重置为4</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="comment">// 重置大小为minimal，其实是第一个大于等于minimal的2^n</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="30d4fd04-9ea3-400c-8733-b028dc42b438-3"><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<ul><li>如果是扩容，<a href="http://xn--sizedict-309lrnyf93ba308jhyz009bulyebpa.ht">则新size为第一个大于等于dict.ht</a>[0].used + 1的2^n</li><li>如果是收缩，<a href="http://xn--sizedict-309lrnyf93ba308jhyz009bulyebpa.ht">则新size为第一个大于等于dict.ht</a>[0].used的2^n （不得小于4）</li></ul></li><li>按照新的realeSize申请内存空间，创建dictht，<a href="http://xn--dict-9k7fo76ei05chfya.ht">并赋值给dict.ht</a>[1]</li><li>设置dict.rehashidx = 0，标示开始rehash</li><li><s><a href="http://xn--dict-fw9g.ht">将dict.ht</a>[0]<a href="http://xn--dictEntryrehashdict-f673ahz3bw09ldr4l367by3xi.ht">中的每一个dictEntry都rehash到dict.ht</a>[1]</s></li><li>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，<a href="http://xn--dict-fj9fn60b3meqtz33c.ht">如果是则将dict.ht</a>[0].table[rehashidx]<a href="http://xn--entryrehashdict-df7y2036bukvcc86b.ht">的entry链表rehash到dict.ht</a>[1]，并且将rehashidx++。<a href="http://xn--dict-907j085c.ht">直至dict.ht</a>[0]<a href="http://xn--rehashdict-s11qz55mghdu3ijtgvl6e2byf.ht">的所有数据都rehash到dict.ht</a>[1]</li><li><a href="http://xn--dict-fw9g.ht">将dict.ht</a>[1]<a href="http://xn--dict-9k7f028vteva.ht">赋值给dict.ht</a>[0]，<a href="http://xn--dict-z95k.ht">给dict.ht</a>[1]初始化为空哈希表，<a href="http://xn--dict-430gi74gild203bjk5c.ht">释放原来的dict.ht</a>[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、<a href="http://xn--dict-ue6fy7b90hub348a7phvn7bvk9i.ht">修改和删除则会在dict.ht</a>[0]<a href="http://xn--dict-z21g.ht">和dict.ht</a>[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><p>Dict的rehash并不是一次性完成的。试想一下，如果Dict中包含数百万的entry，要在一次rehash完成，极有可能导致主线程阻塞。因此Dict的rehash是分多次、渐进式的完成，因此称为渐进式rehash。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label blue">小总结</mark> <p>Dict的结构：</p><ul><li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li><li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li></ul><p>Dict的伸缩：</p><ul><li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li><li>当LoadFactor小于0.1时，Dict收缩</li><li>扩容大小为第一个大于等于used + 1的2^n</li><li>收缩大小为第一个大于等于used 的2^n</li><li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li><li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li></ul><hr><h3 id="ZipList">ZipList</h3><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616120637074.png" alt="image-20230616120637074"></p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>长度</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4 字节</td><td>记录整个压缩列表占用的内存字节数</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2 字节</td><td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td>entry</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1 字节</td><td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table><mark class="hl-label blue">ZipListEntry</mark> <p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986055253.png" alt="1653986055253"></p><ul><li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul></li><li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p></li><li><p>contents：负责保存节点的数据，可以是字符串或整数</p></li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p><mark class="hl-label green">Encoding编码</mark> <p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p><table><thead><tr><th>编码</th><th>编码长度</th><th>字符串大小</th></tr></thead><tbody><tr><td>|00pppppp|</td><td>1 bytes</td><td>&lt;= 63 bytes</td></tr><tr><td>|01pppppp|qqqqqqqq|</td><td>2 bytes</td><td>&lt;= 16383 bytes</td></tr><tr><td>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td><td>5 bytes</td><td>&lt;= 4294967295 bytes</td></tr></tbody></table><p>例如，我们要保存字符串：“ab”和 “bc”</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986172002.png" alt="1653986172002"></p><p>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</p><table><thead><tr><th style="text-align:center">编码</th><th style="text-align:center">编码长度</th><th style="text-align:center">整数类型</th></tr></thead><tbody><tr><td style="text-align:center">11000000</td><td style="text-align:center">1</td><td style="text-align:center">int16_t（2 bytes）</td></tr><tr><td style="text-align:center">11010000</td><td style="text-align:center">1</td><td style="text-align:center">int32_t（4 bytes）</td></tr><tr><td style="text-align:center">11100000</td><td style="text-align:center">1</td><td style="text-align:center">int64_t（8 bytes）</td></tr><tr><td style="text-align:center">11110000</td><td style="text-align:center">1</td><td style="text-align:center">24位有符整数(3 bytes)</td></tr><tr><td style="text-align:center">11111110</td><td style="text-align:center">1</td><td style="text-align:center">8位有符整数(1 bytes)</td></tr><tr><td style="text-align:center">1111xxxx</td><td style="text-align:center">1</td><td style="text-align:center">直接在xxxx位置保存数值，范围从0001~1101(0-12)，减1后结果为实际值</td></tr></tbody></table><p>例如，一个ZipList中包含两个整数值：“2”和“5”</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616143324590.png" alt="image-20230616143324590"></p><mark class="hl-label red">ZipList的连锁更新问题</mark> <p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据<br>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616145824215.png" alt="image-20230616145824215"></p><p>此时往头部添加一个长度大于等于254字节的entry</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986328124.png" alt="1653986328124"></p><p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p><mark class="hl-label blue">小总结</mark> <p>ZipList特性：</p><ul><li>压缩列表的可以看做一种连续内存空间的&quot;双向链表&quot;</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生连续更新问题</li></ul><hr><h3 id="QuickList">QuickList</h3><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p><p>​答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p><p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p><p>​答：我们可以创建多个ZipList来分片存储数据。</p><p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><p>​答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986474927.png" alt="1653986474927"></p><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。<br>如果值为正，则代表ZipList的允许的entry个数的最大值<br>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p><ul><li>1：每个ZipList的内存占用不能超过4kb</li><li>2：每个ZipList的内存占用不能超过8kb</li><li>3：每个ZipList的内存占用不能超过16kb</li><li>4：每个ZipList的内存占用不能超过32kb</li><li>5：每个ZipList的内存占用不能超过64kb</li></ul><p>其默认值为 -2</p><p>除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩。通过配置项list-compress-depth来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p><p>0：特殊值，代表不压缩</p><p>1：标示QuickList的首尾各有1个节点不压缩，中间节点压缩</p><p>2：标示QuickList的首尾各有2个节点不压缩，中间节点压缩</p><p>以此类推</p><p>默认值： 0</p><p>以下是QuickList的和QuickListNode的结构源码：</p><div class="tabs" id="7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52-1"><i class="fas fa-atom"></i>QuickList</button></li><li class="tab"><button type="button" data-href="#7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52-2"><i class="far fa-sun"></i>QuickListNode</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line"><span class="comment">//头节点指针</span></span><br><span class="line">quicklistNode *head;</span><br><span class="line"><span class="comment">//尾节点指针</span></span><br><span class="line">quicklistNode *tail;</span><br><span class="line"><span class="comment">//所有ziplist的entry的数量 </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line"><span class="comment">//ziplists总数量 </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"><span class="comment">//ziplist的entry上限，默认值-2 </span></span><br><span class="line"><span class="type">int</span> fill : QL_FILL_BITS；</span><br><span class="line"><span class="comment">//首尾不压缩的节点数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS;</span><br><span class="line"><span class="comment">//内存重分配时的书签数量及数组，一般用不到</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bookmark_count : QL_BM_BITS;</span><br><span class="line">quicklistBookmark bookmarksD[];</span><br><span class="line">&#125; quicklist</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">  <span class="comment">//前一个节点指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">//下一个节点指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">//当前节点的ZipList指针</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">  <span class="comment">//当前节点的ZipList的字节大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">  <span class="comment">//当前节点的ZipList的entry个数 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;</span><br><span class="line">  <span class="comment">//编码方式：1， Ziplist; 2，lzf压缩模式 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//数据容器类型（预留）：1，其它；2, ZipList</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//是否被解压缩。1：则说明被解压了，将来要重新压缩</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> attempted compress : <span class="number">1</span>;<span class="comment">//测试用</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> extra:<span class="number">10</span>;<span class="comment">/*预留字段*/</span> </span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>我们接下来用一段流程图来描述当前的这个结构</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986718554.png" alt="1653986718554"></p><mark class="hl-label blue">总结</mark> <p>QuickList的特点：</p><ul><li>是一个节点为ZipList的双端链表</li><li>节点采用ZipList，解决了传统链表的内存占用问题</li><li>控制了ZipList大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存</li></ul><hr><h3 id="SkipList">SkipList</h3><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p><p>作为一个链表，我们去访问首或尾的元素的时候，性能还是不错的，但是呢，现在要去访问队列中间的元素，比方说11，那这个时候啊你去查询的性能就比较差了，你不得不一个一个的去遍历。现在这个链表长度还比较短，只有20，那如果说现在这个列表里面达到了上千甚至数万个元素，要去访问中间元素的时候，要遍历的次数是不是可以达到数千甚至上万次。</p><p>为什么链表查询效率慢？就是因为链表它的指针跨度是一。每一个节点，它的指针永远指向的是下一个节点。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986771309.png" alt="1653986771309"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 最大的索引层级，默认是1</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele; <span class="comment">// 节点存储的值</span></span><br><span class="line">    <span class="type">double</span> score;<span class="comment">// 节点分数，排序、查找用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span; <span class="comment">// 索引跨度</span></span><br><span class="line">    &#125; level[]; <span class="comment">// 多级索引数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616095141891.png" alt="image-20230616095141891"></p><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986877620.png" alt="1653986877620"></p><mark class="hl-label blue">小总结</mark> <p>SkipList的特点：</p><ul><li>跳跃表是一个双向链表，每个节点都包含score和ele值</li><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ul><hr><h3 id="RedisObject">RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986956618.png" alt="1653986956618"></p><p>从Redis的使用者的角度来看，⼀个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，⽽value可以是多种数据类型，比如：<br>string, list, hash、set、sorted set等。我们可以看到，key的类型固定是string，而value可能的类型是多个。<br>⽽从Redis内部实现的⾓度来看，database内的这个映射关系是用⼀个dict来维护的。dict的key固定用⼀种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同⼀个dict内能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是robj，全名是redisObject。</p><p>Redis的编码方式</p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><p>Redis的编码方式</p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><table><thead><tr><th><strong>编号</strong></th><th><strong>编码方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>0</td><td>OBJ_ENCODING_RAW</td><td>raw编码动态字符串</td></tr><tr><td>1</td><td>OBJ_ENCODING_INT</td><td>long类型的整数的字符串</td></tr><tr><td>2</td><td>OBJ_ENCODING_HT</td><td>hash表（字典dict）</td></tr><tr><td>3</td><td>OBJ_ENCODING_ZIPMAP</td><td>已废弃</td></tr><tr><td>4</td><td>OBJ_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>5</td><td>OBJ_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>6</td><td>OBJ_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>7</td><td>OBJ_ENCODING_SKIPLIST</td><td>跳表</td></tr><tr><td>8</td><td>OBJ_ENCODING_EMBSTR</td><td>embstr的动态字符串</td></tr><tr><td>9</td><td>OBJ_ENCODING_QUICKLIST</td><td>快速列表</td></tr><tr><td>10</td><td>OBJ_ENCODING_STREAM</td><td>Stream流</td></tr></tbody></table><p>五种数据结构</p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>编码方式</strong></th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>int、embstr、raw</td></tr><tr><td>OBJ_LIST</td><td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td></tr><tr><td>OBJ_SET</td><td>intset、HT</td></tr><tr><td>OBJ_ZSET</td><td>ZipList、HT、SkipList</td></tr><tr><td>OBJ_HASH</td><td>ZipList、HT</td></tr></tbody></table><hr><hr><h2 id="五种数据类型">五种数据类型</h2><h3 id="String">String</h3><p>String是Redis中最常见的数据存储类型：</p><div class="tabs" id="8cde4759-907e-4ac2-862a-e7b98a34c3c1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8cde4759-907e-4ac2-862a-e7b98a34c3c1-1"><i class="fas fa-seedling"></i>RAW</button></li><li class="tab"><button type="button" data-href="#8cde4759-907e-4ac2-862a-e7b98a34c3c1-2"><i class="fas fa-leaf"></i>EMBSTR</button></li><li class="tab"><button type="button" data-href="#8cde4759-907e-4ac2-862a-e7b98a34c3c1-3"><i class="fab fa-apple"></i>INT</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8cde4759-907e-4ac2-862a-e7b98a34c3c1-1"><p>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512mb。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653987103450.png" alt="1653987103450"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8cde4759-907e-4ac2-862a-e7b98a34c3c1-2"><p>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时RedisObject与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616153706417.png" alt="image-20230616153706417"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8cde4759-907e-4ac2-862a-e7b98a34c3c1-3"><p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616154241077.png" alt="image-20230616154241077"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label blue">测试</mark> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name jack</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen name</span><br><span class="line">(<span class="built_in">integer</span>) 44</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen name</span><br><span class="line">(<span class="built_in">integer</span>) 45</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line"><span class="string">&quot;raw&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding age</span><br><span class="line"><span class="string">&quot;int&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="List">List</h3><p>Redis的List类型可以从首、尾操作列表中的元素</p><p>哪一个数据结构能满足上述特征？</p><ul><li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li><li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li><li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li></ul><p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p><p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p><p>在3.2版本之后，Redis统一采用QuickList来实现List。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653987313461.png" alt="1653987313461"></p><hr><h3 id="Set">Set</h3><p>Set是Redis中的单列集合，满足下列特点：</p><ul><li>不保证有序性</li><li>保证元素唯一</li><li>求交集、并集、差集</li></ul><p>可以看出，Set对查询元素的效率要求非常高，思考一下，什么样的数据结构可以满足？</p><p>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null</p><p>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616160631352.png" alt="image-20230616160631352"></p><p>注意：当插入的数据不是整数，IntSet就会转换成Dict。</p><hr><h3 id="ZSET">ZSET</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p><ul><li>可以根据score值排序后</li><li>member必须唯一</li><li>可以根据member查询分数</li></ul><p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。之前学习的哪种编码结构可以满足？</p><ul><li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li><li>HT（Dict）：可以键值存储，并且可以根据key找value</li></ul><div class="tabs" id="87d68fcd-a4ee-4ec3-8596-98d5831447c8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#87d68fcd-a4ee-4ec3-8596-98d5831447c8-1"><i class="fas fa-seedling"></i>Zset结构</button></li><li class="tab"><button type="button" data-href="#87d68fcd-a4ee-4ec3-8596-98d5831447c8-2"><i class="fas fa-leaf"></i>createZsetObject</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="87d68fcd-a4ee-4ec3-8596-98d5831447c8-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">// Dict指针</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// SkipList指针</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="87d68fcd-a4ee-4ec3-8596-98d5831447c8-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">createZsetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 创建Dict</span></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建SkipList</span></span><br><span class="line">    zs-&gt;zsl = zslCreate(); </span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653992172526.png" alt="1653992172526"></p><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p><ul><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zadd添加元素时，先根据key找到zset，不存在则创建新的zset</span></span><br><span class="line">zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line"><span class="keyword">if</span> (checkType(c,zobj,OBJ_ZSET)) <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123; <span class="comment">// zset不存在</span></span><br><span class="line">    <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">        server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">    &#123; <span class="comment">// zset_max_ziplist_entries设置为0就是禁用了ZipList，</span></span><br><span class="line">        <span class="comment">// 或者value大小超过了zset_max_ziplist_value，采用HT + SkipList</span></span><br><span class="line">        zobj = createZsetObject();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，采用 ZipList</span></span><br><span class="line">        zobj = createZsetZiplistObject();</span><br><span class="line">    &#125;</span><br><span class="line">    dbAdd(c-&gt;db,key,zobj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616165412835.png" alt="image-20230616165412835"></p><hr><h3 id="Hash">Hash</h3><p>Hash结构与Redis中的Zset非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>区别如下：</p><ul><li>zset的键是member，值是score；hash的键和值都是任意值</li><li>zset要根据score排序；hash则无需排序</li></ul><p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可。</p><p>Hash结构默认采用ZipList编码，用以节省内存。</p><p>ZipList中相邻的两个entry 分别保存field和value当数据量较大时，Hash结构会转为HT编码，也就是Dict，</p><p>触发条件有两个：</p><p>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</p><p>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616170044461.png" alt="image-20230616170044461"></p><p>转换</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616170222695.png" alt="image-20230616170222695"></p><p>总之，ziplist本来就设计为各个数据项挨在⼀起组成连续的内存空间，这种结构并不擅长做修改操作。⼀旦数据发⽣改动，就会引发内存realloc，可能导致内存拷贝。</p><hr><hr><h2 id="网络模型">网络模型</h2><h3 id="用户空间和内核态空间">用户空间和内核态空间</h3><p>服务器大多都采用Linux系统，这里我们以Linux为例来讲解:</p><p>ubuntu和Centos 都是Linux的发行版，发行版可以看成对linux包了一层壳，任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互。</p><p>计算机硬件包括，如cpu，内存，网卡等等，内核（通过寻址空间）可以操作硬件的，但是内核需要不同设备的驱动，有了这些驱动之后，内核就可以去对计算机硬件去进行 内存管理，文件系统的管理，进程的管理等等。</p><p>我们想要用户的应用来访问，计算机就必须要通过对外暴露的一些接口，才能访问到，从而简介的实现对内核的操控，但是内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加任何限制，用户去操作随意的去操作我们的资源，就有可能导致一些冲突，甚至有可能导致我们的系统出现无法运行的问题，因此我们需要把用户和<strong>内核隔离开</strong>。</p><p>进程的寻址空间会划分为两部分：内核空间、用户空间</p><p>用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问</p><p>内核空间可以执行特权命令（Ring0），调用一切系统资源</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616171453302.png" alt="image-20230616171453302" style="zoom:67%;" /><p>在linux中，他们权限分成两个等级，0和3，用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问内核空间可以执行特权命令（Ring0），调用一切系统资源，所以一般情况下，用户的操作是运行在用户空间，而内核运行的数据是在内核空间的，而有的情况下，一个应用程序需要去调用一些特权资源，去调用一些内核空间的操作，所以此时他俩需要在用户态和内核态之间进行切换。</p><p>比如：</p><p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p><p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p><p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p><p>针对这个操作：我们的用户在写读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的buffer中，然后再返回给应用程序，整体而言，速度慢，就是这个原因，为了加速，我们希望read也好，还是wait for data也最好都不要等待，或者时间尽量的短。</p><hr><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><hr><h3 id="阻塞IO">阻塞IO</h3><p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待。</p><p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653897115346.png" alt="1653897115346"></p><mark class="hl-label blue">具体流程如下</mark> <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616172336294.png" alt="image-20230616172336294"></p><hr><h3 id="非阻塞IO">非阻塞IO</h3><p>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p><p>阶段一：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户进程</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，直到数据就绪</li></ul><p>阶段二：</p><ul><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li><li>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653897490116.png" alt="1653897490116"></p><hr><h3 id="IO多路复用">IO多路复用</h3><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p><ul><li>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。</li><li>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</li></ul><p>比如服务端处理客户端Socket请求时，在单线程情况下，只能依次处理每一个socket，如果正在处理的socket恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有其它客户端socket都必须等待，性能自然会很差。</p><p>所以怎么看起来以上两种方式性能都不好</p><p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p><p>就比如服务员给顾客点餐，分两步：</p><ul><li>顾客思考要吃什么（等待数据就绪）</li><li>顾客想好了，开始点餐（读取数据）</li></ul><p>要提高效率有几种办法？</p><p>方案一：增加更多服务员（多线程）<br>方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）</p><blockquote><p>那么问题来了：用户进程如何知道内核中数据是否就绪呢？</p></blockquote><ul><li>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</li><li>IO多路复用：是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</li></ul><p>阶段一：</p><ul><li>用户进程调用select，指定要监听的FD集合</li><li>内核监听FD对应的多个socket</li><li>任意一个或多个socket数据就绪则返回readable</li><li>此过程中用户进程阻塞</li></ul><p>阶段二：</p><ul><li>用户进程找到就绪的socket</li><li>依次调用recvfrom读取数据</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><p>当用户去读取数据的时候，不再去直接调用recvfrom了，而是调用select的函数，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</p><p>用IO复用模式，可以确保去读数据的时候，数据是一定存在的，他的效率比原来的阻塞IO和非阻塞IO性能都要高</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653898691736.png" alt="1653898691736" style="zoom:67%;" /><p>IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><p>其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p><p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，咱们就省去了遍历的动作。</p><hr><h4 id="select">select</h4><p>select是Linux最早是由的I/O多路复用技术：</p><p>简单说，就是我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的 ），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据，</p><p>比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再将处理掉没有准备好的数据，最后再将这个FD集合写回到用户态中去，此时用户态就知道了，奥，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求，我们会发现，这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情， 比如说频繁的传递fd集合，频繁的去遍历FD等问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类型别名 __fd_mask，本质是 long int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> __fd_mask;</span><br><span class="line"><span class="comment">/* fd_set 记录要监听的fd集合，及其对应状态 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// fds_bits是long类型数组，长度为 1024/32 = 32</span></span><br><span class="line">    <span class="comment">// 共1024个bit位，每个bit位代表一个fd，0代表未就绪，1代表就绪</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line"><span class="comment">// select函数，用于监听fd_set，也就是多个fd的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> nfds, <span class="comment">// 要监视的fd_set的最大fd + 1</span></span></span><br><span class="line"><span class="params">    fd_set *readfds, <span class="comment">// 要监听读事件的fd集合</span></span></span><br><span class="line"><span class="params">    fd_set *writefds,<span class="comment">// 要监听写事件的fd集合</span></span></span><br><span class="line"><span class="params">    fd_set *exceptfds, <span class="comment">// // 要监听异常事件的fd集合</span></span></span><br><span class="line"><span class="params">    <span class="comment">// 超时时间，null-用不超时；0-不阻塞等待；大于0-固定等待时间</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> timeval *timeout</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><div class="tabs" id="5e189b93-ed02-4460-b2cd-18f701c01df2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-1"><i class="fas fa-atom"></i>创建fd_set</button></li><li class="tab"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-2"><i class="far fa-sun"></i>执行select</button></li><li class="tab"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-3"><i class="fas fa-wind"></i>遍历fd_set</button></li><li class="tab"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-4"><i class="fas fa-fire-alt"></i>数据就绪</button></li><li class="tab"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-5"><i class="fas fa-cookie-bite"></i>遍历fd_set</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5e189b93-ed02-4460-b2cd-18f701c01df2-1"><p>假如要监听 fd= 1, 2, 5</p><p>每个bit位代表一个fd</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616204442788.png" alt="image-20230616204442788" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5e189b93-ed02-4460-b2cd-18f701c01df2-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616204552207.png" alt="image-20230616204552207" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5e189b93-ed02-4460-b2cd-18f701c01df2-3"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616204629505.png" alt="image-20230616204629505" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5e189b93-ed02-4460-b2cd-18f701c01df2-4"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616205131015.png" alt="image-20230616205131015" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5e189b93-ed02-4460-b2cd-18f701c01df2-5"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616205352100.png" alt="image-20230616205352100" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>select模式存在的问题：</p><p>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</p><p>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</p><p>fd_set监听的fd数量不能超过1024</p><hr><h4 id="poll">poll</h4><p>poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p><p>IO流程：</p><ul><li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li><li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历fd，判断是否就绪</li><li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li><li>用户进程判断n是否大于0</li><li>大于0则遍历pollfd数组，找到就绪的fd</li></ul><p><strong>与select对比：</strong></p><ul><li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li><li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pollfd 中的事件类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN     <span class="comment">//可读事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT    <span class="comment">//可写事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR    <span class="comment">//错误事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL   <span class="comment">//fd未打开</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;       <span class="comment">/* 要监听的fd  */</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> events; <span class="comment">/* 要监听的事件类型：读、写、异常 */</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> revents;<span class="comment">/* 实际发生的事件类型 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// poll函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> pollfd *fds, <span class="comment">// pollfd数组，可以自定义大小</span></span></span><br><span class="line"><span class="params">    <span class="type">nfds_t</span> nfds, <span class="comment">// 数组元素个数</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout <span class="comment">// 超时时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="epoll">epoll</h4><p>epoll模式是对select和poll的改进，它提供了三个函数：</p><p>第一个是：eventpoll的函数，他内部包含两个东西</p><p>一个是：</p><p>1、红黑树-&gt; 记录的事要监听的FD</p><p>2、一个是链表-&gt;一个链表，记录的是就绪的FD</p><p>紧接着调用epoll_ctl操作，将要监听的数据添加到红黑树上去，并且给每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，就是准备好了，现在就把fd把数据添加到list_head中去</p><p>3、调用epoll_wait函数</p><p>就去等待，在用户态创建一个空的events数组，当就绪之后，我们的回调函数会把数据添加到list_head中去，当调用这个函数的时候，会去检查list_head，当然这个过程需要参考配置的等待时间，可以等一定时间，也可以一直等， 如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的操作的数量，用户态的此时收到响应后，从events中拿到对应准备好的数据的节点，再去调用方法去拿数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span> <span class="comment">// 一颗红黑树，记录要监听的FD</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span><span class="comment">// 一个链表，记录就绪的FD</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1.创建一个epoll实例,内部是event poll，返回对应的句柄epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 2.将一个FD添加到epoll的红黑树中，并设置ep_poll_callback</span></span><br><span class="line"><span class="comment">// callback触发时，就把对应的FD加入到rdlist这个就绪列表中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd,  <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> op,    <span class="comment">// 要执行的操作，包括：ADD、MOD、DEL</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd,    <span class="comment">// 要监听的FD</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *event <span class="comment">// 要监听的事件类型：读、写、异常等</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">// 3.检查rdlist列表是否为空，不为空则返回就绪的FD的数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd,                   <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events, <span class="comment">// 空event数组，用于接收就绪的FD</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents,              <span class="comment">// events数组的最大长度</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout   <span class="comment">// 超时时间，-1用不超时；0不阻塞；大于0为阻塞时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><div class="tabs" id="ab16328b-43e8-47b1-a206-d6732070d977"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ab16328b-43e8-47b1-a206-d6732070d977-1"><i class="fas fa-cat"></i>epoll_create</button></li><li class="tab"><button type="button" data-href="#ab16328b-43e8-47b1-a206-d6732070d977-2"><i class="fas fa-horse"></i>添加要监听的FD，关联callback</button></li><li class="tab"><button type="button" data-href="#ab16328b-43e8-47b1-a206-d6732070d977-3"><i class="fas fa-dove"></i>FD就绪</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ab16328b-43e8-47b1-a206-d6732070d977-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617104551607.png" alt="image-20230617104551607" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab16328b-43e8-47b1-a206-d6732070d977-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617104842869.png" alt="image-20230617104842869" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab16328b-43e8-47b1-a206-d6732070d977-3"><p>就绪触发回调函数添加至就绪链表，拷贝到用户空间</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617105134155.png" alt="image-20230617105134155" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="小总结">小总结</h4><p>select模式存在的三个问题：</p><ul><li>能监听的FD最大不超过1024</li><li>每次select都需要把所有要监听的FD都拷贝到内核空间</li><li>每次都要遍历所有FD来判断就绪状态</li></ul><p>poll模式的问题：</p><ul><li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li></ul><p>epoll模式中如何解决这些问题的？</p><ul><li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li><li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li><li>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下</li></ul><hr><h4 id="事件通知机制">事件通知机制</h4><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li><li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li></ul><p>举个栗子：</p><ul><li>假设一个客户端socket对应的FD已经注册到了epoll实例中</li><li>客户端socket发送了2kb的数据</li><li>服务端调用epoll_wait，得到通知说FD就绪</li><li>服务端从FD读取了1kb数据回到步骤3（再次调用epoll_wait，形成循环）</li></ul><p>结论</p><p>如果我们采用LT模式，因为FD中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知<br>如果我们采用ET模式，因为第③步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时。</p><hr><h4 id="基于epoll的服务器端流程">基于epoll的服务器端流程</h4><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617111058655.png" alt="image-20230617111058655"></p><hr><h3 id="信号驱动IO">信号驱动IO</h3><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>阶段一：</p><ul><li>用户进程调用sigaction，注册信号处理函数</li><li>内核返回成功，开始监听FD</li><li>用户进程不阻塞等待，可以执行其它业务</li><li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li></ul><p>阶段二：</p><ul><li>收到SIGIO回调信号</li><li>调用recvfrom，读取</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653911776583.png" alt="1653911776583"></p><hr><h3 id="异步IO">异步IO</h3><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p><p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653911877542.png" alt="1653911877542"></p><blockquote><p>对比</p></blockquote><p>IO操作是同步还是异步，关键看数据在内核空间与用户空间的拷贝过程（数据读写的IO操作），也就是阶段二是同步还是异步：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653912219712.png" alt="1653912219712"></p><hr><h3 id="Redis网络模型">Redis网络模型</h3><mark class="hl-label blue">Redis到底是单线程还是多线程？</mark> <ul><li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li><li>如果是聊整个Redis，那么答案就是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink</li><li>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</li></ul><p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。</p><mark class="hl-label green">为什么Redis要选择单线程？</mark> <ul><li>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616174058705.png" alt="image-20230616174058705" style="zoom:67%;" /><p>当我们的客户端想要去连接我们服务器，会去先到IO多路复用模型去进行排队，会有一个连接应答处理器，他会去接受读请求，然后又把读请求注册到具体模型中去，此时这些建立起来的连接，如果是客户端请求处理器去进行执行命令时，他会去把数据读取出来，然后把数据放入到client中， clinet去解析当前的命令转化为redis认识的命令，接下来就开始处理这些命令，从redis中的command中找到这些命令，然后就真正的去操作对应的数据了，当数据操作完成后，会去找到命令回复处理器，再由他将数据写出。</p><hr><hr><h2 id="Redis通讯协议-RESP协议">Redis通讯协议-RESP协议</h2><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p><p>客户端（client）向服务端（server）发送一条命令</p><p>服务端解析并执行命令，返回响应结果给客户端</p><p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p><p>而在Redis中采用的是RESP（Redis Serialization Protocol）协议：</p><p>Redis 1.2版本引入了RESP协议</p><p>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</p><p>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</p><p>但目前，默认使用的依然是RESP2协议，也是我们要学习的协议版本（以下简称RESP）。</p><p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p><p>单行字符串：首字节是 ‘+’ ，后面跟上单行字符串，以CRLF（ “\r\n” ）结尾。例如返回&quot;OK&quot;： “+OK\r\n”</p><p>错误（Errors）：首字节是 ‘-’ ，与单行字符串格式一样，只是字符串是异常信息，例如：“-Error message\r\n”</p><p>数值：首字节是 ‘:’ ，后面跟上数字格式的字符串，以CRLF结尾。例如：“:10\r\n”</p><p>多行字符串：首字节是 ‘$’ ，表示二进制安全的字符串，最大支持512MB：</p><p>如果大小为0，则代表空字符串：“$0\r\n\r\n”</p><p>如果大小为-1，则代表不存在：“$-1\r\n”</p><p>数组：首字节是 ‘*’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653982993020.png" alt="1653982993020"></p><hr><h3 id="基于Socket自定义Redis的客户端">基于Socket自定义Redis的客户端</h3><p>Redis支持TCP通信，因此我们可以使用Socket来模拟客户端，与Redis服务端建立连接：</p><div class="tabs" id="37dd8520-68a9-4405-a84e-462cf9cac3c4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#37dd8520-68a9-4405-a84e-462cf9cac3c4-1"><i class="fas fa-bug"></i>main</button></li><li class="tab"><button type="button" data-href="#37dd8520-68a9-4405-a84e-462cf9cac3c4-2"><i class="fas fa-cannabis"></i>handleResponse</button></li><li class="tab"><button type="button" data-href="#37dd8520-68a9-4405-a84e-462cf9cac3c4-3"><i class="fas fa-candy-cane"></i>readBulkString</button></li><li class="tab"><button type="button" data-href="#37dd8520-68a9-4405-a84e-462cf9cac3c4-4"><i class="fas fa-child"></i>sendRequest</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="37dd8520-68a9-4405-a84e-462cf9cac3c4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Socket s;</span><br><span class="line">    <span class="keyword">static</span> PrintWriter writer;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.建立连接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;192.168.150.101&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">            <span class="comment">// 2.获取输出流、输入流</span></span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream(), StandardCharsets.UTF_8));</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.发出请求</span></span><br><span class="line">            <span class="comment">// 3.1.获取授权 auth 123321</span></span><br><span class="line">            sendRequest(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;num&quot;</span>, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5.释放连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="literal">null</span>) reader.close();</span><br><span class="line">                <span class="keyword">if</span> (writer != <span class="literal">null</span>) writer.close();</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="literal">null</span>) s.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37dd8520-68a9-4405-a84e-462cf9cac3c4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">handleResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 读取首字节</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefix</span> <span class="operator">=</span> reader.read();</span><br><span class="line">    <span class="comment">// 判断数据类型标示</span></span><br><span class="line">    <span class="keyword">switch</span> (prefix) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// 单行字符串，直接读一行</span></span><br><span class="line">            <span class="keyword">return</span> reader.readLine();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">// 异常，也读一行</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(reader.readLine());</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>: <span class="comment">// 数字</span></span><br><span class="line">            <span class="keyword">return</span> Long.parseLong(reader.readLine());</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: <span class="comment">// 多行字符串</span></span><br><span class="line">            <span class="comment">// 先读长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再读数据,读len个字节。我们假设没有特殊字符，所以读一行（简化）</span></span><br><span class="line">            <span class="keyword">return</span> reader.readLine();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> readBulkString();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;错误的数据格式！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37dd8520-68a9-4405-a84e-462cf9cac3c4-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">readBulkString</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取数组大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义集合，接收多个元素</span></span><br><span class="line">    List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(len);</span><br><span class="line">    <span class="comment">// 遍历，依次读取每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        list.add(handleResponse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37dd8520-68a9-4405-a84e-462cf9cac3c4-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set name 虎哥</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">    writer.println(<span class="string">&quot;*&quot;</span> + args.length);</span><br><span class="line">    <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">        writer.println(<span class="string">&quot;$&quot;</span> + arg.getBytes(StandardCharsets.UTF_8).length);</span><br><span class="line">        writer.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    writer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="Redis内存回收">Redis内存回收</h2><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。<br>我们可以通过修改配置文件来设置Redis的最大内存：<code>maxmemory 1gb</code></p><p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：</p><ul><li>内存过期策略</li><li>内存淘汰策略</li></ul><hr><h3 id="过期key处理">过期key处理</h3><p>在学习Redis缓存的时候我们说过，可以通过expire命令给Redis的key设置TTL（存活时间)</p><p>当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</p><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p><p>Redis有16个数据库，每个数据库就是一个redisDb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 存放所有key及value的地方，也被称为keyspace*/</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key*/</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="type">int</span> id;                     <span class="comment">/* Database ID，0~15 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;          <span class="comment">/* 记录平均TTL时长 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires_cursor; <span class="comment">/* expire检查时在dict中抽样的索引位置. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* 等待碎片整理的key列表. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653983606531.png" alt="1653983606531"></p><p>这里有两个问题需要我们思考：</p><blockquote><p>Redis是如何知道一个key是否过期呢？</p></blockquote><p>利用两个Dict分别记录key-value对及key-ttl对</p><blockquote><p>是不是TTL到期就立即删除了呢？</p></blockquote><div class="tabs" id="196f3c83-22e3-4425-bd7b-2acf7e57e000"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#196f3c83-22e3-4425-bd7b-2acf7e57e000-1"><i class="fas fa-cat"></i>惰性删除</button></li><li class="tab"><button type="button" data-href="#196f3c83-22e3-4425-bd7b-2acf7e57e000-2"><i class="fas fa-horse"></i>周期删除</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="196f3c83-22e3-4425-bd7b-2acf7e57e000-1"><p>惰性删除：顾明思议并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617162012568.png" alt="image-20230617162012568"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="196f3c83-22e3-4425-bd7b-2acf7e57e000-2"><p>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。</p><p>执行周期有两种：</p><ul><li><p>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW</p></li><li><p>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</p></li></ul><p>SLOW模式规则：</p><p>①执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</p><p>②执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</p><p>③逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</p><p>④如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</p><p>FAST模式规则（过期key比例小于10%不执行 ）：</p><p>①执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</p><p>②执行清理耗时不超过1ms</p><p>③逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</p><p>④如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束④</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label blue">小总结</mark> <p>RedisKey的TTL记录方式：</p><p>在RedisDB中通过一个Dict记录每个Key的TTL时间</p><p>过期key的删除策略：</p><ul><li>惰性清理：每次查找key时判断是否过期，如果过期则删除</li><li>定期清理：定期抽样部分key，判断是否过期，如果过期则删除</li></ul><p>定期清理的两种模式：</p><ul><li>SLOW模式执行频率默认为10，每次不超过25ms</li><li>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li></ul><hr><h3 id="内存淘汰策略">内存淘汰策略</h3><p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果服务器设置了server.maxmemory属性，并且并未有执行lua脚本</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="comment">// 尝试进行内存淘汰performEvictions</span></span><br><span class="line">        <span class="type">int</span> out_of_memory = (performEvictions() == EVICT_FAIL);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label blue">淘汰策略</mark> <p>Redis支持8种不同策略来选择要删除的key：</p><ul><li><p>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p></li><li><p>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</p></li><li><p>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</p></li><li><p>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</p></li><li><p>allkeys-lru： 对全体key，基于LRU算法进行淘汰</p></li><li><p>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</p></li><li><p>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</p></li><li><p>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰</p><p>比较容易混淆的有两个：</p><ul><li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li><li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li></ul></li></ul><p>Redis的数据都会被封装为RedisObject结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;        <span class="comment">// 对象类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS;  <span class="comment">// LRU：以秒为单位记录最近一次访问时间，长度24bit LFU：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</span></span><br><span class="line">    <span class="type">int</span> refcount;           <span class="comment">// 引用计数，计数为0则可以回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;              <span class="comment">// 数据指针，指向真实数据</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p><ul><li>生成0~1之间的随机数R</li><li>计算 (旧次数 * lfu_log_factor + 1)，记录为P</li><li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</li></ul><p>最后用一副图来描述当前的这个流程吧</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984085095.png" alt="1653984085095"></p>]]></content>
    
    
    <summary type="html">数据结构、网络模型、RESP协议</summary>
    
    
    
    <category term="数据库" scheme="https://wuwawawa.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Redis" scheme="https://wuwawawa.github.io/tags/Redis/"/>
    
    <category term="数据库" scheme="https://wuwawawa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
