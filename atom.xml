<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LuckyBoy🥝</title>
  
  
  <link href="https://wuwawawa.github.io/atom.xml" rel="self"/>
  
  <link href="https://wuwawawa.github.io/"/>
  <updated>2024-01-23T12:52:28.681Z</updated>
  <id>https://wuwawawa.github.io/</id>
  
  <author>
    <name>LuckyBoy🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot面试题</title>
    <link href="https://wuwawawa.github.io/posts/f306c360.html"/>
    <id>https://wuwawawa.github.io/posts/f306c360.html</id>
    <published>2024-01-23T02:50:38.000Z</published>
    <updated>2024-01-23T12:52:28.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jarlauncher的作用">Jarlauncher的作用</h2><p>在开发环境中通过运行idea中的run方式即可运行SpringBoot应用，也是在开发过程中最常见的一种方式。这种方式启动使用的类加载器为<code>AppClassLoader</code>，所有依赖的jar包都通过<code>-classpath</code>添加至启动参数。</p><p>在生产环境，将Maven插件将项目打成jar包后，可以通过运行命令函参数<code>java -jar</code>的方式运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes -- 应用程序</span><br><span class="line">│   └── lib --项目运行依赖的jar包</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF --清单文件</span><br><span class="line">│   └── maven</span><br><span class="line">└── org</span><br><span class="line">    └── springframework</span><br><span class="line">        └── boot</span><br><span class="line">            └── loader -- 通过打包插件打入</span><br></pre></td></tr></table></figure><p>在清单文件中<code>MANIFEST.MF</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version</span>: <span class="string">1.0</span></span><br><span class="line"><span class="attr">Created-By</span>: <span class="string">Maven JAR Plugin 3.2.2</span></span><br><span class="line"><span class="attr">Build-Jdk-Spec</span>: <span class="string">17</span></span><br><span class="line"><span class="attr">Main-Class</span>: <span class="string">org.springframework.boot.loader.JarLauncher </span></span><br><span class="line"><span class="attr">Start-Class</span>: <span class="string">com.whut.PortApplication </span></span><br><span class="line"><span class="attr">Spring-Boot-Version</span>: <span class="string">3.0.7</span></span><br><span class="line"><span class="attr">Spring-Boot-Classes</span>: <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="attr">Spring-Boot-Lib</span>: <span class="string">BOOT-INF/lib/</span></span><br><span class="line"><span class="attr">Spring-Boot-Classpath-Index</span>: <span class="string">BOOT-INF/classpath.idx</span></span><br><span class="line"><span class="attr">Spring-Boot-Layers-Index</span>: <span class="string">BOOT-INF/layers.idx</span></span><br></pre></td></tr></table></figure><ul><li><code>Main-Class</code>是<code>org.springframework.boot.loader.JarLauncher</code>，即jar启动的Main函数；</li><li><code>Start-Class</code>是<code>com.whut.PortApplication</code> ，即我们自己SpringBoot项目的启动类；</li></ul><p>因为org.springframework.boot.loader.JarLauncher类存在于org.springframework.boot:spring-boot-loader中，所以看源码之前需要先引入maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-loader<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="tabs" id="91a018db-47a9-47db-82d9-fbd971ee6736"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#91a018db-47a9-47db-82d9-fbd971ee6736-1"><i class="fas fa-seedling"></i>JarLauncher源码</button></li><li class="tab"><button type="button" data-href="#91a018db-47a9-47db-82d9-fbd971ee6736-2"><i class="fas fa-leaf"></i>Launcher#launch(args)方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="91a018db-47a9-47db-82d9-fbd971ee6736-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JarLauncher</span> <span class="keyword">extends</span> <span class="title class_">ExecutableArchiveLauncher</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EntryFilter</span> <span class="variable">NESTED_ARCHIVE_ENTRY_FILTER</span> <span class="operator">=</span> (entry) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line"><span class="keyword">return</span> entry.getName().equals(<span class="string">&quot;BOOT-INF/classes/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> entry.getName().startsWith(<span class="string">&quot;BOOT-INF/lib/&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JarLauncher</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">JarLauncher</span><span class="params">(Archive archive)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(archive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isPostProcessingClassPathArchives</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> NESTED_ARCHIVE_ENTRY_FILTER.matches(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">getArchiveEntryPathPrefix</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;BOOT-INF/&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">JarLauncher</span>().launch(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JarLauncher#main()</code>中新建了<code>JarLauncher</code>并调用父类Launcher中的<code>launch()</code>方法启动程序；<br><code>isNestedArchive(Archinve.Entry entry)</code>方法用于判断FAT JAR资源的相对路径是否为<code>nestedArchive</code>嵌套文档。进而决定这些FAT JAR是否会被launch。当方法返回false时，说明FAT JAR被解压至文件目录</p><blockquote><p>Archive的概念</p></blockquote><p>archive即归档文件，这个概念在linux下比较常见；通常就是一个tar/zip格式的压缩包；而jar正是zip格式的。</p><p>SpringBoot抽象了Archive的概念，一个Archive可以是jar（JarFileArchive），也可以是文件目录（ExplodedArchive）；这样也就统一了访问资源的逻辑层；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Archive</span> <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;Archive.Entry&gt;, AutoCloseable &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Archive</code>继承自<code>Archive.Entry</code>，<code>Archive.Entry</code>有两种实现：</p><ul><li><code>JarFileArchive.JarFileEntry</code> --&gt; 基于<code>java.util.jar.JarEntry</code>实现，表示FAT JAR嵌入资源。</li><li><code>ExplodedArchive.FileEntry</code> --&gt; 基于文件系统实现；</li></ul><p>两者的主要差别是<code>ExplodedArchive</code>相比于JarFileArchive多了一个获取文件的getFile()方法；</p><p>也就是说一个在jar包环境下寻找资源，一个在文件夹目录下寻找资源</p><p><strong>当执行java -jar命令时，将调用/META-INF /MANIFEST.MF文件的Main-Class属性的main()方法，实际上调用的是JarLauncher#launch(args)方法；</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="91a018db-47a9-47db-82d9-fbd971ee6736-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isExploded()) &#123;</span><br><span class="line">        <span class="comment">// phase1：注册jar URL处理器</span></span><br><span class="line">        JarFile.registerUrlProtocolHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// phase2：创建ClassLoader</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> createClassLoader(getClassPathArchivesIterator());</span><br><span class="line">    <span class="type">String</span> <span class="variable">jarMode</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;jarmode&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">launchClass</span> <span class="operator">=</span> (jarMode != <span class="literal">null</span> &amp;&amp; !jarMode.isEmpty()) ? JAR_MODE_LAUNCHER : getMainClass();</span><br><span class="line">    <span class="comment">// phase3：反射调用实际的引导类launch</span></span><br><span class="line">    launch(args, launchClass, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，JDK提供的ClassLoader只能识别jar中的class文件以及加载classpath下的其他jar包中的class文件，对于jar in jar的包无法加载；<br>当SpringBoot FAT JAR被<code>java -jar</code>命令引导时，其内部的JAR文件无法被内嵌实现当做classPath，故需要定义了一套URLStreamHandler实现类和JarURLConnection实现类，用来加载jar in jar包的class类文件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>总结</p></blockquote><p>Spring Boot应用打包之后，生成一个<code>Fat jar</code>，包含了应用依赖的所有三方jar包和SpringBoot Loader相关的类。</p><p>Fat jar的启动Main函数是<code>JarLauncher</code>，它负责创建一个<code>LaunchedURLClassLoader</code>来加载<code>BOOT-INF/classes</code>目录以及<code>/BOOT-INF/lib下面的jar</code>，并利用反射获取<code>mainClass</code>类中的<code>main(Stirng[])</code>方法并调用。</p><p>即：运行JarLauncher实际上是在同进程、同线程内调用Start-Class类的main(Stirng[])方法，并且在调用前准备好ClassPath。</p><hr>]]></content>
    
    
    <summary type="html">SpringBoot面试题</summary>
    
    
    
    <category term="SpringBoot" scheme="https://wuwawawa.github.io/categories/SpringBoot/"/>
    
    
    <category term="面试题" scheme="https://wuwawawa.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java日志体系</title>
    <link href="https://wuwawawa.github.io/posts/b41723d6.html"/>
    <id>https://wuwawawa.github.io/posts/b41723d6.html</id>
    <published>2023-12-25T05:55:36.000Z</published>
    <updated>2023-12-29T01:37:02.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志框架类别">日志框架类别</h2><h3 id="记录型日志框架">记录型日志框架</h3><ol><li><code>Jul (Java Util Logging)</code>：JDK中的日志记录工具，也常称为JDKLog、jdk-logging，自Java1.4以来的官方日志实现。</li><li><code>Log4j</code>：Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一。</li><li><code>Log4j</code>：一个具体的日志实现框架，是Log4j 1的下一个版本，与Log4j 1发生了很大的变化，Log4j 2不兼容Log4j 1。</li><li><code>Logback</code>：一个具体的日志实现框架，和Slf4j是同一个作者，但其性能更好(<span class='p green'>推荐使用</span>) 。</li></ol><hr><h3 id="门面型日志框架">门面型日志框架</h3><ol><li><code>JCL</code>：Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging</li><li><code>SLF4J</code>：是一套简易Java日志门面，<span class='p green'>本身并无日志的实现</span>。（Simple Logging Facade for Java，缩写Slf4j）</li></ol><hr><h2 id="Java日志框架发展史">Java日志框架发展史</h2><div class="tabs" id="429b6ca4-4b72-4496-bb40-135bd75ba457"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-1"><i class="fas fa-bug"></i>1</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-2"><i class="fas fa-cannabis"></i>2</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-3"><i class="fas fa-candy-cane"></i>3</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-4"><i class="fas fa-child"></i>4</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-5"><i class="fas fa-award"></i>5</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-6"><i class="fas fa-baseball-ball"></i>6</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-7"><i class="fas fa-anchor"></i>7</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-8"><i class="fas fa-bone"></i>8</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="429b6ca4-4b72-4496-bb40-135bd75ba457-1"><p>2001年以前，Java是没有日志库的，打印日志全凭<code>System.out</code>和<code>System.err</code></p><p>缺点:</p><ol><li>产生大量的IO操作同时在生产环境中无法合理的控制是否需要输出</li><li>输出的内容不能保存到文件</li><li>只打印在控制台，打印完就过去了，也就是说除非你一直盯着程序跑</li><li>无法定制化，且日志粒度不够细</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-2"><p>2001年，一个<strong>ceki Gulcü</strong>的大佬搞了一个日志框架 log4j后来( log4j成为Apache项目，Ceki加入Apache组织 Apache还曾经建议Sun引入Log4j到Java的标准库中，但Sun拒绝了.</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/3bd956b4a3e905be00f003e0f3600fb4.png" alt="image-20211212211243016"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-3"><p>Sun有自己的小心思，2002年2月JDK1.4发布，Sun推出了自己的日志标准库JUL(Java Util Logging)，其实是照着Log4j抄的，而且还没抄好，还是在JDK1.5以后性能和可用性才有所提升。由于Log4j比JUL好用，并且成熟，所以Log4j在选择上占据了一定的优势。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-4"><p>2002年8月Apache推出了JCL(Jakarta Commons Logging)，也就是日志抽象层，支持运行时动态加载日志组件的实现，当然也提供一个默认实现Simple Log( ClassLoader 中进行查找，如果能找到Log4j则默认使用log4j实现，如果没有则使用JUL实现，再没有则使用JCL内部提供的 Simple Log实现)。</p><p>但是JUL有三个缺点:</p><p>1．效率较低。</p><p>2．容易引发混乱。</p><p>3．使用了自定义ClassLoader的程序中，使用JCL会引发内存泄露。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/bVbAMyv.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-5"><p>2006年巨佬Ceki( Log4j的作者）因为一些原因离开了Apache组织，之后Ceki觉得JCL不好用，自己搀了一套新的日志标准接口规范Slf4j (Simple Logging Facacfor Java)，也可以称为日志门面，很明显Slf4j是对标JCL，后面也证明了Slf4j比JCL更优秀。 巨佬Ceki提供了一系列的桥接包来帮助Slf4j接口与其他日志库建立关系，这种方式称桥接设计模式。 代码使用Slf4j接口，就可以实现日志的统一标准化，后续如果想要更换日志实现，只需引入Slf4j与相关的桥接包，再引入具体的日志标准库即可。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-6"><p>但是由于<code>Slf4j</code>出来的较晚，而且还只是一个日志接口，所以之前已经出现的日志产品，如<code>JUL</code>和<code>Log4j</code>都是没有实现这个接口的，所以尴尬的是光有一个接口，没有实现的产品也是很憋屈啊，就算开发者想用<code>Slf4j</code>也是用不了。</p><p>于是大佬<strong>Ceki Gülcü</strong>撸出了之前提到的桥接包，于是日志系统现在有了这样的结构</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/bVbAMzq.png" alt="image.png" style="zoom:50%;" /><p>但是其实之前很多<code>Java</code>应用应该依赖的<code>JCL</code>，所以光有日志产品桥接包，好像还不够<strong>Ceki Gülcü</strong>：没问题，不就是不够桥接包么，我写，我来证明Slf4j是最完美的。</p><p>于是有了<code>JCL</code>的桥接包</p><img src="https://segmentfault.com/img/bVbAMA9" alt="image.png" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-7"><p>由于使用<code>Slf4j</code>，需要一次桥接包，也就是之前的日志产品都不是正统的<code>Slf4j</code>的实现，因此，2006年，出自<strong>Ceki Gülcü</strong>之手的日志产品<code>Logback</code>应运而生</p><p><code>Logback</code>是完美实现了<code>Slf4j</code>，于是现在日志系统变成了</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/bVbAMUJ.png" alt="未命名文件 (4).png" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-8"><p>2012年，Apache直接推出新项目Log4j2(不兼容Log4j) , Log4j2全面借鉴Slf4j+Logback 。 Log4j2不仅仅具有Logback的所有特性，还做了分离设计，分为log4j-api和log4j-core，log4j-api是日志接口，log4j-core是日志标准库，并且Apache也为Log4j2提供了各种桥接包。</p><p>而且log4j2 的性能提升很大，而且支持异步日志打印。增加很多新的特性。</p><img src="https://segmentfault.com/img/bVcTphN" alt="img" style="zoom: 67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="Slf4j的使用">Slf4j的使用</h2><h3 id="Slf4j与其它日志组件的关系说明">Slf4j与其它日志组件的关系说明</h3><p>Slf4j的设计思想比较简洁，使用了Facade设计模式，Slf4j本身只提供了一个<code>slf4j-api-version.jar</code>包，这个jar中主要是日志的抽象接口，jar中本身并没有对抽象出来的接口做实现。</p><p>对于不同的日志实现方案(例如Logback，Log4j…)，封装出不同的桥接组件(例如logback-classic-version.jar，slf4j-log4j12-version.jar)，这样使用过程中可以灵活的选取自己项目里的日志实现。</p><hr><h3 id="Slf4j与其它日志组件集成图">Slf4j与其它日志组件集成图</h3><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20231225145318031.png" alt="image-20231225145318031" style="zoom:67%;" /><p>如图所示，应用调了sl4j-api，即<strong>日志门面接口</strong>。日志门面接口本身通常并没有实际的日志输出能力，它底层还是需要去调用具体的日志框架API的，也就是实际上它需要跟具体的日志框架结合使用。由于具体日志框架比较多，而且互相也大都不兼容，日志门面接口要想实现与任意日志框架结合可能需要对应的桥接器，上图红框中的组件即是对应的各种桥接器！</p><table><thead><tr><th style="text-align:center"><strong>jar包名</strong></th><th style="text-align:center"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>slf4j-log4j12-1.7.30.jar</strong></td><td style="text-align:center">Log4j1.2版本的桥接器，你需要将Log4j.jar加入Classpath。</td></tr><tr><td style="text-align:center"><strong>slf4j-jdk14-1.7.30.jar</strong></td><td style="text-align:center">java.util.logging的桥接器，Jdk原生日志框架。</td></tr><tr><td style="text-align:center"><strong>slf4j-nop-1.7.30.jar</strong></td><td style="text-align:center">NOP桥接器，默默丢弃一切日志。</td></tr><tr><td style="text-align:center"><strong>slf4j-simple-1.7.30.jar</strong></td><td style="text-align:center">一个简单实现的桥接器，该实现输出所有事件到System.err. 只有Info以及高于该级别的消息被打印，在小型应用中它也许是有用的。</td></tr><tr><td style="text-align:center"><strong>slf4j-jcl-1.7.30.jar</strong></td><td style="text-align:center">Jakarta Commons Logging 的桥接器. 这个桥接器将Slf4j所有日志委派给Jcl。</td></tr><tr><td style="text-align:center"><strong>logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar)</strong></td><td style="text-align:center">Slf4j的原生实现，Logback直接实现了Slf4j的接口，因此使用Slf4j与Logback的结合使用也意味更小的内存与计算开销</td></tr></tbody></table><hr><h2 id="Slf4j源码分析">Slf4j源码分析</h2><blockquote><p>slf4j-api-version.jar中几个核心类与接口</p></blockquote><table><thead><tr><th style="text-align:center"><strong>类与接口</strong></th><th style="text-align:center"><strong>用途</strong></th></tr></thead><tbody><tr><td style="text-align:center">org.slf4j.LoggerFactory(class)</td><td style="text-align:center">给调用方提供的创建Logger的工厂类，在编译时绑定具体的日志实现组件</td></tr><tr><td style="text-align:center">org.slf4j.Logger(interface)</td><td style="text-align:center">给调用方提供的日志记录抽象方法，例如debug(String msg),info(String msg)等方法</td></tr><tr><td style="text-align:center">org.slf4j.ILoggerFactory(interface)</td><td style="text-align:center">获取的Logger的工厂接口，具体的日志组件实现此接口</td></tr><tr><td style="text-align:center">org.slf4j.helpers.NOPLogger(class)</td><td style="text-align:center">对org.slf4j.Logger接口的一个没有任何操作的实现，也是Slf4j的默认日志实现</td></tr><tr><td style="text-align:center">org.slf4j.impl.StaticLoggerBinder(class)</td><td style="text-align:center">与具体的日志实现组件实现的桥接类，具体的日志实现组件需要定义org.slf4j.impl包，并在org.slf4j.impl包下提供此类，注意在slf4j-api-version.jar中不存在org.slf4j.impl.StaticLoggerBinder，在源码包slf4j-api-version-source.jar中才存在此类</td></tr></tbody></table><hr><p><a href="https://juejin.cn/post/6905026199722917902#heading-19">https://juejin.cn/post/6905026199722917902#heading-19</a></p><p><a href="https://www.cnblogs.com/FlyAway2013/p/10691936.html">https://www.cnblogs.com/FlyAway2013/p/10691936.html</a></p><p><a href="https://juejin.cn/post/6939478456287625246">https://juejin.cn/post/6939478456287625246</a></p>]]></content>
    
    
    <summary type="html">Java日志体系</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础面试题</title>
    <link href="https://wuwawawa.github.io/posts/9d2f6ad8.html"/>
    <id>https://wuwawawa.github.io/posts/9d2f6ad8.html</id>
    <published>2023-12-14T11:07:01.000Z</published>
    <updated>2023-12-21T11:35:41.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常">异常</h2><h3 id="throw和throws区别">throw和throws区别</h3><details class="folding-tag" cyan close><summary>  </summary>              <div class='content'>              <p>throws 表示抛出异常，由该方法的调用者来处理</p><p>throw 可以由调用者来处理，也可以方法内部自己处理</p><hr><p>throws 表示有出现异常的可能性，但不一定出现这些异常</p><p>throw 表示抛出了异常</p><hr><p>throws 是在方法上进行声明的，后面可以直接跟异常的类名，可跟多个</p><p>throw 是写在方法内的，后面跟着的是具体的异常对象</p>              </div>            </details>]]></content>
    
    
    <summary type="html">JAVA基础</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="面试题" scheme="https://wuwawawa.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>并发面试题</title>
    <link href="https://wuwawawa.github.io/posts/c7a2e76a.html"/>
    <id>https://wuwawawa.github.io/posts/c7a2e76a.html</id>
    <published>2023-12-14T07:27:31.000Z</published>
    <updated>2024-02-29T01:05:16.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池">线程池</h2><details class="folding-tag" cyan close><summary> 线程池常见参数有哪些？ </summary>              <div class='content'>                            </div>            </details><hr><details class="folding-tag" green close><summary> 线程池中的线程出现异常了会发生什么？ </summary>              <div class='content'>              <p>执行 <code>execute</code> 方法，当任务抛出异常时，当前线程会终止，且会打印异常信息。</p><p>执行 <code>submit</code> 方法，当任务抛出异常时，当前线程不会终止，不会打印异常信息，只有在调用 get 方法的时候，才会打印异常信息。</p><p>解决方法:</p><div class="tabs" id="415ebb07-5613-4502-8cf4-4ca963a9138c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#415ebb07-5613-4502-8cf4-4ca963a9138c-1"><i class="fas fa-cat"></i>使用try-catch代码块</button></li><li class="tab"><button type="button" data-href="#415ebb07-5613-4502-8cf4-4ca963a9138c-2"><i class="fas fa-horse"></i>线程设置UncaughtExceptionHandler</button></li><li class="tab"><button type="button" data-href="#415ebb07-5613-4502-8cf4-4ca963a9138c-3"><i class="fas fa-dove"></i>继承ThreadPoolExecutor重写afterExecute方法</button></li><li class="tab"><button type="button" data-href="#415ebb07-5613-4502-8cf4-4ca963a9138c-4"><i class="fas fa-dragon"></i>实现ThreadFactory，自定义线程工厂类（推荐）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="415ebb07-5613-4502-8cf4-4ca963a9138c-1"><p>在线程的 run() 方法中加入 try-catch 代码块，避免运行时异常，同时可以在 catch 块中记录异常日志。</p><p>线程池中的任务抛出的异常会被自身的 try-catch 代码块捕获，从而防止工作线程因异常而意外退出。这意味着 processWorkerExit 方法不会被执行。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="415ebb07-5613-4502-8cf4-4ca963a9138c-2"><p>在第一个方法中，每个任务都需要手动添加 try-catch 代码块，这样做非常麻烦且不保险。如果有人忘记了添加 try-catch 代码块，在任务出现异常时，线程池会频繁删除异常的工作线程并创建新的工作线程，这样会严重影响线程池的性能。</p><p>可以使用 Thread.setDefaultUncaughtExceptionHandler 方法设置一个全局默认的未捕获异常处理器，该处理器会适用于所有线程。无论是主线程还是创建的其他线程，在发生未捕获异常时都将被该处理器处理。</p><p>但是该方法有两个问题：</p><ol><li>当 submit 方法提交的任务出现异常时，仍然无法处理该异常。</li><li>线程池仍然会删除异常的工作线程并创建新的工作线程，这并没有避免线程池的性能损耗。</li></ol><p>所以不推荐使用未捕获异常处理器来处理线程异常</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="415ebb07-5613-4502-8cf4-4ca963a9138c-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="415ebb07-5613-4502-8cf4-4ca963a9138c-4"><p>自定义线程工厂方法，为每一个 run 方法添加 try-catch 代码块</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details>]]></content>
    
    
    <summary type="html">并发面试题</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="面试题" scheme="https://wuwawawa.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java集合面试题</title>
    <link href="https://wuwawawa.github.io/posts/2e67a3f3.html"/>
    <id>https://wuwawawa.github.io/posts/2e67a3f3.html</id>
    <published>2023-12-14T05:45:41.000Z</published>
    <updated>2024-02-29T01:07:24.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用foreach内部进行删除，为什么会抛出异常">使用foreach内部进行删除，为什么会抛出异常</h2><details class="folding-tag" cyan close><summary>  </summary>              <div class='content'>              <p>迭代器在遍历是直接访问集合中的内容，并且在遍历过程中使用了一个<code>modCount</code>变量。集合在被遍历期间，如果它的内容发生了变化，就会改变<code>modCount</code>变量的值。迭代器在使用<code>hashNext()/next()</code>遍历下一个元素之前，会检测<code>modCount</code>变量是否为预期值，是就返回遍历，否则抛出<code>ConcurrentModificationException</code>异常</p><p>正确的方式是使用 迭代器 对元素进行删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="number">1</span>);</span><br><span class="line">        add(<span class="number">2</span>);</span><br><span class="line">        add(<span class="number">3</span>);</span><br><span class="line">        add(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">cur</span> <span class="operator">=</span> it.next();</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">2</span>) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="List集合的遍历方式" href="/posts/494ad091.html#List集合的遍历方式"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/favicon.png"/></div><div class="right"><p class="text">List集合的遍历方式</p><p class="url">/posts/494ad091.html#List集合的遍历方式</p></div></a></div><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230516205838333.png" alt="image-20230516205838333" style="zoom: 50%;" />              </div>            </details><hr><h2 id="增强for循环的底层实现原理">增强for循环的底层实现原理</h2><details class="folding-tag" green close><summary>  </summary>              <div class='content'>              <p>增强for循环是JAVA提供的语法糖，虽然增强for循环通过迭代器实现，但是删除元素还是得通过迭代器来进行删除。</p><p>以下代码进行反编译</p><div class="tabs" id="12d75644-1286-4f09-9156-e500ad2a10df"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#12d75644-1286-4f09-9156-e500ad2a10df-1"><i class="fas fa-seedling"></i>原代码</button></li><li class="tab"><button type="button" data-href="#12d75644-1286-4f09-9156-e500ad2a10df-2"><i class="fas fa-leaf"></i>反编译后</button></li><li class="tab"><button type="button" data-href="#12d75644-1286-4f09-9156-e500ad2a10df-3"><i class="fab fa-apple"></i>分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="12d75644-1286-4f09-9156-e500ad2a10df-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">   System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="12d75644-1286-4f09-9156-e500ad2a10df-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator(); iterator.hasNext(); System.out.println(i))&#123;</span><br><span class="line">   i = (Integer)iterator.next();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="12d75644-1286-4f09-9156-e500ad2a10df-3"><p>反编译后的代码其实比较复杂，我们按照执行顺序拆解一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i; 定义一个临时变量i</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator(); 获取List的迭代器</span><br><span class="line">iterator.hasNext(); 判断迭代器中是否有未遍历过的元素</span><br><span class="line">i = (Integer)iterator.next(); 获取第一个未遍历的元素，赋值给临时变量i</span><br><span class="line">System.out.println(i) 输出临时变量i的值</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><hr><h2 id="HashMap">HashMap</h2><details class="folding-tag" cyan close><summary> HashMap1.7数据结构、插入方式、扩容并发死链问题 </summary>              <div class='content'>              <p>数据结构：数组+单向链表</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-e326681a8e66e07a23e1cf45d4686001_1440w.webp" alt="img" style="zoom:33%;" /><p>插入方式：头插法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//取出索引位置的元素</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//将新的元素放置到索引位，同时将原节点的作为新元素的next，形成单向链表</span></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-b7d6d61af1a3887611c01e91a1ac5784_1440w.webp" alt="img" style="zoom:33%;" /><blockquote><p>正常情况下扩容</p></blockquote><p>HashMap正常情况下的扩容实现如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-ad1f36eb1b79f629ca500c73987c4531_1440w.webp" alt="img" style="zoom:33%;" /><p>旧HashMap的节点会依次转移到新HashMap中，旧HashMap转移的顺序是A、B、C，而新HashMap使用的是头插法，所以最终在新HashMap中的顺序是C、B、A，也就是上图展示的那样。</p><blockquote><p>并发扩容死链</p></blockquote><p><mark class="hl-label blue">步骤一</mark></p><p>死循环是因为并发HashMap扩容导致的，并发扩容的第一步，线程T1和线程T2要对HashMap进行扩容操作，此时T1和T2指向的是链表的头结点元素A，而T1和T2的下一个节点，也就是T1.next和T2.next指向的是B节点，如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-e0b4f5ea00cb277bde490f315b9b387f_1440w.webp" alt="img" style="zoom:33%;" /><p><mark class="hl-label red">步骤二</mark></p><p>死循环的第二步操作是，线程T2时间片用完进入休眠状态，而线程T1开始执行扩容操作，一直到线程T1扩容完成后，线程T2才被唤醒，扩容之后的场景如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_1440w.webp" alt="img" style="zoom:33%;" /><p>从上图可知线程T1执行之后，因为是头插法，所以HashMap的顺序已经发生了改变，但线程T2对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2指向的是A元素，T2.next指向的节点是B元素。</p><p><mark class="hl-label pink">步骤三</mark></p><p>当线程T1执行完，而线程T2恢复执行时，死循环就建立了，如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-bd4a753db8c985119aa4dcd4356609cf_1440w.webp" alt="img" style="zoom:33%;" /><p>因为T1执行完扩容之后B节点的下一个节点是A，而T2线程指向的首节点是A，第二个节点是B，这个顺序刚好和T1扩完容完之后的节点顺序是相反的。<strong>T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了</strong>，这就是HashMap死循环导致的原因。</p>              </div>            </details><hr><details class="folding-tag" cyan close><summary> HashMap1.8数据结构、插入方式、并发元素丢失 </summary>              <div class='content'>              <p>数据结构：数组+单向链表+红黑树+双向链表</p><p>插入方式：尾插法</p><p>并发元素丢失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素时，会有数据覆盖丢失数据</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//此处，如果多个线程向同一个位置存入元素，会有值覆盖的问题，导致数丢失</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容时，迁移数据的情况下，会有数据覆盖丢失的问题</span></span><br><span class="line"><span class="comment">// 多线程环境下，给同一个数组的相同位置赋值，会有数据覆盖的风险</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="literal">null</span>;</span><br><span class="line">    newTab[j] = loHead;  <span class="comment">//将原始索引位的数据迁移到新数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="literal">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead; <span class="comment">//将新索引位的数据迁移到新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><hr><h2 id="ConcurrentHashMap">ConcurrentHashMap</h2><details class="folding-tag" cyan close><summary> HashMap、HashTable、ConcurrentHashMap区别 </summary>              <div class='content'>              <blockquote><p>HashMap</p></blockquote><p>HashMap 是线程不安全的，在多线程环境下，使用 Hashmap 进行 put 操作会引起死循环，导致 CPU 利用率接近 100%，所以在并发情况下不能使用 HashMap。</p><blockquote><p>HashTable</p></blockquote><p>HashTable 和 HashMap 的实现原理几乎一样，差别无非是</p><ul><li>HashTable 不允许 key 和 value 为 null</li><li>HashTable 是线程安全的 但是 HashTable 线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁。</li></ul><p>多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</p><blockquote><p>ConcurrentHashMap</p></blockquote><p>主要就是为了应对 <code>HashMap</code> 在并发环境下不安全而诞生的， <code>ConcurrentHashMap</code> 的设计与实现非常精巧，大量的利用了 <code>volatile</code>，<code>final</code>， <code>CAS</code> 等无锁技术来减少锁竞争对于性能的影响。</p>              </div>            </details><details class="folding-tag" green close><summary> 1.7、1.8 ConcurrentHashMap对比 </summary>              <div class='content'>              <div class="tabs" id="794a187f-5e35-4305-96f0-a006bcf78cf1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#794a187f-5e35-4305-96f0-a006bcf78cf1-1"><i class="fas fa-seedling"></i>JDK1.7</button></li><li class="tab"><button type="button" data-href="#794a187f-5e35-4305-96f0-a006bcf78cf1-2"><i class="fas fa-leaf"></i>JDK1.8</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="794a187f-5e35-4305-96f0-a006bcf78cf1-1"><p>在 JDK1.7 中 ConcurrentHashMap 采用了数组+Segment+分段锁的方式实现。</p><p><strong>1.Segment(分段锁)</strong><br>ConcurrentHashMap 中的分段锁称为 Segment，它即类似于 HashMap 的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表,同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock）。</p><p><strong>2.内部结构</strong><br>ConcurrentHashMap 使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是 ConcurrentHashMap 的内部结构图：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20240228161103148.png" alt="image-20240228161103148" style="zoom: 33%;" /><p>从上面的结构我们可以了解到，ConcurrentHashMap 定位一个元素的过程需要进行两次 Hash 操作。第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。</p><p><strong>3.该结构的优劣势</strong><br><strong>坏处:</strong><br>这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长<br><strong>好处:</strong><br>写操作的时候可以只对元素所在的 Segment 进行加锁即可，不会影响到其他的 Segment，这样，在最理想的情况下，ConcurrentHashMap 可以最高同时支 持 Segment 数量大小的写操作（刚好这些写操作都非常平均地分布在所有的 Segment 上）。</p><p>所以，通过这一种结构，ConcurrentHashMap 的并发能力可以大大的提高。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="794a187f-5e35-4305-96f0-a006bcf78cf1-2"><p>JDK8 中 ConcurrentHashMap 参考了 JDK8 HashMap 的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用 CAS 操作。</p><p>Java8 ConcurrentHashMap 结构基本上和 Java8 的 HashMap 一样，不过保证线程安全性。</p><p>其实可以看出 JDK1.8 版本的 ConcurrentHashMap 的数据结构已经接近 HashMap，相对而言，ConcurrentHashMap 只是增加了同步的操作来控制并发，从 JDK1.7 版本的 ReentrantLock+Segment+HashEntry，到 JDK1.8 版本中 synchronized+CAS+HashEntry+红黑树。</p><ol><li>数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</li><li>保证线程安全机制：JDK1.7 采用 segment 的分段锁机制实现线程安全，其中 segment 继承自 ReentrantLock。JDK1.8 采用 CAS+Synchronized 保证线程 安全。</li><li>锁的粒度：原来是对需要进行数据操作的 Segment 加锁，现调整为对每个数组元素加锁（Node）。</li><li>链表转化为红黑树:定位结点的 hash 算法简化会带来弊端,Hash 冲突加剧,因此在链表节点数量大于 8 时，会将链表转化为红黑树进行存储。</li><li>查询时间复杂度：从原来的遍历链表 O(n)，变成遍历红黑树O(logN)。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details>]]></content>
    
    
    <summary type="html">Java集合面试题</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="面试题" scheme="https://wuwawawa.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>质量监控</title>
    <link href="https://wuwawawa.github.io/posts/39124153.html"/>
    <id>https://wuwawawa.github.io/posts/39124153.html</id>
    <published>2023-12-11T06:40:17.000Z</published>
    <updated>2023-12-13T07:11:39.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口耗时统计">接口耗时统计</h2><h3 id="Arthas">Arthas</h3><div class="tabs" id="4aa07204-e2ec-45cd-8f96-d331076e1f1b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4aa07204-e2ec-45cd-8f96-d331076e1f1b-1"><i class="fas fa-seedling"></i>下载Arthas</button></li><li class="tab"><button type="button" data-href="#4aa07204-e2ec-45cd-8f96-d331076e1f1b-2"><i class="fas fa-leaf"></i>启动Arthas</button></li><li class="tab"><button type="button" data-href="#4aa07204-e2ec-45cd-8f96-d331076e1f1b-3"><i class="fab fa-apple"></i>trace</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4aa07204-e2ec-45cd-8f96-d331076e1f1b-1"><p><code>curl -O https://alibaba.github.io/arthas/arthas-boot.jar</code></p><p>或者访问下载地址：<a href="https://arthas.aliyun.com/arthas-boot.jar">https://arthas.aliyun.com/arthas-boot.jar</a> ,然后将 Jar 包放到部署服务接口项目的服务器中。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4aa07204-e2ec-45cd-8f96-d331076e1f1b-2"><p><code>java -jar arthas-boot.jar</code></p><p>在随后出现的列表中，选择要监控的Java进程，看到 arthas 的 logo 说明 attach 成功。</p><p>trace org.whut.portweb.controller.UserController.UserController login  -n 5 --skipJDKMethod false</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4aa07204-e2ec-45cd-8f96-d331076e1f1b-3"><p>idea安装<code>arthas idea</code>后，选择要监控的接口，右键生成监控命令。</p><p><code>trace org.whut.portservice.UserService.impl.YhzhServiceImpl login  -n 5 --skipJDKMethod false  </code></p><p>使用测试工具，请求接口，即可生成接口请求耗时统计。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20231211153901184.png" alt="image-20231211153901184" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>使用Arthas优化案例</p></blockquote><p><a href="http://39.103.203.41:4000/chapter2/section2.html">http://39.103.203.41:4000/chapter2/section2.html</a></p><p><a href="https://github.com/alibaba/arthas/issues/1892">通过 Arthas Trace 命令将接口性能优化十倍</a></p><hr><h2 id="SQL耗时统计">SQL耗时统计</h2>]]></content>
    
    
    <summary type="html">监控系统、接口耗时统计、SQL耗时统计</summary>
    
    
    
    <category term="java" scheme="https://wuwawawa.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://wuwawawa.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring面试题</title>
    <link href="https://wuwawawa.github.io/posts/489ef953.html"/>
    <id>https://wuwawawa.github.io/posts/489ef953.html</id>
    <published>2023-12-08T06:04:44.000Z</published>
    <updated>2024-01-23T02:49:52.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring事务失效场景">Spring事务失效场景</h2><details class="folding-tag" cyan close><summary>  </summary>              <div class='content'>              <blockquote><p>配置问题</p></blockquote><p><mark class="hl-label blue">数据库不支持事务</mark></p><p>事务本来就是数据库的功能，如果数据库本身不支持事务，那任凭代码上如何设置也是没用的。以MySQL为例，InnoDB引擎是支持事务的，而像MyISAM、MEMORY等是不支持事务的。从MySQL5.5.5开始默认的存储引擎是InnoDB，之前默认都是MyISAM。</p><hr><p><mark class="hl-label green">未开启事务</mark></p><p>如果是SpringBoot项目，那么SpringBoot通过DataSourceTransactionManagerAutoConfiguration自动配置类帮我们开启了事务。如果是传统的Spring项目，则需要我们自己配置</p><hr><blockquote><p>Spring-AOP代理</p></blockquote><p><mark class="hl-label blue">事务方法被final或static关键字修饰</mark></p><p>如果<code>Spring</code>使用了<code>Cglib</code>代理实现（比如你的代理类没有实现接口），而你的业务方法恰好使用了<code>final</code>或者<code>static</code>关键字，那么事务也会失败。更具体地说，它应该抛出异常，因为<code>Cglib</code>使用字节码增强技术生成被代理类的子类并重写被代理类的方法来实现代理。如果被代理的方法的方法使用<code>final</code>或<code>static</code>关键字，则子类不能重写被代理的方法。</p><p>如果<code>Spring</code>使用<code>JDK</code>动态代理实现，<code>JDK</code>动态代理是基于接口实现的，那么<code>final</code>和<code>static</code>修饰的方法也就无法被代理。</p><p>总而言之，方法连代理都没有，那么肯定无法实现事务回滚了。</p><p><strong>解决方案：</strong></p><p>去掉final或者static关键字</p><hr><p><mark class="hl-label green">方法的访问权限不是public</mark></p><p>如果方法的访问权限不是<code>public</code>，<code>Spring</code>事务也会失败，因为<code>Spring</code>的事务管理源码<code>AbstractFallbackTransactionAttributeSource</code>中有判断<code>computeTransactionAttribute()。</code>如果目标方法不是公共的，则<code>TransactionAttribute</code>返回<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line"><span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p>是将当前方法访问级别更改为<code>public</code></p><hr><p><mark class="hl-label red">同一个类中，方法内部调用</mark></p><p>事务是通过 <code>Spring AOP</code>代理来实现的，而在同一个类中，一个方法调用另一个方法时， 调用方法直接调用目标方法的代码，而不是通过代理类进行调用，因此事务不生效。</p><p><strong>解决方案：</strong></p><ol><li>依赖注入自己（代理），通过代理类来调用目标方法</li><li>开启<code>@EnableAspectJAutoProxy(exposeProxy = true)</code>，<code>AopContext.currentProxy())</code>得到代理对象，再调用目标方法</li></ol><hr><blockquote><p>错误的异常处理</p></blockquote><p><mark class="hl-label blue">抛出检查异常</mark></p><p>比如你的事务控制代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>@Transactional</code> 没有特别指定，Spring 只会在遇到运行时异常RuntimeException或者error时进行回滚，而<code>IOException</code>等检查异常不会影响回滚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rollbackOn</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p>知道原因后，解决方法也很简单。配置<code>rollbackFor</code>属性，例如<code>@Transactional(rollbackFor = Exception.class)</code>。</p><hr><p><mark class="hl-label green">业务方法本身捕获了异常</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">            <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">                accountMapper.update(to, amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种场景下，事务失败的原因也很简单，事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉。</p><p><strong>解决方案：</strong></p><ol><li>异常catch后再次抛出</li><li>手动设置 <code>TransactionInterceptor.currentTransactionstatus().setRolLbackOnly();</code></li></ol><hr><p><mark class="hl-label red">AOP切面顺序导致导致异常在切面处处理</mark></p><p><code>Spring</code>的事务切面优先级最低，所以如果异常被别的切面捕获，Spring也不能正常处理事务，因为事务管理器无法捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* transfer(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;log:&#123;&#125;&quot;</span>, pjp.getTarget());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><ol><li>异常catch后再次抛出</li><li>手动设置 <code>TransactionInterceptor.currentTransactionstatus().setRolLbackOnly();</code></li><li>调整切面顺序，在 MyAspect 上添加 <code>@Order(Ordered.LOWEST_PRECEDENCE - 1)</code> （不推荐）</li></ol><hr><blockquote><p>@Transactional相关</p></blockquote><p><mark class="hl-label blue">使用了错误的事务传播机制</mark></p><p><code>Spring</code>提供了七种事务传播机制，可根据“是否支持当前事务”的维度分为以下 3 类：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image.png" alt="image" style="zoom: 45%;" /><p>若propagation属性设置如下三种事务传播行为，事务将不会发生回滚。</p><ul><li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><hr><p><mark class="hl-label green">Transactional没有保证原子行为</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实际上是有 bug 的，假设 from 余额为 1000，两个线程都来转账 1000，可能会出现扣减为负数的情况</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903120436365.png" alt="image-20210903120436365" style="zoom: 50%;" /><p>如上图所示，红色线程和蓝色线程的查询都发生在扣减之前，都以为自己有足够的余额做扣减</p><p><mark class="hl-label red">针对上面的问题，能否在方法上加synchronized锁来解决呢？</mark></p><p>答案是不行，原因如下：</p><ul><li>synchronized 保证的仅是目标方法的原子性，环绕目标方法的还有 commit 等操作，它们并未处于 sync 块内</li><li>可以参考下图发现，蓝色线程的查询只要在红色线程提交之前执行，那么依然会查询到有 1000 足够余额来转账</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903120800185.png" alt="image-20210903120800185" style="zoom:50%;" /><ul><li><p>解法1：synchronized 范围应扩大至代理方法调用</p></li><li><p>解法2：使用 select … for update 替换 select</p></li></ul><hr><blockquote><p>多线程调用</p></blockquote><p>这是因为 <code>Spring</code>事务是基于线程绑定的， 每个线程都有自己的事务上下文，而多线程环境下可能会存在多个线程共享同一个事务上下文的情况，导致事务不生效。 <code>Spring</code>事务管理器通过使用线程本地变量（ <code>ThreadLocal</code>）来实现线程安全。在Spring事务管理器中，通过<code>TransactionSynchronizationManager</code>类来管理事务上下文。<code>TransactionSynchronizationManager</code>内部维护了一个<code>ThreadLocal</code>对象，用来存储当前线程的事务上下文。在事务开始时，<code>TransactionSynchronizationManager</code>会将事务上下文绑定到当前线程的<code>ThreadLocal</code>对象中，当事务结束时，<code>TransactionSynchronizationManager</code>会将事务上下文从<code>ThreadLocal</code>对象中移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">(User user)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子线程执行</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程执行</span></span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程都会将Connection连接放在自己的threadlocal里面，所以@Transactional获取不到子线程的连接，没法回滚</p><p><strong>解决方案：</strong></p><p>父子线程共用一个连接，子线程如果运行出错，要在主线程中获取到并抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.在主线程里获取数据库连接资源</span></span><br><span class="line">    <span class="type">ConnectionHolder</span> <span class="variable">conHolder</span> <span class="operator">=</span></span><br><span class="line">            (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);</span><br><span class="line">    <span class="comment">//子线程执行</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 2.子线程绑定主线程的数据库连接资源</span></span><br><span class="line">        TransactionSynchronizationManager.bindResource(dataSource, conHolder);</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 3.解绑</span></span><br><span class="line">        TransactionSynchronizationManager.unbindResource(dataSource);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//主线程执行</span></span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">    <span class="comment">// 阻塞等待子线程 并拿到子线程的异常 若抛出异常 则join后也会抛出异常</span></span><br><span class="line">    future.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><hr><h2 id="什么是代理模式-聊聊JDK和CGLib动态代理实现和区别">什么是代理模式?聊聊JDK和CGLib动态代理实现和区别?</h2><details class="folding-tag" cyan close><summary>  </summary>              <div class='content'>              <p>代理模式是一种比较好理解的设计模式。 简单来说就是我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>Java中的代理按照代理类生成时机不同又分为<code>静态代理</code>和<code>动态代理</code>。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有<code>JDK代理</code>和<code>CGLib代理</code>两种。</p><hr><p><mark class="hl-label blue">JDK动态代理</mark></p><p><code>JDK</code>的动态代理是基于<strong>反射</strong>实现。<code>JDK</code>通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的<code>InvocationHandler</code>接口的<code>invoke</code>方法。并且这个代理类是Proxy类的子类。这就是<code>JDK</code>动态代理大致的实现方式。</p><p>优点:</p><ol><li><code>JDK</code>动态代理是<code>JDK</code>原生的，不需要任何依赖即可使用；</li><li>通过反射机制生成代理类的速度要比<code>CGLib</code>操作字节码生成代理类的速度更快；</li></ol><p>缺点:</p><ol><li>如果要使用<code>JDK</code>动态代理，被代理的类必须实现了接口，否则无法代理()；</li><li><code>JDK</code>动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，<code>Spring</code>仍然会使用<code>JDK</code>的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。</li><li><code>JDK</code>动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；</li></ol><p>注：JDK代理，代理的是接口，既然代理的是接口，那如果没有实现类怎么办，能不能代理。答案是可以的，Mybatis就是这样的。</p><hr><p><mark class="hl-label green">CGLib动态代理</mark></p><p><code>CGLib</code>实现动态代理的原理是，底层采用了<code>ASM</code>字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为<code>Spring</code>中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。</p><p>优点:</p><ol><li>使用<code>CGLib</code>代理的类，不需要实现接口，因为<code>CGLib</code>生成的代理类是直接继承自需要被代理的类；</li><li><code>CGLib</code>生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；</li><li><code>CGLib</code>生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以<code>CGLib</code>执行代理方法的效率要高于<code>JDK</code>的动态代理；</li></ol><p>缺点:</p><ol><li>由于<code>CGLib</code>的代理类使用的是继承，这也就意味着如果需要被代理的类是一个<code>final</code>类，则无法使用<code>CGLib</code>代理；</li><li>由于<code>CGLib</code>实现代理方法的方式是重写父类的方法，所以无法对<code>final</code>方法，或者<code>private</code>方法进行代理，因为子类无法重写这些方法；</li><li><code>CGLib</code>生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比<code>JDK</code>通过反射生成代理类的速度更慢；</li></ol>              </div>            </details><hr><p>循环依赖-为什么需要三级缓存？</p><p>二级缓存就已经可以解决循环依赖了为什么还需要三级缓存呢</p><p>解决代理对象</p><p><a href="https://www.bilibili.com/video/BV15b4y117RJ?p=185&amp;spm_id_from=pageDriver&amp;vd_source=367564499a9aaeeabb7fb0ac6eae366a">https://www.bilibili.com/video/BV15b4y117RJ?p=185&amp;spm_id_from=pageDriver&amp;vd_source=367564499a9aaeeabb7fb0ac6eae366a</a></p><hr>]]></content>
    
    
    <summary type="html">Spring面试题</summary>
    
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/categories/Spring/"/>
    
    
    <category term="面试题" scheme="https://wuwawawa.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>区间最值问题与ST表</title>
    <link href="https://wuwawawa.github.io/posts/95223a9d.html"/>
    <id>https://wuwawawa.github.io/posts/95223a9d.html</id>
    <published>2023-10-17T05:22:19.000Z</published>
    <updated>2023-10-17T06:38:47.783Z</updated>
    
    <content type="html"><![CDATA[<p>我们先从一个简单的区间问题切入</p><p>给定一个长度为 N 的数列，和 M 次询问，求出每一次询问的区间[L , R] 内数字的最大值。</p><blockquote><p>示例</p></blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">下标：0<span class="number"> 1 </span>2<span class="number"> 3 </span>4<span class="number"> 5 </span>6 7</span><br><span class="line">数列：9<span class="number"> 3 </span>1<span class="number"> 7 </span>5<span class="number"> 6 </span>0 8</span><br><span class="line">询问：</span><br><span class="line">[0,5] -&gt; 9</span><br><span class="line">[4,5] -&gt; 6</span><br><span class="line">[3,5] -&gt; 7</span><br></pre></td></tr></table></figure><h2 id="暴力解法">暴力解法</h2><div class="tabs" id="f67643ba-62fd-4f13-a803-a1c293ff0cdb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#f67643ba-62fd-4f13-a803-a1c293ff0cdb-1"><i class="fas fa-atom"></i>暴力解法</button></li><li class="tab"><button type="button" data-href="#f67643ba-62fd-4f13-a803-a1c293ff0cdb-2"><i class="far fa-sun"></i>暴力打表</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="f67643ba-62fd-4f13-a803-a1c293ff0cdb-1"><p>对于每次询问，都遍历一遍区间</p><p>O(NM)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt(), M = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        arr[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (M-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextInt(), r = sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f67643ba-62fd-4f13-a803-a1c293ff0cdb-2"><p>定义数组 <code>ans[i][j]</code>  表示[i , j]区间的答案 使用动态规划的思想对数组进行填充</p><p>空间复杂度 O(n*n)</p><p>时间复杂度 O(n*n + m)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt(), M = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        arr[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表</span></span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) ans[i][i] = arr[i];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            ans[i][j] = Math.max(ans[i][j - <span class="number">1</span>], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (M-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextInt(), r = sc.nextInt();</span><br><span class="line">        System.out.println(ans[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h2 id="稀疏表优化">稀疏表优化</h2><p>在暴力打表的解法中 我们把每个小区间都进行了存储，太过于紧凑，使得占用的空间过大</p><p>[0,1] [0,2] [0,3] [0,4] [0,5] [0,6] [0,7]</p><p>[1,2] [1,3] [1,4] [1,5] [1,6] [1,7]</p><p>[2,3] [2,4] [2,5] [2,6] [2,7]</p><p>…</p><hr><p>ST表则是基于动态规划 + 倍增的思想：</p><p>假如我们需要求[0 , x]区间的最大值，我们只需要知道[0 ,  x/2] 和 [x/2 + 1 , x]的最大值 反复减半直至区间长度为1</p><p>定义 <code>dp[i][j]</code> 表示 从 i 开始 ，长度为 2^j 的 区间最大值</p><p>base case</p><p><code>dp[i][0] = arr[i]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于每次询问 [l , r] 区间最大值为 </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(R - L + <span class="number">1</span>) / Math.log(<span class="number">2</span>));</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(dp[L][j], dp[R - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>][j]);</span><br><span class="line"></span><br><span class="line">假设区间为[<span class="number">1</span>,<span class="number">8</span>]</span><br><span class="line">  那我们取的两个区间是[<span class="number">1</span>,<span class="number">8</span>] 和 [<span class="number">1</span>,<span class="number">8</span>]</span><br><span class="line">假设区间为[<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">  那我们取的两个区间是[<span class="number">1</span>,<span class="number">8</span>] 和 [<span class="number">2</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt(), M = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        arr[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(N) / Math.log(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][size + <span class="number">5</span>];</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) dp[i][<span class="number">0</span>] = arr[i];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= size; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; N; i++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (M-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> sc.nextInt(), R = sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(R - L + <span class="number">1</span>) / Math.log(<span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(dp[L][j], dp[R - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>][j]);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结">总结</h2><p>ST表不仅仅可以用来求max ，还可以用来求 min gcd(最大公约数) lcm(最小公倍数)</p><p>ST 表是一个静态表，只能处理一些离线问题，而不能处理在线问题。</p>]]></content>
    
    
    <summary type="html">sparse table 稀疏表</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法模版</title>
    <link href="https://wuwawawa.github.io/posts/bb13e2f5.html"/>
    <id>https://wuwawawa.github.io/posts/bb13e2f5.html</id>
    <published>2023-10-04T03:38:05.000Z</published>
    <updated>2023-12-14T04:28:05.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口">滑动窗口</h2><h3 id="经典模版题">经典模版题</h3><p>关键词： 满足xxx条件（计算结果(加减乘除)、出现次数(cnt数组准备)、同时包含）长度最长/最短子串/子数组</p><p>注意点<br>1.if/while使用条件判断<br>2.right-left+1的重要性</p><div class="tabs" id="df3b0974-b073-4def-8595-8222f2f2897c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#df3b0974-b073-4def-8595-8222f2f2897c-1"><i class="fas fa-seedling"></i>209</button></li><li class="tab"><button type="button" data-href="#df3b0974-b073-4def-8595-8222f2f2897c-2"><i class="fas fa-leaf"></i>713</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="df3b0974-b073-4def-8595-8222f2f2897c-1"><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = <span class="number">0</span> , len = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; len)&#123;</span><br><span class="line">        sum += nums[r];    </span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            res = Math.min(res , r - l + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="df3b0974-b073-4def-8595-8222f2f2897c-2"><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">乘积小于 K 的子数组</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回子数组内所有元素的乘积严格小于 <code>k</code> 的连续子数组的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayProductLessThanK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">1</span> , len = nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; len)&#123;</span><br><span class="line">        product *= nums[r];</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">while</span>(product &gt;= k &amp;&amp; l &lt; r)&#123;</span><br><span class="line">            product /= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 以nums[r] 结尾子数组个数</span></span><br><span class="line">        res += r - l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="两端滑动窗口套路模板题">两端滑动窗口套路模板题</h3><p>正难则反，从两边拿难思考，最大化拿外面等价转换为最小化拿里面<br>由此变为模板题：从两端取数字等等，连续子数组，字串，可以想到滑动窗口解决</p><div class="tabs" id="174d806e-4979-4493-a287-fb02300675f0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#174d806e-4979-4493-a287-fb02300675f0-1"><i class="fas fa-seedling"></i>2516</button></li><li class="tab"><button type="button" data-href="#174d806e-4979-4493-a287-fb02300675f0-2"><i class="fas fa-leaf"></i>1423</button></li><li class="tab"><button type="button" data-href="#174d806e-4979-4493-a287-fb02300675f0-3"><i class="fab fa-apple"></i>1658</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="174d806e-4979-4493-a287-fb02300675f0-1"><p><a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/"> 每种字符至少取 K 个</a></p><p>给你一个由字符 <code>'a'</code>、<code>'b'</code>、<code>'c'</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p><p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回 <code>-1</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">takeCharacters</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cs.length;</span><br><span class="line">    <span class="comment">// 统计词频</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;a&#x27;</span>,-k);</span><br><span class="line">    map.put(<span class="string">&#x27;b&#x27;</span>,-k);</span><br><span class="line">    map.put(<span class="string">&#x27;c&#x27;</span>,-k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : cs) &#123;</span><br><span class="line">       map.merge(c,<span class="number">1</span>,Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 窗口</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">rc</span> <span class="operator">=</span> cs[r];</span><br><span class="line">        window.merge(rc, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">while</span> (window.get(rc) &gt; map.get(rc) &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">lc</span> <span class="operator">=</span> cs[l];</span><br><span class="line">            window.merge(lc, -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, r - l + <span class="number">1</span>);</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="174d806e-4979-4493-a287-fb02300675f0-2"><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">可获得的最大点数</a></p><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(<span class="type">int</span>[] cardPoints, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cardPoints.length;</span><br><span class="line">    k = len - k;</span><br><span class="line">    <span class="comment">// 计算sum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(cardPoints).sum();</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> cardPoints[r];</span><br><span class="line">        total += rx;</span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> == k + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lx</span> <span class="operator">=</span> cardPoints[l];</span><br><span class="line">            total -= lx;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">            ans = Math.min(ans, total);</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="174d806e-4979-4493-a287-fb02300675f0-3"><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">将 x 减到 0 的最小操作数</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p><p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回 <strong>最小操作数</strong> ；否则，返回 <code>-1</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum - x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (x == sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在窗口内找到最长子数组 其和等于target</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> nums[r];</span><br><span class="line">        s += rx;</span><br><span class="line">        <span class="keyword">while</span> (s &gt; target &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lx</span> <span class="operator">=</span> nums[l];</span><br><span class="line">            s -= lx;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == target) &#123;</span><br><span class="line">            res = Math.max(res, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == -<span class="number">1</span> ? -<span class="number">1</span> : len - res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="两个left计算区间个数">两个left计算区间个数</h3><p>滑动窗口区间个数计算模板题（两个left计算区间个数）</p><p>主要解决的问题是利用滑动窗口的两个left计算区间个数的模板解决相关套路题。</p><p>题目中往往包含<span class='p green'>恰好字眼</span></p><blockquote><p>把「恰好」 转换成为 「最多」。</p></blockquote><blockquote><p>例如求恰好k个，就用最多k个 - 最多k-1个 = 恰好k个</p></blockquote><div class="tabs" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8c93d26e-1b54-4ffd-9dce-d4803af8693d-1"><i class="fas fa-seedling"></i>LC930</button></li><li class="tab"><button type="button" data-href="#8c93d26e-1b54-4ffd-9dce-d4803af8693d-2"><i class="fas fa-leaf"></i>LC1248</button></li><li class="tab"><button type="button" data-href="#8c93d26e-1b54-4ffd-9dce-d4803af8693d-3"><i class="fab fa-apple"></i>LC992</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d-1"><p><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">和相同的二元子数组</a></p><p>给你一个二元数组 <code>nums</code> ，<code>nums[i]</code> 不是 <code>0</code> 就是 <code>1 </code>，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cal(nums, goal) - cal(nums, goal - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        s += x;</span><br><span class="line">        <span class="keyword">while</span> (s &gt; k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            s -= nums[left];</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d-2"><p><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/">统计优美子数组</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。如果某个连续子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中 <strong>「优美子数组」</strong> 的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cal(nums, k) - cal(nums, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">countOdd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        countOdd += ((x &amp; <span class="number">1</span>) == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (countOdd &gt; k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            countOdd -= ((nums[left] &amp; <span class="number">1</span>) == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d-3"><p><a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/"> K 个不同整数的子数组</a></p><p>给定一个正整数数组 <code>nums</code>和一个整数 <code>k</code>，返回 <code>nums</code> 中 「<strong>好子数组」</strong> 的数目。</p><p>如果 <code>nums</code> 的某个子数组中不同整数的个数恰好为 <code>k</code>，则称 <code>nums</code> 的这个连续、不一定不同的子数组为 <strong>「好子数组 」</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cal(nums, k) - cal(nums, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        map.merge(rx, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">while</span> (map.size() &gt; k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lx</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            map.merge(lx, -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            <span class="keyword">if</span> (map.get(lx) == <span class="number">0</span>) &#123;</span><br><span class="line">                map.remove(lx);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="分组循环">分组循环</h2><p><strong>适用场景</strong>：按照题目要求，数组会被分割成若干组，且每一组的判断/处理逻辑是一样的。</p><p><strong>核心思想</strong>：</p><ul><li>外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。</li><li>内层循环负责遍历组，找出这一组在哪结束。</li></ul><p>一般来说，分组循环的模板如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(nums)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">    start = i</span><br><span class="line">    <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> ...:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 从 start 到 i-1 是一组</span></span><br><span class="line">    <span class="comment"># 下一组从 i 开始，无需 i += 1</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/">最长奇偶子数组</a></p><p><a href="https://leetcode.cn/problems/consecutive-characters/">连续字符</a></p><p><a href="https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/">哪种连续子字符串更长</a></p><p><a href="https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/">使绳子变成彩色的最短时间</a></p><p><a href="https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/">所有元音按顺序排布的最长子字符串</a></p><h2 id="双向BFS">双向BFS</h2><p>「双向 BFS」的基本实现思路如下：</p><p>创建「两个队列」分别用于两个方向的搜索；<br>创建「两个哈希表」用于「解决相同节点重复搜索」和「记录转换次数」；<br>为了尽可能让两个搜索方向“平均”，每次从队列中取值进行扩展时，先判断哪个队列容量较少；<br>如果在搜索过程中「搜索到对方搜索过的节点」，说明找到了最短路径。<br>「双向 BFS」基本思路对应的伪代码大致如下：</p><div class="tabs" id="019b1ae0-3bce-4c44-8e19-84a975519e1b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#019b1ae0-3bce-4c44-8e19-84a975519e1b-1"><i class="fas fa-seedling"></i>伪代码</button></li><li class="tab"><button type="button" data-href="#019b1ae0-3bce-4c44-8e19-84a975519e1b-2"><i class="fas fa-leaf"></i>示例代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="019b1ae0-3bce-4c44-8e19-84a975519e1b-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d1、d2 为两个方向的队列</span><br><span class="line">m1、m2 为两个方向的哈希表，记录每个节点距离起点的</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 只有两个队列都不空，才有必要继续往下搜索</span></span><br><span class="line"><span class="comment">// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点</span></span><br><span class="line"><span class="keyword">while</span>(!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.size() &lt; d2.size()) &#123;</span><br><span class="line">        update(d1, m1, m2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update(d2, m2, m1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update 为将当前队列 d 中包含的元素取出，进行「一次完整扩展」的逻辑（按层拓展）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Deque d, Map cur, Map other)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="019b1ae0-3bce-4c44-8e19-84a975519e1b-2"><p><a href="https://leetcode.cn/problems/minimum-operations-to-convert-number/">转化数字的最小运算数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(<span class="type">int</span>[] _nums, <span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    nums = _nums;</span><br><span class="line">    Deque&lt;Long&gt; d1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(), d2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Long, Integer&gt; m1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    d1.addLast(s * <span class="number">1L</span>);</span><br><span class="line">    d2.addLast(t * <span class="number">1L</span>);</span><br><span class="line">    m1.put(s * <span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">    m2.put(t * <span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d1.size() &lt; d2.size()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> update(d1, m1, d2, m2, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans != -<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> update(d2, m2, d1, m1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans != -<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(Deque&lt;Long&gt; d1, Map&lt;Long, Integer&gt; m1, Deque&lt;Long&gt; d2, Map&lt;Long, Integer&gt; m2, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> d1.size();</span><br><span class="line">    <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> d1.pollFirst();</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> m1.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// 正向搜索：进行出队检查，只有出队元素符合条件，才能使用出队元素往下拓展</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= cur &amp;&amp; cur &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                    <span class="type">long</span>[] result = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;cur + i, cur - i, cur ^ i&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">long</span> next : result) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (m2.containsKey(next)) <span class="keyword">return</span> step + <span class="number">1</span> + m2.get(next);</span><br><span class="line">                        <span class="keyword">if</span> (!m1.containsKey(next)) &#123;</span><br><span class="line">                            d1.addLast(next);</span><br><span class="line">                            m1.put(next, step + <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反向搜索：进行入队检查，只有拓展元素符合条件，才能将拓展元素入队</span></span><br><span class="line">                <span class="type">long</span>[] result = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;cur + i, cur - i, cur ^ i&#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">long</span> next : result) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= next &amp;&amp; next &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (m2.containsKey(next)) <span class="keyword">return</span> step + <span class="number">1</span> + m2.get(next);</span><br><span class="line">                        <span class="keyword">if</span> (!m1.containsKey(next)) &#123;</span><br><span class="line">                            d1.addLast(next);</span><br><span class="line">                            m1.put(next, step + <span class="number">1</span>);</span><br><span class="line">                        &#125;   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="树形DP">树形DP</h2><h2 id="换根DP">换根DP</h2><hr><h2 id="数位DP">数位DP</h2><p>将 n 转换成字符串 s，定义 <code>f(i,mask,isLimit,hasNum)</code> 表示构造第 i 位及其之后数位的合法方案数，其参数的含义为:</p><ul><li>mask 表示前面选过的数字集合，换句话说，第 i 位要选的数字不能在 mask 中。</li><li>isLimit 表示当前是否受到了 n 的约束（注意要构造的数字不能超过 n）。若为真，则第 i 位填入的数字至多为 s[i]，否则可以是 9。如果在受到约束的情况下填了 s[i]，那么后续填入的数字仍会受到 n 的约束。例如 n=123，那么 i=0 填的是 1 的话，i=1 的这一位至多填 2。</li><li>hasNum 表示 i 前面的数位是否填了数字。若为假，则当前位可以跳过（不填数字），或者要填入的数字至少为 1；若为真，则要填入的数字可以从 0 开始。例如 n=1233，在 i=0 时跳过的话，相当于后面要构造的是一个 9 以内的数字了，如果 i=1 不跳过，那么相当于构造一个 10 到 99 的两位数，如果 i=1 跳过，相当于构造的是一个 9 以内的数字。</li></ul><blockquote><p>如果一个正整数每一个数位都是 <strong>互不相同</strong> 的，我们称它是 <strong>特殊整数</strong> 。给你一个 <strong>正</strong> 整数 <code>n</code> ，请你返回区间 <code>[1, n]</code> 之间特殊整数的数目。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] memo;   <span class="comment">// memo[i][mask]记录当前选择顺位为i，已选状态为mask时，构造第i位及后面位的合法方案数</span></span><br><span class="line">    <span class="type">char</span>[] s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参考灵神の数位DP记忆化DFS模板：</span></span><br><span class="line"><span class="comment">        注意这题与LC1012是一样的，不过这题更直接求每一位都不相同数字</span></span><br><span class="line"><span class="comment">        dfs(i, mask, isLimit, hasNum) 代表从左到右选到第i个数字时(i从0开始)，前面数字已选状态为mask时的合法方案数</span></span><br><span class="line"><span class="comment">        各个参数的含义如下:</span></span><br><span class="line"><span class="comment">        i:当前选择的数字位次，从0开始</span></span><br><span class="line"><span class="comment">        mask:前面已择数字的状态，是一个10位的二进制数，如:0000000010就代表前面已经选了1</span></span><br><span class="line"><span class="comment">        isLimit:boolean类型，代表当前位选择是否被前面位的选择限制了；</span></span><br><span class="line"><span class="comment">            如n=1234，前面选了12，选第3位的时候会被限制在0~3，isLimit=true；否则是0~9，isLimit=false</span></span><br><span class="line"><span class="comment">        hasNum:表示前面是否已经选择了数字，若选择了就为true(识别直接构造低位的情况)</span></span><br><span class="line"><span class="comment">        时间复杂度:O(1024*M*10) 空间复杂度:O(1024*M)</span></span><br><span class="line"><span class="comment">        记忆化DFS的时间复杂度=状态数*每一次枚举的情况数</span></span><br><span class="line"><span class="comment">        **记忆化本质就是减少前面已选状态一致的情况，将1eM的时间复杂度压缩至1&lt;&lt;M，效率非常高**</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s = String.valueOf(n).toCharArray();    <span class="comment">// 转化为字符数组形式</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];     <span class="comment">// i∈[0,m-1]，mask为一个10位二进制数</span></span><br><span class="line">        <span class="comment">// 初始化memo为-1代表该顺位下该已选状态还没进行计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意一开始最高位是有限制的，isLimit=true</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs(i, mask, isLimit, hasNum) 代表从左到右选第i个数字时，前面已选状态为mask时的合法方案数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> mask, <span class="type">boolean</span> isLimit, <span class="type">boolean</span> hasNum)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="comment">// i越过最后一位，此时前面选了就算一个，没选的就不算，因为不选后面也没得选了</span></span><br><span class="line">        <span class="keyword">if</span> (i == s.length) <span class="keyword">return</span> hasNum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 已经计算过该状态，并且该状态是有效的，直接返回该状态</span></span><br><span class="line">        <span class="comment">// 这一步是降低时间复杂度的关键，使得记忆化dfs的时间复杂度控制得很低</span></span><br><span class="line">        <span class="comment">// !isLimit表示没有被限制的才可以直接得出结果，否则还要根据后面的数字进行计算子问题计算</span></span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; hasNum &amp;&amp; memo[i][mask] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][mask];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 结果</span></span><br><span class="line">        <span class="comment">// 本位可以取0(可直接构造低位数)的情况，此时要加上构造低位数0xxx的方案数</span></span><br><span class="line">        <span class="comment">// 将是否选了数字作为分类条件是为了避免出现00010这样有多个0的就不能统计了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasNum) res = dfs(i + <span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 构造与当前顺位相同位数的数字就要枚举可选的数字进行DFS</span></span><br><span class="line">        <span class="comment">// 枚举的起点要视hasNum而定，如果前面选择了数字，那么现在可以选0；否则只能从1开始</span></span><br><span class="line">        <span class="comment">// 枚举得终点视isLimit而定，若被限制了只能到s[i]，否则可以到9</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> hasNum ? <span class="number">0</span> : <span class="number">1</span>, end = isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>; k &lt;= end; k++) &#123;</span><br><span class="line">            <span class="comment">// 如果该数字k还没有被选中，那猫就可以选该位数字</span></span><br><span class="line">            <span class="keyword">if</span> (((mask &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 方案数遵循加法原理</span></span><br><span class="line">                <span class="comment">// i:进行下一位的DFS，因此为i+1</span></span><br><span class="line">                <span class="comment">// mask:由于该位选中了k，mask掩膜传下去就要更新，已选状态加上k</span></span><br><span class="line">                <span class="comment">// isLimit:当且仅当前面的被限制了且该位被限制</span></span><br><span class="line">                <span class="comment">// hasNum:该位选了必定为true</span></span><br><span class="line">                res += dfs(i + <span class="number">1</span>, mask | (<span class="number">1</span> &lt;&lt; k), isLimit &amp;&amp; k == end, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; hasNum) memo[i][mask] = res;    <span class="comment">// 如果前面没有限制，表明后面都是同质的，可以记录进memo中</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题单：</p><p><a href="https://leetcode.cn/problems/number-of-digit-one/">233. 数字 1 的个数</a></p><p><a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></p><p><a href="https://leetcode.cn/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a></p><p><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></p><p><a href="https://leetcode.cn/problems/rotated-digits/">788. 旋转数字</a></p><p><a href="https://leetcode.cn/problems/numbers-with-repeated-digits/">1012. 至少有 1 位重复的数字</a></p><p><a href="https://leetcode.cn/problems/count-special-integers/">2376. 统计特殊整数</a></p><p><a href="https://leetcode.cn/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a></p><hr><h2 id="并查集">并查集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启了路径压缩和按大小合并的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    <span class="comment">// 当前连通分支数目</span></span><br><span class="line">    <span class="type">int</span> branchCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.branchCount = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> parent[x] == x ? x : (parent[x] = find(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按大小合并</span></span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        --branchCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">branchCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> branchCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="前缀和与差分">前缀和与差分</h2><h3 id="一维前缀和">一维前缀和</h3><hr><h3 id="一维差分">一维差分</h3><hr><h3 id="二维前缀和">二维前缀和</h3><p>定义<code>preSum[i][j]</code> 是从(0,0) 到 (i,j) 的 和</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1614615488-IBbfAx-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2.png" alt="二维区域和检索" style="zoom: 25%;" /><p><code>sumRegion(A,D)=sumRegion(O,D)−sumRegion(O,E)−sumRegion(O,F)+sumRegion(O,G)</code></p><div class="tabs" id="5a1f7b08-e592-46ea-9033-85f4cddc1583"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5a1f7b08-e592-46ea-9033-85f4cddc1583-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#5a1f7b08-e592-46ea-9033-85f4cddc1583-2"><i class="fas fa-leaf"></i>2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5a1f7b08-e592-46ea-9033-85f4cddc1583-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">// 二维前缀和</span></span><br><span class="line"><span class="type">int</span>[][] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        preSum[i][j] = preSum[i - <span class="number">1</span>][j] + preSum[i][j - <span class="number">1</span>] - preSum[i - <span class="number">1</span>][j - <span class="number">1</span>] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5a1f7b08-e592-46ea-9033-85f4cddc1583-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="comment">// 二维前缀和</span></span><br><span class="line">    <span class="type">int</span>[][] preSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[rows][cols];</span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; cols;i++)&#123;</span><br><span class="line">            preSum[<span class="number">0</span>][i] = preSum[<span class="number">0</span>][i - <span class="number">1</span>] + matrix[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; rows;i++)&#123;</span><br><span class="line">            preSum[i][<span class="number">0</span>] = preSum[i - <span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; cols;j++)&#123;</span><br><span class="line">                preSum[i][j] = preSum[i - <span class="number">1</span>][j] + preSum[i][j - <span class="number">1</span>] - preSum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i][j]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> preSum[row2][col2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> col1 - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : preSum[row2][col1 - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x3</span> <span class="operator">=</span> row1 - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : preSum[row1 - <span class="number">1</span>][col2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x4</span> <span class="operator">=</span> (col1 - <span class="number">1</span> &lt; <span class="number">0</span> || row1 - <span class="number">1</span> &lt; <span class="number">0</span>) ? <span class="number">0</span> : preSum[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> x1 - x2 - x3 + x4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="二维差分">二维差分</h3><p>如果将矩阵的第 (i,j) 个单元格中的值增加 1，那么，若对矩阵求二维前缀和，那么下图 (a) 中的黄色区域的值都会增加 1。</p><p>如果要将矩阵中的 任意 矩形区域（如下图中 (b) 的蓝色区域）的值增加 1 呢？只需按照下图 © 来修改矩阵即可。修改后，若对矩阵求前缀和，那么，只会有蓝色的区域的值 +1，其它区域的值都不变。</p><img src="https://pic.leetcode-cn.com/1641658840-YrICJa-image.png" alt="image.png" style="zoom: 25%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] rangeAddQueries(<span class="type">int</span> n, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">    <span class="type">int</span>[][] diff = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] q : queries)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> q[<span class="number">0</span>] , y1 = q[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> q[<span class="number">2</span>] , y2 = q[<span class="number">3</span>];</span><br><span class="line">        diff[x1][y1]++;</span><br><span class="line">        diff[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>]++;</span><br><span class="line">        diff[x2 + <span class="number">1</span>][y1]--;</span><br><span class="line">        diff[x1][y2 + <span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 使用差分数组求前缀和</span></span><br><span class="line">    ans[<span class="number">0</span>][<span class="number">0</span>] = diff[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="comment">// 求第一行</span></span><br><span class="line">        ans[<span class="number">0</span>][i] = ans[<span class="number">0</span>][i - <span class="number">1</span>] + diff[<span class="number">0</span>][i];</span><br><span class="line">        <span class="comment">// 求第一列</span></span><br><span class="line">        ans[i][<span class="number">0</span>] = ans[i - <span class="number">1</span>][<span class="number">0</span>] + diff[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">            ans[i][j] = ans[i - <span class="number">1</span>][j] + ans[i][j - <span class="number">1</span>] - ans[i - <span class="number">1</span>][j - <span class="number">1</span>] + diff[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="ST表">ST表</h2><p>ST 表是用于解决 可重复贡献问题 的数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt(), M = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        arr[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(N) / Math.log(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][size + <span class="number">5</span>];</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) dp[i][<span class="number">0</span>] = arr[i];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= size; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; N; i++) &#123;</span><br><span class="line">            dp[i][j] = calculate(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (M-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> sc.nextInt(), R = sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(R - L + <span class="number">1</span>) / Math.log(<span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculate(dp[L][j], dp[R - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>][j]);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快速幂-组合计数">快速幂&amp;组合计数</h2><div class="tabs" id="657446ae-ec88-48e3-9f15-2c6218a8c84b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#657446ae-ec88-48e3-9f15-2c6218a8c84b-1"><i class="fas fa-seedling"></i>DP打表</button></li><li class="tab"><button type="button" data-href="#657446ae-ec88-48e3-9f15-2c6218a8c84b-2"><i class="fas fa-leaf"></i>Lucas</button></li><li class="tab"><button type="button" data-href="#657446ae-ec88-48e3-9f15-2c6218a8c84b-3"><i class="fab fa-apple"></i>exLucas</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="657446ae-ec88-48e3-9f15-2c6218a8c84b-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] comb = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        comb[i][<span class="number">0</span>] = comb[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            comb[i][j] = comb[i - <span class="number">1</span>][j] + comb[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            comb[i][j] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(comb[<span class="number">5</span>][<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="657446ae-ec88-48e3-9f15-2c6218a8c84b-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100002</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">long</span>) (<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span>[] fac = <span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化阶乘</span></span><br><span class="line">    fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ksm</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> mod)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans = ans * x % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">C</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> m, <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m * <span class="number">2</span> &gt; n) &#123;</span><br><span class="line">        m = n - m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fac[(<span class="type">int</span>) n] * ksm(fac[(<span class="type">int</span>) m] * fac[(<span class="type">int</span>) (n - m)] % p, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    计算 C(n,m)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">lucas</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> m, <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="657446ae-ec88-48e3-9f15-2c6218a8c84b-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="原地堆化">原地堆化</h2><div class="tabs" id="e7e66a86-91ce-4f22-b37a-9e457c4b1f9d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-1"><i class="fas fa-seedling"></i>最大堆</button></li><li class="tab"><button type="button" data-href="#e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-2"><i class="fas fa-leaf"></i>最小堆</button></li><li class="tab"><button type="button" data-href="#e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-3"><i class="fab fa-apple"></i>使用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地堆化（最大堆）</span></span><br><span class="line"> <span class="comment">// 堆化可以保证 h[0] 是堆顶元素，且 h[i] &gt;= max(h[2*i+1], h[2*i+2])</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">     <span class="comment">// 倒着遍历，从而保证 i 的左右子树一定是堆，那么 sink(h, i) 就可以把左右子树合并成一个堆</span></span><br><span class="line">     <span class="comment">// 下标 &gt;= h.length / 2 的元素是二叉树的叶子，无需下沉</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         sink(h, i);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 把 h[i] 不断下沉，直到 i 的左右儿子都 &lt;= h[i]</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span>[] h, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> h.length;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// i 的左儿子</span></span><br><span class="line">         <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; h[j + <span class="number">1</span>] &gt; h[j]) &#123; <span class="comment">// i 的右儿子比 i 的左儿子大</span></span><br><span class="line">             j++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (h[j] &lt;= h[i]) &#123; <span class="comment">// 说明 i 的左右儿子都 &lt;= h[i]，停止下沉</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         swap(h, i, j); <span class="comment">// 下沉</span></span><br><span class="line">         i = j;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 交换 h[i] 和 h[j]</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] h, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> h[i];</span><br><span class="line">     h[i] = h[j];</span><br><span class="line">     h[j] = tmp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地堆化（最小堆）</span></span><br><span class="line"><span class="comment">// 堆化可以保证 h[0] 是堆顶元素，且 h[i] &lt;= max(h[2*i+1], h[2*i+2])</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">    <span class="comment">// 倒着遍历，从而保证 i 的左右子树一定是堆，那么 sink(h, i) 就可以把左右子树合并成一个堆</span></span><br><span class="line">    <span class="comment">// 下标 &gt;= h.length / 2 的元素是二叉树的叶子，无需下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sink(h, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 h[i] 不断下沉，直到 i 的左右儿子都 &gt;= h[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span>[] h, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> h.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// i 的左儿子</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; h[j + <span class="number">1</span>] &lt; h[j]) &#123; <span class="comment">// i 的右儿子比 i 的左儿子大</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h[j] &gt;= h[i]) &#123; <span class="comment">// 说明 i 的左右儿子都 &lt;= h[i]，停止下沉</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(h, i, j); <span class="comment">// 下沉</span></span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换 h[i] 和 h[j]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] h, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> h[i];</span><br><span class="line">    h[i] = h[j];</span><br><span class="line">    h[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-3"><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆顶元素 -&gt; h<span class="selector-attr">[0]</span></span><br><span class="line">更改后 <span class="built_in">sink</span>(h, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="线段树">线段树</h2><p><a href="https://leetcode.cn/circle/discuss/H4aMOn/">https://leetcode.cn/circle/discuss/H4aMOn/</a></p><div class="tabs" id="9c7b8dd6-e778-4726-b122-cb09a92c4e26"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#9c7b8dd6-e778-4726-b122-cb09a92c4e26-1"><i class="fas fa-atom"></i>单点覆盖+区间求和+区间求最值</button></li><li class="tab"><button type="button" data-href="#9c7b8dd6-e778-4726-b122-cb09a92c4e26-2"><i class="far fa-sun"></i>区间加值+区间求和</button></li><li class="tab"><button type="button" data-href="#9c7b8dd6-e778-4726-b122-cb09a92c4e26-3"><i class="fas fa-wind"></i>区间覆盖+区间求最值</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="9c7b8dd6-e778-4726-b122-cb09a92c4e26-1"><p>单点修改或覆盖型没必要用上lazy标记，因为这是直接作用于某个点，没有范围可言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BinaryFunction</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原数组  下标从 0 开始</span></span><br><span class="line">    <span class="type">int</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] segTree;</span><br><span class="line"></span><br><span class="line">    BinaryFunction merger;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> unit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] data, BinaryFunction merger, <span class="type">int</span> unit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.merger = merger;</span><br><span class="line">        <span class="built_in">this</span>.unit = unit;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> data.length;</span><br><span class="line">        segTree = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        Arrays.fill(segTree, unit);</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下方方法调用中 root 1  left 1 right n</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            segTree[root] = data[left - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span>, left, mid);</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        segTree[root] = merger.apply(segTree[root &lt;&lt; <span class="number">1</span>], segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将cur位置值修改为val</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> cur, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            segTree[root] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt;= mid) &#123;</span><br><span class="line">            update(root &lt;&lt; <span class="number">1</span>, left, mid, cur, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, cur, val);</span><br><span class="line">        &#125;</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="comment">// 两个区间无重合</span></span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span> unit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完全包含</span></span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; to &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> segTree[root];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l_res</span> <span class="operator">=</span> query(root &lt;&lt; <span class="number">1</span>, left, mid, from, to);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r_res</span> <span class="operator">=</span> query(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to);</span><br><span class="line">        <span class="keyword">return</span> merger.apply(l_res, r_res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9c7b8dd6-e778-4726-b122-cb09a92c4e26-2"><p>对真正的区间操作就需要用到懒惰标记了，懒惰标记的作用在于多次更新，少量查询，就是在update()的时候先暂缓的记下来，最后query的时候一口气作用出来。</p><p>实现思路：</p><p>核心在与如何把单个val加入到一个区间的每个数字中，我们知道一个root代表一个区间，区间就有长度；那只需把val * length(root的区间) 即可；</p><p>可以理解为改区间里的每个点都有一个贡献的val，n个val相加，那就是n*val。同理，在pushDown()的时候也要计算该父节点对应左右孩子的长度；因此，这里的pushDown()还需要传入左右点的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] segTree;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> data.length;</span><br><span class="line">        segTree = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            segTree[root] = data[left - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span>, left, mid);</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        segTree[root] = (segTree[root &lt;&lt; <span class="number">1</span>] + segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLen</span> <span class="operator">=</span> right - mid;</span><br><span class="line">        <span class="keyword">if</span> (lazy[root] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// val 累计lazy*len</span></span><br><span class="line">            segTree[root &lt;&lt; <span class="number">1</span>] = (segTree[root &lt;&lt; <span class="number">1</span>] + lazy[root] * leftLen);</span><br><span class="line">            segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + lazy[root] * rightLen);</span><br><span class="line">            <span class="comment">// lazy 直接累计</span></span><br><span class="line">            lazy[root &lt;&lt; <span class="number">1</span>] = (lazy[root &lt;&lt; <span class="number">1</span>] + lazy[root]);</span><br><span class="line">            lazy[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (lazy[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + lazy[root]);</span><br><span class="line"></span><br><span class="line">            lazy[root] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; right &lt;= to) &#123;</span><br><span class="line">            segTree[root] =</span><br><span class="line">                    (segTree[root] + val * (right - left + <span class="number">1</span>));</span><br><span class="line">            lazy[root] = (lazy[root] + val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown(root, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        update(root &lt;&lt; <span class="number">1</span>, left, mid, from, to, val);</span><br><span class="line">        update(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to, val);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; right &lt;= to) &#123;</span><br><span class="line">            <span class="keyword">return</span> segTree[root];</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown(root, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (query(root &lt;&lt; <span class="number">1</span>, left, mid, from, to) +</span><br><span class="line">                query(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9c7b8dd6-e778-4726-b122-cb09a92c4e26-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] segTree;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> data.length;</span><br><span class="line">        segTree = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            segTree[root] = data[left - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span>, left, mid);</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        segTree[root] = Math.max(segTree[root &lt;&lt; <span class="number">1</span>], segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy[root] != <span class="number">0</span>) &#123;</span><br><span class="line">            segTree[root &lt;&lt; <span class="number">1</span>] = segTree[root];</span><br><span class="line">            segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = segTree[root];</span><br><span class="line">            lazy[root &lt;&lt; <span class="number">1</span>] = lazy[root];</span><br><span class="line">            lazy[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = lazy[root];</span><br><span class="line">            lazy[root] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; right &lt;= to) &#123;</span><br><span class="line">            segTree[root] = val;</span><br><span class="line">            lazy[root] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        update(root &lt;&lt; <span class="number">1</span>, left, mid, from, to, val);</span><br><span class="line">        update(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to, val);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; right &lt;= to) &#123;</span><br><span class="line">            <span class="keyword">return</span> segTree[root];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pushDown(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(query(root &lt;&lt; <span class="number">1</span>, left, mid, from, to), query(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h2 id="树状数组">树状数组</h2><p>高效处理「前缀」查询，单点修改</p><p>通常使用树状数组是为了维护一些前缀，如前缀和、前缀最小值、前缀最大值。</p><p>但由于最小值和最大值不可逆，在大多数情况下是维护不了区间最小值和最大值的。</p><img src="https://pic.leetcode-cn.com/257e6c5742751f7cfdfd0704e7380ceccbd123335347a589165d74fa7ad11d40.png" alt="在这里插入图片描述" style="zoom: 33%;" /><table><thead><tr><th style="text-align:center">数组 <code>C</code> 的值由数组 <code>A</code> 的哪些元素而来</th><th style="text-align:center">数组 <code>A</code> 的元素个数</th></tr></thead><tbody><tr><td style="text-align:center">C[1] = A[1]</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">C[2] = A[1] + A[2]</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">C[3] = A[3]</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">C[4] = A[1] + A[2] + A[3] + A[4]</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">C[5] = A[5]</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">C[6] = A[5] + A[6]</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">C[7] = A[7]</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8]</td><td style="text-align:center">8</td></tr></tbody></table><p>通过图中不难看出，sum[7]=c[7]+c[6]+c[4] ,我们进一步发现,6=7-lowbit(7),4=6-lowbit(6)，所以我们可以通过不断的-lowbit操作来实现求和</p><p>在数据范围比较分散时，可以离散化数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LongBinaryFunction</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">apply</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongGenericBIT</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span>[] data;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> unit;</span><br><span class="line">    LongBinaryFunction merger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建大小A[1...n]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongGenericBIT</span><span class="params">(<span class="type">int</span> n, LongBinaryFunction merger, <span class="type">long</span> unit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.merger = merger;</span><br><span class="line">        <span class="built_in">this</span>.unit = unit;</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lowBit</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询A[1]+A[2]+...+A[x]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> unit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= lowBit(i)) &#123;</span><br><span class="line">            sum = merger.apply(sum, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询A[L]+A[L + 1]+...+A[R]</span></span><br><span class="line"><span class="comment">     * [L,R] = [1,R] - [1,L-1]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> unit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L - <span class="number">1</span>; i &gt; <span class="number">0</span>; i -= lowBit(i)) &#123;</span><br><span class="line">            l = merger.apply(l, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> unit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> R; i &gt; <span class="number">0</span>; i -= lowBit(i)) &#123;</span><br><span class="line">            r = merger.apply(r, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将A[x]更新为A[x]+mod</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> mod)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= n; i += lowBit(i)) &#123;</span><br><span class="line">            data[i] = merger.apply(data[i], mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= n; i += lowBit(i)) &#123;</span><br><span class="line">            data[i] = unit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将A全部清0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        Arrays.fill(data, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            builder.append(query(i)).append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (builder.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            builder.setLength(builder.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="基环树">基环树</h2><p>它的标准定义是：具有N个点N条边的连通图。如果不保证联通，它就会成为基环树森林。</p><p>内向基环树的定义是每个点有且只有一条出边。</p><p>外向基环树的定义是每个点有且只有一条入边。</p><p>从 i 向 to[i] 连边，可以得到一张有向图。由于每个大小为 k 的连通块都有 k 个点和 k 条边，所以<span class='p green'>每个连通块必定有且仅有一个环</span>，且由于每个点的出度均为 1，这样的有向图又叫做内向基环树 (pseudotree)，由基环树组成的森林叫基环树森林 (pseudoforest)。</p><p>每一个内向基环树（连通块）都由一个基环和其余指向基环的树枝组成。例如 以下示例 <code>to = [3,0,1,4,1]</code>  可以得到如下内向基环树，其基环由节点 0、1、3 和 4 组成，节点 2 为其树枝：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1641096462-IsWZUX-1-20231101095643697.png" alt="1.png" style="zoom: 67%;" /><p>常见的处理方式：拓扑排序去掉树枝</p><p><a href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/">参加会议的最多员工数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumInvitations</span><span class="params">(<span class="type">int</span>[] favorite)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> favorite.length;</span><br><span class="line">        <span class="type">int</span>[] deg = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> f : favorite) &#123;</span><br><span class="line">            deg[f]++; <span class="comment">// 统计基环树每个节点的入度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt;[] rg = <span class="keyword">new</span> <span class="title class_">List</span>[n]; <span class="comment">// 反图</span></span><br><span class="line">        Arrays.setAll(rg, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123; <span class="comment">// 拓扑排序，剪掉图上所有树枝</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> favorite[x]; <span class="comment">// x 只有一条出边</span></span><br><span class="line">            rg[y].add(x);</span><br><span class="line">            <span class="keyword">if</span> (--deg[y] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxRingSize</span> <span class="operator">=</span> <span class="number">0</span>, sumChainSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历基环上的点</span></span><br><span class="line">            deg[i] = <span class="number">0</span>; <span class="comment">// 将基环上的点的入度标记为 0，避免重复访问</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ringSize</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 基环长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> favorite[i]; x != i; x = favorite[x]) &#123;</span><br><span class="line">                deg[x] = <span class="number">0</span>; <span class="comment">// 将基环上的点的入度标记为 0，避免重复访问</span></span><br><span class="line">                ringSize++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ringSize == <span class="number">2</span>) &#123; <span class="comment">// 基环长度为 2</span></span><br><span class="line">                sumChainSize += rdfs(i, rg) + rdfs(favorite[i], rg); <span class="comment">// 累加两条最长链的长度</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxRingSize = Math.max(maxRingSize, ringSize); <span class="comment">// 取所有基环长度的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxRingSize, sumChainSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反图 rg 寻找树枝上最深的链</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">rdfs</span><span class="params">(<span class="type">int</span> x, List&lt;Integer&gt;[] rg)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> son : rg[x]) &#123;</span><br><span class="line">            maxDepth = Math.max(maxDepth, rdfs(son, rg) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="字典树-二进制字典树">字典树&amp;二进制字典树</h2><div class="tabs" id="0832b00f-ca2f-43ba-a0f6-65d4ce426d75"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0832b00f-ca2f-43ba-a0f6-65d4ce426d75-1"><i class="fas fa-bug"></i>字典树</button></li><li class="tab"><button type="button" data-href="#0832b00f-ca2f-43ba-a0f6-65d4ce426d75-2"><i class="fas fa-cannabis"></i>二进制字典树</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0832b00f-ca2f-43ba-a0f6-65d4ce426d75-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TireNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            node = node.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            node = node.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TireNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">public</span> TireNode[] next;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TireNode</span><span class="params">()</span> &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        next = <span class="keyword">new</span> <span class="title class_">TireNode</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0832b00f-ca2f-43ba-a0f6-65d4ce426d75-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie01</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_BIT</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TireNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie01</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MAX_BIT; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.next[bit] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.next[bit] = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node.next[bit].cnt++;</span><br><span class="line">            node = node.next[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MAX_BIT; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            node.next[bit].cnt--;</span><br><span class="line">            node = node.next[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TireNode</span> &#123;</span><br><span class="line">    TireNode[] next;</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TireNode</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="keyword">new</span> <span class="title class_">TireNode</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="字符串哈希">字符串哈希</h2><mark class="hl-label blue">BKDR-HASH</mark> <p>把 <code>String</code> 当成一个 <code>X</code> 进制的数</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;123&quot;</span> -&gt; <span class="number">123</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;abz&quot;</span> -&gt; <span class="number">0</span> <span class="number">1</span> <span class="number">26</span>(<span class="number">26</span>)</span><br></pre></td></tr></table></figure><div class="tabs" id="62813119-1ef5-4a50-a4d6-d2ccbf7883b0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#62813119-1ef5-4a50-a4d6-d2ccbf7883b0-1"><i class="fas fa-seedling"></i>求整个字符串哈希</button></li><li class="tab"><button type="button" data-href="#62813119-1ef5-4a50-a4d6-d2ccbf7883b0-2"><i class="fas fa-leaf"></i>前缀和思想求每个子串哈希</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="62813119-1ef5-4a50-a4d6-d2ccbf7883b0-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;abc&quot;</span>.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">13331</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">hash_code</span> <span class="operator">=</span> cs[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">    hash_code = hash_code * x + cs[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="62813119-1ef5-4a50-a4d6-d2ccbf7883b0-2"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br><span class="line">h<span class="comment">[0]</span> = 1h<span class="comment">[1]</span> = 12h<span class="comment">[2]</span> = 123h<span class="comment">[3]</span> = 1234h<span class="comment">[4]</span> = 12345</span><br><span class="line"></span><br><span class="line">如何得到234的hash 即 234</span><br><span class="line">h<span class="comment">[3]</span> - h<span class="comment">[0]</span> ???</span><br><span class="line">h<span class="comment">[3]</span> - h<span class="comment">[0]</span> * 10^3</span><br></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char[] cs = <span class="string">&quot;abcdefe&quot;</span>.toCharArray();</span><br><span class="line">int len = cs.length;</span><br><span class="line">long[] h = new long[len];</span><br><span class="line">long[] x = new long[len];</span><br><span class="line">int <span class="symbol">X</span> = <span class="number">13331</span>;</span><br><span class="line">h[<span class="number">0</span>] = cs[<span class="number">0</span>];</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">for (int i = <span class="number">1</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * <span class="symbol">X</span> + cs[i];</span><br><span class="line">    x[i] = x[i - <span class="number">1</span>] * <span class="symbol">X</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算子字符串hash [<span class="symbol">L</span>,<span class="symbol">R</span>]</span><br><span class="line">int <span class="symbol">L</span>, <span class="symbol">R</span>;</span><br><span class="line">long hash = <span class="symbol">L</span> == <span class="number">0</span> ? h[<span class="symbol">R</span>] : h[<span class="symbol">R</span>] - h[<span class="symbol">L</span> - <span class="number">1</span>] * x[<span class="symbol">R</span> - <span class="symbol">L</span> + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="大小写转换">大小写转换</h2><ol><li>全转小写：ch|=32</li><li>全转大写：ch&amp;=-33 (原理是32的补码（原码取反+1）再-1)</li><li>大小写对换（大写变小写，小写变大）ch^=32</li></ol><hr><h2 id="隔板法">隔板法</h2><p><strong>隔板法</strong> 就是在n个元素间的（n-1）个空中插入k个板，可以把n个元素分成k+1组的方法</p><div class="tabs" id="adcb06f7-b745-4b55-b30a-26b14d08e162"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#adcb06f7-b745-4b55-b30a-26b14d08e162-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#adcb06f7-b745-4b55-b30a-26b14d08e162-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#adcb06f7-b745-4b55-b30a-26b14d08e162-3"><i class="fab fa-apple"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="adcb06f7-b745-4b55-b30a-26b14d08e162-1"><p>例1. 求方程 x+y+z=10的正整数解的个数。<br>分析：将10个球排成一排，球与球之间形成9个空隙，将两个隔板插入这些空隙中（每空至多插一块隔板），规定由隔板分成的左、中、右三部分的球数分别为x、y、z之值（如下图）。则隔法与解的个数之间建立了一一对立关系，故解的个数为C（9，2）=36（个）。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="adcb06f7-b745-4b55-b30a-26b14d08e162-2"><p>例2. 求方程 x+y+z=10的非负整数解的个数。 （添加球数用隔板法）<br>分析：注意到x、y、z可以为零，故例1解法中的限定“每空至多插一块隔板”就不成立了，怎么办呢？只要添加三个球，给x、y、z各添加一个球，这样原问题就转化为求 x+y+z=13的正整数解的个数了，易得解的个数为C（12，2）=66（个）。</p><p>令x1 = x + 1 , y1 = y + 1 , z1 = z + 1 ,则x1 ， y1 , z1 &gt;=1</p><p>则 x1 + y1 + z1 = n + k</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="adcb06f7-b745-4b55-b30a-26b14d08e162-3"><p>例3. 将20个相同的小球放入编号分别为1，2，3，4的四个盒子中，要求每个盒子中的球数不少于它的编号数，求放法总数。（减少球数用隔板法）<br>分析：先在编号1，2，3，4的四个盒子内分别放0，1，2，3个球，剩下14个球，有1种方法；再把剩下的球分成4组，每组至少1个，由例1知方法有C（13，3）=286（种）。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">一些常用的算法模版</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>周赛复盘</title>
    <link href="https://wuwawawa.github.io/posts/e7135cd3.html"/>
    <id>https://wuwawawa.github.io/posts/e7135cd3.html</id>
    <published>2023-10-01T06:13:22.000Z</published>
    <updated>2023-11-12T09:11:35.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前缀最大值-后缀最大值">前缀最大值+后缀最大值</h2><p><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/">有序三元组中的最大值</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>请你从所有满足 <code>i &lt; j &lt; k</code> 的下标三元组 <code>(i, j, k)</code> 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 <code>0</code> 。</p><p><strong>下标三元组</strong> <code>(i, j, k)</code> 的值等于 <code>(nums[i] - nums[j]) * nums[k]</code> 。</p><div class="tabs" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-1"><i class="fas fa-seedling"></i>示例1</button></li><li class="tab"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-2"><i class="fas fa-leaf"></i>示例2</button></li><li class="tab"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-3"><i class="fab fa-apple"></i>示例3</button></li><li class="tab"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-4"><i class="fas fa-tree"></i>数据范围</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-1"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[12,6,1,2,7]</span></span><br><span class="line">输出：77</span><br><span class="line">解释：下标三元组 (0, 2, 4) 的值是 (nums<span class="comment">[0]</span> - nums<span class="comment">[2]</span>) * nums<span class="comment">[4]</span> = 77 。</span><br><span class="line">可以证明不存在值大于 77 的有序下标三元组。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-2"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,10,3,4,19]</span></span><br><span class="line">输出：133</span><br><span class="line">解释：下标三元组 (1, 2, 4) 的值是 (nums<span class="comment">[1]</span> - nums<span class="comment">[2]</span>) * nums<span class="comment">[4]</span> = 133 。</span><br><span class="line">可以证明不存在值大于 133 的有序下标三元组。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-3"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：0</span><br><span class="line">解释：唯一的下标三元组 (0, 1, 2) 的值是一个负数，(nums<span class="comment">[0]</span> - nums<span class="comment">[1]</span>) * nums<span class="comment">[2]</span> = -3 。因此，答案是 0 。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-4"><p>两题的数据只是数据范围存在不同</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="枚举J">枚举J</h3><p>在枚举J的情况下，想要<code>(nums[i] - nums[j]) * nums[k]</code>尽量大，就是要让两个数都尽量大。</p><p>对于 <code>nums[j]</code> 来说，如果固定了 <code>j</code> 的位置，那我们需要知道</p><ul><li><code>nums[j + 1] ~ nums[n - 1]</code> 的最大值 即后缀最大值</li><li><code>nums[0] ~ nums[j - 1]</code> 的最大值 即前缀最大值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 后缀最大值</span></span><br><span class="line">    <span class="type">int</span>[] suf_max = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        suf_max[i] = Math.max(suf_max[i + <span class="number">1</span>] , nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前缀最大值</span></span><br><span class="line">    <span class="type">int</span>[] pre_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    pre_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        pre_max[i] = Math.max(pre_max[i - <span class="number">1</span>] , nums[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//枚举j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n - <span class="number">1</span>;j++)&#123;</span><br><span class="line">        ans = Math.max(ans,(<span class="type">long</span>)(pre_max[j - <span class="number">1</span>] - nums[j]) * suf_max[j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="枚举k">枚举k</h3><p>一次遍历，从左到右遍历所有的 <code>nums[k]</code></p><ul><li>那么就需要维护 <code>nums[i] - nums[j]</code>的最大值 max_diff</li><li>同时我们还需要知道左侧的最大值pre_max</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">max_diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre_max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">        <span class="comment">// 先把 x 当做 nums[k]</span></span><br><span class="line">        ans = Math.max(ans , max_diff * x);</span><br><span class="line">        <span class="comment">// 再把 x 当做 nums[j]</span></span><br><span class="line">        max_diff = Math.max(max_diff , pre_max - x);</span><br><span class="line">        <span class="comment">// 再把 x 当做 nums[i]</span></span><br><span class="line">        pre_max = Math.max(pre_max , x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三句话的顺序不能改变，因为题目严格要求<code>i &lt; j &lt; k</code></p><hr><h2 id="滑动窗口">滑动窗口</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/">无限数组的最短子数组</a></p><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>下标从 <strong>0</strong> 开始的数组 <code>infinite_nums</code> 是通过无限地将 nums 的元素追加到自己之后生成的。</p><p>请你从 <code>infinite_nums</code> 中找出满足 <strong>元素和</strong> 等于 <code>target</code> 的 <strong>最短</strong>子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 <code>-1</code> 。</p><div class="tabs" id="3c20ef88-8338-403a-abf5-62b17d741a18"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-1"><i class="fas fa-seedling"></i>示例1</button></li><li class="tab"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-2"><i class="fas fa-leaf"></i>示例2</button></li><li class="tab"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-3"><i class="fab fa-apple"></i>示例3</button></li><li class="tab"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-4"><i class="fas fa-tree"></i>数据范围</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3c20ef88-8338-403a-abf5-62b17d741a18-1"><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="keyword">target</span> = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：在这个例子中 infinite_nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,...] 。</span><br><span class="line">区间 [<span class="number">1</span>,<span class="number">2</span>] 内的子数组的元素和等于 <span class="keyword">target</span> = <span class="number">5</span> ，且长度 length = <span class="number">2</span> 。</span><br><span class="line">可以证明，当元素和等于目标值 <span class="keyword">target</span> = <span class="number">5</span> 时，<span class="number">2</span> 是子数组的最短长度。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c20ef88-8338-403a-abf5-62b17d741a18-2"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1,1,1,2</span>,<span class="number">3</span>], target = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：在这个例子中 infinite_nums = [<span class="number">1,1,1,2</span>,<span class="number">3,1,1,1</span>,<span class="number">2,3,1,1</span>,...].</span><br><span class="line">区间 [<span class="number">4</span>,<span class="number">5</span>] 内的子数组的元素和等于 target = <span class="number">4</span> ，且长度 length = <span class="number">2</span> 。</span><br><span class="line">可以证明，当元素和等于目标值 target = <span class="number">4</span> 时，<span class="number">2</span> 是子数组的最短长度。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c20ef88-8338-403a-abf5-62b17d741a18-3"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2,4,6,8</span>], target = <span class="number">3</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：在这个例子中 infinite_nums = [<span class="number">2,4,6,8</span>,<span class="number">2,4,6,8</span>,...] 。</span><br><span class="line">可以证明，不存在元素和等于目标值 target = <span class="number">3</span> 的子数组。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c20ef88-8338-403a-abf5-62b17d741a18-4"><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= target &lt;= 109</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1696131371-UYYmoV-w365c-c.png" alt="img" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSizeSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : nums) total += x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; <span class="number">2</span>*n)&#123;</span><br><span class="line">        sum += nums[right % n];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt; target % total)&#123;</span><br><span class="line">            sum -= nums[left % n];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target % total)&#123;</span><br><span class="line">            ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans + (<span class="type">int</span>)(target / total) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="位运算">位运算</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-collect-elements/">收集元素的最少操作次数</a></p><p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>一次操作中，你可以将数组的最后一个元素删除，将该元素添加到一个集合中。</p><p>请你返回收集元素 <code>1, 2, ..., k</code> 需要的 <strong>最少操作次数</strong> 。</p><div class="tabs" id="6a55aa92-f333-4d58-8119-bccb9431f404"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-1"><i class="fas fa-seedling"></i>示例1</button></li><li class="tab"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-2"><i class="fas fa-leaf"></i>示例2</button></li><li class="tab"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-3"><i class="fab fa-apple"></i>示例3</button></li><li class="tab"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-4"><i class="fas fa-tree"></i>数据范围</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6a55aa92-f333-4d58-8119-bccb9431f404-1"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,5,4,2], k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：4 次操作后，集合中的元素依次添加了<span class="number"> 2 </span>，4 ，5 和<span class="number"> 1 </span>。此时集合中包含元素<span class="number"> 1 </span>和<span class="number"> 2 </span>，所以答案为<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a55aa92-f333-4d58-8119-bccb9431f404-2"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,5,4,2], k = 5</span><br><span class="line">输出：5</span><br><span class="line">解释：5 次操作后，集合中的元素依次添加了<span class="number"> 2 </span>，4 ，5 ，1 和<span class="number"> 3 </span>。此时集合中包含元素<span class="number"> 1 </span>到<span class="number"> 5 </span>，所以答案为<span class="number"> 5 </span>。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a55aa92-f333-4d58-8119-bccb9431f404-3"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,5,3,1], k = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：4 次操作后，集合中的元素依次添加了<span class="number"> 1 </span>，3 ，5 和<span class="number"> 2 </span>。此时集合中包含元素<span class="number"> 1 </span>到<span class="number"> 3 </span> ，所以答案为<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a55aa92-f333-4d58-8119-bccb9431f404-4"><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= nums.length</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li><li>输入保证你可以收集到元素 <code>1, 2, ..., k</code> 。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>由于元素范围在[1,50]，我们可以用一个 64 位整数表示集合，只要集合中有 1 到 k 就立刻返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">    <span class="type">long</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 结束状态 mask 是 statsu 的子集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">// 更新status</span></span><br><span class="line">        status |= <span class="number">1L</span> &lt;&lt; nums.get(i);</span><br><span class="line">        <span class="keyword">if</span>((mask &amp; status) == mask)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - i;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针">双指针</h2><p><a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/">找出满足差值条件的下标 II</a></p><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，以及整数 <code>indexDifference</code> 和整数 <code>valueDifference</code> 。</p><p>你的任务是从范围 <code>[0, n - 1]</code> 内找出 <strong>2</strong> 个满足下述所有条件的下标 <code>i</code> 和 <code>j</code> ：</p><ul><li><code>abs(i - j) &gt;= indexDifference</code> 且</li><li><code>abs(nums[i] - nums[j]) &gt;= valueDifference</code></li></ul><p>返回整数数组 <code>answer</code>。如果存在满足题目要求的两个下标，则 <code>answer = [i, j]</code> ；否则，<code>answer = [-1, -1]</code> 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。</p><p><strong>注意：</strong><code>i</code> 和 <code>j</code> 可能 <strong>相等</strong> 。</p><div class="tabs" id="a01cbf90-6b71-4b34-aac8-ad28ebabb777"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a01cbf90-6b71-4b34-aac8-ad28ebabb777-1"><i class="fas fa-seedling"></i>思路</button></li><li class="tab"><button type="button" data-href="#a01cbf90-6b71-4b34-aac8-ad28ebabb777-2"><i class="fas fa-leaf"></i>代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a01cbf90-6b71-4b34-aac8-ad28ebabb777-1"><p>拆绝对值</p><ul><li>j - i &gt;= id</li><li>| ai - aj | &gt;= vd</li></ul><p>一边枚举j ，一边维护j - id 之前的最大和最下值</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a01cbf90-6b71-4b34-aac8-ad28ebabb777-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findIndices(<span class="type">int</span>[] nums, <span class="type">int</span> indexDifference, <span class="type">int</span> valueDifference) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIdx</span> <span class="operator">=</span> <span class="number">0</span>, minIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> indexDifference; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j - indexDifference;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[maxIdx]) &#123;</span><br><span class="line">                maxIdx = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[minIdx]) &#123;</span><br><span class="line">                minIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[maxIdx] - nums[j] &gt;= valueDifference) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;maxIdx, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] - nums[minIdx] &gt;= valueDifference) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;minIdx, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>判断二次幂 + lowBit操作</p><p>~x + 1 相当于-x</p><p><a href="https://leetcode.cn/problems/minimum-impossible-or/">最小无法得到的或值</a></p><h2 id="树形DP">树形DP</h2><p>可自顶向下思考 -&gt; 记忆化搜索</p><p>可自递向上思考 -&gt; 树形DP</p><p><a href="https://leetcode.cn/problems/maximum-points-after-collecting-coins-from-all-nodes/">收集所有金币可获得的最大积分</a></p><h2 id="子序列DP">子序列DP</h2><p><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/">最长相邻不相等子序列 II</a></p><mark class="hl-label DP">子序列</mark> <ul><li>子序列 + 不考虑相邻元素：选或不选。代表题目：<a href="https://leetcode.cn/problems/target-sum/">494. 目标和（0-1 背包）</a>。</li><li>子序列 + 考虑相邻元素：枚举选哪个。代表题目：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getWordsInLongestSubsequence</span><span class="params">(<span class="type">int</span> n, String[] words, <span class="type">int</span>[] groups)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(words[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] from = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[n -<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        from[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxId</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>;i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &gt; dp[i] &amp;&amp; groups[i] != groups[j] &amp;&amp; isDOne(words[i],words[j]))&#123;</span><br><span class="line">                    dp[i] = dp[j];</span><br><span class="line">                    from[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; dp[maxId])&#123;</span><br><span class="line">                maxId = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dp[maxId];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">            res.add(words[maxId]);</span><br><span class="line">            maxId = from[maxId];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDOne</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != t.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                diff = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0-1背包</p><p><a href="https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/">和为目标值的最长子序列的长度</a></p><p>子序列DP 选或不选 + 状态机DP</p><p><a href="https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/">使数组变美的最小增量运算数</a></p><p>单调队列优化DP</p><p><a href="https://leetcode.cn/problems/constrained-subsequence-sum/">1425. 带限制的子序列和</a></p><h2 id="完全背包">完全背包</h2><p><a href="https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/">和带限制的子多重集合的数目</a></p><p>斜率优化 + 滚动数组 + 数据范围优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 多重背包</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubMultisets</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            cnt.merge(x, <span class="number">1</span>, Integer::sum);</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; l) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r = Math.min(r, sum);</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[r + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = cnt.getOrDefault(<span class="number">0</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        cnt.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : cnt.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="comment">// 次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            curMax = Math.min(curMax + x * c, r);</span><br><span class="line">            <span class="type">int</span>[] newDp = dp.clone();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= curMax; i++) &#123;</span><br><span class="line">                newDp[i] = (newDp[i] + newDp[i - x]) % MOD;</span><br><span class="line">                <span class="keyword">if</span> (i - (c + <span class="number">1</span>) * x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    newDp[i] = (newDp[i] - dp[i - (c + <span class="number">1</span>) * x] + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = newDp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; ++i) &#123;</span><br><span class="line">            ans = (ans + dp[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展欧几里得exgcd">拓展欧几里得exgcd</h2><p>求解不定方程 ax + by = c</p><p><a href="https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/">合法分组的最少组数</a></p><h2 id="统计所有子数组">统计所有子数组</h2><p><a href="https://leetcode.cn/problems/total-appeal-of-a-string/">字符串的总引力</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    使用变化量来思考</span></span><br><span class="line"><span class="comment">    示例：</span></span><br><span class="line"><span class="comment">    C   A   B   A   D   A</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2   1</span></span><br><span class="line"><span class="comment">    3   2   1</span></span><br><span class="line"><span class="comment">    2   1   2   1</span></span><br><span class="line"><span class="comment">    3   2   3   2   1</span></span><br><span class="line"><span class="comment">    3   2   2   1   2   1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">统计子串中的唯一字符</a></p><hr><h2 id="01字典树">01字典树</h2><p><a href="https://leetcode.cn/problems/maximum-strong-pair-xor-ii/">找出强数对的最大异或值 II</a></p><p>遇到绝对值要想到排序拆绝对值</p><p>滑动窗口 + 从字典树中删除 + 子数组最大异或<a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值</a></p><hr><h2 id="容斥定理">容斥定理</h2><p><a href="https://leetcode.cn/problems/distribute-candies-among-children-ii/">给小朋友们分糖果 II</a></p><p><a href="https://leetcode.cn/problems/number-of-strings-which-can-be-rearranged-to-contain-substring/">重新排列后包含指定子字符串的字符串数目</a></p>]]></content>
    
    
    <summary type="html">LeetCode周赛</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最短路算法</title>
    <link href="https://wuwawawa.github.io/posts/5697d1d5.html"/>
    <id>https://wuwawawa.github.io/posts/5697d1d5.html</id>
    <published>2023-09-26T06:13:22.000Z</published>
    <updated>2023-10-01T09:00:02.859Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230926155902091.png" alt="image-20230926155902091"></p><h2 id="Dijkstra算法">Dijkstra算法</h2><p>Dijkstra本质上是一种贪心算法，通过不断调整每个点的“当前距离”最终得到最优结果。</p><p>假设现在要求出从某一点s到其他所有点的最短距离，对于每个点v均维护一个“当前距离”（dist[v]）和“是否访问过”(visited[v])。首先将dist[s]初始化为0，将其他点的距离初始化为无穷，并将所有点初始化为未访问的。记u-&gt;v的边权为weight[u-&gt;v]。然后进行以下步骤：</p><ol><li>从所有未访问的点中，找出当前距离最小的，设为u，并将其标记为已访问的。</li><li>调整u的所有边（若是有向图则为出边）连接的并且<strong>未被访问过的</strong>点：若weight[u-&gt;v] + dist[u] &lt; dist[v], 则将dist[v]更新为dist[u]+weight[u-&gt;v]。</li><li>重复1和2步骤，直到所有点都被标记为已访问的，则dist[i]即s到i的最短距离。如果只想求从s到某一点的最短距离，那么当该点被标记为访问过之后可直接退出。</li><li>补充：如果除了最短距离之外还想求出具体的路径，只需建立一个pre数组，在步骤2后添加操作：pre[v] = u（前提是dist[v]被更新）。</li></ol><div class="tabs" id="e1220ca0-3a93-4dc3-aaa1-66a274d0966f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e1220ca0-3a93-4dc3-aaa1-66a274d0966f-1"><i class="fas fa-seedling"></i>邻接矩阵</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e1220ca0-3a93-4dc3-aaa1-66a274d0966f-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">110</span>, M = <span class="number">6010</span>;</span><br><span class="line">    <span class="comment">// 邻接矩阵数组：w[a][b] = c 代表从 a 到 b 有权重为 c 的边</span></span><br><span class="line">    <span class="type">int</span>[][] w = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">    <span class="comment">// dist[x] = y 代表从「源点/起点」到 x 的最短距离为 y</span></span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="comment">// 记录哪些点已经被更新过</span></span><br><span class="line">    <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line">    <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> n, src;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span>[][] conn)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                w[i][j] = w[j][i] = i == j ? <span class="number">0</span> : INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] t : conn) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> t[<span class="number">0</span>], v = t[<span class="number">1</span>], c = t[<span class="number">2</span>];</span><br><span class="line">            w[u][v] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最短路</span></span><br><span class="line">        dijkstra();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 起始先将所有的点标记为「未更新」和「距离为正无穷」</span></span><br><span class="line">        Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">        Arrays.fill(dist, INF);</span><br><span class="line">        <span class="comment">// 只有起点最短距离为 0</span></span><br><span class="line">        dist[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 迭代 n 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt;= n; p++) &#123;</span><br><span class="line">            <span class="comment">// 每次找到「最短距离最小」且「未被更新」的点 t</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i] &amp;&amp; (t == -<span class="number">1</span> || dist[i] &lt; dist[t])) t = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记点 t 为已更新</span></span><br><span class="line">            vis[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 用点 t 的「最小距离」更新其他点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                dist[i] = Math.min(dist[i], dist[t] + w[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Floyd算法">Floyd算法</h2><p>动态规划</p><p><code>dp[i][j]</code> 表示 <code>i-&gt;j</code> 的最短距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借用别的点求解</p>]]></content>
    
    
    <summary type="html">Dijkstra + SPFA + Bellman-Ford + Floyd</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>差分数组</title>
    <link href="https://wuwawawa.github.io/posts/f4bb8efc.html"/>
    <id>https://wuwawawa.github.io/posts/f4bb8efc.html</id>
    <published>2023-09-25T06:45:09.000Z</published>
    <updated>2023-09-25T09:37:30.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景">使用场景</h2><p>在介绍差分数组之前，先回顾一下「前缀和数组」</p><p>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</p><p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</p><p>使用场景：对于一个数组 <code>nums[]</code></p><ul><li>要求一：对 <code>num[2...4]</code> 全部 + 1</li><li>要求二：对 <code>num[1...3]</code> 全部 - 3</li><li>要求三：对 <code>num[0...4]</code> 全部 + 9</li></ul><p>看到上述情景，首先想到的肯定是遍历（bao li）。直接对数组循环 3 遍，每次在规定的区间上按要求进行操作，此时时间复杂度O(3n)</p><p>但是当这样的操作变得频繁后，时间复杂度也呈线性递增</p><p>所以针对这种场景，提出了「差分数组」的概念，举个简单的例子</p><p><img src="https://pic.leetcode-cn.com/1649302054-sjfBPU-1036101649298970IqiB0Himage-20220407103610070.png" alt="1036101649298970IqiB0Himage-20220407103610070.png"></p><p><code>diff[]</code> 和 <code>nums[]</code> 的关系：<code>diff[i] = nums[i] - nums[i - 1]</code>，<code>diff[0]</code> 除外</p><hr><h2 id="使用好处">使用好处</h2><p>当我们需要对 <code>nums[]</code> 进行上述三个要求时，不需要一次一次的遍历整个数组了，而只需要对 <code>diff[]</code> 进行一次 <code>O(1)</code> 的操作即可</p><ul><li>要求一：对 <code>num[2...4]</code> 全部 + 1  -&gt; <code>diff[2] += 1</code></li><li>要求二：对 <code>num[1...3]</code> 全部 - 3  -&gt; <code>diff[1] += (-3); diff[3 + 1] -= (-3)</code></li><li>要求三：对 <code>num[0...4]</code> 全部 + 9  -&gt; <code>diff[0] += 9</code></li></ul><p>总结：对于改变区间 <code>[i, j]</code> 的值，只需要进行如下操作 <code>diff[i] += val; diff[j + 1] -= val</code></p><p><strong>注</strong>：当 <code>j + 1 &gt;= diff.length</code> 时，不需要进行 <code>diff[j + 1] -= val</code> 操作</p><hr><h2 id="还原数据">还原数据</h2><p>怎么通过 <code>diff[]</code> 得到更新后的数组呢？？？？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复原操作</span></span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="comment">// 下标为 0 的元素相等</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res[i] = diff[i] + res[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="diff-原理">diff[] 原理</h2><p>还原数据就相当于对diff数组求一个前缀和。</p><p>当我们需要对区间 <code>[i, j]</code> 进行 <code>+ val</code> 操作时，我们对 <code>diff[i] += val; diff[j + 1] -= val;</code></p><p>在复原操作时，当我们求 <code>res[i]</code> 时，<code>res[i - 1]</code> 没有变，而 <code>diff[i]</code> 增加了 3，所以 <code>res[i]</code> 增加 3</p><p>当我们求 <code>res[i + 1]</code> 时，<code>res[i]</code> 增加了 3，而 <code>diff[i + 1]</code> 没有变，故 <code>res[i + 1] = diff[i + 1] + res[i]</code> 增加 3。即：虽然 <code>diff[i + 1]</code> 没有变，但是 <code>res[i]</code> 对后面的 <code>res[i + 1]</code> 有一个累积作用</p><p>当我们求 <code>res[j + 1]</code> 时，<code>res[j]</code> 增加了 3，而 <code>diff[j + 1]</code> 减少了 3，故 <code>res[j + 1] = diff[j + 1] + res[j]</code> 增加没有变。即：我们在 j + 1 的时候，把上述的累积作用去除了，所以 j + 1 后面的元素不受影响</p><hr><h2 id="完整模版">完整模版</h2><p>差分数组也可以不用原数组进行初始化，使用全为0的元素进行初始化，这样得到的结果数组就是偏移数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 差分数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化差分数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对区间 [i, j] 增加 val（val 可为负数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val val</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复原操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">差分数组</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>筛质数</title>
    <link href="https://wuwawawa.github.io/posts/996e4f07.html"/>
    <id>https://wuwawawa.github.io/posts/996e4f07.html</id>
    <published>2023-09-19T00:51:18.000Z</published>
    <updated>2023-12-09T12:25:39.835Z</updated>
    
    <content type="html"><![CDATA[<p>统计 [2,n] 中质数的数量是一个很常见的题目，也有很多巧妙高效的做法，接下来的部分只会讲述一些常见的做法。</p><h2 id="枚举">枚举</h2><p>很直观的思路是我们枚举每个数判断其是不是质数。</p><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x-1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。</p><p>考虑到如果 y 是 x 的因数，那么 x/y 也必然是x 的因数，因此我们只要校验 y 或者 x/y 。不难发现我们只需要枚举 [2,$\sqrt{x}$]即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li><p>时间复杂度O(n$\sqrt{n}$)。单个数检查的时间复杂度为O($\sqrt{n}$)，一共要检查n个数。</p></li><li><p>空间复杂度O(1)</p></li></ul><hr><hr><h2 id="埃氏筛">埃氏筛</h2><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。</p><p>我们创建一个数组 isPrime[n] , 其中 isPrime[i] 表示数 i 是不是质数。如果是质数则为 0 ，否则为 1 。</p><p>从小到大遍历每个数，如果这个数为质数，则将其所有倍数都标记为合数（除了该质数本身），这样在运行结束的时候我们就能知道质数的个数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,…这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) i * i &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= n; j += i) &#123;</span><br><span class="line">                    isPrime[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度O(nloglog n)。</li><li>空间复杂度O(n)</li></ul><hr><hr><h2 id="线性筛">线性筛</h2><p>埃氏筛其实还是存在冗余的标记操作，比如对于 45 这个数，它会同时被 3,5 两个数标记为合数，因此我们优化的目标是让每个合数只被标记一次，这样时间复杂度即能保证为 O(n)，这就是我们接下来要介绍的线性筛。</p><p>相较于埃氏筛，我们多维护一个 primes 数组表示当前得到的质数集合。我们从小到大遍历，如果当前的数 x 是质数，就将其加入 primes 数组。</p><p>另一点与埃氏筛不同的是，「标记过程」不再仅当 x 为质数时才进行，而是对每个整数 x 都进行。对于整数 x，我们不再标记其所有的倍数 x⋅x,x⋅(x+1),…，而是只标记质数集合中的数与 x 相乘的数，即 x⋅primes[0], x⋅primes[1] … ，且在发现 x mod primes[i] = 0 的时候结束当前标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> prime : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isPrime[i * prime] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primes.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="预处理质数">预处理质数</h2><p>在有些题目中，我们需要预处理质数，省去一些重复计算。</p><div class="tabs" id="c23a3bbc-d05e-4e05-abcf-62948c072c4e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c23a3bbc-d05e-4e05-abcf-62948c072c4e-1"><i class="fas fa-cat"></i>埃氏筛预处理</button></li><li class="tab"><button type="button" data-href="#c23a3bbc-d05e-4e05-abcf-62948c072c4e-2"><i class="fas fa-horse"></i>线性筛预处理</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c23a3bbc-d05e-4e05-abcf-62948c072c4e-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MX</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 0 表示是质数 1 表示是合数</span></span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[MX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= MX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) i * i &lt;= MX) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= MX; j += i) &#123;</span><br><span class="line">                    isPrime[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c23a3bbc-d05e-4e05-abcf-62948c072c4e-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MX</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 0 表示是质数 1 表示是合数</span></span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[MX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= MX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> prime : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime &gt; MX) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isPrime[i * prime] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">枚举、埃氏筛、线性筛</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://wuwawawa.github.io/posts/c517589e.html"/>
    <id>https://wuwawawa.github.io/posts/c517589e.html</id>
    <published>2023-09-14T01:33:46.000Z</published>
    <updated>2023-10-02T07:45:43.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原理">基本原理</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>顾名思义，并查集支持两种操作：</p><ul><li>合并(Union)：合并两个元素所属集合（合并对应的树）</li><li>查询(Find)：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li></ul><hr><hr><h2 id="函数模版">函数模版</h2><p>运用以下这三个函数可以构建并查集算法的基本框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] cnt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集的父节点数组，将每个元素的父节点都初始化为自己</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        N = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素x和元素y所在的集合合并成一个集合。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pra</span> <span class="operator">=</span> find(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">prb</span> <span class="operator">=</span> find(b);</span><br><span class="line">        <span class="keyword">if</span> (pra != prb) &#123;</span><br><span class="line">            parent[prb] = pra;</span><br><span class="line">            cnt[pra] += cnt[prb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素x的父节点，判断元素x属于哪个集合</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 连通块个数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getBlockNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == find(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">并查集</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>大数运算</title>
    <link href="https://wuwawawa.github.io/posts/8878d18a.html"/>
    <id>https://wuwawawa.github.io/posts/8878d18a.html</id>
    <published>2023-09-09T05:44:29.000Z</published>
    <updated>2023-09-14T01:35:39.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大数相加">大数相加</h2><p>算法流程： 设定 i，j 两指针分别指向 num1，num2 尾部，模拟人工加法；</p><p>计算进位： 计算 carry = tmp // 10，代表当前位相加是否产生进位；</p><p>添加当前位： 计算 tmp = n1 + n2 + carry，并将当前位 tmp % 10 添加至 res 头部；</p><p>索引溢出处理： 当指针 i或j 走过数字首部后，给 n1，n2 赋值为 0，相当于给 num1，num2 中长度较短的数字前面填 0，以便后续计算。</p><p>当遍历完 num1，num2 后跳出循环，并根据 carry 值决定是否在头部添加进位 1，最终返回 res 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1 + n2 + carry;</span><br><span class="line">        res.append(tmp % <span class="number">10</span>);</span><br><span class="line">        carry = tmp / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        res.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="大数相乘">大数相乘</h2><p>如果 <code>num1</code> 和 <code>num2</code> 之一是0 ，则直接将0作为结果返回即可。</p><p>如果 <code>num1</code> 和 <code>num2</code> 都不是0，则可以用过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果进行累加。</p><p>这道题中，被乘数是 <code>nums1</code> ,乘数是 <code>num2</code>。</p><p>需要注意的是，<code>num2</code> 除了最低位以外，其余的每一位的运算结果都需要补 0。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/sol1.png" alt="fig1" style="zoom:48%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> num1.length(), len2 = num2.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">curProduct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 补0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len2 - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            curProduct.append(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum2</span> <span class="operator">=</span> num2.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 curNum 去乘 num1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len1 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curNum1</span> <span class="operator">=</span> num1.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> curNum1 * curNum2 + carry;</span><br><span class="line"></span><br><span class="line">            curProduct.append(product % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = addStrings(ans,curProduct.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1 + n2 + carry;</span><br><span class="line">        res.append(tmp % <span class="number">10</span>);</span><br><span class="line">        carry = tmp / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        res.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="大数相减">大数相减</h2><p>1、执行计算前首先比较减数(num1)和被减数(num2)的大小，如果num1&gt;num2,那么就模拟num1-num2的过程，如果num1&lt;num2，那么结果就为-(num2-num1) 。当然可以为了稳定模拟时候一个大一个小，可将num1始终指向较大的那个数，少写一个if/else.</p><p>2、在比较两个数字大小的时候，因为是字符形式，首先比较两个字符串的长度，长的那个更大短的那个更小，如果两个字符串等大，那么就可以通过字典序从前往后进行比较(Java可直接使用compareTo方法)。</p><p>3、和加法不同的是，减法前面可能产生若干前缀0，这些0是需要你去掉的，例如&quot;1100&quot;-“1000&quot;计算得到的结果为&quot;0100”,你就要把前面的0去掉返回&quot;100&quot;。</p><p>4、具体实现的时候和加法相似，如果使用StringBuilder存储，需要逆置顺序，如果是个负数，前面还要加上’-'.</p><p>5、每个位置正常进行减法运算，如果值小于0，那么就需要向上借位(+10),那么处理上一位进行减法时候还要将借位的处理一下。</p><img src="https://ask.qcloudimg.com/http-save/yehe-4372098/mlwn6ygdwd.png" alt="img" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.length() &lt; num2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num1.length() &gt; num2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num1.compareTo(num2) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">subtractString</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="string">&#x27;+&#x27;</span>;<span class="comment">//正负号</span></span><br><span class="line">    <span class="comment">//让num1&gt;num2 如果num1&lt;num2 那么结果就是—(num2-num1)</span></span><br><span class="line">    <span class="comment">//可以先将num1和num2交换和前面情况统一</span></span><br><span class="line">    <span class="keyword">if</span> (!compare(num1, num2)) &#123;</span><br><span class="line">        sign = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">team</span> <span class="operator">=</span> num2;</span><br><span class="line">        num2 = num1;</span><br><span class="line">        num1 = team;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">borrow</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//借位</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? (num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? (num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> n1 - n2 - borrow;</span><br><span class="line">        borrow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)<span class="comment">//需要向前借位</span></span><br><span class="line">        &#123;</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">        sb.append(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sb = sb.reverse();<span class="comment">//需要先翻转</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//去掉前面没用的’0‘</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; sb.length() &amp;&amp; sb.charAt(index) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果两个数相同 直接返回&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (index == sb.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="string">&#x27;+&#x27;</span>)<span class="comment">//如果正数</span></span><br><span class="line">        <span class="keyword">return</span> sb.substring(index);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sign + sb.substring(index);<span class="comment">//负数需要返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="大数相除">大数相除</h2><p>对于大数a/b，一般最多要求求到其整数解或者余数，即a/b=c……d（a,b,c,d均为整）;也就是<strong>a里面有c个b</strong>，并且还剩下d。核心是先求c是多少，对于程序来说，可以通过枚举啊，将除法变成减法，从a中不断减d，一直到不能减为止。</p><p>但是有个问题，如果被除数a很大很大，可能有居多个b，那么这样时间复杂度太高了，不可能执行那么多次，那么需要怎么样去优化这个方法呢？</p><p>那就要加速寻找次数，减少这个减法的次数了，减法次数减小的一个最好方案就是能不能<strong>扩大除数b</strong>。如果b后面加个<code>'0'</code>，那么算出来的结果就乘以10，减法的次数变成原来十分之一。根据这个思想我们可以一直每次找到b的最大10的倍数(小于a)计算减的次数再换算成减b的总词数，将结果要以字符串方式保留，后面一直迭代到最后为止,这虽然是一道除法运算的题，但是也蕴含减法和加法(次数叠加到结果中)。</p>]]></content>
    
    
    <summary type="html">大数相加、大数相减、大数相乘、</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>限流算法</title>
    <link href="https://wuwawawa.github.io/posts/32609cb8.html"/>
    <id>https://wuwawawa.github.io/posts/32609cb8.html</id>
    <published>2023-09-02T05:04:36.000Z</published>
    <updated>2023-09-02T07:37:52.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="固定窗口算法">固定窗口算法</h2><h3 id="实现原理">实现原理</h3><p>固定窗口限流算法，也叫<span class='p green'>计数器限流算法</span>，是最简单的一种限流算法。</p><p><strong>实现原理是：</strong> 在一个固定长度的时间窗口内限制请求数量，每来一个请求，请求次数加一，如果请求数量超过最大限制，就拒绝该请求。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902132700830.png" alt="image-20230902132700830" style="zoom: 50%;" /><hr><h3 id="代码实现">代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定窗口限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixWindowLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10L</span>; <span class="comment">// 每个窗口的最大请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000L</span>; <span class="comment">// 窗口大小，单位ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">reqCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 窗口内的当前请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 窗口开始时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限流方法，返回true表示限流</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 判断是否在当前时间窗口内，如果不在就开启一个新的时间窗口</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastTime &gt; windowUnit) &#123;</span><br><span class="line">            <span class="comment">// 重置计数器</span></span><br><span class="line">            reqCount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 开启新窗口</span></span><br><span class="line">            lastTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// // 判断是否超过最大请求量</span></span><br><span class="line">        <span class="keyword">if</span> (reqCount &lt; threshold) &#123;</span><br><span class="line">            reqCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点">优缺点</h3><p><strong>优点：</strong> 实现简单，容易理解。</p><p><strong>缺点：</strong></p><ol><li>限流不够平滑。例如：限流是每秒3个，在第一毫秒发送了3个请求，达到限流，窗口剩余时间的请求都将会被拒绝，体验不好。</li><li>无法处理窗口边界问题。因为是在某个时间窗口内进行流量控制，所以可能会出现窗口边界效应，即在时间窗口的边界处可能会有大量的请求被允许通过，从而导致突发流量。</li></ol><p>例如：限流是每秒3个，在第一秒的最后一毫秒发送了3个请求，在第二秒的第一毫秒又发送了3个请求。在这两毫米内处理了6个请求，但是并没有触发限流。如果出现突发流量，可能会压垮服务器。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902134743416.png" alt="image-20230902134743416" style="zoom: 50%;" /><hr><hr><h2 id="滑动窗口算法">滑动窗口算法</h2><h3 id="实现原理-2">实现原理</h3><p>为了解决固定窗口算法统计精度太低的问题，引入了滑动窗口算法。在滑动窗口算法中，窗口的起止时间是动态的，窗口的大小固定。这种算法能够较好地处理窗口边界问题，但是实现相对复杂，需要记录每个请求的时间戳。</p><p><strong>实现原理是：</strong> 每来一个请求，就向后推一个时间窗口，计算这个窗口内的请求数量。如果请求数量超过限制就拒绝请求，否则就处理请求，并记录请求的时间戳。另外还需要一个任务清理过期的时间戳。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902135306151.png" alt="image-20230902135306151" style="zoom:50%;" /><hr><h3 id="代码实现-2">代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 每个窗口的最大请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 窗口大小，1000ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Long&gt; requestList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//  请求集合，用来存储窗口内的请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限流方法，返回true表示拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 统计当前窗口内，有效的请求数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeOfValid</span> <span class="operator">=</span> <span class="built_in">this</span>.sizeOfValid(currentTime);</span><br><span class="line">        <span class="comment">// 判断是否超过最大请求数量</span></span><br><span class="line">        <span class="keyword">if</span> (sizeOfValid &lt; threshold) &#123;</span><br><span class="line">            <span class="comment">// 把当前请求添加到请求集合里</span></span><br><span class="line">            requestList.add(currentTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计当前窗口内，有效的请求数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sizeOfValid</span><span class="params">(<span class="type">long</span> currentTime)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeOfValid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long requestTime : requestList) &#123;</span><br><span class="line">            <span class="comment">// 判断是否在当前时间窗口内</span></span><br><span class="line">            <span class="keyword">if</span> (currentTime - requestTime &lt;= windowUnit) &#123;</span><br><span class="line">                sizeOfValid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sizeOfValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理过期的请求（单独启动一个线程处理）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否超出当前时间窗口内</span></span><br><span class="line">        requestList.removeIf(requestTime -&gt; System.currentTimeMillis() - requestTime &gt; windowUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点-2">优缺点</h3><p><strong>优点：</strong> 解决了固定窗口算法的窗口边界问题，避免突发流量压垮服务器。</p><p><strong>缺点：</strong> 还是存在限流不够平滑的问题。例如：限流是每秒3个，在第一毫秒发送了3个请求，达到限流，剩余窗口时间的请求都将会被拒绝，体验不好。</p><hr><hr><h2 id="漏桶算法">漏桶算法</h2><h3 id="实现原理-3">实现原理</h3><p>漏桶限流算法是一种常用的流量整形（Traffic Shaping）和流量控制（Traffic Policing）的算法，它可以有效地控制数据的传输速率以及防止网络拥塞。</p><p>实现原理是：</p><ol><li>一个固定容量的漏桶，按照固定速率出水（处理请求）；</li><li>当流入水（请求数量）的速度过大会直接溢出（请求数量超过限制则直接拒绝）。</li><li>桶里的水（请求）不够则无法出水（桶内没有请求则不处理）。</li></ol><p>当请求流量正常或者较小的时候，请求能够得到正常的处理。当请求流量过大时，漏桶限流算法可以通过丢弃部分请求来防止系统过载。</p><p>这种算法的一个重要特性是，输出数据的速率始终是稳定的，无论输入的数据流量如何变化。这就确保了系统的负载不会超过预设的阈值。但是，由于漏桶的出口速度是固定的，所以无法处理突发流量。此外，如果入口流量过大，漏桶可能会溢出，导致数据丢失。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902144242297.png" alt="image-20230902144242297" style="zoom:50%;" /><hr><h3 id="算法实现">算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucketLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 桶的最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 桶内当前水量(当前累计的请求数)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">leakRate</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 漏水速率(每秒系统能处理的请求数)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastLeakTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 上次漏水时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true，表示限流</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用漏水方法</span></span><br><span class="line">        <span class="built_in">this</span>.leak();</span><br><span class="line">        <span class="comment">// 判断是否超过最大请求数量</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; threshold) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 漏水方法，计算并更新这段时间内漏水量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leak</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 计算这段时间内，需要流出的水量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">leakWater</span> <span class="operator">=</span> (currentTime - lastLeakTime) * leakRate / <span class="number">1000</span>;</span><br><span class="line">        count = Math.max(count - leakWater, <span class="number">0</span>);</span><br><span class="line">        lastLeakTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点-3">优缺点</h3><p><strong>优点：</strong></p><ol><li>**平滑流量。**由于漏桶算法以固定的速率处理请求，可以有效地平滑和整形流量，避免流量的突发和波动（类似于消息队列的削峰填谷的作用）。</li><li>**防止过载。**当流入的请求超过桶的容量时，可以直接丢弃请求，防止系统过载。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>无法处理突发流量</strong>：由于漏桶的出口速度是固定的，无法处理突发流量。面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这不是我们想看到的。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验。</li><li><strong>可能会丢失数据</strong>：如果入口流量过大，超过了桶的容量，那么就需要丢弃部分请求。在一些不能接受丢失请求的场景中，这可能是一个问题。</li><li><strong>不适合速率变化大的场景</strong>：如果速率变化大，或者需要动态调整速率，那么漏桶算法就无法满足需求。</li></ol><hr><hr><h2 id="令牌桶算法">令牌桶算法</h2><h3 id="实现原理-4">实现原理</h3><p>令牌桶限流算法是一种常用的流量整形和速率限制算法。与漏桶算法一样，令牌桶算法也是用来控制发送到网络上的数据的数量。</p><p>实现原理：</p><ol><li>系统以固定的速率向桶中添加令牌；</li><li>当有请求到来时，会尝试从桶中移除一个令牌，如果桶中有足够的令牌，则请求可以被处理或数据包可以被发送；</li><li>如果桶中没有令牌，那么请求将被拒绝；</li><li>桶中的令牌数不能超过桶的容量，如果新生成的令牌超过了桶的容量，那么新的令牌会被丢弃。</li></ol><p>令牌桶算法的一个重要特性是，它能够应对突发流量。当桶中有足够的令牌时，可以一次性处理多个请求，这对于需要处理突发流量的应用场景非常有用。但是又不会无限制的增加处理速率导致压垮服务器，因为桶内令牌数量是有限制的。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902150018034.png" alt="image-20230902150018034" style="zoom:50%;" /><hr><h3 id="代码实现-3">代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucketLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 桶的最大容量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 桶内当前的令牌数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">tokenRate</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 令牌生成速率（每秒5次）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastRefillTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 上次生成令牌的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true表示限流</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用生成令牌方法</span></span><br><span class="line">        <span class="built_in">this</span>.refillTokens();</span><br><span class="line">        <span class="comment">// 判断桶内是否还有令牌</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成令牌方法，计算并更新这段时间内生成的令牌数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refillTokens</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 计算这段时间内，需要生成的令牌数量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">refillTokens</span> <span class="operator">=</span> (currentTime - lastRefillTime) * tokenRate / <span class="number">1000</span>;</span><br><span class="line">        count = Math.min(count + refillTokens, threshold);</span><br><span class="line">        lastRefillTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点-4">优缺点</h3><p><strong>优点：</strong></p><ol><li><strong>可以处理突发流量</strong>：令牌桶算法可以处理突发流量。当桶满时，能够以最大速度处理请求。这对于需要处理突发流量的应用场景非常有用。</li><li><strong>限制平均速率</strong>：在长期运行中，数据的传输率会被限制在预定义的平均速率（即生成令牌的速率）。</li><li><strong>灵活性</strong>：与漏桶算法相比，令牌桶算法提供了更大的灵活性。例如，可以动态地调整生成令牌的速率。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>可能导致过载</strong>：如果令牌产生的速度过快，可能会导致大量的突发流量，这可能会使网络或服务过载。</li><li><strong>需要存储空间</strong>：令牌桶需要一定的存储空间来保存令牌，可能会导致内存资源的浪费。</li><li><strong>实现稍复杂</strong>：相比于计数器算法，令牌桶算法的实现稍微复杂一些。</li></ol><hr><hr><h2 id="总结">总结</h2><p><strong>固定窗口算法</strong>实现简单，但是限流不够平滑，存在窗口边界问题，适用于需要简单实现限流的场景。</p><p><strong>滑动窗口算法</strong>解决了窗口边界问题，但是还是存在限流不够平滑的问题，适用于需要控制平均请求速率的场景。</p><p><strong>漏桶算法</strong>的优点是流量处理更平滑，但是无法应对突发流量，适用于需要平滑流量的场景。</p><p><strong>令牌桶算法</strong>既能平滑流量，又能处理突发流量，适用于需要处理突发流量的场景。</p>]]></content>
    
    
    <summary type="html">固定窗口、滑动窗口、漏桶和令牌桶限流</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="限流算法" scheme="https://wuwawawa.github.io/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找-红蓝边界法</title>
    <link href="https://wuwawawa.github.io/posts/c1110203.html"/>
    <id>https://wuwawawa.github.io/posts/c1110203.html</id>
    <published>2023-08-11T06:49:12.000Z</published>
    <updated>2023-09-14T13:32:08.638Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是一种在有序数组中查找某一特定元素的搜索算法。在很多人的印象里，二分查找是一种比较简单的算法。然而在实际中，二分查找经常容易写错，特别是在处理边界条件的时候。算法大神高德纳曾经说过，“虽然二分查找的基本思想相对简单直白，但是细节上却惊人的tricky”。</p><h2 id="问题">问题</h2><p>给定有序数组<code>1 2 3 5 5 5 8 9</code>，有4个小问题分别是：</p><ol><li><p>找到第一个<code>&gt;=5</code>的元素</p></li><li><p>找到最后一个<code>&lt;5</code>的元素</p></li><li><p>找到第一个<code>&gt;5</code>的元素</p></li><li><p>找到最后一个<code>&lt;=5</code>的元素</p></li></ol><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230715195248912.png" alt="image-20230715195248912" style="zoom: 50%;" /><p>大家可以看到，对于这四个问题来说，它们表面上是比较相似的，但是细节上却有些微的不同，它们的答案也是完全不同的。</p><p>可想而知，如果我们用二分查找来解决这个问题，细节处理并不容易，一不小心可能就会出错。</p><hr><hr><h2 id="新的角度">新的角度</h2><p>让我们暂时忘掉刚才的问题，从一个全新的角度来审视二分查找。</p><p>大家可以看到，这里有一个数组，里面一共有N个元素，这些元素的编号是0到N-1。在这N个元素里面，前K个元素颜色是蓝色，后面的元素是红色。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716093005464.png" alt="image-20230716093005464" style="zoom:80%;" /><p>然而，在这个问题中，蓝红边界的位置是未知的，即K是未知的。换句话说，在我们一开始拿到数组的时候，整个数组都是灰色的。这个问题的最终目标，是把蓝红边界找出来，即求出未知数K。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716093139742.png" alt="image-20230716093139742" style="zoom:80%;" /><hr><h2 id="朴素算法">朴素算法</h2><p>在这里，我们假设一共有9个元素，前面5个元素是蓝色，后面4个元素是红色</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716093644294.png" alt="image-20230716093644294"></p><p>在我们一开始拿到数组的时候，整个数组都是灰色的。</p><p>我们可以设计一个蓝色指针，一开始指向最左面，随后不断向右移动，直到移动到蓝红边界。或者设计一个红色指针，一开始指向最右面，然后不断向左移动，直到移动到蓝红边界。</p><p>这样就求得了蓝红边界所在的位置。</p><p>当然，这种算法是非常低效的，它的算法复杂度是O(n）</p><hr><h2 id="二分查找">二分查找</h2><p>接下来我们看一下如何通过二分查找高效的寻找到蓝红边界，在刚才的朴素算法中，我们持续不断的将蓝色指针向右移动。对于这个过程，我们可以把它理解为蓝色区域不断被拓展。同理，红色指针不断向左移动，我们可以把这个过程理解为红色区域不断被拓展。</p><p>朴素算法之所以效率低下，是因为蓝色区域和红色区域的拓展是缓慢进行的，每次只能拓展一个元素。</p><hr><h3 id="基本步骤">基本步骤</h3><blockquote><p>那么，我们有没有什么办法来加速两个区域的拓展过程呢？</p></blockquote><div class="tabs" id="c747378e-3702-44cf-8e98-a9f5063d2056"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c747378e-3702-44cf-8e98-a9f5063d2056-1"><i class="fas fa-seedling"></i>循环次数1</button></li><li class="tab"><button type="button" data-href="#c747378e-3702-44cf-8e98-a9f5063d2056-2"><i class="fas fa-leaf"></i>循环次数2</button></li><li class="tab"><button type="button" data-href="#c747378e-3702-44cf-8e98-a9f5063d2056-3"><i class="fab fa-apple"></i>循环次数3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c747378e-3702-44cf-8e98-a9f5063d2056-1"><p>我们可以这样做，我们可以直接看一下灰色区域最中间的那个元素颜色。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094245363.png" alt="image-20230716094245363"></p><p>在这里，我们发现这个元素颜色为蓝色。它就意味着，这个元素，以及这个元素之前所有的元素都是蓝色。这样的话，我们便可以直援将蓝色区域拓展到这个元素所在位置。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094329526.png" alt="image-20230716094329526"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c747378e-3702-44cf-8e98-a9f5063d2056-2"><p>让我们继续这样的操作。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094455062.png" alt="image-20230716094455062"></p><p>观察灰色区域中最中间的那个元素颜色，我们发现它是红色，这也就说明了，这个元素以及这个元素后面的元素都是红色。这样的话，我们便可以直接将红色区域拓展到这个元素所在的位置。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094652765.png" alt="image-20230716094652765"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c747378e-3702-44cf-8e98-a9f5063d2056-3"><p>接下来，我们不断的重复这种操作</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094835833.png" alt="image-20230716094835833"></p><p>直到最后，我们便找到了蓝红边界</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094859442.png" alt="image-20230716094859442"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="伪代码实现">伪代码实现</h3><div class="tabs" id="33539071-8bba-4bca-a801-0931002f5bff"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-4"><i class="fas fa-tree"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="33539071-8bba-4bca-a801-0931002f5bff-1"><p>一开始，我们设计L，R两个指针，L指向-1,R指向N</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095333538.png" alt="image-20230716095333538"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="33539071-8bba-4bca-a801-0931002f5bff-2"><p>当L+1！=R的时候，就会进入循环体。</p><p>然后，我们求得灰色区域中间的那个元素位置M，M=(L+R) /2并且向下取整。如果M的颜色是蓝色，我们就将L赋值为M，也就是将蓝色区域拓展到M。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095536554.png" alt="image-20230716095536554"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="33539071-8bba-4bca-a801-0931002f5bff-3"><p>如果M的颜色是红色，我们便将R赋值为M，也就是将红色区域拓展到M</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095650860.png" alt="image-20230716095650860"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="33539071-8bba-4bca-a801-0931002f5bff-4"><p>我们持续不断的重复这个过程，直到达成L+1=R这个条件，便退出循环。</p><p>此时，我们可以发现，L和R刚刚好指向蓝红边界，我们可以根据实际情况来决定返回L还是R。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095837237.png" alt="image-20230716095837237"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="细节问题">细节问题</h3><p>刚刚我绍的二分查找伪代码，可能和大家在其他地方所看到的版本有所不同。为了进一步证明算法的正确性，让我们看几个细节问题。</p><blockquote><p>为什么<span class='p blue'>L</span>的初始值为-1，<span class='p red'>R</span>的初始值为N?</p></blockquote><p>难道我们不能将L初始化为0，或者让R初始化为N-1么?</p><p>答案是不可以</p><p>试想一下，假如整个数组都是红色,那么如果让L初始化为0，L一开始便处于红色区域内，这也便会造成错误。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100233717.png" alt="image-20230716100233717"></p><p>同理，如果整个数组都是蓝色，那么如果让R初始化为N-1，R一开始便处于蓝色区域，也就造成了错误。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100344067.png" alt="image-20230716100344067"></p><p>所以，我们需要让L初始化为-1，R初始化为N。</p><hr><blockquote><p>更新指针时，能不能写成L=m+1，或者R=m-1?</p></blockquote><p>比如说，对于这样一种情况，在某次循环中，M刚刚好指向蓝色区域的最后一个元素。那么，如果我们让L变成M+1，就会让L指向红色区域，这样就造成了错误。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100809314.png" alt="image-20230716100809314"></p><hr><h2 id="问题答案">问题答案</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100920458.png" alt="image-20230716100920458"></p><hr><h2 id="一般流程">一般流程</h2><ul><li>建模：划分<span class='p blue'>蓝</span><span class='p red'>红</span>区域，确定<code>isBlue()</code>函数</li><li>确定返回<span class='p blue'>L</span>还是<span class='p red'>R</span></li><li>套用算法模版</li><li>后处理逻辑</li></ul>]]></content>
    
    
    <summary type="html">二分查找</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://wuwawawa.github.io/posts/e8eb0480.html"/>
    <id>https://wuwawawa.github.io/posts/e8eb0480.html</id>
    <published>2023-08-10T02:28:21.000Z</published>
    <updated>2023-09-14T13:32:14.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寻找一个数-基本的二分查找">寻找一个数(基本的二分查找)</h2><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意点分析</p></blockquote><div class="tabs" id="5c9537ee-7214-4745-8b2a-37749be89f75"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5c9537ee-7214-4745-8b2a-37749be89f75-1"><i class="fas fa-seedling"></i>while循环退出条件</button></li><li class="tab"><button type="button" data-href="#5c9537ee-7214-4745-8b2a-37749be89f75-2"><i class="fas fa-leaf"></i>l和r更新</button></li><li class="tab"><button type="button" data-href="#5c9537ee-7214-4745-8b2a-37749be89f75-3"><i class="fab fa-apple"></i>缺陷</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5c9537ee-7214-4745-8b2a-37749be89f75-1"><p><mark class="hl-label blue">为什么while循环的条件中是&lt;=而不是&lt;</mark></p><p>因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code></p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p><p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。</p><p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有索引既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[left, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5c9537ee-7214-4745-8b2a-37749be89f75-2"><p>什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断？</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？</p><p>当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> 对不对？因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5c9537ee-7214-4745-8b2a-37749be89f75-3"><p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="寻找第一个满足该条件的值">寻找第一个满足该条件的值</h2><p>当 check(mid) == true 调整的是 r 时：计算 mid 的方式应该为 mid = l + r &gt;&gt; 1</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">int</span> l = <span class="number">0</span>, r = <span class="built_in">n</span> - <span class="number">1</span>;</span><br><span class="line">while (l &lt; r) &#123;</span><br><span class="line">       <span class="built_in">int</span> <span class="built_in">mid</span> = l + r &gt;&gt; <span class="number">1</span>; //推荐写法 <span class="built_in">int</span> <span class="built_in">mid</span> = l +( r - l) / <span class="number">2</span>;</span><br><span class="line">       <span class="built_in">if</span> (check(<span class="built_in">mid</span>)) &#123;</span><br><span class="line">           //偏移r, 求第一个满足该条件的值</span><br><span class="line">           r = <span class="built_in">mid</span>;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           l = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="寻找最后一个满足该条件的值">寻找最后一个满足该条件的值</h2><p>当 check(mid) == true 调整的是 l 时：计算 mid 的方式应该为 mid = l + r + 1 &gt;&gt; 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//向上取整， +1 操作主要是为了避免发生「死循环」</span></span><br><span class="line">       <span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">           <span class="comment">//偏移l, 求最后一个满足该条件的值</span></span><br><span class="line">           l = mid;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           r = mid - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二分查找</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="https://wuwawawa.github.io/posts/f92eff5d.html"/>
    <id>https://wuwawawa.github.io/posts/f92eff5d.html</id>
    <published>2023-08-02T04:06:11.000Z</published>
    <updated>2023-09-14T01:35:44.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="划分k个相等的子集">划分k个相等的子集</h2><div class="tabs" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-1"><i class="fas fa-seedling"></i>火柴拼正方形</button></li><li class="tab"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-2"><i class="fas fa-leaf"></i>划分为k个相等的子集</button></li><li class="tab"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-4"><i class="fas fa-tree"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-1"><div class="tag link"><a class="link-card" title="473. 火柴拼正方形" href="https://leetcode.cn/problems/matchsticks-to-square/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">473. 火柴拼正方形</p><p class="url">https://leetcode.cn/problems/matchsticks-to-square/</p></div></a></div><p>你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。</p><p>如果你能使这个正方形，则返回 true ，否则返回 false 。</p><div class="tabs" id="10b05bf4-7acc-4492-a4d8-1a859f0abe58"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#10b05bf4-7acc-4492-a4d8-1a859f0abe58-1"><i class="fas fa-cat"></i>解法一</button></li><li class="tab"><button type="button" data-href="#10b05bf4-7acc-4492-a4d8-1a859f0abe58-2"><i class="fas fa-horse"></i>解法二</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="10b05bf4-7acc-4492-a4d8-1a859f0abe58-1"><p>边界条件时不需要对每个桶是否都达到target进行判断。</p><p>若某个桶的长度小于target，那达到末尾时，就必然会有桶长度大于target。而这种情况不会进入下一次递归的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] matchsticks;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makesquare</span><span class="params">(<span class="type">int</span>[] _matchsticks)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(_matchsticks).sum();</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    target = sum/<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    matchsticks = Arrays.stream(_matchsticks).boxed().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span> , <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> idx ,<span class="type">int</span>[] edges)</span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(idx == matchsticks.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前的木棍放置到4个桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">        edges[i] += matchsticks[idx];</span><br><span class="line">        <span class="keyword">if</span>(edges[i] &lt;= target &amp;&amp; dfs(idx + <span class="number">1</span>,edges))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edges[i] -= matchsticks[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="10b05bf4-7acc-4492-a4d8-1a859f0abe58-2"><p>状态压缩+记忆化</p><p>使用<code>curSum + matchsticks[i] &lt;= side</code>和<code>int newSum = (curSum + matchsticks[i]) % side;</code></p><p>两种方式巧妙实现单边的增长以及当达到side时进行下一条边的选择。</p><p>当sum&lt;side时，sum会一直累积。当刚好达到side时，清0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> side; <span class="comment">// 边长</span></span><br><span class="line"><span class="type">int</span>[] cache;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] matchsticks;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makesquare</span><span class="params">(<span class="type">int</span>[] _matchsticks)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(_matchsticks).sum();</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    side = sum / <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    matchsticks = Arrays.stream(_matchsticks).boxed().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    n = _matchsticks.length;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">    cache[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> curSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[state] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[state] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((state &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; curSum + matchsticks[i] &lt;= side) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newSum</span> <span class="operator">=</span> (curSum + matchsticks[i]) % side;</span><br><span class="line">            <span class="keyword">if</span> (dfs(state | (<span class="number">1</span> &lt;&lt; i), newSum)) &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache[state] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-2"><div class="tag link"><a class="link-card" title="698. 火柴拼正方形" href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">698. 火柴拼正方形</p><p class="url">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</p></div></a></div><p>给定一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p><p>同上一题写法</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">回溯</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从暴力递归到动态规划</title>
    <link href="https://wuwawawa.github.io/posts/1d80917d.html"/>
    <id>https://wuwawawa.github.io/posts/1d80917d.html</id>
    <published>2023-07-05T13:11:40.000Z</published>
    <updated>2023-09-14T01:35:54.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><h3 id="什么暴力递归可以继续优化？">什么暴力递归可以继续优化？</h3><p>有重复调用同一个子问题的解，这种递归可以优化</p><p>如果每一个子问题都是不同的解，无法优化也不用优化</p><hr><h3 id="暴力递归和动态规划的关系">暴力递归和动态规划的关系</h3><p>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划</p><p>任何动态规划问题，都一定对应着某一个有重复过程的暴力递归</p><p>但不是所有的暴力递归，都一定对应着动态规划</p><hr><h3 id="如何找到问题的动态规划方式？">如何找到问题的动态规划方式？</h3><ul><li>设计暴力递归：原则+4种常见尝试模型！</li><li>分析有没有重复解</li><li>用记忆化搜索-&gt;用严格表结构实现动态规划</li><li>看看能否继续优化</li></ul><hr><h3 id="设计暴力递归过程的原则">设计暴力递归过程的原则</h3><p>1）每一个可变参数的类型，一定不要比int类型更加复杂</p><p>2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数（贴纸问题）</p><p>3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可</p><p>4）可变参数的个数，能少则少</p><p>一定要逼自己找到不违反原则情况下的暴力尝试！</p><p>如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！</p><p>如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！</p><hr><h3 id="常见的4种尝试模型">常见的4种尝试模型</h3><p>1）从左往右的尝试模型：关注i位置结尾，或者i位置开头的情况，或者看i联合i+1,i+2的情况，填表往往是上到下，或者下到上，左到右，右到左。</p><p>2）范围上的尝试模型：关注L和R的情况，填表格式非常固定，主对角，副对角，倒回来填</p><p>3）多样本位置全对应的尝试模型：2个样本，一个样本做行，一个样本做列，关注i和j对应位置的情况，先填边界，再填中间</p><p>4）寻找业务限制的尝试模型：比如走棋盘，固定的几个方向可以走，先填边界，再填中间。</p><hr><h3 id="暴力递归到动态规划的套路">暴力递归到动态规划的套路</h3><p>1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用<br>2）找到哪些参数的变化会影响返回值，对每一个列出变化范围<br>3）参数间的所有的组合数量，意味着表大小<br>4）记忆化搜索的方法就是傻缓存，非常容易得到<br>5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解<br>6）对于有枚举行为的决策过程，进一步优化</p><hr><h3 id="动态规划的进一步优化">动态规划的进一步优化</h3><p>1）空间压缩<br>2）状态化简<br>3）四边形不等式</p><p>4）其他优化技巧</p><hr><hr><h2 id="从左往右的尝试模型">从左往右的尝试模型</h2><p>关注i位置结尾，或者i位置开头的情况，或者看i联合i+1,i+2的情况，填表往往是上到下，或者下到上，左到右，右到左。</p><h3 id="题目一">题目一</h3><p>假设有排成一行的N个位置，记为1~N，N 一定大于或等于2</p><p>开始时机器人在其中的M位置上(M 一定是1~N 中的一个）</p><p>如果机器人来到1位置，那么下一步只能往右来到2位置；</p><p>如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；</p><p>如果机器人来到中间位置，那么下一步可以往左走或者往右走；</p><p>规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个）的方法有多少种</p><p>给定四个参数N、M、K、P，返回方法数。</p><div class="tabs" id="6fc3a967-8198-4bf8-900f-bd039c7f5726"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-1"><i class="fas fa-seedling"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-2"><i class="fas fa-leaf"></i>重复解分析</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-3"><i class="fab fa-apple"></i>傻缓存法</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-4"><i class="fas fa-heartbeat"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-5"><i class="fas fa-tree"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways1</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process1(start, K, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 机器人当前来到的位置是cur，</span></span><br><span class="line"><span class="comment">// 机器人还有rest步需要去走，</span></span><br><span class="line"><span class="comment">// 最终的目标是aim，</span></span><br><span class="line"><span class="comment">// 有哪些位置？1~N</span></span><br><span class="line"><span class="comment">// 返回：机器人从cur出发，走过rest步之后，最终停在aim的方法数，是多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> aim, <span class="type">int</span> N)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123; <span class="comment">// 如果已经不需要走了，走完了！</span></span><br><span class="line"><span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line"><span class="keyword">if</span> (cur == <span class="number">1</span>) &#123; <span class="comment">// 1 -&gt; 2</span></span><br><span class="line"><span class="keyword">return</span> process1(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line"><span class="keyword">if</span> (cur == N) &#123; <span class="comment">// N-1 &lt;- N</span></span><br><span class="line"><span class="keyword">return</span> process1(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line"><span class="keyword">return</span> process1(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N) + process1(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-2"><p>假如从7位置出发走到13，还有10步需要走，存在重复解。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230706110749520.png" alt="image-20230706110749520" style="zoom:67%;" /><p>cur和rest是决定返回值的key</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-3"><p>记忆化搜索（从顶向下的动态规划）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways2</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp就是缓存表</span></span><br><span class="line"><span class="comment">// dp[cur][rest] == -1 -&gt; process1(cur, rest)之前没算过！</span></span><br><span class="line"><span class="comment">// dp[cur][rest] != -1 -&gt; process1(cur, rest)之前算过！返回值，dp[cur][rest]</span></span><br><span class="line"><span class="comment">// N+1 * K+1</span></span><br><span class="line"><span class="keyword">return</span> process2(start, K, aim, N, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cur 范: 1 ~ N</span></span><br><span class="line"><span class="comment">// rest 范：0 ~ K</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> aim, <span class="type">int</span> N, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[cur][rest] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之前没算过！</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">ans = cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">ans = process2(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">ans = process2(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans = process2(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp) + process2(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">&#125;</span><br><span class="line">dp[cur][rest] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-4"><p>假设现在有5个位置，机器人当前在2位置，要前往4位置，有6步需要走</p><p>即N = 5，cur=2，aim=4，rest=6</p><div class="tabs" id="ada86bca-98db-41ea-ad53-a4296606c901"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ada86bca-98db-41ea-ad53-a4296606c901-1"><i class="fas fa-cat"></i>初始情况</button></li><li class="tab"><button type="button" data-href="#ada86bca-98db-41ea-ad53-a4296606c901-2"><i class="fas fa-horse"></i>basecase和ans</button></li><li class="tab"><button type="button" data-href="#ada86bca-98db-41ea-ad53-a4296606c901-3"><i class="fas fa-dove"></i>普遍位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ada86bca-98db-41ea-ad53-a4296606c901-1"><p>cur = 0位置是弃用的，cur只能是1-N</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E5%88%9D%E5%A7%8B%E6%83%85%E5%86%B51.png" alt="初始情况1"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ada86bca-98db-41ea-ad53-a4296606c901-2"><p>主函数中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">process1</span><span class="params">(start, K, aim, N)</span></span>;</span><br></pre></td></tr></table></figure><p>暴力递归函数中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123; <span class="comment">// 如果已经不需要走了，走完了！</span></span><br><span class="line"><span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当rest等于0时，只有cur==aim是，才是1，最终需要process(2,6)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/baseCase%E5%92%8Cans1.png" alt="baseCase和ans1"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ada86bca-98db-41ea-ad53-a4296606c901-3"><p>暴力递归中</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line">if (cur == <span class="number">1</span>) &#123; <span class="comment">// 1 -&gt; 2</span></span><br><span class="line">return <span class="built_in">process1</span>(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line">if (cur == N) &#123; <span class="comment">// N-1 &lt;- N</span></span><br><span class="line">return <span class="built_in">process1</span>(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line">return <span class="built_in">process1</span>(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N) + <span class="built_in">process1</span>(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br></pre></td></tr></table></figure><p>既不是第一行，也不最后一行，普遍位置依赖坐上角的值和坐下角的值</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%99%AE%E9%81%8D%E4%BD%8D%E7%BD%AE1.png" alt="普遍位置1"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways3</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">dp[aim][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= K; rest++) &#123;</span><br><span class="line">dp[<span class="number">1</span>][rest] = dp[<span class="number">2</span>][rest - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">2</span>; cur &lt; N; cur++) &#123;</span><br><span class="line">dp[cur][rest] = dp[cur - <span class="number">1</span>][rest - <span class="number">1</span>] + dp[cur + <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[N][rest] = dp[N - <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[start][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="题目二">题目二</h3><p>规定1和A对应、2和B对应、3和C对应…</p><p>那么一个数字字符串比如&quot;111&quot;就可以转化为：“AAA”、“KA&quot;和&quot;AK”</p><p>给定一个只有数字字符组成的字符串str，返回有多少种转化结果</p><div class="tabs" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2b7683cc-3522-45ca-9ef3-7374aaed0b7a-1"><i class="fas fa-cat"></i>暴力尝试</button></li><li class="tab"><button type="button" data-href="#2b7683cc-3522-45ca-9ef3-7374aaed0b7a-2"><i class="fas fa-horse"></i>重复问题分析</button></li><li class="tab"><button type="button" data-href="#2b7683cc-3522-45ca-9ef3-7374aaed0b7a-3"><i class="fas fa-dragon"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str只含有数字字符0~9</span></span><br><span class="line"><span class="comment">// 返回多少种转化方案</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">number</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[0..i-1]转化无需过问</span></span><br><span class="line"><span class="comment">// str[i.....]去转化，返回有多少种转化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i没到最后，说明有字符</span></span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 之前的决定有问题</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// str[i] != &#x27;0&#x27;</span></span><br><span class="line"><span class="comment">// 可能性一，i单转</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> process(str, i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">ways += process(str, i + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a-2"><p>假如str = “111”</p><p>两个1 解读为两个字符  p(0)-&gt;p(2)</p><p>两个1 解读为一个字符  p(0)-&gt;p(2)</p><p>存在重复问题</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">dp[N] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> dp[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">ways += dp[i + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="背包问题">背包问题</h3><div class="tabs" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-1"><i class="fas fa-bug"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-2"><i class="fas fa-cannabis"></i>重复解分析</button></li><li class="tab"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-3"><i class="fas fa-candy-cane"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-4"><i class="fas fa-child"></i>严格位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的货，重量和价值，都在w和v数组里</span></span><br><span class="line"><span class="comment">// 为了方便，其中没有负数</span></span><br><span class="line"><span class="comment">// bag背包容量，不能超过这个载重</span></span><br><span class="line"><span class="comment">// 返回：不超重的情况下，能够得到的最大价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length != v.length || w.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试函数！</span></span><br><span class="line"><span class="keyword">return</span> process(w, v, <span class="number">0</span>, bag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前考虑到了index号货物，index...所有的货物可以自由选择</span></span><br><span class="line"><span class="comment">// 做的选择不能超过背包容量</span></span><br><span class="line"><span class="comment">// 返回最大价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 不要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest);</span><br><span class="line">  <span class="comment">// 要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest - w[index]);</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = v[index] + next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-2"><p>w = [3,2,5…]</p><p>v = [7,4,6…]</p><p>bag = 15</p><p>要了0，1号货，没要2号货调用过程  p(0,15)-&gt;p(1,12)-p(2,10)-&gt;p(3,10)</p><p>没要0，1，但是要了2号货调用过程 p(0,15)-&gt;p(1,15)-&gt;p(2,15)-&gt;p(3,10)</p><p>存在重复调用</p><p>index rest 即为变量</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-3"><p>假设背包大小为10，共有4件物品</p><div class="tabs" id="e59b06c7-c7b9-4440-bffd-7640af43b5de"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e59b06c7-c7b9-4440-bffd-7640af43b5de-1"><i class="fas fa-seedling"></i>basecase和ans</button></li><li class="tab"><button type="button" data-href="#e59b06c7-c7b9-4440-bffd-7640af43b5de-2"><i class="fas fa-leaf"></i>普遍位置分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e59b06c7-c7b9-4440-bffd-7640af43b5de-1"><p>index 在递归中是可以到w.length的</p><p>最终需要process(0,bag)状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98basecase.png" alt="背包问题basecase"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e59b06c7-c7b9-4440-bffd-7640af43b5de-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 不要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest);</span><br><span class="line"> <span class="comment">// 要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest - w[index]);</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = v[index] + next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设</p><p>w[1] = 2 v[1] = 4，则普遍位置？依赖如图所示</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%99%AE%E9%81%8D%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%96.png" alt="背包问题普遍位置依赖"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length != v.length || w.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> w.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][bag + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= bag; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> rest - w[index] &lt; <span class="number">0</span> ? -<span class="number">1</span> : dp[index + <span class="number">1</span>][rest - w[index]];</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = v[index] + next;</span><br><span class="line">&#125;</span><br><span class="line">dp[index][rest] = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="零钱兑换问题">零钱兑换问题</h3><h4 id="零钱兑换问题Ⅰ">零钱兑换问题Ⅰ</h4><p>arr是货币数组，其中的值都是正数。再给定一个正数aim。</p><p>每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的。</p><p>返回组成aim的方法数</p><p>例如：art ={1,1,1} aim = 2</p><p>第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2 一共就3种方法，所以返回3</p><div class="tabs" id="183f6f4e-28dc-487b-81f9-db439f37ab9c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#183f6f4e-28dc-487b-81f9-db439f37ab9c-1"><i class="fas fa-atom"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#183f6f4e-28dc-487b-81f9-db439f37ab9c-2"><i class="far fa-sun"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="183f6f4e-28dc-487b-81f9-db439f37ab9c-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinWays</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index....] 组成正好rest这么多的钱，有几种方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 没钱了！</span></span><br><span class="line"><span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, index + <span class="number">1</span>, rest) + process(arr, index + <span class="number">1</span>, rest - arr[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="183f6f4e-28dc-487b-81f9-db439f37ab9c-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest] + (rest - arr[index] &gt;= <span class="number">0</span> ? dp[index + <span class="number">1</span>][rest - arr[index]] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h4 id="零钱兑换问题Ⅱ-斜率优化">零钱兑换问题Ⅱ(斜率优化)</h4><p>arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。</p><p>每个值都认为是一种面值，且认为张数是无限的，返回组成aim的方法数。</p><p>例如：arr ={1,2)， aim = 4</p><p>方法如下：1+1+1+1、1+1+2、2+2一共就3种方法，所以返回3</p><div class="tabs" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-1"><i class="fas fa-bug"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-2"><i class="fas fa-cannabis"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-3"><i class="fas fa-candy-cane"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-4"><i class="fas fa-child"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinsWay</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 没钱了</span></span><br><span class="line"><span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">ways += process(arr, index + <span class="number">1</span>, rest - (zhang * arr[index]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-2"><p>index = 2 时   面值为3</p><p>f(2,10) -&gt; f(3,10)  f(3,7)  f(3,4)  f(3,1)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A21111.png" alt="零钱兑换1111"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">ways += dp[index + <span class="number">1</span>][rest - (zhang * arr[index])];</span><br><span class="line">&#125;</span><br><span class="line">dp[index][rest] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-4"><p>当一个格子没有枚举行为，只依赖有限的格子时，记忆化搜索和严格表结构一样的好</p><p>当一个格子有枚举行为，可以根据位置依赖严格表结构进行分析，进一步优化</p><p>index = 2 时   面值为3</p><p>p(2,10) = p(3,10) +p(3,7)+p(3,4) +p(3,1)</p><p>注意看</p><p>p(2,7) = p(3,7)+p(3,4) +p(3,1)</p><p>所以</p><p>p(2,10) = p(3,10) +p(2,7)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2222.png" alt="零钱兑换222"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[index][rest] += dp[index][rest - arr[index]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="零钱兑换问题Ⅲ-斜率优化">零钱兑换问题Ⅲ(斜率优化)</h4><p>arr是货币数组，其中的值都是正数。再给定一个正数aim。</p><p>每个值都认为是一张货币，认为值相同的货币没有任何不同，</p><p>返回组成aim的方法数</p><p>例如：arr={1,2,1,1,2,1,2)， aim = 4</p><p>方法：1+1+1+1、 1+1+2、 2+2 一共就3种方法，所以返回3</p><div class="tabs" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-1"><i class="fas fa-cat"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-2"><i class="fas fa-horse"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-3"><i class="fas fa-dove"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-4"><i class="fas fa-dragon"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinsWay</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(value)) &#123;</span><br><span class="line">            counts.put(value, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counts.put(value, counts.get(value) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> counts.size();</span><br><span class="line">    <span class="type">int</span>[] coins = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span>[] zhangs = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">        coins[index] = entry.getKey();</span><br><span class="line">        zhangs[index++] = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(coins, zhangs, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// coins 面值数组，正数且去重</span></span><br><span class="line"><span class="comment">// zhangs 每种面值对应的张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span>[] zhangs, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == coins.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * coins[index] &lt;= rest &amp;&amp; zhang &lt;= zhangs[index]; zhang++) &#123;</span><br><span class="line">        ways += process(coins, zhangs, index + <span class="number">1</span>, rest - (zhang * coins[index]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-2"><p>假设aim = 13</p><p>货币数设处理后为</p><p>coins = [1,3,4]</p><p>zhangs = [1,2,3]</p><p>p(2,10) = a +b+c</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2444.png" alt="零钱兑换444"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-3"><pre><code>public static int dp1(int[] arr, int aim) {if (arr == null || arr.length == 0 || aim &lt; 0) {return 0;}Info info = getInfo(arr);int[] coins = info.coins;int[] zhangs = info.zhangs;int N = coins.length;int[][] dp = new int[N + 1][aim + 1];dp[N][0] = 1;for (int index = N - 1; index &gt;= 0; index--) {for (int rest = 0; rest &lt;= aim; rest++) {int ways = 0;for (int zhang = 0; zhang * coins[index] &lt;= rest &amp;&amp; zhang &lt;= zhangs[index]; zhang++) {ways += dp[index + 1][rest - (zhang * coins[index])];}dp[index][rest] = ways;}}return dp[0][aim];}</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-4"><p>p(2,10) = a+b+c</p><p>p(2,7) = b+c+d</p><p>p(2,10) = a+p(2,7)-d</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%A2%86%E5%8F%96%E5%85%91%E6%8D%A2333.png" alt="领取兑换333"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> getInfo(arr);</span><br><span class="line"><span class="type">int</span>[] coins = info.coins;</span><br><span class="line"><span class="type">int</span>[] zhangs = info.zhangs;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> coins.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - coins[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[index][rest] += dp[index][rest - coins[index]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rest - coins[index] * (zhangs[index] + <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[index][rest] -= dp[index + <span class="number">1</span>][rest - coins[index] * (zhangs[index] + <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="零钱兑换问题Ⅳ-斜率优化">零钱兑换问题Ⅳ(斜率优化)</h4><p>ar是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。</p><p>每个值都认为是一种面值，且认为张数是无限的。</p><p>返回组成aim的最少货币数</p><div class="tabs" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-1"><i class="fas fa-cat"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-2"><i class="fas fa-horse"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-3"><i class="fas fa-dove"></i>严格表依赖</button></li><li class="tab"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-4"><i class="fas fa-dragon"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCoins</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index...]面值，每种面值张数自由选择，</span></span><br><span class="line"><span class="comment">// 搞出rest正好这么多钱，返回最小张数</span></span><br><span class="line"><span class="comment">// 拿Integer.MAX_VALUE标记怎么都搞定不了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(arr, index + <span class="number">1</span>, rest - zhang * arr[index]);</span><br><span class="line"><span class="keyword">if</span> (next != Integer.MAX_VALUE) &#123;</span><br><span class="line">ans = Math.min(ans, zhang + next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-2"><p>p(2,10) = min (a,b,c,d)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1666.png" alt="零钱666"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">dp[N][j] = Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][rest - zhang * arr[index]];</span><br><span class="line"><span class="keyword">if</span> (next != Integer.MAX_VALUE) &#123;</span><br><span class="line">ans = Math.min(ans, zhang + next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[index][rest] = ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-4"><p>p(2,10) = min (a,b+1,c+2,d+3)</p><p>p(2,7) = min(b,c+1,d+2)</p><p>p(2,10) = min(a,p(2,7)+1)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6777.png" alt="零777"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">dp[N][j] = Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span> </span><br><span class="line">&amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="数字分割问题">数字分割问题</h3><h4 id="数字分割问题Ⅰ-斜率优化">数字分割问题Ⅰ(斜率优化)</h4><p>将数num进行裂开，要求后面的数不能小于前面的数，返回裂开的方式数</p><p>例如</p><p>3 = 1+1+1 = 1+2  = 3</p><p>不能 2+1这样裂开</p><p>返回 3</p><div class="tabs" id="0ffe2f89-db64-4548-8e41-67e6895903cc"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-2"><i class="fas fa-baseball-ball"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-3"><i class="fas fa-bone"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-4"><i class="fas fa-anchor"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0ffe2f89-db64-4548-8e41-67e6895903cc-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n为正数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一个拆出来的数是pre</span></span><br><span class="line"><span class="comment">// 还剩rest需要去拆</span></span><br><span class="line"><span class="comment">// 返回拆解的方法数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre &gt; rest) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> pre; first &lt;= rest; first++) &#123;</span><br><span class="line">ways += process(first, rest - first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ffe2f89-db64-4548-8e41-67e6895903cc-2"><p>假设 num = 8</p><p>p(3,6) = p(3,3)+p(4,2)+p(5,1)+p(6,0)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E5%88%86%E5%89%B2%E6%95%B0%E5%AD%974.png" alt="分割数字4"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ffe2f89-db64-4548-8e41-67e6895903cc-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>; pre &lt;= n; pre++) &#123;</span><br><span class="line">dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[pre][pre] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> n - <span class="number">1</span>; pre &gt;= <span class="number">1</span>; pre--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> pre + <span class="number">1</span>; rest &lt;= n; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> pre; first &lt;= rest; first++) &#123;</span><br><span class="line">ways += dp[first][rest - first];</span><br><span class="line">&#125;</span><br><span class="line">dp[pre][rest] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ffe2f89-db64-4548-8e41-67e6895903cc-4"><p>p(3,6) = p(3,3)+p(4,2)+p(5,1)+p(6,0)</p><p>p(4,6) = p(4,2)+p(5,1)+p(6,0)</p><p>p(3,6) = p(3,3)+p(4,6)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E5%88%86%E5%89%B2%E6%95%B0%E5%AD%975.png" alt="分割数字5"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>; pre &lt;= n; pre++) &#123;</span><br><span class="line">dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[pre][pre] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> n - <span class="number">1</span>; pre &gt;= <span class="number">1</span>; pre--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> pre + <span class="number">1</span>; rest &lt;= n; rest++) &#123;</span><br><span class="line">dp[pre][rest] = dp[pre + <span class="number">1</span>][rest];</span><br><span class="line">dp[pre][rest] += dp[pre][rest - pre];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h4 id="数字分割问题Ⅱ">数字分割问题Ⅱ</h4><p>给定一个正数数组arr,请把arr中所有数分成两个集合，尽量让两个集合的累加和接近</p><p>返回：</p><p>最接近的情况下，较小集合的累加和</p><div class="tabs" id="0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-1"><i class="fas fa-seedling"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-2"><i class="fab fa-apple"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, sum / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[i...]可以自由选择，请返回累加和尽量接近rest，但不能超过rest的情况下，最接近的累加和是多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 还有数，arr[i]这个数</span></span><br><span class="line"><span class="comment">// 可能性1，不使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(arr, i + <span class="number">1</span>, rest);</span><br><span class="line"><span class="comment">// 可能性2，要使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= rest) &#123;</span><br><span class="line">p2 = arr[i] + process(arr, i + <span class="number">1</span>, rest - arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= sum; rest++) &#123;</span><br><span class="line"><span class="comment">// 可能性1，不使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i + <span class="number">1</span>][rest];</span><br><span class="line"><span class="comment">// 可能性2，要使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= rest) &#123;</span><br><span class="line">p2 = arr[i] + dp[i + <span class="number">1</span>][rest - arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">dp[i][rest] = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="数字分割问题Ⅲ">数字分割问题Ⅲ</h4><p>给定一个正数数组arr，请把arr中所有的数分成两个集合</p><p>如果arr长度为偶数，两个集合包含数的个数要一样多</p><p>如果ar长度为奇数，两个集合包含数的个数必须只差一个</p><p>请尽量让两个集合的累加和接近。</p><p>返回：</p><p>最接近的情况下，较小集合的累加和</p><div class="tabs" id="141151c9-b391-4995-af55-9e30d6dfa3c4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#141151c9-b391-4995-af55-9e30d6dfa3c4-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#141151c9-b391-4995-af55-9e30d6dfa3c4-2"><i class="fas fa-baseball-ball"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="141151c9-b391-4995-af55-9e30d6dfa3c4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>, sum / <span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>, sum / <span class="number">2</span>), process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span> + <span class="number">1</span>, sum / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[i....]自由选择，挑选的个数一定要是picks个，累加和&lt;=rest, 离rest最近的返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> picks, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> picks == <span class="number">0</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(arr, i + <span class="number">1</span>, picks, rest);</span><br><span class="line"><span class="comment">// 就是要使用arr[i]这个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= rest) &#123;</span><br><span class="line">next = process(arr, i + <span class="number">1</span>, picks - <span class="number">1</span>, rest - arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = arr[i] + next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="141151c9-b391-4995-af55-9e30d6dfa3c4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> (N + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][M + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= M; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= sum; k++) &#123;</span><br><span class="line">dp[i][j][k] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= sum; rest++) &#123;</span><br><span class="line">dp[N][<span class="number">0</span>][rest] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">picks</span> <span class="operator">=</span> <span class="number">0</span>; picks &lt;= M; picks++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= sum; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i + <span class="number">1</span>][picks][rest];</span><br><span class="line"><span class="comment">// 就是要使用arr[i]这个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (picks - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[i] &lt;= rest) &#123;</span><br><span class="line">next = dp[i + <span class="number">1</span>][picks - <span class="number">1</span>][rest - arr[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = arr[i] + next;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][picks][rest] = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][arr.length / <span class="number">2</span>][sum];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(dp[<span class="number">0</span>][arr.length / <span class="number">2</span>][sum], dp[<span class="number">0</span>][(arr.length / <span class="number">2</span>) + <span class="number">1</span>][sum]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><hr><h2 id="范围上的尝试模型">范围上的尝试模型</h2><p>关注L和R的情况，填表格式非常固定，主对角，副对角，倒回来填</p><h3 id="题目一-2">题目一</h3><p>给定一个整型数组arr，代表数值不同的纸牌排成一条线</p><p>玩家A和玩家B依次拿走每张纸牌</p><p>规定玩家A先拿，玩家B后拿</p><p>但是每个玩家每次只能拿走最左或最右的纸牌</p><p>玩家A和玩家B都绝顶聪明</p><p>请返回最后获胜者的分数。</p><div class="tabs" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-1"><i class="fas fa-atom"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-2"><i class="far fa-sun"></i>重复解分析</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-3"><i class="fas fa-wind"></i>傻缓存法</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-4"><i class="fas fa-heartbeat"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-5"><i class="fas fa-fire-alt"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据规则，返回获胜者的分数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> f1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> g1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Math.max(first, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，先手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> arr[L] + g1(arr, L + <span class="number">1</span>, R);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> arr[R] + g1(arr, L, R - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // arr[L..R]，后手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">g1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f1(arr, L + <span class="number">1</span>, R); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f1(arr, L, R - <span class="number">1</span>); <span class="comment">// 对手拿走了R位置的数</span></span><br><span class="line"><span class="keyword">return</span> Math.min(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-2"><p>0-7号纸牌</p><p>对于先手来说，在f(0,7)做最优选择</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230706120741650.png" alt="image-20230706120741650" style="zoom:67%;" /><p>出现重叠</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] fmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="type">int</span>[][] gmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">fmap[i][j] = -<span class="number">1</span>;</span><br><span class="line">gmap[i][j] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> f2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, fmap, gmap);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> g2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, fmap, gmap);</span><br><span class="line"><span class="keyword">return</span> Math.max(first, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，先手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>[][] fmap, <span class="type">int</span>[][] gmap)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fmap[L][R] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> fmap[L][R];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">ans = arr[L];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> arr[L] + g2(arr, L + <span class="number">1</span>, R, fmap, gmap);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> arr[R] + g2(arr, L, R - <span class="number">1</span>, fmap, gmap);</span><br><span class="line">ans = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">fmap[L][R] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // arr[L..R]，后手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">g2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>[][] fmap, <span class="type">int</span>[][] gmap)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (gmap[L][R] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> gmap[L][R];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L != R) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f2(arr, L + <span class="number">1</span>, R, fmap, gmap); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f2(arr, L, R - <span class="number">1</span>, fmap, gmap); <span class="comment">// 对手拿走了R位置的数</span></span><br><span class="line">ans = Math.min(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">gmap[L][R] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-4"><p>假如arr = [7,4,16,15,1]</p><div class="tabs" id="d26e497e-188d-4de1-9c81-a51e2769de01"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d26e497e-188d-4de1-9c81-a51e2769de01-1"><i class="fas fa-award"></i>basease和ans</button></li><li class="tab"><button type="button" data-href="#d26e497e-188d-4de1-9c81-a51e2769de01-2"><i class="fas fa-baseball-ball"></i>普遍位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d26e497e-188d-4de1-9c81-a51e2769de01-1"><p>f的basecase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>g的basecase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终需要的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> f1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> g1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Math.max(first, second);</span><br></pre></td></tr></table></figure><p>即<code>Math.max(fmap[0][4],gmap[0][4]);</code></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/basecase%E5%92%8Cans2.png" alt="basecase和ans2"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d26e497e-188d-4de1-9c81-a51e2769de01-2"><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int p1 = arr[L] + g1(arr, <span class="class">L + 1, R);</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">int </span>p2 = arr[R] + g1(arr, <span class="class">L, R - 1);</span></span><br></pre></td></tr></table></figure><p>fmap ？位置依赖</p><p>作gmap中？位置对称点？'，？位置依赖gmap中△ 位置。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%962-1.png" alt="位置依赖2-1"></p><p>同理分析gmap中？位置的依赖</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> p1 = f1(arr, L + <span class="number">1</span>, R); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line"><span class="built_in">int</span> p2 = f1(arr, L, R - <span class="number">1</span>); <span class="comment">// 对手拿走了R位置的数</span></span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%962-2.png" alt="位置依赖2-2"></p><p>互推对角线</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win3</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] fmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="type">int</span>[][] gmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">fmap[i][i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> <span class="number">1</span>; startCol &lt; N; startCol++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> startCol;</span><br><span class="line"><span class="keyword">while</span> (R &lt; N) &#123;</span><br><span class="line">fmap[L][R] = Math.max(arr[L] + gmap[L + <span class="number">1</span>][R], arr[R] + gmap[L][R - <span class="number">1</span>]);</span><br><span class="line">gmap[L][R] = Math.min(fmap[L + <span class="number">1</span>][R], fmap[L][R - <span class="number">1</span>]);</span><br><span class="line">L++;</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(fmap[<span class="number">0</span>][N - <span class="number">1</span>], gmap[<span class="number">0</span>][N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="最长回文子序列长度-带优化">最长回文子序列长度(带优化)</h3><p>给定一个字符串str，返回这个字符串的最长回文子序列长度</p><p>比如：str = “a12b3c43def2ghi1kpm”</p><p>最长回文子序列是 “1234321” 或者 “123c321”，返回长度7</p><blockquote><p>解法1</p></blockquote><p>生成str的逆序串</p><p>str逆 = “mpk1ihg2fed34cb21a”</p><p>原串和逆序串的最长公共子序列即为原串的最长回文子序列</p><blockquote><p>解法2：范围尝试模型</p></blockquote><div class="tabs" id="bd07aba8-9097-4e19-bd74-af70a8555478"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-1"><i class="fas fa-seedling"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-2"><i class="fab fa-apple"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-3"><i class="fas fa-leaf"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-4"><i class="fas fa-heartbeat"></i>继续优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="bd07aba8-9097-4e19-bd74-af70a8555478-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl1</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">return</span> f(str, <span class="number">0</span>, str.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[L..R]最长回文子序列长度返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L == R - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str[L] == str[R] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f(str, L + <span class="number">1</span>, R - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f(str, L, R - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> f(str, L + <span class="number">1</span>, R);</span><br><span class="line"><span class="type">int</span> <span class="variable">p4</span> <span class="operator">=</span> str[L] != str[R] ? <span class="number">0</span> : (<span class="number">2</span> + f(str, L + <span class="number">1</span>, R - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> Math.max(Math.max(p1, p2), Math.max(p3, p4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd07aba8-9097-4e19-bd74-af70a8555478-2"><p>basecase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L == R - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str[L] == str[R] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ans</p><p>f(0,str.length - 1)</p><p>从底往上填</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97222.png" alt="最长回文子序列222"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd07aba8-9097-4e19-bd74-af70a8555478-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl2</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">dp[N - <span class="number">1</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i] = <span class="number">1</span>;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> N - <span class="number">3</span>; L &gt;= <span class="number">0</span>; L--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + <span class="number">2</span>; R &lt; N; R++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[L+<span class="number">1</span>][R-<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[L][R-<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> dp[L+<span class="number">1</span>][R];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p4</span> <span class="operator">=</span> str[L] == stl[R] ? <span class="number">2</span> + dp[L + <span class="number">1</span>][R - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">dp[L][R] = Math.max(Math.max(p1,p2),Math.max(p3,p4));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd07aba8-9097-4e19-bd74-af70a8555478-4"><p>?格子要求出来依赖左、左下和下。并是取最大值。</p><p>那么？格子绝不比坐下和下格子小</p><p>在之前求左格子时，依赖它的左、左下和下</p><p>那么在图中，左格子不可能比左下格子小。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230706170257845.png" alt="image-20230706170257845"></p><p><mark class="hl-label blue">优化</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl2</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">dp[N - <span class="number">1</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i] = <span class="number">1</span>;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> N - <span class="number">3</span>; L &gt;= <span class="number">0</span>; L--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + <span class="number">2</span>; R &lt; N; R++) &#123;</span><br><span class="line">dp[L][R] = Math.max(dp[L][R - <span class="number">1</span>], dp[L + <span class="number">1</span>][R]);</span><br><span class="line"><span class="keyword">if</span> (str[L] == str[R]) &#123;</span><br><span class="line">dp[L][R] = Math.max(dp[L][R], <span class="number">2</span> + dp[L + <span class="number">1</span>][R - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="多样本位置全对应的尝试模型">多样本位置全对应的尝试模型</h2><p>多个样本，一个样本做行，一个样本做列，关注i和j对应位置的情况，先填边界，再填中间</p><h3 id="最长公共子序列">最长公共子序列</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p><div class="tabs" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2ce89215-5f65-4349-8cf3-c2ca8eb27f51-1"><i class="fas fa-bug"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#2ce89215-5f65-4349-8cf3-c2ca8eb27f51-2"><i class="fas fa-cannabis"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#2ce89215-5f65-4349-8cf3-c2ca8eb27f51-3"><i class="fas fa-candy-cane"></i>严格位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence1</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line"><span class="comment">// 尝试</span></span><br><span class="line"><span class="keyword">return</span> process1(str1, str2, str1.length - <span class="number">1</span>, str2.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// str1[0...i]与str2[0...j]最长公共子序列多长？</span></span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str1[i] == str2[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// i != 0 &amp;&amp; j != 0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> str1[i] == str2[j] ? (<span class="number">1</span> + process1(str1, str2, i - <span class="number">1</span>, j - <span class="number">1</span>)) : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, Math.max(p2, p3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51-2"><p>假设str1 = “a12c3d”,str2 = “efg123xy”</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%9711.png" alt="最长公共子序列11"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence2</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> str2.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][M];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = str1[<span class="number">0</span>] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = str1[<span class="number">0</span>] == str2[j] ? <span class="number">1</span> : dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = str1[i] == str2[<span class="number">0</span>] ? <span class="number">1</span> : dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> str1[i] == str2[j] ? (<span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">dp[i][j] = Math.max(p1, Math.max(p2, p3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N - <span class="number">1</span>][M - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="表达式匹配TODO">表达式匹配TODO</h3><hr><hr><hr><h2 id="寻找业务限制的尝试模型">寻找业务限制的尝试模型</h2><p>比如走棋盘，固定的几个方向可以走，先填边界，再填中间。</p><h3 id="题目一-3">题目一</h3><p>请同学们自行搜索或者想象一个象棋的棋盘，</p><p>然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置</p><p>那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域给你三个参数x，y，k</p><p>返回马从(0,0)位置出发，必须走k步</p><p>最后落在(x,y)上的方法数有多少种？</p><div class="tabs" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-2"><i class="fas fa-baseball-ball"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-3"><i class="fas fa-bone"></i>严格位置分析</button></li><li class="tab"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-4"><i class="fas fa-anchor"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前来到的位置是（x,y）</span></span><br><span class="line"><span class="comment">// 还剩下rest步需要跳</span></span><br><span class="line"><span class="comment">// 跳完rest步，正好跳到a，b的方法数是多少？</span></span><br><span class="line"><span class="comment">// 10 * 9</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(<span class="number">0</span>, <span class="number">0</span>, k, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rest, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (x == a &amp;&amp; y == b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> process(x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-2"><p>以xy为xy轴，rest为轴</p><p>以不同rest为不同层，同一层之间是不相互依赖的</p><p>从第0层推第一层。。。。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-3"><p>在递归时越界时，我们还能返回0。在数组中越界了可就报错了，所以写一个函数从数组中取出来。</p><p>越界了就返回0，没越界才给你去拿</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">9</span>][k + <span class="number">1</span>];</span><br><span class="line">dp[a][b][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= k; rest++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; <span class="number">9</span>; y++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> pick(dp, x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">dp[x][y][rest] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pick</span><span class="params">(<span class="type">int</span>[][][] dp, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[x][y][rest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="题目二-空间优化">题目二(空间优化)</h3><p>给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和返回最小距离累加和</p><p>若<code>dp[i][j]</code>的意思表示为 从(i , j)点走到右下角，最省的路径和是多少。则<code>dp[0][0]</code>为最终答案</p><p>若<code>dp[i][j]</code>的意思表示为 从(0 , 0)点到(i , j)点，最省的路径和是多少。则<code>dp[row - 1][col - 1]</code>为最终答案</p><p>两种写法都可以</p><div class="tabs" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-1"><i class="fas fa-seedling"></i>空间依赖分析</button></li><li class="tab"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-2"><i class="fas fa-leaf"></i>严格表依赖</button></li><li class="tab"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-3"><i class="fab fa-apple"></i>空间优化分析</button></li><li class="tab"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-4"><i class="fas fa-tree"></i>优化代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-1"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84111.png" alt="最短路径111"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathSum1</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> m.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + m[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + m[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-3"><p>在我们推第17行的值时只需要16行的值，之前行的值已经不需要了。</p><p>在更新c的时候，左边已经是更新好的，当前位置还未跟新。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96111.png" alt="空间优化111"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathSum2</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> m.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[col];</span><br><span class="line">dp[<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[j] = dp[j - <span class="number">1</span>] + m[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>] += m[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="贴纸问题">贴纸问题</h3><p>给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文</p><p>arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来</p><p>返回需要至少多少张贴纸可以完成这个任务</p><p>例子：str = “babac” ,arr={“ba”,“c”,“abcd”}</p><p>至少需要两张贴纸&quot;ba&quot;和&quot;abcd&quot;,因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2。</p><div class="tabs" id="c5e51d73-18c3-429e-bba5-5f04a785aca8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c5e51d73-18c3-429e-bba5-5f04a785aca8-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#c5e51d73-18c3-429e-bba5-5f04a785aca8-2"><i class="fas fa-baseball-ball"></i>词频表优化</button></li><li class="tab"><button type="button" data-href="#c5e51d73-18c3-429e-bba5-5f04a785aca8-3"><i class="fas fa-bone"></i>哈希表优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c5e51d73-18c3-429e-bba5-5f04a785aca8-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers1</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process1(stickers, target);</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有贴纸stickers，每一种贴纸都有无穷张</span></span><br><span class="line"><span class="comment">// target</span></span><br><span class="line"><span class="comment">// 最少张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (String first : stickers) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> minus(target, first);</span><br><span class="line"><span class="keyword">if</span> (rest.length() != target.length()) &#123;</span><br><span class="line">min = Math.min(min, process1(stickers, rest));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minus</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line"><span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str1) &#123;</span><br><span class="line">count[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str2) &#123;</span><br><span class="line">count[cha - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count[i]; j++) &#123;</span><br><span class="line">builder.append((<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c5e51d73-18c3-429e-bba5-5f04a785aca8-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers2</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="comment">// 关键优化(用词频表替代贴纸数组)</span></span><br><span class="line"><span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">counts[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process2(counts, target);</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stickers[i] 数组，当初i号贴纸的字符统计 int[][] stickers -&gt; 所有的贴纸</span></span><br><span class="line"><span class="comment">// 每一种贴纸都有无穷张</span></span><br><span class="line"><span class="comment">// 返回搞定target的最少张数</span></span><br><span class="line"><span class="comment">// 最少张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[][] stickers, String t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target做出词频统计</span></span><br><span class="line"><span class="comment">// target  aabbc  2 2 1..</span></span><br><span class="line"><span class="comment">//                0 1 2..</span></span><br><span class="line"><span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line"><span class="type">int</span>[] tcounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : target) &#123;</span><br><span class="line">tcounts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="comment">// 尝试第一张贴纸是谁</span></span><br><span class="line"><span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line"><span class="comment">// 最关键的优化(重要的剪枝!这一步也是贪心!)</span></span><br><span class="line"><span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> tcounts[j] - sticker[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums; k++) &#123;</span><br><span class="line">builder.append((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">min = Math.min(min, process2(stickers, rest));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c5e51d73-18c3-429e-bba5-5f04a785aca8-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers3</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">counts[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HashMap&lt;String, Integer&gt; dp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">dp.put(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process3(counts, target, dp);</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process3</span><span class="params">(<span class="type">int</span>[][] stickers, String t, HashMap&lt;String, Integer&gt; dp)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dp.containsKey(t)) &#123;</span><br><span class="line"><span class="keyword">return</span> dp.get(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line"><span class="type">int</span>[] tcounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : target) &#123;</span><br><span class="line">tcounts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line"><span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> tcounts[j] - sticker[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums; k++) &#123;</span><br><span class="line">builder.append((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">min = Math.min(min, process3(stickers, rest, dp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">dp.put(t, ans);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> ]]></content>
    
    
    <summary type="html">暴力递归、记忆化搜索、严格表结构、斜率优化</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
