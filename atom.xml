<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LuckyBoy🥝</title>
  
  
  <link href="https://wuwawawa.github.io/atom.xml" rel="self"/>
  
  <link href="https://wuwawawa.github.io/"/>
  <updated>2023-05-24T04:06:35.709Z</updated>
  <id>https://wuwawawa.github.io/</id>
  
  <author>
    <name>LuckyBoy🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://wuwawawa.github.io/posts/da3e1361.html"/>
    <id>https://wuwawawa.github.io/posts/da3e1361.html</id>
    <published>2023-05-24T04:02:50.000Z</published>
    <updated>2023-05-24T04:06:35.709Z</updated>
    
    
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="https://wuwawawa.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>HashMap和TreeMap</title>
    <link href="https://wuwawawa.github.io/posts/9a196584.html"/>
    <id>https://wuwawawa.github.io/posts/9a196584.html</id>
    <published>2023-05-22T09:47:10.000Z</published>
    <updated>2023-05-22T14:49:55.102Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap继承体系">HashMap继承体系</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522184524368.png" alt="image-20230522184524368"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><p>HashMap是Map里面的一个实现类。</p><p>没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。</p><p>特点都是由键决定的：无序、不重复、无索引</p><p>HashMap跟HashSet底层原理是一模一样的，都是哈希表结构</p><h2 id="HashMap底层原理">HashMap底层原理</h2><div class="tabs" id="d8861ef8-b02e-43e2-925f-acf859a71222"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d8861ef8-b02e-43e2-925f-acf859a71222-1"><i class="fas fa-atom"></i>1</button></li><li class="tab"><button type="button" data-href="#d8861ef8-b02e-43e2-925f-acf859a71222-2"><i class="far fa-sun"></i>2</button></li><li class="tab"><button type="button" data-href="#d8861ef8-b02e-43e2-925f-acf859a71222-3"><i class="fas fa-wind"></i>3</button></li><li class="tab"><button type="button" data-href="#d8861ef8-b02e-43e2-925f-acf859a71222-4"><i class="fas fa-fire-alt"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d8861ef8-b02e-43e2-925f-acf859a71222-1"><p>当创建一个HashMap对象的时候，在底层创建了一个长度为16，负载因子为0.75的<code>Node&lt;K,V&gt;[] table</code>数组。</p><p>在利用put方法就可以添加数据了，put方法的底层会创建一个Entry对象，Entry对象记录的就是要添加的键和值。</p><p><span class='p red'>再利用键计算出键的Hash值，只要键的Hash值，和值无关。</span></p><p>然后再计算出数组中该存入的索引4，如果该位置为null，就直接添加进去。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522195854184.png" alt="image-20230522195854184" style="zoom:50%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522200359353.png" alt="image-20230522200359353" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d8861ef8-b02e-43e2-925f-acf859a71222-2"><p>再添加一个Entry对象，计算出来的索引还是4，那此时4索引处就不是null了。</p><p>调用equals方法比较键的属性值，只比较键的属性值，</p><p>如果键里面的数据是一样的，那么它就会覆盖原有的Entry对象。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522200427206.png" alt="image-20230522200427206" style="zoom:67%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522200447565.png" alt="image-20230522200447565" style="zoom: 67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d8861ef8-b02e-43e2-925f-acf859a71222-3"><p>如果equal比较完后，发现键不一样，就会添加新的Entry对象</p><p>在JDK8以前，新元素添加到数组当中，旧元素挂在下面，形成一条链表</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522200715009.png" alt="image-20230522200715009" style="zoom:67%;" /><p>在JDK8以后就没有那么复杂了</p><p>新的元素直接挂在老元素的下面，形成一条链表</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522200803368.png" alt="image-20230522200803368" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d8861ef8-b02e-43e2-925f-acf859a71222-4"><p>额外的，在JDK8的时候，为了提升性能，当链表的长度超过8且数组的长度大于等于64的时候，链表就会自动转成红黑树。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522201115466.png" alt="image-20230522201115466" style="zoom:67%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522201131434.png" alt="image-20230522201131434" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <blockquote><p>总结</p></blockquote><ol><li><p>HashMap底层是哈希表结构的</p></li><li><p>依赖hashCode方法和equals方法保证<span class='p red'>键的唯一</span></p></li><li><p>如果键存储的是自定义对象，需要重写hashCode和equals方法</p></li><li><p>如果值存储自定义对象，不需要重写hashCode和equals方法</p></li></ol><hr><hr><h2 id="HashMap关键字段分析">HashMap关键字段分析</h2><div class="tabs" id="77fc3bbe-ef4c-40d7-8b63-40523f4490a0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#77fc3bbe-ef4c-40d7-8b63-40523f4490a0-1"><i class="fas fa-bug"></i>1</button></li><li class="tab"><button type="button" data-href="#77fc3bbe-ef4c-40d7-8b63-40523f4490a0-2"><i class="fas fa-cannabis"></i>2</button></li><li class="tab"><button type="button" data-href="#77fc3bbe-ef4c-40d7-8b63-40523f4490a0-3"><i class="fas fa-candy-cane"></i>3</button></li><li class="tab"><button type="button" data-href="#77fc3bbe-ef4c-40d7-8b63-40523f4490a0-4"><i class="fas fa-child"></i>4</button></li><li class="tab"><button type="button" data-href="#77fc3bbe-ef4c-40d7-8b63-40523f4490a0-5"><i class="fas fa-seedling"></i>5</button></li><li class="tab"><button type="button" data-href="#77fc3bbe-ef4c-40d7-8b63-40523f4490a0-6"><i class="fas fa-leaf"></i>6</button></li><li class="tab"><button type="button" data-href="#77fc3bbe-ef4c-40d7-8b63-40523f4490a0-7"><i class="fab fa-apple"></i>7</button></li><li class="tab"><button type="button" data-href="#77fc3bbe-ef4c-40d7-8b63-40523f4490a0-8"><i class="fas fa-tree"></i>8</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="77fc3bbe-ef4c-40d7-8b63-40523f4490a0-1"><p>这个字段表示默认的哈希表的长度，也就是<code>HashMap</code>底层使用数组的默认长度，在<code>HashMap</code>当中底层所使用的的数组的长度必须是<code>2</code>的整数次幂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="77fc3bbe-ef4c-40d7-8b63-40523f4490a0-2"><p>这个字段表示哈希表当中数组的最大长度，<code>HashMap</code>底层使用的数组长度不能超过这个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="77fc3bbe-ef4c-40d7-8b63-40523f4490a0-3"><p>字段<code>DEFAULT_LOAD_FACTOR</code>的作用表示在<code>HashMap</code>当中默认的负载因子的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>在实际情况当中我们并不是当<code>HashMap</code>当中的数组完全被使用完之后才进行扩容，因为如果数组快被使用完之后，再加入数据产生哈希冲突的可能性就会很大，因此我们通常会设置一个负载因子<code>(load factor)</code>，当数组的使用率超过这个值的时候就进行扩容，即当(数组长度为<code>L</code>，数组当中数据个数为<code>S</code>，负载因子为<code>F</code>)：</p><p>S&gt;=L*F</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="77fc3bbe-ef4c-40d7-8b63-40523f4490a0-4"><p><code>TREEIFY_THRESHOLD</code> 这个字段主要表示将链表（在<code>JDK</code>当中是采用链地址法去解决哈希冲突的问题）变成一个红黑树的条件，在<code>JDK1.8</code>之后<code>JDK</code>中实现<code>HashMap</code>不仅采用链地址法去解决哈希冲突，而且链表满足一定条件之后会将链表变成一颗红黑树。而将链表变成一颗红黑树的<code>必要条件</code>是链表当中数据的个数要大于等于<code>TREEIFY_THRESHOLD</code>，请大家注意是<code>必要条件</code>不是<code>充分条件</code>，也就是说满足这个条件还不行，它还需要满足另外一个条件，就是哈希表中数组的长度要大于等于<code>MIN_TREEIFY_CAPACITY</code>，<code>MIN_TREEIFY_CAPACITY</code>在<code>JDK</code>当中的默认值是64。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="77fc3bbe-ef4c-40d7-8b63-40523f4490a0-5"><p><code>UNTREEIFY_THRESHOLD</code>表示当在进行<code>resize</code>操作的过程当中，红黑树当中的节点个数小于<code>UNTREEIFY_THRESHOLD</code>时，就需要将一颗红黑树重新恢复成链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="77fc3bbe-ef4c-40d7-8b63-40523f4490a0-6"><p><code>table</code>数组对象就是<code>HashMap</code>底层当中真正用于存储数据的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="77fc3bbe-ef4c-40d7-8b63-40523f4490a0-7"><p><code>size</code>表示哈希表中存储的<code>key-value</code>对象的个数，也就是放入了多少个键值对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="77fc3bbe-ef4c-40d7-8b63-40523f4490a0-8"><p><code>threshold</code>表示容器当中能够存储的数据个数的阈值，当<code>HashMap</code>当中存储的数据的个数超过这个值的时候，<code>HashMap</code>底层使用的数组就需要进行扩容。下列公式中<code>Capacity</code>表示底层数组的长度（<code>2</code>的整数次幂，注意与<code>size</code>进行区分）。</p><p>threshold = LoadFactor * Capacity</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>HashMap底层节点类</p></blockquote><p><code>Node&lt;K,V&gt;[] table</code>底层当中真正用于存储数据的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="HashMap主要方法分析">HashMap主要方法分析</h2><h3 id="构造方法">构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定初始容量的构造函数</span></span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                initialCapacity);</span><br><span class="line">    <span class="comment">// 如果大于允许的最大容量，就将数组的长度这是为最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//因为我们需要底层使用的数组table的长度是2的整数次幂，而我们之后在初始化函数当中会允许用户输入一个数组长度的大小</span></span><br><span class="line">    <span class="comment">//但是用户输入的数字可能不是2的整数次幂，因此我们需要将用户输入的数据变成2的整数次幂</span></span><br><span class="line">    <span class="comment">//tableSizeFor方法可以将用户输入的数据变成大于等于这个数的最小的2的整数次幂。</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="put">put</h3><div class="tabs" id="e79f4da6-a38b-4729-ab7b-06e2c986f535"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e79f4da6-a38b-4729-ab7b-06e2c986f535-1"><i class="fas fa-bug"></i>put</button></li><li class="tab"><button type="button" data-href="#e79f4da6-a38b-4729-ab7b-06e2c986f535-2"><i class="fas fa-cannabis"></i>putVal</button></li><li class="tab"><button type="button" data-href="#e79f4da6-a38b-4729-ab7b-06e2c986f535-3"><i class="fas fa-candy-cane"></i>resize</button></li><li class="tab"><button type="button" data-href="#e79f4da6-a38b-4729-ab7b-06e2c986f535-4"><i class="fas fa-child"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e79f4da6-a38b-4729-ab7b-06e2c986f535-1"><p>在<code>put</code>函数当中首先计算参数<code>key</code>的哈希值，然后调用<code>putVal</code>函数真正的将输入插入到数据当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数一：键</span></span><br><span class="line"><span class="comment">//参数二：值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：被覆盖元素的值，如果没有覆盖，返回null</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用键计算出对应的哈希值，再把哈希值进行一些额外的处理</span></span><br><span class="line"><span class="comment">//简单理解：返回值就是返回键的哈希值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark class="hl-label green">整体流程</mark></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220712235514945-220342780.png" alt="img" style="zoom:60%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e79f4da6-a38b-4729-ab7b-06e2c986f535-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数一：键的哈希值</span></span><br><span class="line">    <span class="comment">//参数二：键</span></span><br><span class="line">    <span class="comment">//参数三：值</span></span><br><span class="line">    <span class="comment">//参数四：如果键重复了是否保留</span></span><br><span class="line">    <span class="comment">//   true，表示老元素的值保留，不会覆盖</span></span><br><span class="line">    <span class="comment">//   false，表示老元素的值不保留，会进行覆盖</span></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个局部变量，用来记录哈希表中数组的地址值。</span></span><br><span class="line">        Node&lt;K, V&gt;[] tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时的第三方变量，用来记录键值对对象的地址值</span></span><br><span class="line">        Node&lt;K, V&gt; p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示当前数组的长度</span></span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示索引</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把哈希表中数组的地址值，赋值给局部变量tab</span></span><br><span class="line">        tab = table;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//1.如果当前是第一次添加数据，底层会创建一个默认长度为16，加载因子为0.75的数组</span></span><br><span class="line">            <span class="comment">//2.如果不是第一次添加数据，会看数组中的元素是否达到了扩容的条件</span></span><br><span class="line">            <span class="comment">//如果没有达到扩容条件，底层不会做任何操作</span></span><br><span class="line">            <span class="comment">//如果达到了扩容条件，底层会把数组扩容为原先的两倍，并把数据全部转移到新的哈希表中</span></span><br><span class="line">            tab = resize();</span><br><span class="line">            <span class="comment">//表示把当前数组的长度赋值给n</span></span><br><span class="line">            n = tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿着数组的长度跟键的哈希值进行计算，计算出当前键值对对象，在数组中应存入的位置</span></span><br><span class="line">        i = (n - <span class="number">1</span>) &amp; hash;<span class="comment">//index</span></span><br><span class="line">        <span class="comment">//获取数组中对应元素的数据</span></span><br><span class="line">        p = tab[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//底层会创建一个键值对对象，直接放到数组当中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            K k;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等号的左边：数组中键值对的哈希值</span></span><br><span class="line">            <span class="comment">//等号的右边：当前要添加键值对的哈希值</span></span><br><span class="line">            <span class="comment">//如果键不一样，此时返回false</span></span><br><span class="line">            <span class="comment">//如果键一样，返回true</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> p.hash == hash;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (b1 &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                e = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                <span class="comment">//判断数组中获取出来的键值对是不是红黑树中的节点</span></span><br><span class="line">                <span class="comment">//如果是，则调用方法putTreeVal，把当前的节点按照红黑树的规则添加到树当中。</span></span><br><span class="line">                e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果从数组中获取出来的键值对不是红黑树中的节点</span></span><br><span class="line">                <span class="comment">//表示此时下面挂的是链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//此时就会创建一个新的节点，挂在下面形成链表</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//判断当前链表长度是否超过8，如果超过8，就会调用方法treeifyBin</span></span><br><span class="line">                        <span class="comment">//treeifyBin方法的底层还会继续判断</span></span><br><span class="line">                        <span class="comment">//判断数组的长度是否大于等于64</span></span><br><span class="line">                        <span class="comment">//如果同时满足这两个条件，就会把这个链表转成红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//e：  0x0044  ddd  444</span></span><br><span class="line">                    <span class="comment">//要添加的元素： 0x0055   ddd   555</span></span><br><span class="line">                    <span class="comment">//如果哈希值一样，就会调用equals方法比较内部的属性值是否相同</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果e为null，表示当前不需要覆盖任何元素</span></span><br><span class="line">            <span class="comment">//如果e不为null，表示当前的键是一样的，值会被覆盖</span></span><br><span class="line">            <span class="comment">//e:0x0044  ddd  555</span></span><br><span class="line">            <span class="comment">//要添加的元素： 0x0055   ddd   555</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//等号的右边：当前要添加的值</span></span><br><span class="line">                    <span class="comment">//等号的左边：0x0044的值</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                &#125;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//threshold：记录的就是数组的长度 * 0.75，哈希表的扩容时机  16 * 0.75 = 12</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold) &#123;</span><br><span class="line">            resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示当前没有覆盖任何元素，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e79f4da6-a38b-4729-ab7b-06e2c986f535-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">// 旧数组的数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 旧的扩容的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面的代码主要是计算得到新的阈值 newThr 和数组长度 newCap</span></span><br><span class="line">    </span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 开辟新的数组空间</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 现在需要将旧数组当中的数据加入到新数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// e.next == null 表示只有一个数据，并没有形成 2 个</span></span><br><span class="line">                <span class="comment">// 数据以上的链表，因此可以直接加入到心得数组 当中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果节点是红黑树节点，则在将红黑树当中的节点加入到新数组当中</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表的代码比较复杂，大家可以看下面的分析</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e79f4da6-a38b-4729-ab7b-06e2c986f535-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="remove">remove</h3><p>整个函数分成一下两个步骤：</p><ul><li>先找到要删除的节点。</li><li>删除找到的节点。</li></ul><div class="tabs" id="893ebc87-56df-4723-a233-b33f7144b79e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#893ebc87-56df-4723-a233-b33f7144b79e-1"><i class="fas fa-seedling"></i>remove</button></li><li class="tab"><button type="button" data-href="#893ebc87-56df-4723-a233-b33f7144b79e-2"><i class="fas fa-leaf"></i>removeNode</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="893ebc87-56df-4723-a233-b33f7144b79e-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="893ebc87-56df-4723-a233-b33f7144b79e-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="comment">// matchValue 这个参数如果为 true 表示传入的参数 value</span></span><br><span class="line">    <span class="comment">// 和查找到的数据的 value 相等才进行删除</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 先找到节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="LinkedHashMap">LinkedHashMap</h2><p>LinkedHashMap是HashMap的子类，与LinkedHashMap类似</p><ul><li><p>由键决定：<span class='p red'>有序</span>、不重复、无索引。</p></li><li><p>这里的有序指的是保证存储和取出的元素顺序一致</p></li><li><p>原理：底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</p></li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230521133546661.png" alt="image-20230521133546661"></p><div class="tag link"><a class="link-card" title="LinkedHashSet" href="/posts/edc5fe5c.html#LinkedHashSet"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/favicon.png"/></div><div class="right"><p class="text">LinkedHashSet</p><p class="url">/posts/edc5fe5c.html#LinkedHashSet</p></div></a></div><hr><hr><h2 id="TreeMap">TreeMap</h2><ul><li><p>TreeMap跟TreeSet底层原理一样，都是红黑树结构的。</p></li><li><p>由键决定特性：不重复、无索引、可排序</p></li><li><p>可排序：<span class='p red'>对键进行排序</span>。</p></li><li><p>注意：默认按照键的从小到大进行排序，也可以自己规定键的排序规则</p></li></ul><blockquote><p>比较规则</p></blockquote><ul><li><p>实现Comparable接口，指定比较规则。</p></li><li><p>创建集合时传递Comparator比较器对象，指定比较规则。</p></li></ul><blockquote><p>TreeMap添加元素的时候，键是否需要重写hashCode和equals方法？</p></blockquote><p>此时是不需要重写的</p><p>在Java中，<code>TreeMap</code> 是基于红黑树实现的，它的元素排序是根据 key 的自然顺序或者根据提供的比较器（<code>Comparator</code>）来实现的。所以在使用 <code>TreeMap</code> 时，无需重写 key 的 <code>hashCode</code> 和 <code>equals</code> 方法。相反，你需要确保 key 类实现了 <code>Comparable</code> 接口或者向 <code>TreeMap</code> 提供一个 <code>Comparator</code> 实例。</p><hr><h3 id="基本使用">基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建集合对象</span></span><br><span class="line">TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(((o1, o2) -&gt; o2 - o1));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">treeMap.put(<span class="number">1</span>,<span class="string">&quot;奥利奥&quot;</span>);</span><br><span class="line">treeMap.put(<span class="number">2</span>,<span class="string">&quot;雪碧&quot;</span>);</span><br><span class="line">treeMap.put(<span class="number">3</span>,<span class="string">&quot;六个核桃&quot;</span>);</span><br><span class="line">treeMap.put(<span class="number">4</span>,<span class="string">&quot;康师傅&quot;</span>);</span><br><span class="line">treeMap.put(<span class="number">5</span>,<span class="string">&quot;可口可乐&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.遍历元素</span></span><br><span class="line">treeMap.forEach((k,v)-&gt;&#123;</span><br><span class="line">    System.out.println(k+<span class="string">&quot;=&quot;</span>+v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出：</p><p>5=可口可乐<br>4=康师傅<br>3=六个核桃<br>2=雪碧<br>1=奥利奥</p><hr><h3 id="底层原理">底层原理</h3><blockquote><p>TreeMap中每一个节点的内部属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">K key;<span class="comment">//键</span></span><br><span class="line">V value;<span class="comment">//值</span></span><br><span class="line">Entry&lt;K,V&gt; left;<span class="comment">//左子节点</span></span><br><span class="line">Entry&lt;K,V&gt; right;<span class="comment">//右子节点</span></span><br><span class="line">Entry&lt;K,V&gt; parent;<span class="comment">//父节点</span></span><br><span class="line"><span class="type">boolean</span> color;<span class="comment">//节点的颜色</span></span><br></pre></td></tr></table></figure><blockquote><p>TreeMap类中中要知道的一些成员变量和方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较器对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//空参构造就是没有传递比较器对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带参构造就是传递了比较器对象。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> put(key, value, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label blue">添加元素过程</mark> <div class="tabs" id="5bf345b5-27ff-4798-bc80-e63b974c626f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5bf345b5-27ff-4798-bc80-e63b974c626f-1"><i class="fas fa-seedling"></i>put</button></li><li class="tab"><button type="button" data-href="#5bf345b5-27ff-4798-bc80-e63b974c626f-2"><i class="fas fa-leaf"></i>put</button></li><li class="tab"><button type="button" data-href="#5bf345b5-27ff-4798-bc80-e63b974c626f-3"><i class="fab fa-apple"></i>addEntry</button></li><li class="tab"><button type="button" data-href="#5bf345b5-27ff-4798-bc80-e63b974c626f-4"><i class="fas fa-tree"></i>fixAfterInsertion</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5bf345b5-27ff-4798-bc80-e63b974c626f-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> put(key, value, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5bf345b5-27ff-4798-bc80-e63b974c626f-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">put</span><span class="params">(K key, V value, <span class="type">boolean</span> replaceOld)</span> &#123;</span><br><span class="line">    <span class="comment">//获取根节点的地址值，赋值给局部变量t</span></span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">//判断根节点是否为null</span></span><br><span class="line">    <span class="comment">//如果为null，表示当前是第一次添加，会把当前要添加的元素，当做根节点</span></span><br><span class="line">    <span class="comment">//如果不为null，表示当前不是第一次添加，跳过这个判断继续执行下面的代码</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//方法的底层，会创建一个Entry对象，把他当做根节点</span></span><br><span class="line">        addEntryToEmptyMap(key, value);</span><br><span class="line">        <span class="comment">//表示此时没有覆盖任何的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示两个元素的键比较之后的结果</span></span><br><span class="line">    <span class="type">int</span> cmp;</span><br><span class="line">    <span class="comment">//表示当前要添加节点的父节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示当前的比较规则</span></span><br><span class="line">    <span class="comment">//如果我们是采取默认的自然排序，那么此时comparator记录的是null，cpr记录的也是null</span></span><br><span class="line">    <span class="comment">//如果我们是采取比较去排序方式，那么此时comparator记录的是就是比较器</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="comment">//表示判断当前是否有比较器对象</span></span><br><span class="line">    <span class="comment">//如果传递了比较器对象，就执行if里面的代码，此时以比较器的规则为准</span></span><br><span class="line">    <span class="comment">//如果没有传递比较器对象，就执行else里面的代码，此时以自然排序的规则为准</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> t.value;</span><br><span class="line">                <span class="keyword">if</span> (replaceOld || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                    t.value = value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//把键进行强转，强转成Comparable类型的</span></span><br><span class="line">        <span class="comment">//要求：键必须要实现Comparable接口，如果没有实现这个接口</span></span><br><span class="line">        <span class="comment">//此时在强转的时候，就会报错。</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//把根节点当做当前节点的父节点</span></span><br><span class="line">            parent = t;</span><br><span class="line">            <span class="comment">//调用compareTo方法，比较根节点和当前要添加节点的大小关系</span></span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果比较的结果为负数</span></span><br><span class="line">                <span class="comment">//那么继续到根节点的左边去找</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果比较的结果为正数</span></span><br><span class="line">                <span class="comment">//那么继续到根节点的右边去找</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果比较的结果为0，会覆盖</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> t.value;</span><br><span class="line">                <span class="keyword">if</span> (replaceOld || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                    t.value = value;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//就会把当前节点按照指定的规则进行添加</span></span><br><span class="line">    addEntry(key, value, parent, cmp &lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5bf345b5-27ff-4798-bc80-e63b974c626f-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(K key, V value, Entry&lt;K, V&gt; parent, <span class="type">boolean</span> addToLeft)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (addToLeft)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">//添加完毕之后，需要按照红黑树的规则进行调整</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5bf345b5-27ff-4798-bc80-e63b974c626f-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">//因为红黑树的节点默认就是红色的</span></span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照红黑规则进行调整</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//parentOf:获取x的父节点</span></span><br><span class="line">    <span class="comment">//parentOf(parentOf(x)):获取x的爷爷节点</span></span><br><span class="line">    <span class="comment">//leftOf:获取左子节点</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前节点的父节点是爷爷节点的左子节点还是右子节点</span></span><br><span class="line">        <span class="comment">//目的：为了获取当前节点的叔叔节点</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">//表示当前节点的父节点是爷爷节点的左子节点</span></span><br><span class="line">            <span class="comment">//那么下面就可以用rightOf获取到当前节点的叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                <span class="comment">//叔叔节点为红色的处理方案</span></span><br><span class="line">                <span class="comment">//把父节点设置为黑色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                <span class="comment">//把叔叔节点设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                <span class="comment">//把爷爷节点设置为红色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                <span class="comment">//把爷爷节点设置为当前节点</span></span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//叔叔节点为黑色的处理方案</span></span><br><span class="line">                <span class="comment">//表示判断当前节点是否为父节点的右子节点</span></span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//表示当前节点是父节点的右子节点</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    <span class="comment">//左旋</span></span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//表示当前节点的父节点是爷爷节点的右子节点</span></span><br><span class="line">            <span class="comment">//那么下面就可以用leftOf获取到当前节点的叔叔节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把根节点设置为黑色</span></span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="思考题">思考题</h3><blockquote><p>TreeMap添加元素的时候，键是否需要重写hashCode和equals方法？</p></blockquote><p>此时是不需要重写的</p><p>在Java中，<code>TreeMap</code> 是基于红黑树实现的，它的元素排序是根据 key 的自然顺序或者根据提供的比较器（<code>Comparator</code>）来实现的。所以在使用 <code>TreeMap</code> 时，无需重写 key 的 <code>hashCode</code> 和 <code>equals</code> 方法。相反，你需要确保 key 类实现了 <code>Comparable</code> 接口或者向 <code>TreeMap</code> 提供一个 <code>Comparator</code> 实例。</p><blockquote><p>HashMap是哈希表结构的，JDK8开始由数组，链表，红黑树组成的，既然有红黑树，HashMap的键是否需要实现Compareable接口或者传递比较器对象呢？</p></blockquote><p>不需要的。</p><p>因为在HashMap的底层，默认是利用哈希值的大小关系来创建红黑树的</p><blockquote><p>TreeMap和HashMap谁的效率更高？</p></blockquote><p>如果是最坏情况，添加了8个元素，这8个元素形成了链表，此时TreeMap的效率要更高</p><p>但是这种情况出现的几率非常的少。</p><p>一般而言，还是HashMap的效率要更高。</p><blockquote><p>你觉得在Map集合中，java会提供一个如果键重复了，不会覆盖的put方法呢？</p></blockquote><p>putIfAbsent</p><p>传递一个思想：</p><p>​    代码中的逻辑都有两面性，如果我们只知道了其中的A面，而且代码中还发现了有变量可以控制两面性的发生。</p><p>​    那么该逻辑一定会有B面。</p><p>​    习惯：</p><p>​        boolean类型的变量控制，一般只有AB两面，因为boolean只有两个值</p><p>​        int类型的变量控制，一般至少有三面，因为int可以取多个值。</p><p>​</p><blockquote><p>三种双列集合，以后如何选择？</p></blockquote><p>​    HashMap LinkedHashMap TreeMap</p><p>​    默认：HashMap（效率最高）</p><p>​    如果要保证存取有序：LinkedHashMap</p><p>​    如果要进行排序：TreeMap</p>]]></content>
    
    
    <summary type="html">HashMap、TreeMap解析</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
    <category term="容器" scheme="https://wuwawawa.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>双列集合接口Map</title>
    <link href="https://wuwawawa.github.io/posts/eee6e16.html"/>
    <id>https://wuwawawa.github.io/posts/eee6e16.html</id>
    <published>2023-05-22T08:08:46.000Z</published>
    <updated>2023-05-22T09:56:58.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map继承体系">Map继承体系</h2><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522164255312.png" alt="image-20230522164255312" style="zoom:67%;" /><p>双列集合的特点</p><p>① 双列集合一次需要存一对数据，分别为键和值</p><p>② 键不能重复，值可以重复</p><p>③ 键和值是一一对应的，每一个键只能找到自己对应的值</p><p>④ 键+值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做 “Entry对象”</p><hr><hr><h2 id="Map接口常见方法">Map接口常见方法</h2><p>Map是双列集合的顶层接口，它的功能是全部双列集合都可以继承使用的</p><p>往Map集合中添加key已经存在的新键值对，会覆盖原来的键值对。</p><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>V put(K key, V value)</code></td><td style="text-align:left">添加元素</td></tr><tr><td style="text-align:left"><code>V remove(Object key)</code></td><td style="text-align:left">根据键删除键值对元素</td></tr><tr><td style="text-align:left"><code>V get(Object key)</code></td><td style="text-align:left">根据key获取value</td></tr><tr><td style="text-align:left"><code>V getOrDefault(Object key, V defaultValue)</code></td><td style="text-align:left">根据key获取value，带默认值</td></tr><tr><td style="text-align:left"><code>void clear()</code></td><td style="text-align:left">移除所有的键值对元素</td></tr><tr><td style="text-align:left"><code>boolean containsKey(Object key)</code></td><td style="text-align:left">判断集合是否包含指定的键</td></tr><tr><td style="text-align:left"><code>boolean containsValue(Object value)</code></td><td style="text-align:left">判断集合是否包含指定的值</td></tr><tr><td style="text-align:left"><code>boolean isEmpty()</code></td><td style="text-align:left">判断集合是否为空</td></tr><tr><td style="text-align:left"><code>int size()</code></td><td style="text-align:left">集合的长度，也就是集合中键值对的个数</td></tr><tr><td style="text-align:left"><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code></td><td style="text-align:left">添加多个键值对</td></tr><tr><td style="text-align:left"><code>Set&lt;K&gt; keySet()</code></td><td style="text-align:left">返回一个包含所有key元素的Set集合</td></tr><tr><td style="text-align:left"><code>Collection&lt;V&gt; values()</code></td><td style="text-align:left">返回一个包含所有value元素的Collection集合</td></tr><tr><td style="text-align:left"><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td><td style="text-align:left">返回Map集合中所有键值对的一个Set集合</td></tr><tr><td style="text-align:left"><code>void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code></td><td style="text-align:left">结合lambda遍历集合</td></tr></tbody></table><blockquote><p>添加元素V put(K key, V value)</p></blockquote><p>在添加数据的时候，如果键不存在，那么直按把键值对对象添加到map集合当中，方法返回null。</p><p>在添加数据的时候，如果健是存在的，那么会把原有的键值对对象覆盖。会把被覆盖的值进行返回。</p><hr><hr><h2 id="Map遍历方式">Map遍历方式</h2><div class="tabs" id="cc6a501f-d013-469f-bffd-54511506df74"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#cc6a501f-d013-469f-bffd-54511506df74-1"><i class="fas fa-cat"></i>键找值</button></li><li class="tab"><button type="button" data-href="#cc6a501f-d013-469f-bffd-54511506df74-2"><i class="fas fa-horse"></i>键值对</button></li><li class="tab"><button type="button" data-href="#cc6a501f-d013-469f-bffd-54511506df74-3"><i class="fas fa-dove"></i>Lambda表达式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="cc6a501f-d013-469f-bffd-54511506df74-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建Map集合的对象</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;333&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过键找值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.1获取所有的键</span></span><br><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line"><span class="comment">//3.2遍历单列集合，获取value</span></span><br><span class="line"><span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(<span class="string">&quot;key = &quot;</span> + key);</span><br><span class="line">    System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key = 1<br>value = 1<br>key = 2<br>value = 22<br>key = 3<br>value = 333</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc6a501f-d013-469f-bffd-54511506df74-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建Map集合的对象</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;333&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.1获取所有的键值对</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">//3.2遍历单列集合，获取key和value</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(<span class="string">&quot;key = &quot;</span> + key);</span><br><span class="line">    System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cc6a501f-d013-469f-bffd-54511506df74-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建Map集合的对象</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;333&quot;</span>);</span><br><span class="line"></span><br><span class="line">map.forEach((key,value)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key = &quot;</span> + key);</span><br><span class="line">    System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="Map-Entry说明">Map.Entry说明</h2><p>Map是java中的接口，<code>Map.Entry</code>是Map的一个内部接口。点进Map中，在源码375行的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line"></span><br><span class="line">        K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map提供了一些常用方法，如<code>keySet()</code>、<code>entrySet()</code>等方法，<code>keySet()</code>方法返回值是Map中key值的集合；<code>entrySet()</code>的返回值也是返回一个Set集合，此集合的类型为<code>Map.Entry</code>。</p><p><code>Map.Entry</code>是Map声明的一个内部接口，此接口为泛型接口，定义为<code>Entry&lt;K,V&gt;</code>。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。</p><blockquote><p>Map.Entry使用</p></blockquote><p>通常是遍历时会使用它，Map并没用继承Collection接口，并不能使用迭代器遍历。</p><p>以前，我们便利一个Map集合时，需要获取key的值，然后再获取value的值，稍微有亿点点麻烦，麻烦还是次要的，主要是从Map中取得关键字之后，我们必须每次重复返回到Map中取得相对的值，这是很繁琐和费时的。幸运的是，这里有一个更加简单的途径。Map类提供了一个称为entrySet()的方法，这个方法返回一个<code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code>。接着，<code>Map.Entry</code>类提供了一个<code>getKey()</code>方法和一个<code>getValue()</code>方法，因此，上面的代码可以被组织得更符合逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">map.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">map.put(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">map.put(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">map.put(<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; next : entrySet) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> next.getKey();</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> next.getValue();</span><br><span class="line">    System.out.println(<span class="string">&quot;key = &quot;</span> + key);</span><br><span class="line">    System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Map继承体系、接口方法、遍历方式</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
    <category term="容器" scheme="https://wuwawawa.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>堆PriorityQueue和ArrayDeque</title>
    <link href="https://wuwawawa.github.io/posts/c320ea51.html"/>
    <id>https://wuwawawa.github.io/posts/c320ea51.html</id>
    <published>2023-05-22T00:21:06.000Z</published>
    <updated>2023-05-23T12:27:33.433Z</updated>
    
    <content type="html"><![CDATA[<img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230521200611562.png" alt="image-20230521200611562" style="zoom: 50%;" /><h2 id="PriorityQueue">PriorityQueue</h2><h3 id="数据结构-堆">数据结构-堆</h3><p>前面介绍过队列，队列是一种先进先出(FIFO)的数据结构，但有些情况下，操作的数据可能带有优先级，一般出队列时，可能需要优先级高的元素先出队列，该场景下，使用队列显然不合适。在这种情况下，数据结构应该提供两个最基本的操作，一个是返回最高优先级对象，一个是添加新的对象。这种数据结构就是优先级队列(Priority Queue)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="number">50</span>);</span><br><span class="line">queue.offer(<span class="number">60</span>);</span><br><span class="line">queue.offer(<span class="number">30</span>);</span><br><span class="line">queue.offer(<span class="number">25</span>);</span><br><span class="line">queue.offer(<span class="number">70</span>);</span><br><span class="line">queue.offer(<span class="number">20</span>);</span><br><span class="line">queue.offer(<span class="number">10</span>);</span><br><span class="line">queue.offer(<span class="number">40</span>);</span><br><span class="line">System.out.println(queue);</span><br><span class="line"><span class="comment">//输出：[10, 30, 20, 40, 70, 50, 25, 60]</span></span><br></pre></td></tr></table></figure><blockquote><p>观察一下元素打印顺序有没有什么特点呢？能不能用已知的某种的数据结构来描述PriorityQueue这样的集合呢？</p></blockquote><p>首先，我们可以发现这些元素并不是按添加顺序打印的，排除了线性表、链表、队列这三种的可能性。</p><p>其次，打印的顺序并不是按照元素的升序或降序排列的，所以也就排除了有序数组、二叉排序树的可能性。</p><p>那么剩下的就只剩下哈希表和<span class='p green'>堆</span>了。</p><blockquote><mark class="hl-label green">堆的性质</mark> </blockquote><p>堆是一种<span class='p blue'>特殊的树</span>。</p><p>只要满足以下两点，它就是一个堆：</p><ul><li>堆是一个<span class='p green'>完全二叉树</span></li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值</li></ul><p>第一点，堆必须是一个完全二叉树。完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列，自然堆也具有完全二叉树的所有性质</p><p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p><p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做<code>大顶堆</code>。</p><p>对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做<code>小顶堆</code>。</p><p>如果要获得有序的特性， 逐个出队(poll) ：行! 用迭代器：不行!</p><hr><h3 id="源码实现">源码实现</h3><blockquote><p>存储方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"><span class="comment">//存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="comment">//队列中元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//如果comparator为null，则队列按照元素自然顺序进行排序，否则按照comparator指定的顺序进行排序</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> E&gt; comparator;</span><br><span class="line"><span class="comment">//队列被修改的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>堆底层是用数组实现，其中queue[n]的两个子节点为queue[2n+1]和queue[2(n+1)]。</p><hr><h4 id="堆的插入">堆的插入</h4><p>offer函数有两个要点：</p><ul><li><p>如果堆为空，则无需扩容，也无需调整</p></li><li><p>否则：</p><p>1、判断数组是否需要扩容，如需要调用grow方法<br>2、插入元素后，有可能破坏了堆的平衡，调用siftUp(上滤)方法调整堆至平衡</p></li></ul><div class="tabs" id="eddc6051-32c1-445c-8877-50ed82a70a46"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#eddc6051-32c1-445c-8877-50ed82a70a46-1"><i class="fas fa-cat"></i>offer函数</button></li><li class="tab"><button type="button" data-href="#eddc6051-32c1-445c-8877-50ed82a70a46-2"><i class="fas fa-horse"></i>grow函数</button></li><li class="tab"><button type="button" data-href="#eddc6051-32c1-445c-8877-50ed82a70a46-3"><i class="fas fa-dove"></i>siftUp函数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="eddc6051-32c1-445c-8877-50ed82a70a46-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="eddc6051-32c1-445c-8877-50ed82a70a46-2"><p>堆的扩容与ArrayList相似：</p><ul><li>若数组容量小于64，扩大为原来容量的2倍+2</li><li>若数组容量大于等于64，扩大为原来的1.5倍</li><li>将原来的数组拷贝到新的数组，并丢弃原来的数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                     (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                     (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="eddc6051-32c1-445c-8877-50ed82a70a46-3"><p>以小根堆为例：</p><p>自底向上，不断比较、交换</p><p>假设插入元素E,把E插入到堆的末尾,假设在数组queue的k位置插入元素key</p><ul><li><p>不断的比较key与k的父节点e（即queue[(k-1)/2]) 的关系</p><p>1、若key&lt;e，则queue[k]=e，k回溯至e<br>2、若key&gt;=e或者k已经到达根节点，则结束循环</p></li><li><p>queue[k]=E</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label green">插入示意图</mark> <div class="tabs" id="2c1a2338-21d1-4774-a1a4-409ddc8ad324"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2c1a2338-21d1-4774-a1a4-409ddc8ad324-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#2c1a2338-21d1-4774-a1a4-409ddc8ad324-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#2c1a2338-21d1-4774-a1a4-409ddc8ad324-3"><i class="fas fa-dove"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2c1a2338-21d1-4774-a1a4-409ddc8ad324-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522095612801.png" alt="image-20230522095612801" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2c1a2338-21d1-4774-a1a4-409ddc8ad324-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522095647563.png" alt="image-20230522095647563" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2c1a2338-21d1-4774-a1a4-409ddc8ad324-3"><p>此时已经符合小根堆的要求</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522095717386.png" alt="image-20230522095717386" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="堆的删除">堆的删除</h4><p>调用poll方法，会删除堆顶元素</p><p>删除之后，把末尾元素直接放到堆顶，则破坏了堆的平衡</p><p>调用siftDown（下坠）函数使堆重新恢复平衡</p><p>siftDown与siftUp类似，只不过是自顶向下</p><p>被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止</p><blockquote><p>siftDown原理</p></blockquote><p>以小根堆为例：</p><p>自顶向下，选择较小的子节点，不断比较、交换直到：</p><p>1、下标越界<br>2、节点的值同时小于等于左孩子和右孩子</p><p>假设数组queue最后一个元素的值为key，下标k从0（堆顶）开始当k存在左孩子时，执行以下循环：</p><p>若k有右孩子，则比较左孩子和右孩子的大小，并选出较小孩子child 比较key与c=queuelchila]的大小：</p><p>1、 若key&lt;=c，结束循环<br>2、若key&gt;c，则queue[k]=c,k=child，继续循环</p><p>最后queue[k]=key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="堆的建立">堆的建立</h4><p>当构造函数传入一个集合的时候，会调用 heapify方法进行堆的调整</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label blue">演示</mark> <p>调整为最小堆</p><p>i = (size &gt;&gt;&gt; 1) - 1找到第一个非叶子节点进行调整</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230522101817238.png" alt="image-20230522101817238" style="zoom:67%;" /><hr><h3 id="堆排序">堆排序</h3><p>给定无序数组array，长度为n，将数组排成有序序列</p><p>要求时间复杂度为O(NlogN)，空间复杂度为O(1）</p><div class="tabs" id="c4068611-0241-463f-bdf4-6d2e574df7e0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c4068611-0241-463f-bdf4-6d2e574df7e0-1"><i class="fas fa-award"></i>方案一</button></li><li class="tab"><button type="button" data-href="#c4068611-0241-463f-bdf4-6d2e574df7e0-2"><i class="fas fa-baseball-ball"></i>方案二</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c4068611-0241-463f-bdf4-6d2e574df7e0-1"><p>利用PriorityQueue</p><p>1、新建另外一个最小堆<br>2、调用N次offer方法，将元素依次插入最小堆T1 (N)=O(NlogN)，S1(N)=O(N)<br>3、执行n次poll，把堆顶元素依次复制进原数组，T2(N)=O(NlogN)，S(N)=0(1)</p><p>总时间复杂度T(N)=O(NlogN)+O(NlogN)=O(NlogN)</p><p>总空间复杂度S(N)=O(N)+0(1)+O(N)</p><p>面试官可能会问你</p><p>可否把空间复杂度优化为O(1)？</p><p>那就需要用到方案二</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c4068611-0241-463f-bdf4-6d2e574df7e0-2"><p>堆排序，HeapSort</p><p>将数组本身看成最大堆，借助heapify函数，将数组构造成最大堆</p><p>1、利用heapify函数思路，构建<span class='p green'>最大堆</span><br>2、移除堆顶元素，交换到数组的末尾，<span class='p red'>并让堆的大小减少1</span>，再调用siftDown<br>3、不断执行2，直到堆的大小为1，排序完毕</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="大顶堆小顶堆">大顶堆小顶堆</h3><p>以存储Integer为例</p><div class="tabs" id="e0dd0eb7-e5ae-435c-8a2e-e0c5133de091"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e0dd0eb7-e5ae-435c-8a2e-e0c5133de091-1"><i class="fas fa-cat"></i>大顶堆的实现</button></li><li class="tab"><button type="button" data-href="#e0dd0eb7-e5ae-435c-8a2e-e0c5133de091-2"><i class="fas fa-horse"></i>小顶堆的实现</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e0dd0eb7-e5ae-435c-8a2e-e0c5133de091-1"><p><code>大顶堆</code>：对于每个节点的值都<span class='p red'>大于</span>等于子树中每个节点值的堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">        ((o1, o2) -&gt; o2-o1)</span><br><span class="line">);</span><br><span class="line">queue.offer(<span class="number">50</span>);</span><br><span class="line">queue.offer(<span class="number">60</span>);</span><br><span class="line">queue.offer(<span class="number">30</span>);</span><br><span class="line">queue.offer(<span class="number">25</span>);</span><br><span class="line">queue.offer(<span class="number">70</span>);</span><br><span class="line">queue.offer(<span class="number">20</span>);</span><br><span class="line">queue.offer(<span class="number">10</span>);</span><br><span class="line">queue.offer(<span class="number">40</span>);</span><br><span class="line">System.out.println(queue);</span><br><span class="line"><span class="comment">//输出：[70, 60, 30, 40, 50, 20, 10, 25]</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e0dd0eb7-e5ae-435c-8a2e-e0c5133de091-2"><p><code>小顶堆</code>：对于每个节点的值都<span class='p green'>小于</span>等于子树中每个节点值的堆</p><p>默认的PriorityQueue就是一个小顶堆</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="ArrayDeque">ArrayDeque</h2><p>这里主要跟介绍<code>JDK</code>给我们提供的一种用数组实现的<span class='p green'>双端队列</span>，在之前的文章我们已经介绍了一种<strong>双端队列</strong>，不过与<code>ArrayDeque</code>不同的是，<code>LinkedList</code>的双端队列使用双向链表实现的。</p><div class="tag link"><a class="link-card" title="LinkedList继承体系" href="/posts/7ec37ec5.html#LinkedList继承体系"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/favicon.png"/></div><div class="right"><p class="text">LinkedList继承体系</p><p class="url">/posts/7ec37ec5.html#LinkedList继承体系</p></div></a></div><blockquote><p>整体分析</p></blockquote><p>我们通常所谈论到的队列都是一端进一端出，而双端队列的两端则都是可进可出。</p><p><code>ArrayDeque</code>底层是使用数组实现的，而且数组的长度必须是<code>2</code>的整数次幂，这么操作的原因是为了后面位运算好操作。在<code>ArrayDeque</code>当中有两个整形变量<code>head</code>和<code>tail</code>，分别指向右侧的第一个进入队列的数据和左侧第一个进行队列的数据，整个内存布局如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220715010318405-150064473.png" alt="img" style="zoom: 67%;" /><p>其中<code>tail</code>指的位置没有数据，<code>head</code>指的位置存在数据。</p><div class="tabs" id="6960b700-7eac-4d0a-babe-81852ff7156c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6960b700-7eac-4d0a-babe-81852ff7156c-1"><i class="fas fa-award"></i>1</button></li><li class="tab"><button type="button" data-href="#6960b700-7eac-4d0a-babe-81852ff7156c-2"><i class="fas fa-baseball-ball"></i>2</button></li><li class="tab"><button type="button" data-href="#6960b700-7eac-4d0a-babe-81852ff7156c-3"><i class="fas fa-bone"></i>3</button></li><li class="tab"><button type="button" data-href="#6960b700-7eac-4d0a-babe-81852ff7156c-4"><i class="fas fa-anchor"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6960b700-7eac-4d0a-babe-81852ff7156c-1"><p>向队列尾部添加数据，内存当中数据变化情况如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220715010328930-112988730.png" alt="img" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6960b700-7eac-4d0a-babe-81852ff7156c-2"><p>队列头部添加数据，内存当中数据变化情况如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220715010339150-1082019999.png" alt="img" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6960b700-7eac-4d0a-babe-81852ff7156c-3"><p>队尾元素删除，内存当中数据变化情况如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220715010352215-1154696099.png" alt="img" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6960b700-7eac-4d0a-babe-81852ff7156c-4"><p>队首元素删除</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220715010402157-1785624671.png" alt="img" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="源码分析">源码分析</h3><h4 id="关键字段">关键字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层用于存储具体数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line"><span class="comment">// 这就是前面谈到的 head</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> head;</span><br><span class="line"><span class="comment">// 与上文谈到的 tail 含义一样</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="comment">// MIN_INITIAL_CAPACITY 表示数组 elements 的最短长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="构造函数">构造函数</h4><ul><li>默认构造函数，数组默认申请的长度为<code>16</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">()</span> &#123;</span><br><span class="line">    elements = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="关键函数">关键函数</h4><div class="tabs" id="e0ae5b59-a787-48a2-b770-38f92dae3c98"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e0ae5b59-a787-48a2-b770-38f92dae3c98-1"><i class="fas fa-seedling"></i>addLast</button></li><li class="tab"><button type="button" data-href="#e0ae5b59-a787-48a2-b770-38f92dae3c98-2"><i class="fas fa-leaf"></i>addFirst</button></li><li class="tab"><button type="button" data-href="#e0ae5b59-a787-48a2-b770-38f92dae3c98-3"><i class="fab fa-apple"></i>doubleCapacity</button></li><li class="tab"><button type="button" data-href="#e0ae5b59-a787-48a2-b770-38f92dae3c98-4"><i class="fas fa-tree"></i>扩容图示</button></li><li class="tab"><button type="button" data-href="#e0ae5b59-a787-48a2-b770-38f92dae3c98-5"><i class="fas fa-heartbeat"></i>pollFirst</button></li><li class="tab"><button type="button" data-href="#e0ae5b59-a787-48a2-b770-38f92dae3c98-6"><i class="fas fa-cookie-bite"></i>pollLast</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e0ae5b59-a787-48a2-b770-38f92dae3c98-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tail 的初始值为 0 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="comment">// 这里进行的 &amp; 位运算 相当于取余数操作</span></span><br><span class="line">    <span class="comment">// (tail + 1) &amp; (elements.length - 1) == (tail + 1) % elements.length</span></span><br><span class="line">    <span class="comment">// 这个操作主要是用于判断数组是否满了，如果满了则需要扩容</span></span><br><span class="line">    <span class="comment">// 同时这个操作将 tail + 1，即 tail = tail + 1</span></span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e0ae5b59-a787-48a2-b770-38f92dae3c98-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head 的初始值为 0 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 若此时数组长度elements.length = 16</span></span><br><span class="line">    <span class="comment">// 那么下面代码执行过后 head = 15</span></span><br><span class="line">    <span class="comment">// 下面代码的操作结果和下面两行代码含义一致</span></span><br><span class="line">    <span class="comment">// elements[(head - 1 + elements.length) % elements.length] = e</span></span><br><span class="line">    <span class="comment">// head = (head - 1 + elements.length) % elements.length</span></span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e0ae5b59-a787-48a2-b770-38f92dae3c98-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 上面是函数 System.arraycopy 的函数参数列表</span></span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">    elements = a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e0ae5b59-a787-48a2-b770-38f92dae3c98-4"><p>扩容之后将原来数组的数据拷贝到了新数组当中，虽然数据在旧数组和新数组当中的顺序发生变化了，但是他们的相对顺序却没有发生变化，他们的逻辑顺序也是一样的，这里的逻辑可能有点绕，大家在这里可以好好思考一下。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220715185849697-121038371.png" alt="img" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e0ae5b59-a787-48a2-b770-38f92dae3c98-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[h];</span><br><span class="line">    <span class="comment">// Element is null if deque empty</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    elements[h] = <span class="literal">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e0ae5b59-a787-48a2-b770-38f92dae3c98-6"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 计算出待删除的数据的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) elements[t];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 将需要删除的数据的下标值设置为 null 这样这块内存就</span></span><br><span class="line">    <span class="comment">// 可以被回收了</span></span><br><span class="line">    elements[t] = <span class="literal">null</span>;</span><br><span class="line">    tail = t;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">堆：PriorityQueue、ArrayDeque和LinkedList</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
    <category term="容器" scheme="https://wuwawawa.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>队列接口Queue</title>
    <link href="https://wuwawawa.github.io/posts/54307854.html"/>
    <id>https://wuwawawa.github.io/posts/54307854.html</id>
    <published>2023-05-21T11:58:41.000Z</published>
    <updated>2023-05-21T14:14:35.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Queue体系架构">Queue体系架构</h2><p>Queue接口提供了队列数据结构的功能。它继承了Collection接口， 用于保存将要按FIFO(先进先出)顺序处理的元素。</p><p>它是一个有序的对象列表，其用途仅限于在列表末尾插入元素和从列表开头删除元素。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230521200611562.png" alt="image-20230521200611562" style="zoom: 50%;" /><hr><hr><h2 id="Queue接口的方法">Queue接口的方法</h2><p>Queue接口包括Collection接口的所有方法。</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">来源</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean add(E e)</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">将指定的元素插入到队列尾部，并在成功时返回true。</td></tr><tr><td style="text-align:left"><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">添加多个元素至队列尾部</td></tr><tr><td style="text-align:left"><code>int size()</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">返回集合的长度</td></tr><tr><td style="text-align:left"><code>boolean isEmpty()</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">判断集合是否为空</td></tr><tr><td style="text-align:left"><code>boolean remove(Object o)</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">移除指定的元素</td></tr><tr><td style="text-align:left"><code>boolean removeIf(Predicate&lt;? super E&gt; filter)</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">根据条件进行移除</td></tr><tr><td style="text-align:left"><code>boolean removeAll(Collection&lt;?&gt; c)</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">移除多个元素</td></tr><tr><td style="text-align:left"><code>void clear()</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">清空集合中的元素</td></tr><tr><td style="text-align:left"><code>boolean contains(Object o)</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">判断集合中是否存在指定的元素</td></tr><tr><td style="text-align:left"><code>Iterator&lt; E &gt; iterator()</code></td><td style="text-align:left"><span class='p blue'>Collection</span></td><td style="text-align:left">返回迭代器对象</td></tr><tr><td style="text-align:left"><code>boolean offer(E e)</code></td><td style="text-align:left"><span class='p green'>Queue</span></td><td style="text-align:left">添加到队列尾部</td></tr><tr><td style="text-align:left"><code>E remove()</code></td><td style="text-align:left"><span class='p green'>Queue</span></td><td style="text-align:left">删除并返回该队列的头部元素,如果队列为空,则引发异常</td></tr><tr><td style="text-align:left"><code>E poll()</code></td><td style="text-align:left"><span class='p green'>Queue</span></td><td style="text-align:left">返回并删除该队列的头部元素, 如果队列为空,则返回null</td></tr><tr><td style="text-align:left"><code>E peek()</code></td><td style="text-align:left"><span class='p green'>Queue</span></td><td style="text-align:left">返回队列头部元素，如果队列为空，则返回null</td></tr><tr><td style="text-align:left"><code>E element()</code></td><td style="text-align:left"><span class='p green'>Queue</span></td><td style="text-align:left">返回队列头部元素，如果队列为空，则引发异常</td></tr></tbody></table><mark class="hl-label blue">分类</mark> <div class="tabs" id="30fb45ed-f2eb-4ed0-8f0f-7555fff212e1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#30fb45ed-f2eb-4ed0-8f0f-7555fff212e1-1"><i class="fas fa-cat"></i>压入元素(添加)</button></li><li class="tab"><button type="button" data-href="#30fb45ed-f2eb-4ed0-8f0f-7555fff212e1-2"><i class="fas fa-horse"></i>弹出元素(删除)</button></li><li class="tab"><button type="button" data-href="#30fb45ed-f2eb-4ed0-8f0f-7555fff212e1-3"><i class="fas fa-dove"></i>获取队头元素(不删除)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="30fb45ed-f2eb-4ed0-8f0f-7555fff212e1-1"><blockquote><p><strong>add()、offer()</strong></p></blockquote><ul><li>相同：未超出容量，从队尾压入元素，返回压入的那个元素。</li><li>区别：在超出容量时，add()方法会对抛出异常，offer()返回false</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="30fb45ed-f2eb-4ed0-8f0f-7555fff212e1-2"><blockquote><p><strong>remove()、poll()</strong></p></blockquote><ul><li>相同：容量大于0的时候，删除并返回队头被删除的那个元素。</li><li>区别：在容量为0的时候，remove()会抛出异常，poll()返回false</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="30fb45ed-f2eb-4ed0-8f0f-7555fff212e1-3"><blockquote><p><strong>element()、peek()</strong></p></blockquote><ul><li>相同：容量大于0的时候，都返回队头元素。但是不删除。</li><li>区别：容量为0的时候，element()会抛出异常，peek()返回null。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="Deque接口的方法">Deque接口的方法</h2><p>Deque接口提供了双端队列(Deque)的功能。它继承了Queue接口，包括Collection和Queue接口的所有方法。</p><p>Deque是一个线性collection，支持在两端插入和移除元素。Deque的实现类是LinkedList、ArrayDeque、LinkedBlockingDeque，其中LinkedList是最常用的。</p><p>除了Queue接口中可用的方法之外，Deque还包括以下方法：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>void addFirst(E e)</code></td><td style="text-align:left">在双端队列的开头添加指定的元素。如果双端队列已满，则引发异常</td></tr><tr><td style="text-align:left"><code>void addLast(E e)</code></td><td style="text-align:left">在双端队列的末尾添加指定的元素。如果双端队列已满，则引发异常</td></tr><tr><td style="text-align:left"><code>boolean offerFirst(E e)</code></td><td style="text-align:left">在双端队列的开头添加指定的元素。如果双端队列已满，则返回false</td></tr><tr><td style="text-align:left"><code>boolean offerLast(E e)</code></td><td style="text-align:left">在双端队列的末尾添加指定的元素。如果双端队列已满，则返回false</td></tr><tr><td style="text-align:left"><code>E removeFirst()</code></td><td style="text-align:left">返回并删除双端队列的第一个元素。如果双端队列为空，则引发异常</td></tr><tr><td style="text-align:left"><code>E removeLast()</code></td><td style="text-align:left">返回并删除双端队列的最后一个元素。如果双端队列为空，则引发异常</td></tr><tr><td style="text-align:left"><code>E pollFirst()</code></td><td style="text-align:left">返回并删除双端队列的第一个元素。如果双端队列为空，则返回null</td></tr><tr><td style="text-align:left"><code>E pollLast()</code></td><td style="text-align:left">返回并删除双端队列的最后一个元素。如果双端队列为空，则返回null</td></tr><tr><td style="text-align:left"><code>E getFirst()</code></td><td style="text-align:left">返回双端队列的第一个元素。如果双端队列为空，则引发异常</td></tr><tr><td style="text-align:left"><code>E getLast()</code></td><td style="text-align:left">返回双端队列的最后一个元素。如果双端队列为空，则引发异常</td></tr><tr><td style="text-align:left"><code>E peekFirst()</code></td><td style="text-align:left">返回双端队列的第一个元素。如果双端队列为空，则返回null</td></tr><tr><td style="text-align:left"><code>E peekLast()</code></td><td style="text-align:left">返回双端队列的最后一个元素。如果双端队列为空，则返回null</td></tr><tr><td style="text-align:left"><code>boolean removeFirstOccurrence(Object o)</code></td><td style="text-align:left">删除第一次出现的指定元素,不存在时返回false</td></tr><tr><td style="text-align:left"><code>boolean removeLastOccurrence(Object o)</code></td><td style="text-align:left">删除最后一次出现的指定元素,不存在时返回false</td></tr></tbody></table><hr><p>Java堆栈Stack类已经过时，Java官方推荐使用Deque替代Stack使用。</p><p>以下是Deque接口提供的用于实现栈的方法：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>void push(E e)</code></td><td style="text-align:left">在双端队列的开头添加元素</td></tr><tr><td style="text-align:left"><code>E pop()</code></td><td style="text-align:left">从双端队列的开头删除元素</td></tr><tr><td style="text-align:left"><code>E peek()</code></td><td style="text-align:left">返回队列头部元素，如果队列为空，则返回null</td></tr></tbody></table><p>push = addFirst</p><p>pop = removeFirst</p><p>只是使用了不同的方法名体现队列表示栈结构时的特点</p><p>当我们把Deque作为Stack使用时，注意只调用push()/pop()/peek()方法，不要调用addFirst()/removeFirst()/peekFirst()方法，这样代码更加清晰。</p><hr><p>当 peek() poll() peek() remove()这些操作不带First时，默认是first，操作对象是队首</p><p>add()和offer()默认是队尾</p><table><thead><tr><th style="text-align:left">Queue方法</th><th style="text-align:left">等效Deque方法</th></tr></thead><tbody><tr><td style="text-align:left"><code>add(e)</code></td><td style="text-align:left"><code>addLast(e)</code></td></tr><tr><td style="text-align:left"><code>offer(e)</code></td><td style="text-align:left"><code>offerLast(e)</code></td></tr><tr><td style="text-align:left"><code>remove()</code></td><td style="text-align:left"><code>removeFirst()</code></td></tr><tr><td style="text-align:left"><code>poll()</code></td><td style="text-align:left"><code>pollFirst()</code></td></tr><tr><td style="text-align:left"><code>element()</code></td><td style="text-align:left"><code>getFirst()</code></td></tr><tr><td style="text-align:left"><code>peek()</code></td><td style="text-align:left"><code>peekFirst()</code></td></tr></tbody></table><hr><hr><h2 id="Queue遍历方式">Queue遍历方式</h2><p>Queue遍历方法上基本上与Collection的一致。</p><ol><li>迭代器遍历</li><li>增强for遍历</li><li>Lambda表达式</li></ol><div class="tag link"><a class="link-card" title="Collection集合的遍历方式" href="/posts/71c14870.html#Collection遍历方式"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/favicon.png"/></div><div class="right"><p class="text">Collection集合的遍历方式</p><p class="url">/posts/71c14870.html#Collection遍历方式</p></div></a></div>]]></content>
    
    
    <summary type="html">Queue体系架构、Queue接口方法、Deque接口方法</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
    <category term="容器" scheme="https://wuwawawa.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HashSet和TreeSet</title>
    <link href="https://wuwawawa.github.io/posts/edc5fe5c.html"/>
    <id>https://wuwawawa.github.io/posts/edc5fe5c.html</id>
    <published>2023-05-20T03:29:18.000Z</published>
    <updated>2023-05-24T01:28:09.820Z</updated>
    
    <content type="html"><![CDATA[<img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/Set%E4%BD%93%E7%B3%BB%E5%9B%BE1.jpg" alt="Set体系图1" style="zoom:50%;" /><h2 id="HashSet">HashSet</h2><p>HashSet集合底层采取哈希表(HashMap)存储数据,<s>身在Collection心在 Map</s></p><p>哈希表是一种对于增删改查数据性能都较好的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="哈希表组成">哈希表组成</h3><p>JDK8之前：数组+链表</p><p>JDK8开始：数组+链表+红黑树</p><p>在哈希表中，有一个很重要的值叫做哈希值，是哈希表的灵魂所在。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230520194828555.png" alt="image-20230520194828555" style="zoom:67%;" /><p>如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230520195353131.png" alt="image-20230520195353131" style="zoom:75%;" /><p>在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。（<span class='p red'>哈希碰撞</span>）</p><hr><h3 id="底层原理">底层原理</h3><div class="tabs" id="515cce44-45a3-4097-8f7e-6ad0a4ce246a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#515cce44-45a3-4097-8f7e-6ad0a4ce246a-1"><i class="fas fa-cat"></i>HashSetJDK8以前底层原理</button></li><li class="tab"><button type="button" data-href="#515cce44-45a3-4097-8f7e-6ad0a4ce246a-2"><i class="fas fa-horse"></i>HashSetJDK8底层原理</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="515cce44-45a3-4097-8f7e-6ad0a4ce246a-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/14_JKD8%E4%BB%A5%E5%89%8D%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="14_JKD8以前哈希表"  /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="515cce44-45a3-4097-8f7e-6ad0a4ce246a-2"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/15_JKD8%E4%BB%A5%E5%90%8E%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="15_JKD8以后哈希表"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ol><li><p><code>HashSet&lt;String&gt; hm = new HashSet&lt;&gt;();</code></p></li><li><p><code>int index = (数组长度-1) &amp; 哈希值;</code></p></li><li><p>一样：不存</p><p>不一样：存入数组，形成链表</p><ul><li><p>JDK8以前：新数组存入数组，老元素挂在新元素下面</p></li><li><p>JDK8以后：新元素直接挂在老元素下面</p></li></ul></li></ol><p>扩容时机：</p><ul><li>当数组中存了16*0.75=12个元素的时候，那么数组就会扩容成原先的两倍。</li><li>JDK8以后，当联表长度<span class='p red'>超过8</span>，且数组长度<span class='p red'>大于等于64</span>，那么当前的链表就会自动转成红黑树。</li></ul><blockquote><p>注意</p></blockquote><p>如果集合中存储的是自定义对象，必须要重写<span class='p red'>hashCode</span>和<span class='p red'>equals</span>方法</p><hr><h3 id="HashSet的三个问题">HashSet的三个问题</h3><div class="tabs" id="eddb45d3-b9a7-4d4c-8827-37b9acb7a487"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#eddb45d3-b9a7-4d4c-8827-37b9acb7a487-1"><i class="fas fa-cat"></i>问题1</button></li><li class="tab"><button type="button" data-href="#eddb45d3-b9a7-4d4c-8827-37b9acb7a487-2"><i class="fas fa-horse"></i>问题2</button></li><li class="tab"><button type="button" data-href="#eddb45d3-b9a7-4d4c-8827-37b9acb7a487-3"><i class="fas fa-dove"></i>问题3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="eddb45d3-b9a7-4d4c-8827-37b9acb7a487-1"><blockquote><p>问题1：HashSet为什么存和取的顺序不一样？</p></blockquote><p>HashSet 遍历元素的顺序是基于哈希表中元素的存储位置来进行的，从数组的0索引开始，一条链表一条链表这样遍历的。，而哈希表中元素的存储位置是由哈希值决定的，因此，元素的遍历顺序与元素添加的顺序无关。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230520212602484.png" alt="image-20230520212602484" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="eddb45d3-b9a7-4d4c-8827-37b9acb7a487-2"><blockquote><p>问题2：HashSet为什么没有索引？</p></blockquote><p>索引没有意义</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="eddb45d3-b9a7-4d4c-8827-37b9acb7a487-3"><blockquote><p>HashSet是利用什么机制保证数据去重的？</p></blockquote><p>HashCode方法+equals方法</p><p>利用HashCode方法得到Hash值，得到Hash值后就可以知道当前元素是添加到数组中的哪个位置。</p><p>如果该位置已经存在元素，HashSet会equals方法比较该元素与已存在元素的值否相等，如果相等则不进行操作，如果不相等则将该元素加入 HashSet 中。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="案例演示">案例演示</h3><div class="tabs" id="b39c48bf-8146-47ec-b2a0-8db90e8ab7c8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b39c48bf-8146-47ec-b2a0-8db90e8ab7c8-1"><i class="fas fa-bug"></i>1</button></li><li class="tab"><button type="button" data-href="#b39c48bf-8146-47ec-b2a0-8db90e8ab7c8-2"><i class="fas fa-cannabis"></i>2</button></li><li class="tab"><button type="button" data-href="#b39c48bf-8146-47ec-b2a0-8db90e8ab7c8-3"><i class="fas fa-candy-cane"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b39c48bf-8146-47ec-b2a0-8db90e8ab7c8-1"><p>此时并没有重写equals和Hashcode方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b39c48bf-8146-47ec-b2a0-8db90e8ab7c8-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建三个学生对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangwu&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建集合添加元素</span></span><br><span class="line">HashSet&lt;Student&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加元素</span></span><br><span class="line">System.out.println(hs.add(s1));</span><br><span class="line">System.out.println(hs.add(s2));</span><br><span class="line">System.out.println(hs.add(s3));</span><br><span class="line">System.out.println(hs.add(s4));</span><br><span class="line"><span class="comment">//4.打印集合</span></span><br><span class="line">System.out.println(hs);</span><br></pre></td></tr></table></figure><p>true<br>true<br>true<br>true<br>[Student(name=zhangsan, age=23), Student(name=lisi, age=24), Student(name=zhangsan, age=23), Student(name=wangwu, age=25)]</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b39c48bf-8146-47ec-b2a0-8db90e8ab7c8-3"><p>在Student类添加上@EqualsAndHashCode后输出：</p><p>true<br>false<br>true<br>true<br>[Student(name=zhangsan, age=23), Student(name=lisi, age=24), Student(name=wangwu, age=25)]</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="LinkedHashSet">LinkedHashSet</h2><p>LinkedHashSet继承于HashSet，方法与HashSet一致。</p><p>LinkedHashSet底层是一个 LinkedHashMap，底层维护了一个<span class='p green'>数组+双向链表</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">       map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><span class='p red'>有序</span>、不重复、无索引。</li><li>这里的有序指的是保证存储和取出的元素顺序一致。</li><li><span class='p red'>原理</span>：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。</li></ul><p>例子</p><ul><li>第一个元素根据Hash值得到数组中该存入的位置为8，该位置没有元素为null，直接添加进去，于此同时底层还多了双向链表，头结点就为刚刚添加的元素</li><li>继续添加第二个元素，计算出第二个元素该存入的索引为3索引，没有元素直接添加，第一个元素第二个元素直接形成双向链表</li><li>继续添加第三个元素，根据Hash值计算出第三个元素该存入的索引为3索引，存在元素，根据equals方法，比较两个对象属性值是否相等，不一样，根据JDK8以后的规则，新的元素挂在下面，于此同时，第二个元素和第三个元素还要再形成双向链表</li><li>继续添加第四个元素，计算出第二个元素该存入的索引为0索引，与第三个元素形成双向链表</li><li>添加完成，此时头结点就为8元素，尾节点为0元素</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230521133546661.png" alt="image-20230521133546661"></p><p>在遍历的时候就和HashSet不一样了（从数组的0索引开始一条链表一条链表遍历），在LinkedHashSet中，从头结点开始以此遍历，直至尾节点。</p><p>这时候获得的数据，就和添加元素的顺序一样了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建三个学生对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangwu&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建集合添加元素</span></span><br><span class="line">LinkedHashSet&lt;Student&gt; lhs = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加元素</span></span><br><span class="line">System.out.println(lhs.add(s1));</span><br><span class="line">System.out.println(lhs.add(s2));</span><br><span class="line">System.out.println(lhs.add(s3));</span><br><span class="line">System.out.println(lhs.add(s4));</span><br><span class="line"><span class="comment">//4.打印集合</span></span><br><span class="line">System.out.println(lhs);</span><br></pre></td></tr></table></figure><p>输出：</p><p>true<br>false<br>true<br>true<br>[Student(name=zhangsan, age=23), Student(name=lisi, age=24), Student(name=wangwu, age=25)]</p><hr><hr><h2 id="TreeSet">TreeSet</h2><h3 id="特点">特点</h3><p>延续了Set集合两个特点：不重复、无索引</p><p>但是TreeSet多了一个特点：<span class='p red'>可排序</span></p><p>可排序：按照元素的默认规则（有小到大）排序。</p><p>TreeSet集合底层是基于<span class='p red'>红黑树</span>的数据结构实现排序的，增删改查性能都较好。</p><p>不依赖Hashcode和equals方法</p><hr><h3 id="方法">方法</h3><p>TreeSet实现了NavigableSet，NavigableSet是一个接口，继承自SortedSet接口，用于实现可导航的Set。它具有SortedSet所拥有的一些功能，比如能够自动进行排序、去重等，同时还具备一些额外的功能，比如顺序遍历元素、获取特定区间内的元素等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">来源</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>E first()</code></td><td style="text-align:left"><code>SortedSet</code></td><td style="text-align:left">获取当前集合的首元素</td></tr><tr><td style="text-align:left"><code>E last()</code></td><td style="text-align:left"><code>SortedSet</code></td><td style="text-align:left">获取当前集合的尾元素</td></tr><tr><td style="text-align:left"><code>SortedSet&lt;E&gt; headSet(E toElement)</code></td><td style="text-align:left"><code>SortedSet</code></td><td style="text-align:left">返回值小于的toElement子集</td></tr><tr><td style="text-align:left"><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code></td><td style="text-align:left"><code>SortedSet</code></td><td style="text-align:left">返回值大于或等于fromElement的子集</td></tr><tr><td style="text-align:left"><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code></td><td style="text-align:left"><code>SortedSet</code></td><td style="text-align:left">返回值范围为[fromElement,toElement)范围的子集</td></tr><tr><td style="text-align:left"><code>Iterator&lt;E&gt; iterator()</code></td><td style="text-align:left"><code>SortedSet</code></td><td style="text-align:left">返回迭代器</td></tr><tr><td style="text-align:left"><code>E lower(E e)</code></td><td style="text-align:left"><code>NavigableSet</code></td><td style="text-align:left">返回小于指定元素的那些元素中最大的元素</td></tr><tr><td style="text-align:left"><code>E floor(E e)</code></td><td style="text-align:left"><code>NavigableSet</code></td><td style="text-align:left">回小于或等于指定元素的那些元素中最大的元素</td></tr><tr><td style="text-align:left"><code>E ceiling(E e)</code></td><td style="text-align:left"><code>NavigableSet</code></td><td style="text-align:left">返回大于或等于指定元素的那些元素中的最小元素</td></tr><tr><td style="text-align:left"><code>E higher(E e)</code></td><td style="text-align:left"><code>NavigableSet</code></td><td style="text-align:left">返回大于指定元素的那些元素中的最小元素</td></tr><tr><td style="text-align:left"><code>E pollFirst()</code></td><td style="text-align:left"><code>NavigableSet</code></td><td style="text-align:left">返回并从集合中删除第一个元素</td></tr><tr><td style="text-align:left"><code>E pollLast()</code></td><td style="text-align:left"><code>NavigableSet</code></td><td style="text-align:left">返回并从集合中删除最后一个元素</td></tr><tr><td style="text-align:left"><code>Iterator&lt;E&gt; descendingIterator()</code></td><td style="text-align:left"><code>NavigableSet</code></td><td style="text-align:left">返回可用于以相反顺序迭代集合的迭代器</td></tr></tbody></table><hr><h3 id="默认排序规则">默认排序规则</h3><ul><li><p>对于数值类型：Integer，Double，默认按照从小到大的顺序进行排序。</p></li><li><p>对于字符、字符串类型：按照字符在ASCI码表中的数字升序进行排序。</p></li><li><p>如果要使用自定义的排序规则来排序元素，可以在创建TreeSet时传入一个Comparator对象，实现自定义的比较逻辑。在这种情况下，TreeSet会根据Comparator对象的比较结果来排序元素。</p></li></ul><hr><h3 id="案例演示-2">案例演示</h3><p>需求：创建TreeSet集合，并添加3个学生对象</p><p>学生对象属性：姓名，年龄。</p><p>要求按照学生的年龄进行排序，同年龄按照姓名字母排列（暂不考虑中文） 同姓名，同年龄认为是同一个人</p><div class="tabs" id="876ca747-d446-48f5-8a59-9b81d6730fb3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#876ca747-d446-48f5-8a59-9b81d6730fb3-1"><i class="fas fa-cat"></i>Student类</button></li><li class="tab"><button type="button" data-href="#876ca747-d446-48f5-8a59-9b81d6730fb3-2"><i class="fas fa-dove"></i>比较器排序</button></li><li class="tab"><button type="button" data-href="#876ca747-d446-48f5-8a59-9b81d6730fb3-3"><i class="fas fa-horse"></i>bean类实现Comparable接口指定比较规则</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="876ca747-d446-48f5-8a59-9b81d6730fb3-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="876ca747-d446-48f5-8a59-9b81d6730fb3-2"><p>创建TreeSet对象时候，传递比较器Comparator指定规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建三个学生对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangwu&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建集合添加元素</span></span><br><span class="line">TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((stu1,stu2)-&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (stu1.getAge()==stu2.getAge())&#123;</span><br><span class="line">        <span class="keyword">return</span> stu1.getName().compareTo(stu2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stu1.getAge()-stu2.getAge();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.添加元素</span></span><br><span class="line">ts.add(s1);</span><br><span class="line">ts.add(s2);</span><br><span class="line">ts.add(s3);</span><br><span class="line"><span class="comment">//4.打印集合</span></span><br><span class="line">System.out.println(ts);</span><br></pre></td></tr></table></figure><p>输出</p><p>[Student(name=zhangsan, age=23), Student(name=zhangsan, age=24), Student(name=wangwu, age=25)]</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="876ca747-d446-48f5-8a59-9b81d6730fb3-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.getAge()==o.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getName().compareTo(o.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAge()-o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：[Student(name=zhangsan, age=23), Student(name=zhangsan, age=24), Student(name=wangwu, age=25)]</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><span class='p red'>注意</span><p>如果两种方式都存在，优先选择传入的比较器</p><hr><h3 id="总结">总结</h3><blockquote><p>Tree Set集合的特点是怎么样的？</p></blockquote><p>可排序、不重复、无索引</p><p>底层基于红黑树实现排序，增删改查性能较好</p><blockquote><p>TreeSet集合自定义排序规则有几种方式</p></blockquote><p>方式一：Javabean类实现Comparable接口，指定比较规则</p><p>方式二：创建集合时，自定义Comparator比较器对象，指定比较规则</p><blockquote><p>方法返回值的特点</p></blockquote><p>负数：表示当前要添加的元素是小的，存左边</p><p>正数：表示当前要添加的元素是大的，存右边</p><p>0：表示当前要添加的元素已经存在，舍弃</p><hr><hr><h2 id="总结-2">总结</h2><ol><li><p>如果想要集合中的元素可重复</p><ul><li>用ArrayList集合，基于数组的。<span class='p red'>（用的最多）</span></li></ul></li><li><p>如果想要集合中的元素可重复，而且当前的<span class='p red'>增删操作明显多于查询</span></p><ul><li>用LinkedList集合，基于链表的。</li></ul></li><li><p>如果想对集合中的元素去重</p><ul><li>用HashSet集合，基于哈希表的。<span class='p red'>（用的最多）</span></li></ul></li><li><p>如果想对集合中的元素去重，而且<span class='p red'>保证存取顺序</span></p><ul><li>用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet。</li></ul></li><li><p>如果想对集合中的元素进行<span class='p red'>排序</span></p><ul><li>用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">HashSet、LinkedHashSet和TreeSet解析</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
    <category term="容器" scheme="https://wuwawawa.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>无序集合接口Set</title>
    <link href="https://wuwawawa.github.io/posts/c6185e82.html"/>
    <id>https://wuwawawa.github.io/posts/c6185e82.html</id>
    <published>2023-05-20T02:36:16.000Z</published>
    <updated>2023-05-20T03:30:16.226Z</updated>
    
    <content type="html"><![CDATA[<img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/Set%E4%BD%93%E7%B3%BB%E5%9B%BE1.jpg" alt="Set体系图1" style="zoom:50%;" /><h2 id="Set集合的概述和特点">Set集合的概述和特点</h2><blockquote><p>Set集合的概述</p></blockquote><ul><li>无序集合,这里的无序指的是存取顺序</li><li>用户不可以精确控制列表中每个元素的插入位置</li><li>与List集合不同,列表不允许重复的元素</li></ul><blockquote><p>Set集合的特点</p></blockquote><ul><li>无序： 存和取的元素顺序不一致</li><li>无索引： 没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素</li><li>不重复： 可以去除重复</li></ul><blockquote><p>Set集合的实现类</p></blockquote><ul><li>HashSet：无序、不重复、无索引</li><li>LinkedHashSet：<span class='p blue'>有序</span>、不重复、无索引</li><li>TreeSet：<span class='p green'>可排序</span>、不重复、无索引</li></ul><h2 id="Set集合方法">Set集合方法</h2><p>Set接口中的方法上基本上与Collection的API一致。</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">boolean add(E e)</td><td style="text-align:left">添加元素</td></tr><tr><td style="text-align:left">boolean addAll(Collection&lt;? extends E&gt; c)</td><td style="text-align:left">添加多个元素</td></tr><tr><td style="text-align:left">boolean remove(Object o)</td><td style="text-align:left">移除指定的元素</td></tr><tr><td style="text-align:left">boolean removeIf(Predicate&lt;? super E&gt; filter)</td><td style="text-align:left">根据条件进行移除</td></tr><tr><td style="text-align:left">boolean removeAll(Collection&lt;?&gt; c);</td><td style="text-align:left">移除多个元素</td></tr><tr><td style="text-align:left">void clear()</td><td style="text-align:left">清空集合中的元素</td></tr><tr><td style="text-align:left">boolean contains(Object o)</td><td style="text-align:left">判断集合中是否存在指定的元素</td></tr><tr><td style="text-align:left">boolean isEmpty()</td><td style="text-align:left">判断集合是否为空</td></tr><tr><td style="text-align:left">int size()</td><td style="text-align:left">集合的长度，也就是集合中元素的个数</td></tr></tbody></table><h2 id="Set遍历方式">Set遍历方式</h2><p>Set遍历方法上基本上与Collection的一致。</p><ol><li>迭代器遍历</li><li>增强for遍历</li><li>Lambda表达式</li></ol><div class="tag link"><a class="link-card" title="Collection集合的遍历方式" href="/posts/71c14870.html#Collection遍历方式"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/favicon.png"/></div><div class="right"><p class="text">Collection集合的遍历方式</p><p class="url">/posts/71c14870.html#Collection遍历方式</p></div></a></div>]]></content>
    
    
    <summary type="html">Set中常见的方法和遍历方式</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
    <category term="容器" scheme="https://wuwawawa.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList和LinkedList</title>
    <link href="https://wuwawawa.github.io/posts/7ec37ec5.html"/>
    <id>https://wuwawawa.github.io/posts/7ec37ec5.html</id>
    <published>2023-05-16T13:40:28.000Z</published>
    <updated>2023-05-24T00:23:13.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ArrayList继承体系分析">ArrayList继承体系分析</h2><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220707231107149-2112590708.png" alt="img" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><div class="tabs" id="41484376-eb71-4843-b44f-05f3c2bd6ccd"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#41484376-eb71-4843-b44f-05f3c2bd6ccd-1"><i class="fas fa-cookie-bite"></i>AbstractList</button></li><li class="tab"><button type="button" data-href="#41484376-eb71-4843-b44f-05f3c2bd6ccd-2"><i class="fas fa-dragon"></i>List</button></li><li class="tab"><button type="button" data-href="#41484376-eb71-4843-b44f-05f3c2bd6ccd-3"><i class="fas fa-cat"></i>RandomAccess</button></li><li class="tab"><button type="button" data-href="#41484376-eb71-4843-b44f-05f3c2bd6ccd-4"><i class="fas fa-dove"></i>Cloneable</button></li><li class="tab"><button type="button" data-href="#41484376-eb71-4843-b44f-05f3c2bd6ccd-5"><i class="fas fa-horse"></i>Serializable</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="41484376-eb71-4843-b44f-05f3c2bd6ccd-1"><p>这个抽象类也实现了<code>List</code>接口里面的方法，并且为其提供了默认代码实现，比如说<code>AbstractList</code>中对<code>indexOf</code>的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法的作用就是返回对象 o 在容器当中的下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过迭代器去遍历数据</span></span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator();</span><br><span class="line">    <span class="keyword">if</span> (o==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (it.next()==<span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 返回数据 o 的下标</span></span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">            <span class="keyword">if</span> (o.equals(it.next()))</span><br><span class="line">                <span class="comment">// 返回数据 o 的下标</span></span><br><span class="line">                <span class="keyword">return</span> it.previousIndex();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="41484376-eb71-4843-b44f-05f3c2bd6ccd-2"><p>这个接口主要定义了一些list集合常用的方法让<code>ArrayList</code>进行实现，</p><p>比如<code>add</code>，<code>addAll</code>，<code>contains</code>，<code>remove</code>，<code>set</code>，<code>get</code>，<code>size</code>，<code>indexOf</code>，<code>listIterator</code>等等方法。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="41484376-eb71-4843-b44f-05f3c2bd6ccd-3"><p>标记接口，内部并没有抽象方法。</p><p>这个接口的含义表示可以随机访问<code>ArrayList</code>当中的数据，拿什么是随机访问呢？随机访问就是表示我们可以在常量时间复杂度内访问数据，也就是时间复杂度是<code>O(1)</code>。因为在<code>ArrayList</code>当中我们使用的最基本的数据类型是<code>数组</code>，而数组是可以随机访问的。</p><p>而链表是不可以随机访问的，比如说我们想通过下标访问链表当中的某个数据，需要从头结点或者尾节点开始遍历，直到遍历到下标对应的数据，比如下图中的单链表找到第3个数据，需要从头开始遍历，而这个时间复杂度为<code>O(n)</code>。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220707231535445-1718441250.png" alt="img"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="41484376-eb71-4843-b44f-05f3c2bd6ccd-4"><p>实现<code>Cloneable</code>接口那么实现<code>Cloneable</code>的类就能够调用<code>clone</code>这个方法，如果没有实现<code>Cloneable</code>接口就调用方法，则会抛出异常<code>java.lang.CloneNotSupportedException</code>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="41484376-eb71-4843-b44f-05f3c2bd6ccd-5"><p>Serializable接口主要用于序列化，所谓序列化就是能将对象写入磁盘，反序列化就是能够将对象从磁盘当中读取出来，如果想序列化和反序列化<code>ArrayList</code>的实例对象就必须实现这个接口，如果没有实现这个接口，在实例化的时候程序执行会报错。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="ArrayList关键字段分析">ArrayList关键字段分析</h2><p>在<code>ArrayList</code>当中主要有以下这些字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList当中默认初始化容量,使用无参构造器，则elementData[]初始容量为0,第一次添加元素扩容为10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 存放具体数据的数组 ArrayList 底层就是使用数组进行存储的</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// size 表示容器当中数据的个数 注意和容器的长度区分开来</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">// 当容器当中没有元素的时候将 elementData 赋值为以下数据（不同情况不一样）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个函数是 ArrayList 的构造函数，从下面两个函数当中</span></span><br><span class="line"><span class="comment">// 我们可以看出 EMPTY_ELEMENTDATA 和 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 使用区别</span></span><br><span class="line"><span class="comment">// EMPTY_ELEMENTDATA 是容器容量为0时使用，DEFAULTCAPACITY_EMPTY_ELEMENTDATA是默认构造的时候使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//创建 ArrayList 对象时，如果使用无参构造器，则 elementData[] 初始容量为 0</span></span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="ArrayList主要方法分析">ArrayList主要方法分析</h2><h3 id="add">add</h3><p><code>add</code>方法，这个方法用于往容器的末尾增加数据，也是<code>ArrayList</code>当中最核心的方法。主要工作流程如下图所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220707231130867-1867898666.png" alt="img" style="zoom:67%;" /><p>首先调用函数<code>ensureCapacityInternal</code>确保<code>ArrayList</code>当中的数组长度能够满足需求，不然数组会报数组下标越界异常，<code>add</code>函数调用过程当中所涉及到的函数如下。</p><div class="tabs" id="6a318352-1ba6-4cb9-9bbe-84d380a0a3cf"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-1">add</button></li><li class="tab"><button type="button" data-href="#6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-2">ensureCapacityInternal</button></li><li class="tab"><button type="button" data-href="#6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-3">calculateCapacity</button></li><li class="tab"><button type="button" data-href="#6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-4">ensureExplicitCapacity</button></li><li class="tab"><button type="button" data-href="#6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-5">grow⭐️</button></li><li class="tab"><button type="button" data-href="#6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-6">hugeCapacity</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个函数的主要目的是确保 elementData 的容量有 size + 1 ，否则存储数据的时候数组就会越界</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// size 表示容器当中数据的个数 注意和容器的长度区分开来</span></span><br><span class="line">    <span class="comment">// 加入数据之后 容器当中数据的个数也要 + 1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minCapacity 表示 ArrayList 中的数组最小的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(</span><br><span class="line">        <span class="comment">// 这个函数计算数组的最小长度</span></span><br><span class="line">        calculateCapacity(elementData, minCapacity)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是无参构造的话，取默认长度和需求长度 minCapacity 中比较大的值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个表示容器发生改变的次数，我们在后续分析迭代器的时候进行分析</span></span><br><span class="line">    modCount++;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果最小的需求容量 minCapacity 大于现在容器当中数组的长度，则需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 新数组的长度为原数组的长度的1.5倍，右移一位相当于除以2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果新数组的长度，小于需要的最小的容量，则更新数组的长度为 minCapacity</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这个函数的主要目的是判断整数是否发生溢出</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a318352-1ba6-4cb9-9bbe-84d380a0a3cf-6"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>上述代码的调用流程如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220707231142437-124193873.png" alt="img" style="zoom: 50%;" /><hr><hr><h3 id="get和set">get和set</h3><div class="tabs" id="c18f7a24-21a8-44ee-ae7e-1a8287cc5f76"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c18f7a24-21a8-44ee-ae7e-1a8287cc5f76-1"><i class="fas fa-atom"></i>get</button></li><li class="tab"><button type="button" data-href="#c18f7a24-21a8-44ee-ae7e-1a8287cc5f76-2"><i class="far fa-sun"></i>set</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c18f7a24-21a8-44ee-ae7e-1a8287cc5f76-1"><p>获取对应下标的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行数组下标的检查，如果下标超过 ArrayList 中数据的个数，则抛出异常</span></span><br><span class="line">    <span class="comment">// 注意这里是容器当中数据的个数 不是数组的长度</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回对应下标的数据</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c18f7a24-21a8-44ee-ae7e-1a8287cc5f76-2"><p>这个方法主要是用于设置指定下标的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"> </span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="remove">remove</h3><p>删除<code>ArrayList</code>当中的数据</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220707231154448-1597746352.png" alt="img" style="zoom:80%;" /><div class="tabs" id="7a56d341-394e-4470-add8-6e8a906bebcf"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7a56d341-394e-4470-add8-6e8a906bebcf-1">remove(int index)</button></li><li class="tab"><button type="button" data-href="#7a56d341-394e-4470-add8-6e8a906bebcf-2">remove(Object o)</button></li><li class="tab"><button type="button" data-href="#7a56d341-394e-4470-add8-6e8a906bebcf-3">fastRemove(int index)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7a56d341-394e-4470-add8-6e8a906bebcf-1"><p>通过下标删除数据，这个函数的意义是删除下标为 index 的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先检查下标是否合法，如果不合法，抛出下标越界异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"> </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">  <span class="comment">// 因为删除某个数据，需要将该数据后面的数据往数组前面移动</span></span><br><span class="line">    <span class="comment">// 这里需要计算需要移动的数据的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 通过拷贝移动数据</span></span><br><span class="line">        <span class="comment">// 这个函数的意义是将 index + 1和其之后的数据整体移动到 index</span></span><br><span class="line">        <span class="comment">// 的位置</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 因为最后一个数据已经拷贝到前一个位置了，所以可以设置为 null</span></span><br><span class="line">    <span class="comment">// 可以做垃圾回收了</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7a56d341-394e-4470-add8-6e8a906bebcf-2"><p>删除容器当中的第一个等于 o 的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7a56d341-394e-4470-add8-6e8a906bebcf-3"><p>这个方法和第一个 remove 方法原理一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="toString">toString</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><p><code>toString</code>方法没有直接在<code>ArrayList</code>当中实现，而是在它继承的类<code>AbstractCollection</code>当中实现的，<code>toString</code>的源代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 得到 ArrayList 的迭代器 </span></span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="comment">// 如果容器当中没有数据则返回空</span></span><br><span class="line">    <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> it.next();</span><br><span class="line">        <span class="comment">// 将对象加入到 StringBuilder 当中，这里加入的也是一个对象</span></span><br><span class="line">        <span class="comment">// 但是在 append 源代码当中会同样会使用 String.ValueOf </span></span><br><span class="line">        <span class="comment">// 得到对象的 toString 方法的结果</span></span><br><span class="line">        sb.append(e == <span class="built_in">this</span> ? <span class="string">&quot;(this Collection)&quot;</span> : e);</span><br><span class="line">        <span class="keyword">if</span> (! it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> sb.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">        sb.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果容器当中没有数据，直接返回[]。</li><li>如果容器当中有数据的话，那么通过迭代每个数据，调用<code>StringBuilder</code>的<code>append</code>方法，将数据加入到输出的<code>StringBuilder</code>对象当中。在<code>append</code>方法中添加到<code>StringBuilder</code>当中的字符串仍然是<code>ArrayList</code>当中数据对象的<code>toString</code>方法返回的数据。</li></ul><hr><h3 id="equals">equals</h3><p>在<code>ArrayList</code>当中的<code>equals</code>方法和<code>toString</code>方法不一样，</p><p><code>equlas</code>方法是在类<code>AbstractList</code>当中实现的，其源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    ListIterator&lt;E&gt; e1 = listIterator();</span><br><span class="line">    ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator();</span><br><span class="line">    <span class="keyword">while</span> (e1.hasNext() &amp;&amp; e2.hasNext()) &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">o1</span> <span class="operator">=</span> e1.next();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> e2.next();</span><br><span class="line">        <span class="keyword">if</span> (!(o1==<span class="literal">null</span> ? o2==<span class="literal">null</span> : o1.equals(o2)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(e1.hasNext() || e2.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的主要流程：</p><ul><li>首先判断<code>o</code>和<code>this</code>是否是同一个对象</li><li>如果对象没有实现<code>List</code>接口返回<code>false</code>。</li><li>逐个判断迭代器里面的对象是否相等（调equals），如果两个链表当中节点数目一样而且都相等则返回<code>true</code>否则返回<code>false</code>。</li></ul><hr><h3 id="clone">clone</h3><p>集合的 <code>clone</code> 方法执行的是浅拷贝。这意味着，新创建的集合对象会包含原始集合中的同一组对象引用。如果原始集合中的对象是可变的，那么在新集合中对这些对象所做的更改也会反映在原始集合中。</p><p>如果需要执行深拷贝，可以通过使用序列化和反序列化技术或手动复制对象并创建新的对象引用来实现。例如，可以使用 Java 序列化 API 或第三方库（如 Apache Commons Lang 库）来执行深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个拷贝过程如下如所示：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220707231203740-1128103203.png" alt="img" style="zoom:50%;" /><p>虽然发生了数组的拷贝，但是拷贝之后的数组中数据的指向并没有发生变化，也就是说两个数组指向的内容是一样的。</p><hr><hr><h2 id="ArrayList迭代器Iterator">ArrayList迭代器Iterator</h2><h3 id="Iterator字段分析">Iterator字段分析</h3><p><code>Itr</code>类是<code>ArrayList</code>的内部类，接下来我们仔细分析<code>Itr</code>类的实现。</p><p>在<code>Itr</code>类当中主要有以下几个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下一个元素的下标 当我们 new 这个对象的时候这个值默认初始化为0</span></span><br><span class="line"><span class="type">int</span> cursor;       </span><br><span class="line"><span class="comment">// 上一个通过 next 方法返回的元素的下标  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount; </span><br></pre></td></tr></table></figure><p><code>modCount</code>表示数组当中数据改变的次数 ,是<code>ArrayList</code>当中的类变量。</p><p><code>expectedModCount </code>是<code>ArrayList内部类 Itr</code>中的类变量 然后将这个变量保存到 expectedModCount当中。使用 expectedModCount 主要用于 fast-fail 机制。</p><p><code>modCount</code>（英文全称为：modifications count，修改次数）这个字段。当<code>ArrayList</code>当中发生一次<strong>结构修改</strong>(<code>Structural modifications</code>)时，<code>modCount</code>就++。所谓<strong>结构修改</strong>就是那些让<code>ArrayList</code>当中数组的数据个数<code>size</code>发生变化的操作，比如说<code>add</code>、<code>remove</code>方法，因为这两个方法一个是增加数据，一个是删除数据，都会导致容器当中数据个数发生变化。而<code>set</code>方法就不会是的<code>modCount</code>发生变化，因为没有改变容器当中数据的个数。</p><hr><h3 id="next和hasnext">next和hasnext</h3><div class="tabs" id="b80a58c5-9f6c-45f6-ac2d-8de41ea96561"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b80a58c5-9f6c-45f6-ac2d-8de41ea96561-1"><i class="fas fa-atom"></i>hasNext()</button></li><li class="tab"><button type="button" data-href="#b80a58c5-9f6c-45f6-ac2d-8de41ea96561-2"><i class="far fa-sun"></i>next()</button></li><li class="tab"><button type="button" data-href="#b80a58c5-9f6c-45f6-ac2d-8de41ea96561-3"><i class="fas fa-wind"></i>checkForComodification()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b80a58c5-9f6c-45f6-ac2d-8de41ea96561-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个 size 是外部类 ArrayList 当中的 size 表示的是 ArrayList当中数据元素的个数，</span></span><br><span class="line">    <span class="comment">// cursor 的初始值为 0 每调用一个 next cursor的值就+1，当等于 size 是容器当中的数据已经遍历完成了 hasNext 就返回 false 了</span></span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b80a58c5-9f6c-45f6-ac2d-8de41ea96561-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法主要是用于检测在数据迭代的过程当中 ArrayList 是否发生 结构修改</span></span><br><span class="line">    <span class="comment">// 如果发生结构修改就抛出 ConcurrentModificationException 异常</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    <span class="comment">// 更改 cursor 的值 并将其设置为下一个返回元素的下标 这一点我们在</span></span><br><span class="line">    <span class="comment">// 字段分析的时候已经谈到过了</span></span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回数据 表达式 lastRet = i 的返回值为 i </span></span><br><span class="line">    <span class="comment">// 这个表达式不仅将 lastRet 的值赋值为 i 同时返回 i</span></span><br><span class="line">    <span class="comment">// 因此可以返回下标为 i 的数据</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b80a58c5-9f6c-45f6-ac2d-8de41ea96561-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果发生 结构修改那么 modCount 的值会++ 那么就和 expectedModCount 不相等了</span></span><br><span class="line">    <span class="comment">// expectedModCount 初始化的时候令其等于 expectedModCount</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <p>为什么要抛出<code>ConcurrentModificationException</code>异常呢，我们先想想是什么导致<code>modCount</code>发生变化。肯定迭代器在进行遍历的同时，修改了<code>modCount</code>的值，通常这种现象的发生出现在并发的情况下，因此抛出<code>ConcurrentModificationException</code>异常。像这种通过迭代器遍历过程进行检查并且当发生不符合条件的情况下抛出异常的现象就称作<code>Fast-fail</code>。</p><hr><h3 id="remove-2">remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    <span class="comment">// 进行合法性检查，看是否需要抛出异常</span></span><br><span class="line">    checkForComodification();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 ArrayList 的remove方法实现</span></span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 因为 remove 会改变 modCount 的值，因此需要将 expectedModCount 重新赋值</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="ArrayList总结">ArrayList总结</h2><h3 id="时间复杂度分析">时间复杂度分析</h3><ul><li>因为<code>ArrayList</code>是随机存取的，因此我们通过下标查找数据的时间复杂度是<code>O(1)</code>。</li><li>插入数据的时间复杂度是<code>O(n)</code>。</li></ul><h3 id="扩容机制">扩容机制</h3><p>① 利用空参创建的集合，在底层创建一个默认长度为0的数组</p><p>② 添加第一个元素时，底层会创建一个新的长度为10的数组</p><p>③ 存满时，会扩容1.5倍</p><p>④ 如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</p><blockquote><p>为什么是1.5倍</p></blockquote><p>假设我们在使用<code>ArrayList</code>的时候没有指定初始化的时候数组的长度，也就是说初始长度为<code>ArrayList</code>的默认长度也就是10。那么当我们不停地往容器当中增加数据，扩容导致的数组长度的变化如上图所示，横轴表示扩容次数，纵轴表示数组长度，蓝色的扩容为原数组长度的1.5倍，另外一条是2倍。我们很清晰的发现扩容为原来的<code>2倍</code>在后期的数组长度将会远大于扩容<code>1.5倍</code>。这很可能会导致我们会浪费很大的数组空间，比如说刚好加入最后一个数据的时候导致<code>ArrayList</code>进行扩容操作，这可能是<code>ArrayList</code>在设计时候的考量。</p><img src="https://img2022.cnblogs.com/blog/2519003/202207/2519003-20220707231216216-531592090.png" alt="img" style="zoom:67%;" /><p>1.5^8=25.6</p><p>2^8=256</p><hr><hr><h2 id="LinkedList继承体系">LinkedList继承体系</h2><p>首先先直观的看一下<code>LinedList</code>的继承体系和实现的接口</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220704233923694-1289934053.png" alt="img" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><ul><li>实现了<code>List</code>接口，这个接口定义了一些常见的容器的方法，比如<code>add</code>、<code>addAll</code>、<code>get</code>、<code>set</code>、<code>contains</code>、<code>sort</code>等等。</li><li>实现了<code>Deque</code>接口，这个接口你可以简单的认为是一个双端队列，两头都可以进可以出，它定义的方法有<code>getFirst</code>、<code>getLast</code>、<code>addFirst</code>、<code>addLast</code>、<code>removeFirst</code>、<code>removeLast</code>、<code>peekFirst</code>、<code>peekLast</code>等等。</li><li>实现<code>Cloneable</code>和<code>Serializable</code>接口主要是为了能够进行深拷贝和序列化。</li><li><code>AbstractSequentialList</code>主要是给一些接口方法提供默认实现。</li></ul><p>链表作为一个容器肯定需要将数据加入到容器当中，也需要从容器当中得到某个数据，判断数据是否存在容器当中，因此有<code>add</code>、<code>addAll</code>、<code>get</code>、<code>set</code>、<code>contains</code>、<code>sort</code>这些方法是很自然的。此外<code>LinedList</code>实现的是双向链表，我们很容易在链表的任意位置进行插入和删除，当我们在链表的头部和尾部进行插入和删除的时候就可以满足<code>Deque</code>的需求了（双端队列需要能够在队列的头和尾进行出队和入队，就相当于插入和删除），因此<code>LinedList</code>实现<code>getFirst</code>、<code>getLast</code>、<code>addFirst</code>、<code>addLast</code>、<code>removeFirst</code>、<code>removeLast</code>也就很容易理解了。</p><hr><hr><h2 id="LinkedList整体结构">LinkedList整体结构</h2><mark class="hl-label blue">主要字段</mark> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用于记录链表当中节点的个数，也就是有几个数据</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to first node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 指向双向链表的头结点</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to last node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">// 指向双向链表的尾节点</span></span><br></pre></td></tr></table></figure><mark class="hl-label green">内部节点的形式</mark> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"> </span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的字段分析，<code>LinkedList</code>内部结构主要如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2519003-20220704233936333-32626593.png" alt="img" style="zoom:67%;" /><p>链表当中有<code>first</code>和<code>last</code>字段主要指向链表当中第一个节点和最后一个节点，如果链表当中没有节点，那么他们都是<code>null</code>，如果链表当中有一个节点他们指向同一个节点，如果链表中节点个数大于2，他们分别指向第一个节点和最后一个节点。</p><hr><h2 id="LinkedList主要方法">LinkedList主要方法</h2><h3 id="add-2">add</h3><p><code>add</code>方法，这个方法主要是向链表尾部增加一个元素。</p><div class="tabs" id="f35b9d04-2acd-45e7-b0f1-fd07df6de800"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#f35b9d04-2acd-45e7-b0f1-fd07df6de800-1"><i class="fas fa-cat"></i>add</button></li><li class="tab"><button type="button" data-href="#f35b9d04-2acd-45e7-b0f1-fd07df6de800-2"><i class="fas fa-horse"></i>linkLast</button></li><li class="tab"><button type="button" data-href="#f35b9d04-2acd-45e7-b0f1-fd07df6de800-3"><i class="fas fa-heartbeat"></i>linkBefore</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="f35b9d04-2acd-45e7-b0f1-fd07df6de800-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法主要是向链表尾部增加一个元素</span></span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f35b9d04-2acd-45e7-b0f1-fd07df6de800-2"><p>向链表尾部增加一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f35b9d04-2acd-45e7-b0f1-fd07df6de800-3"><p><code>linkBefore</code>和<code>linkLast</code>的作用相反，是在某个节点前面插入数据<code>e</code>，大体和前面的<code>linkLast</code>方法一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts element e before non-null Node succ.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="get和set-2">get和set</h3><div class="tabs" id="2ca762ce-3adb-46d9-b490-59bdef0bbc39"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2ca762ce-3adb-46d9-b490-59bdef0bbc39-1"><i class="fas fa-award"></i>get</button></li><li class="tab"><button type="button" data-href="#2ca762ce-3adb-46d9-b490-59bdef0bbc39-2"><i class="fas fa-baseball-ball"></i>set</button></li><li class="tab"><button type="button" data-href="#2ca762ce-3adb-46d9-b490-59bdef0bbc39-3"><i class="fas fa-bone"></i>node</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2ca762ce-3adb-46d9-b490-59bdef0bbc39-1"><p>通过下标获取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index); <span class="comment">// 判断下标是否合法</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item; <span class="comment">// 取出对应的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ca762ce-3adb-46d9-b490-59bdef0bbc39-2"><p>更新某个下标的数据<code>item</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">       checkElementIndex(index); <span class="comment">// 判断下标是否合法</span></span><br><span class="line">       Node&lt;E&gt; x = node(index);</span><br><span class="line">       <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">       x.item = element; <span class="comment">// 更新数据</span></span><br><span class="line">       <span class="keyword">return</span> oldVal; <span class="comment">// 返回旧数据</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ca762ce-3adb-46d9-b490-59bdef0bbc39-3"><p>根据下标找到对应的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到第 index + 1 个元素</span></span><br><span class="line">    <span class="comment">// 判断对应位置的元素是离链表头部近还是离链表尾部近，哪头近就从哪头遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="remove-3">remove</h3><div class="tabs" id="c97870d9-78a0-4bce-98ab-0dca438c346f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c97870d9-78a0-4bce-98ab-0dca438c346f-1"><i class="fas fa-atom"></i>remove</button></li><li class="tab"><button type="button" data-href="#c97870d9-78a0-4bce-98ab-0dca438c346f-2"><i class="far fa-sun"></i>unlink</button></li><li class="tab"><button type="button" data-href="#c97870d9-78a0-4bce-98ab-0dca438c346f-3"><i class="fas fa-wind"></i>unlinkFirst</button></li><li class="tab"><button type="button" data-href="#c97870d9-78a0-4bce-98ab-0dca438c346f-4"><i class="fas fa-fire-alt"></i>unlinkLast</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c97870d9-78a0-4bce-98ab-0dca438c346f-1"><p>删除链表当中的某个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果元素为 null，就删除链表当中第一个值为 null 的元素</span></span><br><span class="line">    <span class="comment">// 从这里也可以看出 LinkedList 支持值为 null 的对象</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c97870d9-78a0-4bce-98ab-0dca438c346f-2"><p>删除某个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前一个节点为 null 说明被删除的就是首节点，因此需要跟新首节点为原来节点的下一个节点，也就是 next</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 同样的，如果 next 为 null ，那么被删除的节点就是为节点，因此需要更新 last 为被删除节点的上一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c97870d9-78a0-4bce-98ab-0dca438c346f-3"><p>删除链表当中第一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// f 表示头结点，且 f 不等于 null</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> f.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = <span class="literal">null</span>;</span><br><span class="line">    f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    first = next; <span class="comment">// 头结点变成f的下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">        last = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="literal">null</span>;</span><br><span class="line">    size--; <span class="comment">// 删除一个节点链表当中数据少了一个，因此size--</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c97870d9-78a0-4bce-98ab-0dca438c346f-4"><p>删除链表当中最后一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> &#123;</span><br><span class="line">    <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> l.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = <span class="literal">null</span>;</span><br><span class="line">    l.prev = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>)</span><br><span class="line">        first = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev.next = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="clone-2">clone</h3><p>当我们想要克隆一个对象的时候我们通常会使用到这个方法，这个方法通常是将被克隆的对象复制一份，我们来看一下<code>LinkedList</code>的<code>clone</code>方法。</p><p>我们可以知道<code>LinkedList</code>的克隆方法创建了一个新的链表但是没有改变里面的数据，因此如果你修改克隆链表中的数据的话，原来的链表里面的数据也会改。</p><div class="tabs" id="ce746b79-24bb-4517-9916-86e9830c22b2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ce746b79-24bb-4517-9916-86e9830c22b2-1"><i class="fas fa-bug"></i>clone</button></li><li class="tab"><button type="button" data-href="#ce746b79-24bb-4517-9916-86e9830c22b2-2"><i class="fas fa-cannabis"></i>superClone</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ce746b79-24bb-4517-9916-86e9830c22b2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkedList&lt;E&gt; clone = superClone();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Put clone into &quot;virgin&quot; state</span></span><br><span class="line">    clone.first = clone.last = <span class="literal">null</span>;</span><br><span class="line">    clone.size = <span class="number">0</span>;</span><br><span class="line">    clone.modCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize clone with our elements</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">        clone.add(x.item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ce746b79-24bb-4517-9916-86e9830c22b2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LinkedList&lt;E&gt; <span class="title function_">superClone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (LinkedList&lt;E&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">ArrayList和LinkedList设计分析</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
    <category term="容器" scheme="https://wuwawawa.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>有序集合接口List</title>
    <link href="https://wuwawawa.github.io/posts/494ad091.html"/>
    <id>https://wuwawawa.github.io/posts/494ad091.html</id>
    <published>2023-05-16T11:22:46.000Z</published>
    <updated>2023-05-20T03:04:35.445Z</updated>
    
    <content type="html"><![CDATA[<img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/List%E4%BD%93%E7%B3%BB%E5%9B%BE1.jpg" alt="List体系图1" style="zoom:50%;" /><h2 id="List集合的概述和特点">List集合的概述和特点</h2><blockquote><p>List集合的概述</p></blockquote><ul><li>有序集合,这里的有序指的是存取顺序</li><li>用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素</li><li>与Set集合不同,列表通常允许重复的元素</li></ul><blockquote><p>List集合的特点</p></blockquote><ul><li>有序： 存和取的元素顺序一致</li><li>有索引： 可以通过索引操作元素</li><li>可重复：存储的元素可以重复</li></ul><hr><hr><h2 id="List集合的特有方法">List集合的特有方法</h2><ul><li>Collection的方法List都继承了</li><li>List集合因为有索引，索引多了很多索引操作的方法</li></ul><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void add(int index,E element)</td><td>在此集合中的指定位置插入指定的元素</td></tr><tr><td>E remove(int index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>E set(int index,E element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E get(int index)</td><td>返回指定索引处的元素</td></tr><tr><td>int indexOf(Object o);</td><td>返回指定元素的索引</td></tr><tr><td>ListIterator&lt; E &gt; listIterator();</td><td>返回列表迭代器</td></tr></tbody></table><blockquote><p>List系列集合中两个增加的方法</p></blockquote><p>第一个Collection接口中方法 <code> boolean add(E e);</code>添加指定的元素,返回值表示当前元素是否添加成功</p><p>第二个List接口中方法 <code> void add(int index,E element)</code> 添加指定索引的元素，无返回值</p><blockquote><p>List系列集合中两个删除的方法</p></blockquote><p>第一个Collection接口中方法  <code> boolean remove(Object o)</code>删除指定的元素,返回值表示当前元素是否删除成功</p><p>第二个List接口中方法 <code> E remove(int index)</code> 删除指定索引的元素,返回值表示实际删除的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建集合并添加元素</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 删除元素</span></span><br><span class="line"><span class="comment">//请问：此时删除的是1这个元素，还是1索引上的元素 为什么</span></span><br><span class="line"><span class="comment">//在调用方法的时候，如果出现了重载现象</span></span><br><span class="line"><span class="comment">//优先调用，实参和形参类型一致的那个方法</span></span><br><span class="line">list.remove(<span class="number">1</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//[1, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动装箱,手动把基本数据类型的1，变成Integer类型</span></span><br><span class="line"><span class="comment">// 此时删除的就是1这个元素</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">list.remove(i);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//[3]</span></span><br></pre></td></tr></table></figure><hr><h2 id="List集合的遍历方式">List集合的遍历方式</h2><p>List继承于Collection，三种遍历方式也都可以用</p><ul><li>迭代器遍历</li><li>增强for遍历</li><li>Lambda表达式遍历</li></ul><p>在此基础上，还有两种单独的遍历方式</p><ul><li>列表迭代器遍历</li><li>普通for循环（因为List集合存在索引）</li></ul><p>创建集合并添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建集合并添加元素</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br></pre></td></tr></table></figure><div class="tabs" id="1c246663-c60c-42f3-ba8d-77e38f358527"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1c246663-c60c-42f3-ba8d-77e38f358527-1"><i class="fas fa-child"></i>迭代器</button></li><li class="tab"><button type="button" data-href="#1c246663-c60c-42f3-ba8d-77e38f358527-2"><i class="fas fa-child"></i>增强for</button></li><li class="tab"><button type="button" data-href="#1c246663-c60c-42f3-ba8d-77e38f358527-3"><i class="fas fa-child"></i>Lambda表达式</button></li><li class="tab"><button type="button" data-href="#1c246663-c60c-42f3-ba8d-77e38f358527-4"><i class="fas fa-cookie-bite"></i>列表迭代器</button></li><li class="tab"><button type="button" data-href="#1c246663-c60c-42f3-ba8d-77e38f358527-5"><i class="fas fa-cookie-bite"></i>普通for</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1c246663-c60c-42f3-ba8d-77e38f358527-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1c246663-c60c-42f3-ba8d-77e38f358527-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.增强for</span></span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1c246663-c60c-42f3-ba8d-77e38f358527-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.Lambda表达式</span></span><br><span class="line"> list.forEach(System.out::println);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1c246663-c60c-42f3-ba8d-77e38f358527-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.列表迭代器</span></span><br><span class="line">ListIterator&lt;String&gt; stringListIterator = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (stringListIterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span>  stringListIterator.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1c246663-c60c-42f3-ba8d-77e38f358527-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.普通for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><code>ListIterator</code>接口继承了<code>Iterator</code>接口</p><p><code>interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt;</code></p><p><code>Iterator</code>原有方法<code>boolean hasNext()</code> 和 <code>E next()</code></p><p><code>ListIterator</code>新加了<code>boolean hasPrevious();</code>和<code>E previous()</code>向前遍历</p><p>和<code>void add(E e)</code>添加元素的方法</p><blockquote><p>五种遍历方式对比</p></blockquote><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230516205838333.png" alt="image-20230516205838333" style="zoom:67%;" />]]></content>
    
    
    <summary type="html">List中常见的方法和五种遍历方式</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
    <category term="容器" scheme="https://wuwawawa.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>顶层接口Collection</title>
    <link href="https://wuwawawa.github.io/posts/71c14870.html"/>
    <id>https://wuwawawa.github.io/posts/71c14870.html</id>
    <published>2023-05-16T06:05:20.000Z</published>
    <updated>2023-05-23T12:33:19.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合体系结构">集合体系结构</h2><p>Java的容器主要分为2个大类，即<code>Collection</code>和<code>Map</code>。</p><ul><li><span class='p red'>Collection 接口（单列集合）</span>：可以存放多个元素。每个元素可以是 Object<p>Collection 接口有两个重要子接口：List（有序集合）和 Set（无序集合）</p></li><li><span class='p blue'>Map 接口（双列集合）</span>：用于保存具有映射关系的数据：key - value（双列元素）<p>key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value 可以重复</p><p>key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value</p></li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230516142001202.png" alt="image-20230516142001202" style="zoom:67%;" /><hr><hr><h2 id="Collection继承体系">Collection继承体系</h2><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230516142842394.png" alt="image-20230516142842394" style="zoom:67%;" /><p>根据图，首先提一下<code>List</code> <code>Queue</code> <code>Set</code> 这三个的区别。</p><p><code>List(对付顺序的好帮手)</code>: 添加的元素是有序、可重复、有索引的。<br><code>Set(注重独一无二的性质)</code>：添加的元素是无序的、不可重复、无索引的。<br><code>Queue(实现排队功能的叫号机)</code>:按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><hr><hr><h2 id="Collection接口方法">Collection接口方法</h2><p>Collection是单列集合的祖宗接口，它的功能是全部单列集合都可以继承使用的。</p><p>JDK不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">boolean add(E e)</td><td style="text-align:left">添加元素</td></tr><tr><td style="text-align:left">boolean addAll(Collection&lt;? extends E&gt; c)</td><td style="text-align:left">添加多个元素</td></tr><tr><td style="text-align:left">boolean remove(Object o)</td><td style="text-align:left">移除指定的元素</td></tr><tr><td style="text-align:left">boolean removeIf(Predicate&lt;? super E&gt; filter)</td><td style="text-align:left">根据条件进行移除</td></tr><tr><td style="text-align:left">boolean removeAll(Collection&lt;?&gt; c)</td><td style="text-align:left">移除多个元素</td></tr><tr><td style="text-align:left">void clear()</td><td style="text-align:left">清空集合中的元素</td></tr><tr><td style="text-align:left">boolean contains(Object o)</td><td style="text-align:left">判断集合中是否存在指定的元素</td></tr><tr><td style="text-align:left">boolean isEmpty()</td><td style="text-align:left">判断集合是否为空</td></tr><tr><td style="text-align:left">int size()</td><td style="text-align:left">集合的长度，也就是集合中元素的个数</td></tr></tbody></table><blockquote><p>添加元素 boolean add(E e)</p></blockquote><p>细节1：如果我们要往List系列集合添加数据，那么方法永远返回ture，因为List系列是允许元素重复的。</p><p>细节2：如果我们要往Set系列集合添加数据</p><p>如果当前要添加的元素不存在，方法返回true，表示添加成功。</p><p>如果当前要添加的元素存在，方法返回false，表示添加失败。</p><p>因为Set系列集合不允许重复。</p><blockquote><p>移除元素 boolean remove(Object o)</p></blockquote><p>细节1：根据元素的对象进行删除，不能通过索引删，因为Set系列是没有索引的，在Collection中定义的是共性的方法。</p><p>细节2：方法会有一个布尔类型的返回值，删除成功返回true，删除失败返回false。如果要删除的元素不存在，就会删除失败。</p><blockquote><p>判断元素是否包含 boolean contains(Object o)</p></blockquote><p>底层是依赖equals方法进行判断是否存在的。所以，如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在自定义类中，一定要重写equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建集合的对象</span></span><br><span class="line">Collection&lt;Studebt&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建三个学生对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">23</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">24</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangwu&quot;</span>,<span class="number">23</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.把学生对象添加到集合当中</span></span><br><span class="line">coll.add(s1);</span><br><span class="line">coll.add(s2);</span><br><span class="line">coll.add(s3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.判断集合中某一个学生对象是否包含，如果同姓名同年龄，就认为是</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">23</span>);</span><br><span class="line"><span class="comment">// 因为contains方法在底层依赖equals方法判断对象是否一致的。</span></span><br><span class="line"><span class="comment">// 如果存的是自定义对象，没有重写equals方法，那么默认使用Object类中的equals方法进行判断</span></span><br><span class="line"><span class="comment">// 而Object类中equals方法，依赖地址值就行判断。</span></span><br><span class="line"><span class="comment">// 所以，需要在自定义的类中，重写equals方法就可以了。</span></span><br><span class="line">System.out.println(coll.contains(s4));</span><br></pre></td></tr></table></figure><hr><hr><h2 id="Collection遍历方式">Collection遍历方式</h2><p>Collection通用遍历方式有三种：</p><ol><li>迭代器遍历</li><li>增强for遍历</li><li>Lambda表达式</li></ol><hr><h3 id="迭代器遍历">迭代器遍历</h3><p>迭代器在Java中的类是<span class='p red'>Iterator</span>，迭代器是集合专用的遍历方式。</p><mark class="hl-label blue">Collection集合获取迭代器</mark> <table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Iterator&lt; E &gt; iterator()</td><td style="text-align:left">返回迭代器对象，默认指向当前集合的0索引</td></tr></tbody></table><mark class="hl-label green">iterator中的常用方法</mark> <table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>boolean hasNext()</td><td>判断当前位置是否有元素，有元素返回true，没有元素返回false</td></tr><tr><td>E next()</td><td>获取当前位置的元素，并将迭代器对象移向下一个位置</td></tr></tbody></table><div class="tabs" id="453454f2-6b5c-4dc3-a93a-77c2d76544de"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#453454f2-6b5c-4dc3-a93a-77c2d76544de-1"><i class="fas fa-cat"></i>开始情况</button></li><li class="tab"><button type="button" data-href="#453454f2-6b5c-4dc3-a93a-77c2d76544de-2"><i class="fas fa-horse"></i>结束情况</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="453454f2-6b5c-4dc3-a93a-77c2d76544de-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230516170605737.png" alt="image-20230516170605737" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="453454f2-6b5c-4dc3-a93a-77c2d76544de-2"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230516172114394.png" alt="image-20230516172114394"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label red">细节注意点</mark> <ol><li>当上面的循环结束后，迭代器指向集合的末尾，再强行调用next方法获取元素的话，就会报错NoSuchElementException</li><li>迭代器遍历完毕后，迭代器是不会复位的，如果要想重新遍历一次，可以重新获取迭代器对象</li><li>循环中只能使用一次next方法，因为在while判断条件中只判断了一次hasNext，hasNext和next要一一对应</li><li>迭代器遍历时，不能使用集合的方法进行增加或者删除(会导致expectedModCount和modCount不相等)，如果实在要删除，那么可以用迭代器提供的remove方法进行删除</li></ol><hr><h3 id="增强for遍历">增强for遍历</h3><p>增强for的底层就是迭代器，为了简化迭代器的代码书写的。</p><p>它是JDK5之后出现的，其内部原理就是一个Iterator迭代器</p><p>增强for循环可以用来遍历数组和实现了<code>Iterable</code>接口的集合对象。</p><p>在Java中，所有的单列集合都实现了<code>Iterable</code>接口，因此可以使用增强for循环遍历这些集合。</p><p>单列集合包括<code>List</code>、<code>Set</code>、<code>Queue</code>等，但不包括<code>Map</code>，因为<code>Map</code>是双列集合。</p><mark class="hl-label green">格式</mark> <p>idea 快速生成方式   <code>集合的名字.for</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">for</span>(元素数据类型 变量名 : 数组或者集合)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">for</span>(String s in coll)&#123;</span><br><span class="line">System<span class="selector-class">.out</span><span class="selector-class">.println</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label red">注意点</mark> <p>s其实就是一个第三方变量，在循环的过程中依次表示集合中的每一个数据</p><p>修改增强for中的变量，不会改变集合中原本的数据</p><hr><h3 id="Lambda表达式遍历">Lambda表达式遍历</h3><p>得益于JDK 8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>defalut void forEach(Consumer&lt;? super T&gt; action)</td><td>结合lambda遍历集合</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类的形式</span></span><br><span class="line">coll.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式</span></span><br><span class="line">coll.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure><mark class="hl-label blue">底层原理</mark> <p>方法内部也会循环遍历集合，依次得到每一个元素，把得到的每一个元素，传递给accept方法消费</p><hr><hr><h2 id="Collection遍历规律">Collection遍历规律</h2><ol><li>遍历顺序与元素添加的顺序有关的集合：ArrayList、LinkedList、LinkedHashSet、ArrayDeque、LinkedList。</li><li>遍历顺序与Comparator有关的集合：PriorityQueue、TreeSet。</li></ol><p>PriorityQueue遍历并没有什么意义，因为PriorityQueue是一种基于堆的数据结构，堆顶元素永远是优先级最高的元素，而遍历PriorityQueue需要访问所有元素，因此会浪费很多时间访问那些优先级较低的元素。</p><p>PriorityQueue 使用数组存储，作为堆，你只能获得他的最大，最小值，可以存储重复的值。</p><p>TreeSet可以保证数据全部按照某个顺序排列，不允许重复，可获得其中的任意值，提供比优先队列更多的特性，但同样意味着需要进行更多的计算。</p>]]></content>
    
    
    <summary type="html">集合体系结构和顶层接口Collection</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
    <category term="容器" scheme="https://wuwawawa.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://wuwawawa.github.io/posts/397c083a.html"/>
    <id>https://wuwawawa.github.io/posts/397c083a.html</id>
    <published>2023-05-10T08:05:42.000Z</published>
    <updated>2023-05-16T05:47:33.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java8新特性的好处">Java8新特性的好处</h2><ol><li>速度更快</li><li>代码更少（Lambda简化代码书写）</li><li>强大的Stream API</li><li>便于并行</li><li>最大化减少空指针异常：Optional</li><li>Nashorn引擎，允许在JVM上运行JS应用</li></ol><hr><hr><h2 id="接口变化">接口变化</h2><p>在JDK 8 以前，接口中只有抽象方法和静态常量，会存在以下问题：在接口中新增方法，所有实现类都要重写该方法，不利于接口的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">静态常量（<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>）;</span><br><span class="line">抽象方法（<span class="keyword">public</span> <span class="keyword">abstract</span>）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK 8 之后，接口中增加了default方法和static方法，分别使用 static 和 default 关键字修饰，这两种方法可以有方法体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">静态常量（<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>）;</span><br><span class="line">抽象方法（<span class="keyword">public</span> <span class="keyword">abstract</span>）;</span><br><span class="line">默认方法</span><br><span class="line">静态方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label blue">区别</mark> <ol><li>默认方法通过实例调用，静态方法通过接口名调用</li><li>默认方法可以被继承，实现类可以直接调用接口默认方法，也可以重写接口默认方法</li><li>静态方法不能被继承，实现类不能重写接口的静态方法，只能使用接口名调用</li></ol><hr><h3 id="默认方法">默认方法</h3><p>在JDK8以前接口中只能有抽象方法和静态常量，会存在以下的问题：<br>如果接口中新增抽象方法，那么实现类都必须要抽象这个抽象方法，非常不利于接口的扩展的。</p><div class="tabs" id="ca8a7413-161b-4f1e-a04b-8bf7f205b9aa"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ca8a7413-161b-4f1e-a04b-8bf7f205b9aa-1"><i class="fas fa-cat"></i>语法</button></li><li class="tab"><button type="button" data-href="#ca8a7413-161b-4f1e-a04b-8bf7f205b9aa-2"><i class="fas fa-horse"></i>使用</button></li><li class="tab"><button type="button" data-href="#ca8a7413-161b-4f1e-a04b-8bf7f205b9aa-3"><i class="fas fa-dove"></i>样例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ca8a7413-161b-4f1e-a04b-8bf7f205b9aa-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">修饰符 <span class="keyword">default</span> 返回值类型 方法名&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca8a7413-161b-4f1e-a04b-8bf7f205b9aa-2"><ol><li>实现类直接调用接口的默认方法</li><li>实现类重写接口的默认方法</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca8a7413-161b-4f1e-a04b-8bf7f205b9aa-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在接口中新增方法，所有实现类都要重写该方法，不利于接口的扩展</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> String <span class="title function_">testDefaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口中的默认方法执行了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="静态方法">静态方法</h3><p>JDK8中为接口新增了静态方法，作用也是为了接口的扩展<div class="tabs" id="2bbf712d-0e57-4b42-aaec-bfc43b69f6a5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2bbf712d-0e57-4b42-aaec-bfc43b69f6a5-1"><i class="fas fa-atom"></i>语法</button></li><li class="tab"><button type="button" data-href="#2bbf712d-0e57-4b42-aaec-bfc43b69f6a5-2"><i class="far fa-sun"></i>使用</button></li><li class="tab"><button type="button" data-href="#2bbf712d-0e57-4b42-aaec-bfc43b69f6a5-3"><i class="fas fa-wind"></i>样例</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2bbf712d-0e57-4b42-aaec-bfc43b69f6a5-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名&#123;</span><br><span class="line">    修饰符 <span class="keyword">static</span> 返回值类型 方法名&#123;</span><br><span class="line">    方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bbf712d-0e57-4b42-aaec-bfc43b69f6a5-2"><p>接口中的静态方法在实现类中是不能被重写的，调用的话只能通过接口类型来实现: 接口名.静态方法名();</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bbf712d-0e57-4b42-aaec-bfc43b69f6a5-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestInterA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在接口中新增方法，所有实现类都要重写该方法，不利于接口的扩展</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAbstract01</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testAbstract02</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStaticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestInterA里面的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">testDefaultMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestInterA里面的默认方法testDefaultMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><hr><hr><h2 id="Comparator接口">Comparator接口</h2><h3 id="底层原理分析">底层原理分析</h3><p>Comparator接口用来定义两个对象之间的比较方法，它有一个叫做<code>compare</code>的方法，函数签名如下：</p><p><code>int compare(T o1,T o2)</code></p><p>查看sort方法的相关源码：如果compare的返回值为正数，就交换进行比较的两个元素的位置。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/cbcf171cd6bc494abfe61be71508287a.png" alt="img" style="zoom:67%;" /><p>结论</p><ul><li>如果 o1 &gt; o2 时compare(o1,o2)返回正数，那么交换位置后大的元素在后，这就实现了升序排序；</li><li>如果 o1 &lt; o2 时compare(o1,o2)返回负数，那么交换位置后小的元素在后，这就实现了降序排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 升序。</span></span><br><span class="line"><span class="comment">// 若o1 - o2 &lt; 0，则o1小于o2，不用交换，即为升序。</span></span><br><span class="line"><span class="comment">// 若o1 - o2 &gt; 0，则o1大于o2，交换后小的在前，大的在后，即为升序。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> o1, <span class="type">int</span> o2)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> o1 -o2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序。</span></span><br><span class="line"><span class="comment">// 若o2 - o1 &lt; 0，则o2小于o1，不用交换，即降序。</span></span><br><span class="line"><span class="comment">// 若o2 - o1 &gt; 0，则o2大于o1，交换后大的在前，小的在后，即为降序。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> o1, <span class="type">int</span> o2)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> o2 -o1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较器的使用">比较器的使用</h3><p>为了对一个集合进行排序，我们将比较器(Comparator)实例传递给<code>Stream.sorted</code>、<code>Collections.sort</code>、<code>List.sort</code>和<code>Arrays.sort</code>方法。</p><p>比较器(Comparator)还可以控制<code>SortedSet</code>的顺序和<code>SortedMap</code>数据结构的键顺序。</p><h3 id="比较器的方法">比较器的方法</h3><p>在<code>Java 8</code>中，比较器接口引入了一些静态和默认的方法。</p><p>我们可以将比较器与<code>Stream.sorted</code>、<code>List.sort</code>、<code>Collections.sort</code>和<code>Arrays.sort</code>一起使用来对集合和<code>Map</code>进行排序。</p><div class="tabs" id="061c08cf-c9fe-4314-ae92-e318b541721f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#061c08cf-c9fe-4314-ae92-e318b541721f-1"><i class="fas fa-seedling"></i>reversed</button></li><li class="tab"><button type="button" data-href="#061c08cf-c9fe-4314-ae92-e318b541721f-2"><i class="fas fa-leaf"></i>reverseOrder</button></li><li class="tab"><button type="button" data-href="#061c08cf-c9fe-4314-ae92-e318b541721f-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#061c08cf-c9fe-4314-ae92-e318b541721f-4"><i class="fas fa-tree"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="061c08cf-c9fe-4314-ae92-e318b541721f-1"><p>reversed是Java比较器功能接口的默认方法。reversed返回一个比较器，该比较器强制执行反向排序。函数签名如下：</p><p><code>default Comparator&lt;T&gt; reversed() </code></p><p>要使用<code>reversed</code>方法，我们需要实例化我们的比较器并调用该方法。</p><p><code>reversed</code>将返回新的比较器实例，该实例将强加该比较器的反向排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Student&gt; nameComparator = (s1, s2) -&gt; s1.getName().compareTo(s2.getName());</span><br><span class="line">Collections.sort(list, nameComparator.reversed()); </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="061c08cf-c9fe-4314-ae92-e318b541721f-2"><p>reverseOrder是一个静态方法，返回比较器，对对象集合进行反向自然排序。</p><p>对于自然排序，一个类需要实现比较器并定义compareTo方法。</p><p>一个对象集合根据自然排序中的compareTo进行排序。</p><p>Comparator.reverseOrder反转了自然排序。</p><p>它在内部调用Collections.reverseOrder()并返回比较器实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.reverseOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="061c08cf-c9fe-4314-ae92-e318b541721f-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="061c08cf-c9fe-4314-ae92-e318b541721f-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="并行流与串行流">并行流与串行流</h2><ul><li>并行流就是把一个内容分为多个数据块，并用不同的线程分别处理每个数据块的流，相比较于串行流，可以很大程度上提高程序的执行效率</li><li>Java8中将其进行了优化，我们可以很容易的对数据进行并行操作。</li><li>Stream API 可以声明性地通过parallel()和sequential()在并行流与顺序流之间进行切换</li></ul><hr><hr><h2 id="Lambda表达式">Lambda表达式</h2><ul><li>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。</li><li>使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，是Java的语言表达能力得到了提升</li></ul><blockquote><span class='p red'>lambda表达式使用前提</span></blockquote><p>必须有接口,接口中有且只能有一个抽象方法(函数式接口)</p><p>Lambda表达式是可推导可以省略的，Lambda表达式可以推导出来，省略就是重写唯一的抽象方法进而可以进一步对参数和返回值进行简化</p><ol><li><p>举例： (o1,o2) -&gt; Integer.compare(o1,o2);</p></li><li><p>格式：</p><ul><li><code>-&gt;：</code>lambda操作符或箭头操作符</li><li><code>-&gt;左边：</code>lambda形参列表（其实就是接口中的抽象方法的形参列表）</li><li><code>-&gt;右边：</code>lambda体（其实就是重写的抽象方法的方法体）</li></ul></li><li><p>Lambda表达式的使用：</p><ul><li><p>Lambda形参列表的参数类型可以省略</p></li><li><p>如果Lambda形参列表只有一个参数，其一对()也可以省略</p></li><li><p>Lambda体应该使用一对{}包裹</p></li><li><p>如果Lambda体只有一条执行语句(可能是return语句),可以省略这一对{}和return关键字</p></li></ul></li></ol><p>分为6种情况介绍</p><div class="tabs" id="a8a76b8b-df65-4a0a-a2c4-660e9341c1fe"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-1"><i class="fas fa-bug"></i>格式一</button></li><li class="tab"><button type="button" data-href="#a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-2"><i class="fas fa-cannabis"></i>格式二</button></li><li class="tab"><button type="button" data-href="#a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-3"><i class="fas fa-candy-cane"></i>格式三</button></li><li class="tab"><button type="button" data-href="#a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-4"><i class="fas fa-child"></i>格式四</button></li><li class="tab"><button type="button" data-href="#a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-5"><i class="fas fa-heartbeat"></i>格式五</button></li><li class="tab"><button type="button" data-href="#a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-6"><i class="fas fa-cookie-bite"></i>格式六</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-1"><p><code>语法格式一：</code>无参无返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你 的 城 市 好 像 不 欢 迎 我&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    runnable01.run();</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable02</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;所 以 我 只 好 转 身 离 开 了&quot;</span>);</span><br><span class="line">    runnable02.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-2"><p><code>语法格式二：</code>Lambda需要一个参数，但是没有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Consumer&lt;String&gt; consumer01 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer01.accept(<span class="string">&quot;其实我存过你照片 也研究过你的星座&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; consumer02 = (String s) -&gt; &#123;System.out.println(s);&#125;;</span><br><span class="line">    consumer02.accept(<span class="string">&quot;你喜欢的歌我也会去听 你喜欢的事物我也会想去了解&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-3"><p><code>语法格式三：</code>数据类型可以省略，因为可由<code>类型推断</code>得出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Consumer&lt;String&gt; consumer01 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer01.accept(<span class="string">&quot;我远比表面上更喜欢你&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; consumer02 = (s) -&gt; &#123;System.out.println(s);&#125;;</span><br><span class="line">    consumer02.accept(<span class="string">&quot;但我没有说&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-4"><p><code>语法格式四：</code>Lambda若只需要一个参数，参数的小括号可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Consumer&lt;String&gt; consumer01 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer01.accept(<span class="string">&quot;我远比表面上更喜欢你&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Consumer&lt;String&gt; consumer02 = s -&gt; &#123;System.out.println(s);&#125;;</span><br><span class="line">    consumer02.accept(<span class="string">&quot;但我没有说&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-5"><p><code>语法格式五：</code>Lambda需要两个或以上参数，多条执行语句，并且有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator01 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator01.compare(<span class="number">95</span>, <span class="number">27</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator02 = (o1, o2) -&gt; &#123;</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator02.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a8a76b8b-df65-4a0a-a2c4-660e9341c1fe-6"><p><code>语法格式六：</code>当Lambda体只有一条语句时，return与{}若有，则都可以省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator01 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparator01.compare(<span class="number">95</span>, <span class="number">27</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Lambda表达式</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator02 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">    System.out.println(comparator02.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="函数式接口">函数式接口</h2><ul><li>Lambda表达式的本质：作为函数式接口的实例</li><li>如果在一个接口中，只声明了一个抽象方法，则此接口就被称为函数式接口，我们可以在一个接口上使用@FunctionalInterface注解来验证该接口是否为函数式接口（如果你在该接口中写了两个方法，则编译期就会报错）</li><li>正是因为抽象方法中只有一个方法，所以我们才可以省略@Override函数声明等内容</li><li>在<code>java.util.function</code>包下定义了Java 8 的丰富的函数式接口</li><li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP)编程是一切。但是随着Python、Scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还可以支持OOF（面向函数编程）</li><li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口。</li><li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用Lambda表达式来表示。</li><li>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。</li></ul><blockquote><p>Java内置的函数式接口介绍及使用举例</p></blockquote><table><thead><tr><th style="text-align:center">函数式接口</th><th style="text-align:center">方法</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">Consumer 消费型接口</td><td style="text-align:center">void accept(T t)</td><td style="text-align:center">对类型为T的对象应用操作</td></tr><tr><td style="text-align:center">Supplier 供给型接口</td><td style="text-align:center">T get()</td><td style="text-align:center">返回类型为T的对象</td></tr><tr><td style="text-align:center">Function 函数型接口</td><td style="text-align:center">R apply(T t)</td><td style="text-align:center">对类型为T的对象应用操作返回结果</td></tr><tr><td style="text-align:center">Predicate 断定型接口</td><td style="text-align:center">boolean test(T t)</td><td style="text-align:center">确定类型为T的对象是否满足某约束</td></tr><tr><td style="text-align:center">BiConsumer</td><td style="text-align:center">void accept(T t,U u)</td><td style="text-align:center">对类型为T,U参数应用操作</td></tr><tr><td style="text-align:center">BiPredicate</td><td style="text-align:center">boolean</td><td style="text-align:center">包含方法为：boolean test(T t,U u)</td></tr><tr><td style="text-align:center">BiFunction</td><td style="text-align:center">R apply(T t,U u)</td><td style="text-align:center">对类型为T,U参数应用操作，返回R类型的结果</td></tr><tr><td style="text-align:center">UnaryOperator(Function子接口)</td><td style="text-align:center">T apply(T t)</td><td style="text-align:center">对类型为T的对象进行一元运算</td></tr><tr><td style="text-align:center">BinaryOperator(BiFunction子接口)</td><td style="text-align:center">T apply(T t1,T t2)</td><td style="text-align:center">对类型为T的对象进行二元运算</td></tr></tbody></table><div class="tabs" id="10d20ccf-24f3-4841-8532-22635d831135"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#10d20ccf-24f3-4841-8532-22635d831135-1"><i class="fas fa-cat"></i>消费型</button></li><li class="tab"><button type="button" data-href="#10d20ccf-24f3-4841-8532-22635d831135-2"><i class="fas fa-horse"></i>断定型</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="10d20ccf-24f3-4841-8532-22635d831135-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">happyTime</span><span class="params">(<span class="type">double</span> money, Consumer&lt;Double&gt; consumer)</span> &#123;</span><br><span class="line">    consumer.accept(money);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    happyTime(<span class="number">1241</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Double&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Double money)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;突然想回一趟成都了，机票花费&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Lambda表达式，将之前的6行代码压缩到了1行</span></span><br><span class="line">    happyTime(<span class="number">648</span>, money -&gt; System.out.println(<span class="string">&quot;学习太累了，奖励自己一发648，花费&quot;</span> + money));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">突然想回一趟成都了，机票花费1241.0</span></span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="comment">学习太累了，奖励自己一发648，花费648.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="10d20ccf-24f3-4841-8532-22635d831135-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">filterString</span><span class="params">(List&lt;String&gt; strings, Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(string))</span><br><span class="line">            res.add(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;东京&quot;</span>, <span class="string">&quot;西京&quot;</span>, <span class="string">&quot;南京&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;中京&quot;</span>);</span><br><span class="line">    <span class="comment">//1. 以前的写法</span></span><br><span class="line">    List&lt;String&gt; list = filterString(string s, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s.contains(<span class="string">&quot;京&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 现在的写法，相比较之前的代码优雅了许多</span></span><br><span class="line">    List&lt;String&gt; res = filterString(string s, s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[东京, 西京, 南京, 北京, 中京]</span></span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="comment">[东京, 西京, 南京, 北京, 中京]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="方法引用和构造器引用">方法引用和构造器引用</h2><ul><li>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</li><li>方法引用可以看做会Lambda表达式的深层次表达，换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖</li><li>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</li><li>格式：使用操作符<code>::</code>将类或对象与方法名分割开来</li><li>有如下三种使用情况<ol><li>对象::实例方法名</li><li>类::静态方法名</li><li>类::实例方法名</li></ol></li></ul><hr><h3 id="方法引用">方法引用</h3><p>方法引用的使用</p><ol><li>使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！</li><li>方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也是函数式接口的实例。</li><li>使用格式： 类(或对象) :: 方法名</li><li>具体分为如下的三种情况：<ul><li>情况1：对象 :: 非静态方法</li><li>情况2：类 :: 静态方法</li><li>情况3：类 :: 非静态方法</li></ul></li><li>方法引用使用的要求：要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</li></ol><div class="tabs" id="5a1398c5-f32b-470b-81f3-16840cd41579"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5a1398c5-f32b-470b-81f3-16840cd41579-1"><i class="far fa-sun"></i>对象::非静态方法</button></li><li class="tab"><button type="button" data-href="#5a1398c5-f32b-470b-81f3-16840cd41579-2"><i class="fas fa-wind"></i>类::静态方法</button></li><li class="tab"><button type="button" data-href="#5a1398c5-f32b-470b-81f3-16840cd41579-3"><i class="fas fa-fire-alt"></i>类::实例方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5a1398c5-f32b-470b-81f3-16840cd41579-1"><p>抽象方法的<code>形参列表</code>和<code>返回值类型</code>与<code>方法引用</code>的方法的<code>形参列表</code>和返回值类型相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line"><span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line"><span class="comment">//形参列表均为(T t)，返回值均为void，可以使用方法引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Consumer&lt;String&gt; consumer01 = s -&gt; System.out.println(s);</span><br><span class="line">    consumer01.accept(<span class="string">&quot;她的手只有我的手四分之三那麼大&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> System.out;</span><br><span class="line">    Consumer&lt;String&gt; consumer02 = printStream::println;</span><br><span class="line">    consumer02.accept(<span class="string">&quot;可我還是沒能抓住&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 但貌似也可以这么写</span></span><br><span class="line">    Consumer&lt;String&gt; consumer03 = System.out::println;</span><br><span class="line">    consumer03.accept(<span class="string">&quot;花落下的时候没死 风捡起花 又丢下 花才死了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">她的手只有我的手四分之三那麼大</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">可我還是沒能抓住</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">花落下的时候没死 风捡起花 又丢下 花才死了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5a1398c5-f32b-470b-81f3-16840cd41579-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//形参列表均为(T t1,T t2)，返回值均为int，可以使用方法引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test07</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator01 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line">    System.out.println(comparator01.compare(<span class="number">20</span>, <span class="number">77</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator02 = Integer::compare;</span><br><span class="line">    System.out.println(comparator02.compare(<span class="number">94</span>, <span class="number">21</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line"><span class="comment">//返回值和参数列表为泛型，也可以匹配上，可以使用方法引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Function&lt;Double,Long&gt; function01 = aDouble -&gt; Math.round(aDouble);</span><br><span class="line">    System.out.println(function01.apply(<span class="number">3.141</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    Function&lt;Double,Long&gt; function02 = Math::round;</span><br><span class="line">    System.out.println(function02.apply(<span class="number">2.717</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5a1398c5-f32b-470b-81f3-16840cd41579-3"><p>一个参数作为调用者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator中的int comapre(T t1,T t2)</span></span><br><span class="line"><span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator01 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">    System.out.println(comparator01.compare(<span class="number">94</span>, <span class="number">21</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; comparator02 = Integer::compareTo;</span><br><span class="line">    System.out.println(comparator02.compare(<span class="number">43</span>, <span class="number">96</span>));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">---------------------------</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    BiPredicate&lt;String,String&gt; biPredicate01 = (o1, o2) -&gt; o1.equals(o2);</span><br><span class="line">    System.out.println(biPredicate01.test(<span class="string">&quot;Kyle&quot;</span>, <span class="string">&quot;Kyle&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    BiPredicate&lt;String,String&gt; biPredicate02 = String::equals;</span><br><span class="line">    System.out.println(biPredicate02.test(<span class="string">&quot;Violet&quot;</span>, <span class="string">&quot;Violet&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">// Employee中的String toString();</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Stu</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;Kyle&quot;</span>, <span class="number">9527</span>);</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    Function&lt;Stu,String&gt; function01 = stu -&gt; stu.toString();</span><br><span class="line">    System.out.println(function01.apply(student));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 方法引用</span></span><br><span class="line">    Function&lt;Stu,String&gt; function02 = Stu::toString;</span><br><span class="line">    System.out.println(function02.apply(student));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Stu&#123;name=&#x27;Kyle&#x27;, id=9527&#125;</span></span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line"><span class="comment">Stu&#123;name=&#x27;Kyle&#x27;, id=9527&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="构造器引用和数组引用">构造器引用和数组引用</h3><ul><li>与函数式接口相结合，自动与函数式接口中方法兼容。</li><li>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致！且方法的返回值即为构造器对应类的对象。</li></ul><div class="tabs" id="a1dd04d3-232a-4861-a5b8-a514f0e242d6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a1dd04d3-232a-4861-a5b8-a514f0e242d6-1"><i class="fas fa-atom"></i>构造器引用</button></li><li class="tab"><button type="button" data-href="#a1dd04d3-232a-4861-a5b8-a514f0e242d6-2"><i class="far fa-sun"></i>数组引用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a1dd04d3-232a-4861-a5b8-a514f0e242d6-1"><p>和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</p><p>抽象方法的返回值类型即为构造器所属的类的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda</span></span><br><span class="line">    BiFunction&lt;String, Integer, Stu&gt; function01 = (string, integer) -&gt; <span class="keyword">new</span> <span class="title class_">Stu</span>(string, integer);</span><br><span class="line">    System.out.println(function01.apply(<span class="string">&quot;Kyle&quot;</span>, <span class="number">9527</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 构造器引用</span></span><br><span class="line">    BiFunction&lt;String, Integer, Stu&gt; function02 = Stu::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(function02.apply(<span class="string">&quot;Lucy&quot;</span>, <span class="number">9421</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Stu&#123;name=&#x27;Kyle&#x27;, id=9527&#125;</span></span><br><span class="line"><span class="comment">-------------------------------</span></span><br><span class="line"><span class="comment">Stu&#123;name=&#x27;Lucy&#x27;, id=9421&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a1dd04d3-232a-4861-a5b8-a514f0e242d6-2"><p>可以把数组看做是一个特殊的类，则写法与构造器引用一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test13</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. Lambda 创建一个指定长度的string数组</span></span><br><span class="line">    Function&lt;Integer, String[]&gt; function01 = (integer -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[integer]);</span><br><span class="line">    System.out.println(Arrays.toString(function01.apply(<span class="number">5</span>)));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 数组引用</span></span><br><span class="line">    Function&lt;Integer, String[]&gt; function02 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(Arrays.toString(function02.apply(<span class="number">7</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[null, null, null, null, null]</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">[null, null, null, null, null, null, null]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><hr><h2 id="强大的Stream-API⭐️">强大的Stream API⭐️</h2><h3 id="Stream-API概述">Stream API概述</h3><ul><li>Java8中有两个最为重要的改变，第一个就是Lambda表达式，另外一个则是Stream API</li><li>Stream API(java.util.stream)把真正的函数式编程风格引入到Java中，这是目前为止对Java类库最好的补充，因为Stream API可以极大地提高程序员生产力，让程序员写出高效、简介的代码</li><li>Stream是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。</li><li>使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询，也可以使用Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式</li><li>为什么要使用Stream API<ul><li>实际开发中，项目中多数数据源都是来自MySQL、Oracle 等。但现在数据源可以更多了，有MongDB、Redis等，而这些NoSQL的数据就需要Java层面去处理。</li><li>Stream 和Collection集合的区别：Collection 是一种静态的内存数据结构，而Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU 实现计算（这也就是为啥一旦执行终止操作之后，Stream 就不能被再次使用，得重新创建一个新的流才行）</li></ul></li></ul><blockquote><p>小结</p></blockquote><ol><li>Stream 关注的是对数据的运算，与CPU 打交道；<br>集合关注的是数据的存储，与内存打交道</li><li>Stream 自己不会存储数据；<br>Stream 不会改变源对象，相反，他们会返回一个持有结果的新Stream<br>Stream 操作是延迟执行的，这意味着他们会等到需要结果的时候才执行</li><li>Stream 执行流程<ul><li>Stream实例化</li><li>一系列中间操作（过滤、映射、…）</li><li>终止操作</li></ul></li><li>说明<ul><li>一系列中间操作连，对数据源的数据进行处理</li><li>一旦执行终止操作，就执行中间操作连，并产生结果，之后，不会再被使用</li></ul></li></ol><hr><h3 id="Stream的实例化">Stream的实例化</h3><div class="tabs" id="495d7dff-9394-4804-8bf5-e1083ed7e664"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#495d7dff-9394-4804-8bf5-e1083ed7e664-1"><i class="fas fa-baseball-ball"></i>方式一</button></li><li class="tab"><button type="button" data-href="#495d7dff-9394-4804-8bf5-e1083ed7e664-2"><i class="fas fa-bone"></i>方式二</button></li><li class="tab"><button type="button" data-href="#495d7dff-9394-4804-8bf5-e1083ed7e664-3"><i class="fas fa-heartbeat"></i>方式三</button></li><li class="tab"><button type="button" data-href="#495d7dff-9394-4804-8bf5-e1083ed7e664-4"><i class="fas fa-cookie-bite"></i>方式四</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="495d7dff-9394-4804-8bf5-e1083ed7e664-1"><p>通过集合创建Stream,使用 <code>Collection</code> 接口的 <code>stream()</code> 方法或 <code>parallelStream()</code> 方法创建流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream(); <span class="comment">// 创建串行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="comment">// 创建并行流</span></span><br></pre></td></tr></table></figure><p>注意</p><p>Map 接口是不继承 Collection 接口的，因此 Map 没有提供 stream() 方法用于生成流对象。</p><p>可以通过 Map 的 entrySet() 方法获取一个<code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code>对象，该对象包含了 Map 中的所有键值对。因为 Set 实现了 Collection 接口，因此可以通过该 Set 对象生成流对象。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="495d7dff-9394-4804-8bf5-e1083ed7e664-2"><p>通过数组创建String，使用 <code>Arrays</code> 类的 <code>stream(T[] array)</code> 方法创建流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr); <span class="comment">// 创建基本类型流</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="495d7dff-9394-4804-8bf5-e1083ed7e664-3"><p>通过自定义创建流：使用 <code>Stream</code> 接口提供的静态方法 <code>of()</code>、<code>iterate()</code>、<code>generate()</code> 创建流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>); <span class="comment">// 创建流，包含指定的元素</span></span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, n -&gt; n + <span class="number">1</span>).limit(<span class="number">5</span>); <span class="comment">// 创建流，包含 1 到 5 的整数</span></span><br><span class="line">Stream&lt;Double&gt; stream = Stream.generate(Math::random).limit(<span class="number">5</span>); <span class="comment">// 创建流，包含 5 个随机数</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="495d7dff-9394-4804-8bf5-e1083ed7e664-4"><p>通过数值范围创建流：使用 <code>IntStream</code>、<code>LongStream</code> 或 <code>DoubleStream</code> 接口提供的 <code>range()</code>、<code>rangeClosed()</code> 方法创建流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>, <span class="number">5</span>); <span class="comment">// 创建范围流，包括 1 不包括 5</span></span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> IntStream.rangeClosed(<span class="number">1</span>, <span class="number">5</span>); <span class="comment">// 创建范围流，包括 1 和 5</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="Stream的中间操作">Stream的中间操作</h3><blockquote><mark class="hl-label blue">包装</mark> </blockquote><p><code>boxed()</code> 方法作用是将基本类型流转换成对应的包装类型流。例如，将 <code>IntStream</code> 转换成 <code>Stream&lt;Integer&gt;</code>，将 <code>DoubleStream</code> 转换成 <code>Stream&lt;Double&gt;</code> 等。</p><p>这通常是为了在流处理过程中使用某些不适用于基本类型的功能，例如将基本类型元素收集到某种集合中或需要使用对象引用时。</p><p>例如基本数据类型流的排序不能传入比较器，得使用包装类型流。</p><blockquote><mark class="hl-label blue">筛选与切片</mark> </blockquote><p>筛选与切片操作用于对流中的元素进行过滤和截取，常用的方法包括:</p><p><code>filter(Predicate&lt;T&gt; predicate)</code>：过滤流中不符合条件的元素，返回一个新的流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 过滤偶数</span></span><br></pre></td></tr></table></figure><p><code>distinct()</code>：去除流中重复的元素，返回一个新的流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().distinct(); <span class="comment">// 去重</span></span><br></pre></td></tr></table></figure><p><code>limit(long maxSize)</code>：截取流中的前 <code>maxSize</code> 个元素，返回一个新的流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().limit(<span class="number">3</span>); <span class="comment">// 截取前三个元素</span></span><br></pre></td></tr></table></figure><p><code>skip(long n)</code>：跳过流中的前 <code>n</code> 个元素，返回一个新的流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().skip(<span class="number">2</span>); <span class="comment">// 跳过前两个元素</span></span><br></pre></td></tr></table></figure><blockquote><mark class="hl-label blue">映射</mark> </blockquote><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">map(Function f)</td><td style="text-align:center">接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td></tr><tr><td style="text-align:center">mapToDouble(ToDoubleFunction f)</td><td style="text-align:center">接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream。</td></tr><tr><td style="text-align:center">mapToInt(ToIntFunction f)</td><td style="text-align:center">接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream。</td></tr><tr><td style="text-align:center">mapToLong(ToLongFunction f)</td><td style="text-align:center">接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream。</td></tr><tr><td style="text-align:center">flatMap(Function f)</td><td style="text-align:center">接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table><p>映射操作用于对流中的元素进行转换和提取，常用的方法包括：</p><p><code>map(Function&lt;T, R&gt; mapper)</code>：将流中的每个元素都映射成另外一个元素，返回一个新的流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().map(s -&gt; s.length()); <span class="comment">// 将字符串转换成长度</span></span><br></pre></td></tr></table></figure><p><code>flatMap(Function&lt;T, Stream&lt;R&gt;&gt; mapper)</code>：将流中的每个元素都映射成一个流，然后将这些流合并成一个流，返回一个新的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = Arrays.asList(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>), Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().flatMap(Collection::stream); <span class="comment">// 将多个列表合并成一个流</span></span><br></pre></td></tr></table></figure><blockquote><mark class="hl-label blue">排序</mark> </blockquote><p><code>sorted()</code>：按自然顺序对流中的元素进行排序，返回一个新的流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().sorted(); <span class="comment">// 对整数列表进行排序 增序</span></span><br></pre></td></tr></table></figure><p><code>sorted(Comparator&lt;T&gt; comparator)</code>：按指定的比较器对流中的元素进行排序，返回一个新的流。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pear&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream().sorted(Comparator.comparing(String::length)); <span class="comment">// 对字符串列表按长度进行排序</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream().sorted(Comparator.reverseOrder()); <span class="comment">// 对整数列表进行排序 降序</span></span><br></pre></td></tr></table></figure><p>需要注意的是，逆序比较器只对实现了 <code>Comparable</code> 接口的类型有效，对于其他类型的元素，需要提供自定义的比较器。</p><hr><h3 id="Stream的终止操作">Stream的终止操作</h3><p>流的终止操作用于触发流的计算，并产生一个最终的结果或副作用。常用的终止操作包括：</p><blockquote><mark class="hl-label blue">匹配与查找</mark> </blockquote><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">allMatch(Predicate p)</td><td style="text-align:center">检查是否匹配所有元素</td></tr><tr><td style="text-align:center">anyMatch(Predicate p)</td><td style="text-align:center">检查是否至少匹配一个元素</td></tr><tr><td style="text-align:center">noneMatch(Predicate p)</td><td style="text-align:center">检查是否没有匹配所有元素</td></tr><tr><td style="text-align:center">findFirst()</td><td style="text-align:center">返回第一个元素</td></tr><tr><td style="text-align:center">findAny()</td><td style="text-align:center">返回当前流中的任意元素</td></tr><tr><td style="text-align:center">count()</td><td style="text-align:center">返回流中元素总数</td></tr><tr><td style="text-align:center">max(Comparator c)</td><td style="text-align:center">返回流中最大值</td></tr><tr><td style="text-align:center">min(Comparator c)</td><td style="text-align:center">返回流中最小值</td></tr><tr><td style="text-align:center">forEach(Consumer c)</td><td style="text-align:center">内部迭代(使用Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"><span class="comment">// allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否所有的员工的工资是否都大于5000：&quot;</span>+employees.stream().allMatch(employee -&gt; employee.getSalary() &gt; <span class="number">5000</span>));</span><br><span class="line"><span class="comment">// anyMatch(Predicate p)——检查是否至少匹配一个元素。</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否存在员工年龄小于15：&quot;</span>+employees.stream().anyMatch(employee -&gt; employee.getAge() &lt; <span class="number">15</span>));</span><br><span class="line"><span class="comment">// noneMatch(Predicate p)——检查是否没有匹配的元素。</span></span><br><span class="line">System.out.println(<span class="string">&quot;是否不存在员工姓马：&quot;</span>+employees.stream().noneMatch(employee -&gt; employee.getName().startsWith(<span class="string">&quot;马&quot;</span>)));</span><br><span class="line"><span class="comment">//findFirst——返回第一个元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;返回第一个元素：&quot;</span>+employees.stream().findFirst());</span><br><span class="line"><span class="comment">//findAny——返回当前流中的任意元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;返回当前流中的任意元素&quot;</span>+employees.stream().findAny());</span><br><span class="line"><span class="comment">//count——返回流中元素的总个数</span></span><br><span class="line">System.out.println(<span class="string">&quot;返回元素总数：&quot;</span>+employees.stream().count());</span><br><span class="line"><span class="comment">//max(Comparator c)——返回流中最大值</span></span><br><span class="line">System.out.println(<span class="string">&quot;返回最高工资：&quot;</span>+employees.stream().map(Employee::getSalary).max(Double::compare));</span><br><span class="line"><span class="comment">//min(Comparator c)——返回流中最小值</span></span><br><span class="line">System.out.println(<span class="string">&quot;返回最小年龄：&quot;</span>+employees.stream().map(Employee::getAge).min(Integer::compare));</span><br><span class="line"><span class="comment">//forEach(Consumer c)——内部迭代</span></span><br><span class="line">employees.stream().forEach(System.out::println);</span><br><span class="line">System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"><span class="comment">////使用集合的遍历操作</span></span><br><span class="line">employees.forEach(System.out::println);</span><br></pre></td></tr></table></figure><blockquote><mark class="hl-label blue">归约</mark> </blockquote><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">reduce(T iden, BinaryOperator b)</td><td style="text-align:center">可以将流中元素反复结合起来，得到一个值。返回T</td></tr><tr><td style="text-align:center">reduce(BinaryOperator b)</td><td style="text-align:center">可以将流中元素反复结合起来，得到一个值。返回Optional</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test22</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; nums = Arrays.asList(<span class="number">13</span>, <span class="number">32</span>, <span class="number">23</span>, <span class="number">31</span>, <span class="number">94</span>, <span class="number">20</span>, <span class="number">77</span>, <span class="number">21</span>, <span class="number">17</span>);</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">// reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class="line">    <span class="comment">// 练习1：计算1-10的自然数的和</span></span><br><span class="line">    System.out.println(nums.stream().reduce(<span class="number">0</span>, Integer::sum));</span><br><span class="line">    <span class="comment">//reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class="line">    <span class="comment">// 练习2：计算公司所有员工工资总和</span></span><br><span class="line">    System.out.println(employees.stream().map(Employee::getSalary).reduce((o1, o2) -&gt; o1 + o2));</span><br><span class="line">    <span class="comment">// 别的写法，计算年龄总和</span></span><br><span class="line">    System.out.println(employees.stream().map(Employee::getAge).reduce(Integer::sum));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">328</span></span><br><span class="line"><span class="comment">Optional[48424.08]</span></span><br><span class="line"><span class="comment">Optional[273]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><mark class="hl-label blue">收集</mark> </blockquote><p><code>collect(Collector&lt;T, A, R&gt; collector)</code>：将流中的元素收集到一个集合中，返回一个最终的结果。</p><p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map)。</p><p>Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表</p><table>  <tbody>    <tr style="text-align:center">      <td bgcolor="3366ff" style="color:white">方法</td>      <td bgcolor="3366ff" style="color:white">返回类型</td>      <td bgcolor="3366ff" style="color:white">作用</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">toList</td>      <td bgcolor="3399ff" style="color:white">List&lt;T&gt;</td>      <td bgcolor="3399ff" style="color:white">把流中元素收集到List</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">toSet</td>      <td bgcolor="3399ff" style="color:white">List&lt;T&gt;</td>      <td bgcolor="3399ff" style="color:white">把流中元素收集到List</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">toCollection</td>      <td bgcolor="3399ff" style="color:white"> Collection&lt;T&gt;</td>      <td bgcolor="3399ff" style="color:white">把流中元素收集到创建的集合</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::new));</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">counting</td>      <td bgcolor="3399ff" style="color:white">Long</td>      <td bgcolor="3399ff" style="color:white">计算流中元素的个数</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">long count = list.stream().collect(Collectors.counting());</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">summinglnt</td>      <td bgcolor="3399ff" style="color:white">Integer</td>      <td bgcolor="3399ff" style="color:white">对流中元素的整数属性求和</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">int total=list.stream().collect(Collectors.summingInt(Employee::getSalary));</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">averagingInt</td>      <td bgcolor="3399ff" style="color:white">Double</td>      <td bgcolor="3399ff" style="color:white">计算流中元素Integer属性的平均值</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">summarizinglnt</td>      <td bgcolor="3399ff" style="color:white">IntSummaryStatistics</td>      <td bgcolor="3399ff" style="color:white">收集流中Integer属性的统计值。如:平均值</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">int SummaryStatisticsiss=list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">joining</td>      <td bgcolor="3399ff" style="color:white">String</td>      <td bgcolor="3399ff" style="color:white">连接流中每个字符串</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">String str= list.stream().map(Employee::getName).collect(Collectors.joining());</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">maxBy</td>      <td bgcolor="3399ff" style="color:white">Optional&lt;T&gt;</td>      <td bgcolor="3399ff" style="color:white">根据比较器选择最大值</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">optional&lt;Emp&gt;max=list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary));</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">minBy</td>      <td bgcolor="3399ff" style="color:white">Optional&lt;T&gt;</td>      <td bgcolor="3399ff" style="color:white">根据比较器选择最小值</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">Optional&lt;Emp&gt;min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary));</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">reducing</td>      <td bgcolor="3399ff" style="color:white">归约产生的类型</td>      <td bgcolor="3399ff" style="color:white">从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">int total=list.stream().collect(Collectors.reducing(0, Employe::getSalar, Integer::sum));</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">collectingAndThen</td>      <td bgcolor="3399ff" style="color:white">转换函数返回的类型</td>      <td bgcolor="3399ff" style="color:white">包裹另一个收集器，对其结果转换函数</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">groupingBy</td>      <td bgcolor="3399ff" style="color:white"> Map&lt;K, List&lt;T&gt;&gt;</td>      <td bgcolor="3399ff" style="color:white">根据某属性值对流分组，属性为K,结果为V</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">Map&lt;Emp.Status, List&lt;Emp&gt;&gt;map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</td>    </tr>    <tr style="text-align:center">      <td bgcolor="3399ff" style="color:white">partitioningBy</td>      <td bgcolor="3399ff" style="color:white">Map&lt;Boolean,List&lt;T&gt;&gt;</td>      <td bgcolor="3399ff" style="color:white">根据true或false进行分区</td>    </tr>    <tr style="text-align:center">      <td colspan="3" bgcolor="33ccff" style="color:white">Map&lt;Boolean,List&lt;Emp&gt;&gt;vd=list.stream().collect(Collectors.partitioningBy(Employee::getManage));</td>    </tr></tbody></table><hr><hr><h2 id="Stream的使用实例">Stream的使用实例</h2><blockquote><p>map中存储了各元素的出现次数。</p></blockquote><p>k = 2 ，v = 3</p><p>说明数字2 出现了3次</p><p>现在要将map中各元素的出现次数，从大到小排。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()</span><br><span class="line">            .sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))</span><br><span class="line">            .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><p>获得差值序列</p></blockquote><p>nums[1, 7, 4, 9, 2, 5]   前项减去后项</p><p>差值 [6, -3, 5, -7, 3]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = IntStream.range(<span class="number">1</span>, nums.length) <span class="comment">// 创建 1到 nums.length 一共 nums.length-1 哥</span></span><br><span class="line">                .map(i -&gt; nums[i-<span class="number">1</span>] - nums[i])<span class="comment">// 映射</span></span><br><span class="line">                .toArray();</span><br></pre></td></tr></table></figure><blockquote><p>取得二维List的最后一个元素存储</p></blockquote><p>levels = [[3], [9, 20], [15, 7]]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; levels =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Stream.of(levels)</span><br><span class="line">      .flatMap(List::stream)</span><br><span class="line">      .mapToInt(list -&gt; list.get(list.size() - <span class="number">1</span>))</span><br><span class="line">      .forEach(res::add);</span><br></pre></td></tr></table></figure><p>res = [3,20,7]</p>]]></content>
    
    
    <summary type="html">Lambda表达式、函数式接口、Stream API</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://wuwawawa.github.io/posts/e85d694a.html"/>
    <id>https://wuwawawa.github.io/posts/e85d694a.html</id>
    <published>2023-05-10T05:04:05.000Z</published>
    <updated>2023-05-12T00:53:14.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="翻转二叉树">翻转二叉树</h2><div class="tag link"><a class="link-card" title="226. 翻转二叉树" href="https://leetcode.cn/problems/invert-binary-tree/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">226. 翻转二叉树</p><p class="url">https://leetcode.cn/problems/invert-binary-tree/</p></div></a></div><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p>示例 1：</p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img" style="zoom:67%;" /><p>递归三部曲</p><ol><li>确定递归函数的参数和返回值。</li><li>确定终止条件。当前节点为空的时候，就返回</li><li>确定单层递归的逻辑。因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">//递归函数的终止条件，节点为空时返回</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面三句是将当前节点的左右子树交换</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.right;</span><br><span class="line">    root.right = root.left;</span><br><span class="line">    root.left = tmp;</span><br><span class="line">    <span class="comment">//递归交换当前节点的左子树</span></span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    <span class="comment">//递归交换当前节点的 右子树</span></span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="comment">//函数返回时就表示当前这个节点，以及它的左右子树</span></span><br><span class="line">    <span class="comment">//都已经交换完了</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="对称二叉树">对称二叉树</h2><div class="tag link"><a class="link-card" title="101. 对称二叉树" href="https://leetcode.cn/problems/symmetric-tree/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">101. 对称二叉树</p><p class="url">https://leetcode.cn/problems/symmetric-tree/</p></div></a></div><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p>示例 1：</p><img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="img" style="zoom:67%;" /><p>递归三部曲</p><ol><li>确定递归函数的参数和返回值</li></ol><p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p><p>返回值自然是bool类型。</p><ol start="2"><li>确定终止条件</li></ol><p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p><p>节点为空的情况有：（注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点）</p><ul><li>左节点为空，右节点不为空，不对称，return false</li><li>左不为空，右为空，不对称 return false</li><li>左右都为空，对称，返回true</li></ul><p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p><ul><li>左右都不为空，比较节点数值，不相同就return false</li></ul><p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p><ol start="3"><li>确定单层递归的逻辑</li></ol><p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内测是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用递归函数，比较左节点，右节点</span></span><br><span class="line">    <span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left==<span class="literal">null</span> || right == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left.val!=right.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(left.left,right.right)&amp;&amp;dfs(left.right,right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="二叉树的最大深度⭐️">二叉树的最大深度⭐️</h2><div class="tag link"><a class="link-card" title="104. 二叉树的最大深度" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">104. 二叉树的最大深度</p><p class="url">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</p></div></a></div><div class="tag link"><a class="link-card" title="559. n叉树的最大深度" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">559. n叉树的最大深度</p><p class="url">https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/</p></div></a></div><p>给定一个二叉树，找出其最大深度。</p><p>示例：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">3</span></span><br><span class="line">  / <span class="string">\</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">20</span></span><br><span class="line"> /  <span class="string">\</span></span><br><span class="line"><span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><ol><li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。</li><li>确定终止条件：如果为空节点的话，就返回0，表示高度为0。</li><li>确定单层递归的逻辑：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li></ol><p>关键：</p><p>根节点的高度其实就是二叉树的最大深度。</p><p>需要<code>后序遍历</code>从低向上返回高度。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="二叉树" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> rightDepth= maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth,rightDepth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="二叉树的最小深度">二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。</p><p>示例 1：</p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img" style="zoom:67%;" /><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p>直觉上好像和求最大深度差不多，其实还是差不少的。</p><p>本题依然是前序遍历和后序遍历都可以，前序求的是深度，后序求的是高度。</p><hr><hr><h2 id="二叉树的最近公共祖先">二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>节点5,4 的公共祖先为 5  ，节点5，1的公共祖先为3</p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p><p>那么二叉树如何可以自底向上查找呢？</p><p>回溯啊，二叉树回溯的过程就是从低到上。</p><p>后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。</p><p>接下来就看如何判断一个节点是节点q和节点p的公共祖先呢。</p><p>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。 即情况一：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230511221814323.png" alt="image-20230511221814323" style="zoom:67%;" /><p>判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，</p><p>那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。</p><p>特殊情况，就是节点本身p(q)，它拥有一个子孙节点q§。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123; <span class="comment">// 递归结束条件</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若未找到节点 p 或 q</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 若找到两个节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="平衡二叉树">平衡二叉树</h2><hr><hr><h2 id="二叉树的所有路径">二叉树的所有路径</h2><div class="tag link"><a class="link-card" title="257. 二叉树的所有路径" href="https://leetcode.cn/problems/binary-tree-paths/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">257. 二叉树的所有路径</p><p class="url">https://leetcode.cn/problems/binary-tree-paths/</p></div></a></div><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p><p>叶子节点 是指没有子节点的节点。</p><img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="img" style="zoom:67%;" /><p>示例 1：</p><p>输入：root = [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,“1-&gt;3”]</p><hr><hr><h2 id="找树左下角的值⭐️">找树左下角的值⭐️</h2><div class="tag link"><a class="link-card" title="513. 找树左下角的值" href="https://leetcode.cn/problems/find-bottom-left-tree-value/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">513. 找树左下角的值</p><p class="url">https://leetcode.cn/problems/find-bottom-left-tree-value/</p></div></a></div><p>给定一个二叉树的 根节点 <code>root</code>，请找出该二叉树的 最底层 最左边 节点的值。</p><p>假设二叉树中至少有一个节点。</p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img" style="zoom:67%;" /><p>输出: 7</p><div class="tabs" id="0e595ee9-d0e0-428a-b10c-1f89283cc4f9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0e595ee9-d0e0-428a-b10c-1f89283cc4f9-1"><i class="fas fa-cat"></i>回溯写法</button></li><li class="tab"><button type="button" data-href="#0e595ee9-d0e0-428a-b10c-1f89283cc4f9-2"><i class="fas fa-horse"></i>精简回溯</button></li><li class="tab"><button type="button" data-href="#0e595ee9-d0e0-428a-b10c-1f89283cc4f9-3"><i class="fas fa-cookie-bite"></i>层序</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0e595ee9-d0e0-428a-b10c-1f89283cc4f9-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traversal(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left== <span class="literal">null</span> &amp;&amp; root .right ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(depth&gt;maxDepth)&#123;</span><br><span class="line">                maxDepth=depth;</span><br><span class="line">                result=root.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            traversal(root.left,depth);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            traversal(root.right,depth);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0e595ee9-d0e0-428a-b10c-1f89283cc4f9-2"><p>回溯逻辑其实就隐藏在<code>traversal(root.left,depth+1);</code>中的 <code>depth+1</code>。 每次函数调用完，depth依然是没有加上1的，这就是回溯了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traversal(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left== <span class="literal">null</span> &amp;&amp; root .right ==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;maxDepth)&#123;</span><br><span class="line">            maxDepth=depth;</span><br><span class="line">            result=root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        traversal(root.left,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        traversal(root.right,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0e595ee9-d0e0-428a-b10c-1f89283cc4f9-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; deque= <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    deque.addFirst(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">        ans = deque.peekFirst().val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">        <span class="keyword">while</span>(size-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">poll</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (poll.left != <span class="literal">null</span>) deque.addLast(poll.left);</span><br><span class="line">            <span class="keyword">if</span> (poll.right != <span class="literal">null</span>) deque.addLast(poll.right);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="根据序列构造二叉树">根据序列构造二叉树</h2><div class="tag link"><a class="link-card" title="105. 从前序与中序遍历序列构造二叉树" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">105. 从前序与中序遍历序列构造二叉树</p><p class="url">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</p></div></a></div><div class="tag link"><a class="link-card" title="106. 从中序与后序遍历序列构造二叉树" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/submissions/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">106. 从中序与后序遍历序列构造二叉树</p><p class="url">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/submissions/</p></div></a></div><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗二叉树 。</p><p>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3],preorder = [3,9,20,15,7]</p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img" style="zoom:67%;" /><p>前序遍历： 根  左  右</p><p>中序遍历： 左  根   右</p><p>后序遍历： 左  右   根</p><ul><li>第一步：如果数组大小为零的话，说明是空节点了。</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li><li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li><li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li><li>第五步：切割后序数组，切成后序左数组和后序右数组</li><li>第六步：递归处理左区间和右区间</li></ul><p>中序和后序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123; <span class="comment">// 用map保存中序序列的数值对应位置</span></span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findNode(inorder,  <span class="number">0</span>, inorder.length, postorder,<span class="number">0</span>, postorder.length);  <span class="comment">// 前闭后开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postBegin, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数里的范围都是前闭后开</span></span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt;= inEnd || postBegin &gt;= postEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(postorder[postEnd - <span class="number">1</span>]);  <span class="comment">// 找到后序遍历的最后一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">        root.left = findNode(inorder, inBegin, rootIndex,</span><br><span class="line">                postorder, postBegin, postBegin + lenOfLeft);</span><br><span class="line">        root.right = findNode(inorder, rootIndex + <span class="number">1</span>, inEnd,</span><br><span class="line">                postorder, postBegin + lenOfLeft, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前序和中序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123; <span class="comment">// 用map保存中序序列的数值对应位置</span></span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findNode(inorder,  <span class="number">0</span>, inorder.length, preorder,<span class="number">0</span>, preorder.length);  <span class="comment">// 前闭后开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TreeNode <span class="title function_">findNode</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd, <span class="type">int</span>[] preorder, <span class="type">int</span> preBegin, <span class="type">int</span> preEnd)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数里的范围都是前闭后开</span></span><br><span class="line">    <span class="keyword">if</span> (inBegin &gt;= inEnd || preBegin &gt;= preEnd) &#123;  <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(preorder[preBegin]);  <span class="comment">// 找到前序遍历的最后一个元素在中序遍历中的位置</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">    root.left = findNode(inorder, inBegin, rootIndex,</span><br><span class="line">            preorder, preBegin+<span class="number">1</span>, preBegin +<span class="number">1</span> + lenOfLeft);</span><br><span class="line">    root.right = findNode(inorder, rootIndex + <span class="number">1</span>, inEnd,</span><br><span class="line">            preorder, preBegin +<span class="number">1</span> + lenOfLeft, preEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="最大二叉树">最大二叉树</h2><div class="tag link"><a class="link-card" title="654. 最大二叉树" href="https://leetcode.cn/problems/maximum-binary-tree/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">654. 最大二叉树</p><p class="url">https://leetcode.cn/problems/maximum-binary-tree/</p></div></a></div><p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p><p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p><p>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p><ul><li>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。<ul><li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul><li>空数组，无子节点。</li><li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul><li>空数组，无子节点。</li><li>只有一个元素，所以子节点是一个值为 1 的节点。</li></ul></li></ul></li><li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul><li>只有一个元素，所以子节点是一个值为 0 的节点。</li><li>空数组，无子节点。</li></ul></li></ul></li></ul><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> constructMaximumBinaryTree(nums,<span class="number">0</span>,nums.length); <span class="comment">// 前闭后开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> begin,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 参数范围前闭后开</span></span><br><span class="line">    <span class="keyword">if</span>(begin&gt;=end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= begin;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;=maxValue)&#123;</span><br><span class="line">            maxValue=nums[i];</span><br><span class="line">            maxIndex=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[maxIndex]);  <span class="comment">// 构造结点</span></span><br><span class="line">    <span class="comment">// 构造左子树</span></span><br><span class="line">    root.left = constructMaximumBinaryTree(nums,begin,maxIndex);</span><br><span class="line">    <span class="comment">// 构造右子树</span></span><br><span class="line">    root.right = constructMaximumBinaryTree(nums,maxIndex+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="二叉搜索树的插入">二叉搜索树的插入</h2><p>一般是插入到叶子节点上</p><hr><h2 id="二叉搜索树的删除">二叉搜索树的删除</h2>]]></content>
    
    
    <summary type="html">二叉树专题</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="递归" scheme="https://wuwawawa.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="回溯" scheme="https://wuwawawa.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="https://wuwawawa.github.io/posts/7678a22a.html"/>
    <id>https://wuwawawa.github.io/posts/7678a22a.html</id>
    <published>2023-05-09T08:05:42.000Z</published>
    <updated>2023-05-19T08:08:16.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是泛型">1. 什么是泛型</h2><div class="tabs" id="ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-1"><i class="fas fa-cat"></i>背景</button></li><li class="tab"><button type="button" data-href="#ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-2"><i class="fas fa-horse"></i>定义</button></li><li class="tab"><button type="button" data-href="#ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-3"><i class="fas fa-dove"></i>规则</button></li><li class="tab"><button type="button" data-href="#ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-4"><i class="fas fa-dragon"></i>分类</button></li><li class="tab"><button type="button" data-href="#ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-5"><i class="fas fa-heartbeat"></i>注意</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-1"><p>JAVA推出泛型以前，程序员可以构建一个元素类型为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的过程中，需要程序员明确知道存储每个元素的数据类型，否则很容易引发ClassCastException异常。</p><p>手动进行类型强转，在编译时无法进行类型检查，只能在运行期才能检查出来，这样就很容易造成类型转换异常。<br>Java中引入泛型最主要的目的是将<code>类型检查</code>工作提前到编译时期，将<code>类型强转（cast）</code>工作交给编译器，从而让你在编译时期就获得类型转换异常以及去掉源码中的类型强转代码。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-2"><p>Java泛型（generics）是JDK5中引入的一个新特性，泛型提供了编译时类型安全监测机制，该机制允许我们在编译时检测到非法的类型数据结构。泛型的本质就是参数化类型，也就是所操作的数据类型被指定为一个参数。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-3"><p>泛型可以随便写，但默认的规则为：</p><p>E—Element，常用在Java的集合中</p><p>K,V-----key,value 代表Map中的键值对</p><p>N-----Number 代表数字</p><p>T----Type 类型，如String，Integer等等</p><p>？：表示不确定的java类型</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-4"><p>参数类型可以用在类、接口和方法中，分别被称为<strong>泛型类、泛型接口、泛型方法</strong>。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ccbefa2a-4cf4-4189-bf4c-d5b96ea1f5e1-5"><p>基本数据类型不能作为泛型</p><p>在集合中不使用泛型时，可以存储任意类型的对象，集合中的元素是Object。</p><p>泛型在编译期有效，可以动态修改参数类型。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="2-泛型类和泛型接口">2. 泛型类和泛型接口</h2><p>泛型类是指在类的定义中使用一个或多个类型参数，来表示类中的成员变量、方法参数和返回值的类型。使用泛型类可以使代码更加通用，能够处理多种数据类型，同时也可以提高代码的类型安全性。</p><h3 id="2-1-泛型类语法">2.1 泛型类语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class 类名称 &lt;泛型标识,泛型标识,...&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> 泛型标识 变量名;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的泛型标识：T、E、K、V</p><mark class="hl-label green">使用语法</mark> <p><code>类名&lt;具体的数据类型&gt; 对象名 = new 类名&lt;具体的数据类型&gt;();</code></p><p>Java1.7以后，后面的&lt;&gt;中的具体的数据类型可以省略不写</p><p><code>s类名&lt;具体的数据类型&gt; 对象名 = new 类名&lt;&gt;(); </code></p><mark class="hl-label red">注意事项</mark> <ul><li><p>泛型类，如果没有指定具体的数据类型，此时，操作类型是Object</p></li><li><p>泛型的类型参数只能是类类型，不能是基本数据类型</p></li><li><p>泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是相同类型</p></li></ul><hr><h3 id="2-2-泛型类派生子类">2.2 泛型类派生子类</h3><p>存在两种情况</p><div class="tabs" id="01135cc1-be26-4bda-98b3-d383bc66c525"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#01135cc1-be26-4bda-98b3-d383bc66c525-1"><i class="fas fa-heartbeat"></i>泛型父类</button></li><li class="tab"><button type="button" data-href="#01135cc1-be26-4bda-98b3-d383bc66c525-2"><i class="fas fa-cat"></i>子类也是泛型类</button></li><li class="tab"><button type="button" data-href="#01135cc1-be26-4bda-98b3-d383bc66c525-3"><i class="fas fa-horse"></i>子类不是泛型类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="01135cc1-be26-4bda-98b3-d383bc66c525-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> E value;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(E value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="01135cc1-be26-4bda-98b3-d383bc66c525-2"><p>子类和父类的泛型类型要一致<br><code>class ChildGeneric&lt;T&gt; extends Generic&lt;T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类派生子类，子类也是泛型类，那么子类的泛型标识要和父类一致。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildFirst</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="01135cc1-be26-4bda-98b3-d383bc66c525-3"><p>父类要明确泛型的数据类型<br><code>class ChildGeneric extends Generic&lt;String&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型类派生子类，如果子类不是泛型类，那么父类要明确数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildSecond</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><p>泛型接口是指在接口的定义中使用一个或多个类型参数，来表示接口中的方法参数、返回值或者接口本身的类型。</p><h3 id="2-3-泛型接口语法">2.3 泛型接口语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名称 &lt;泛型标识，泛型标识，…&gt; &#123;</span><br><span class="line">泛型标识 方法名(); </span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-泛型接口实现类">2.4 泛型接口实现类</h3><p>也同样分为两种情况</p><div class="tabs" id="ae6c27a2-48d6-426a-9865-8b0c5ec26f68"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ae6c27a2-48d6-426a-9865-8b0c5ec26f68-1"><i class="fas fa-atom"></i>泛型接口</button></li><li class="tab"><button type="button" data-href="#ae6c27a2-48d6-426a-9865-8b0c5ec26f68-2"><i class="far fa-sun"></i>实现类也是泛型类</button></li><li class="tab"><button type="button" data-href="#ae6c27a2-48d6-426a-9865-8b0c5ec26f68-3"><i class="fas fa-wind"></i>实现类不是泛型类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ae6c27a2-48d6-426a-9865-8b0c5ec26f68-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ae6c27a2-48d6-426a-9865-8b0c5ec26f68-2"><ul><li>实现类也是泛型类，实现类和接口的泛型类型要一致</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口的实现类，是一个泛型类，</span></span><br><span class="line"><span class="comment"> * 那么要保证实现接口的泛型类泛型标识包含泛型接口的泛型标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T,E&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="keyword">private</span> E value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T key, E value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ae6c27a2-48d6-426a-9865-8b0c5ec26f68-3"><p>实现类不是泛型类，接口要明确数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现泛型接口的类，不是泛型类，需要明确实现泛型接口的数据类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello generic&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><hr><h2 id="3-泛型方法与可变参数">3. 泛型方法与可变参数</h2><p>虽然泛型类可以用来实现大多数泛型需求，但是有些情况下，我们只需要对某个方法进行泛型化，而不需要将整个类泛型化。这时，泛型方法就能发挥作用了。</p><div class="tabs" id="7a694214-ff8a-44f9-ba05-dcfdcd17cef3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7a694214-ff8a-44f9-ba05-dcfdcd17cef3-1"><i class="fas fa-cat"></i>用法</button></li><li class="tab"><button type="button" data-href="#7a694214-ff8a-44f9-ba05-dcfdcd17cef3-2"><i class="fas fa-horse"></i>语法</button></li><li class="tab"><button type="button" data-href="#7a694214-ff8a-44f9-ba05-dcfdcd17cef3-3"><i class="fas fa-dove"></i>说明</button></li><li class="tab"><button type="button" data-href="#7a694214-ff8a-44f9-ba05-dcfdcd17cef3-4"><i class="fas fa-dragon"></i>可变参数</button></li><li class="tab"><button type="button" data-href="#7a694214-ff8a-44f9-ba05-dcfdcd17cef3-5"><i class="fas fa-cookie-bite"></i>使用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7a694214-ff8a-44f9-ba05-dcfdcd17cef3-1"><p>泛型方法是在调用方法的时候指明泛型的具体类型。</p><p>调用方法时，我们通常不需要像泛型类那样手动指定具体类型，因为编译器会根据你的调用，自动推导出具体类型。</p><p>比如你操作的是String类型的对象，那么类型参数参数就是String类型。</p><p>类型参数只能是引用类型，不能是基本类型。即使使用基本类型，也会自动装箱成包装类型。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7a694214-ff8a-44f9-ba05-dcfdcd17cef3-2"><p><code>修饰符 &lt;T，E, ...&gt; 返回值类型 方法名(形参列表) { 方法体... }</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7a694214-ff8a-44f9-ba05-dcfdcd17cef3-3"><p>修饰符与返回值中间的&lt; T &gt;非常重要，可以理解为声明此方法为泛型方法</p><p>只有声明了&lt; T &gt;的方法才是泛型方法，泛型类中使用了泛型成员的方法并不是泛型方法</p><p>&lt; T &gt;表示该方法将使用泛型类型T，此时才可以在方法中试用贴泛型类型T</p><p>与泛型类的定义一样，此处的T可以为任意标识，常见的T、E、K、V等形式参数都常用于表示泛型</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7a694214-ff8a-44f9-ba05-dcfdcd17cef3-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反省可变参数的定义</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(E... e)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(E el : e)&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可变参数泛型方法的调用</span></span><br><span class="line">ProductGetter.print(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7a694214-ff8a-44f9-ba05-dcfdcd17cef3-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; E <span class="title function_">getProduct</span><span class="params">(ArrayList&lt;E&gt; list)</span>&#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">return</span> list.get(random.nextInt(list.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">    <span class="type">ArrayListTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayListTest</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">product</span> <span class="operator">=</span> test.getProduct(list);</span><br><span class="line">    System.out.println(product);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>注意</p></blockquote><ul><li>泛型方法能使方法独立于类而产生变化</li><li>如果一个静态方法需要使用泛型能力（即需要支持泛型类型参数），那么它必须声明为泛型方法。在 Java 中，泛型类型参数只能在方法或类中声明，因此一个静态方法如果需要使用泛型类型参数，就必须在方法签名中声明泛型类型参数。在静态方法中，不能直接使用类的类型参数，因为我们在指定泛型参数具体类型时，是在实例化该类时指定的，而静态方法与对象无关。因此，如果要在静态方法中使用泛型类型参数，必须在方法签名中进行声明。</li></ul><hr><hr><h2 id="4-类型通配符">4. 类型通配符</h2><p>在Java中，泛型类型通配符用于表示不确定的类型。它们是一种表示范围的方法，可以让我们更灵活地处理泛型集合。我们来详细了解一下这三种通配符：</p><div class="tabs" id="44d38253-73a5-4f2b-a821-d8efe4126534"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#44d38253-73a5-4f2b-a821-d8efe4126534-1">?</button></li><li class="tab"><button type="button" data-href="#44d38253-73a5-4f2b-a821-d8efe4126534-2"><i class="fas fa-cookie-bite"></i>爷子孙</button></li><li class="tab"><button type="button" data-href="#44d38253-73a5-4f2b-a821-d8efe4126534-3">? extends T</button></li><li class="tab"><button type="button" data-href="#44d38253-73a5-4f2b-a821-d8efe4126534-4">? super T</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="44d38253-73a5-4f2b-a821-d8efe4126534-1"><p>这是一个无限制的通配符，表示任意类型。当我们不关心参数化类型的具体类型时，可以使用这个通配符。例如，当我们想要编写一个方法来处理<code>List&lt;?&gt;</code>时，这意味着这个方法可以接受任何类型的列表，无论它是<code>List&lt;String&gt;</code>、<code>List&lt;Integer&gt;</code>还是其他任何类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object item : list) &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，当 &lt; ? &gt;存在时，List对象丧失了 add() 方法的功能，编译器不通过。</p><p>因为&lt;?&gt;匹配任意类型,所以无法确定add方法应该添加什么类型的元素。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="44d38253-73a5-4f2b-a821-d8efe4126534-2"><p>定义了三个类，实现爷子孙的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dove</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="44d38253-73a5-4f2b-a821-d8efe4126534-3"><p>上界的通配符，表示类型参数必须是T（或T的子类）。这通常在我们需要限制类型参数的范围时使用。</p><p><mark class="hl-label blue">定义方法</mark></p><p>传递的集合类型，只能是Bird或Bird的子类类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBirds</span><span class="params">(ArrayList&lt;? extends  Bird&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>; i&lt;list.size();i++)&#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">        System.out.println(bird);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark class="hl-label green">使用</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Animal&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Bird&gt; birds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Dove&gt; doves = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//showBirds(animals); ❎</span></span><br><span class="line">showBirds(birds);  </span><br><span class="line">showBirds(doves);  </span><br></pre></td></tr></table></figure><p><mark class="hl-label red">注意</mark></p><p>不能够填充元素。那是因为，extendsT中存放的其实是T的一种子类，如果我们去添加元素，其实不知道到底应该添加T的哪个子类，这个时候，在进行强转的时候，肯定会出错。但是如果是从集合中将元素取出来，我们则可以知道取出来的元素肯定是T类型（全是它的子类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBirds</span><span class="params">(ArrayList&lt;? extends  Bird&gt; list)</span>&#123;</span><br><span class="line">    <span class="comment">//list.add(new Animal());❎</span></span><br><span class="line">    <span class="comment">//list.add(new Bird());❎</span></span><br><span class="line">    <span class="comment">//list.add(new Dove());❎</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="44d38253-73a5-4f2b-a821-d8efe4126534-4"><p>下界的通配符，表示类型参数必须是T（或T的超类）。这通常在我们需要添加元素到集合中时使用。</p><p><mark class="hl-label blue">定义方法</mark></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBirds</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Bird&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><mark class="hl-label green">使用</mark></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Animal&gt; animals <span class="operator">=</span> new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">ArrayList&lt;Bird&gt; birds <span class="operator">=</span> new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">ArrayList&lt;Dove&gt; doves <span class="operator">=</span> new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line">showBirds(animals)<span class="comment">; </span></span><br><span class="line">showBirds(birds)<span class="comment">;  </span></span><br><span class="line">//showBirds(doves)<span class="comment">; ❎</span></span><br></pre></td></tr></table></figure><p><mark class="hl-label red">注意</mark></p><p>和上限通配符不同，下限通配符可以填充元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBirds</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Bird&gt; list)</span>&#123;</span><br><span class="line">    <span class="comment">//list.add(new Animal());// 不可以</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Bird</span>()); <span class="comment">//可以</span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Dove</span>()); <span class="comment">//可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>superT中，因为<code>存</code>的都是类型T的父类（容器），所以如果去添加T类或者T的子类（操作），肯定没什么问题。但是如果将元素取出来，则不知道到底是什么类型，所以superT可以添加元素，但是只能用Object接收。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <blockquote><p>JDK源码TreeSet中类型通配符的应用</p></blockquote><p>在<code>TreeSet</code>有两个构造方法，一个使用到了上限通配符，一个使用了下限统配符</p><p><code>public TreeSet(Comparator&lt;? super E&gt; comparator)</code></p><p><code>public TreeSet(Collection&lt;? extends E&gt; c)</code></p><p>以下限通配符为案例</p><div class="tabs" id="980249a4-bd6e-48f8-bf7a-c8c4181217c7"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#980249a4-bd6e-48f8-bf7a-c8c4181217c7-1"><i class="fas fa-cat"></i>准备爷子孙</button></li><li class="tab"><button type="button" data-href="#980249a4-bd6e-48f8-bf7a-c8c4181217c7-2"><i class="fas fa-horse"></i>定义比较器</button></li><li class="tab"><button type="button" data-href="#980249a4-bd6e-48f8-bf7a-c8c4181217c7-3"><i class="fas fa-dove"></i>传递比较器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="980249a4-bd6e-48f8-bf7a-c8c4181217c7-1"><p>在其中添加一些成员变量，并实现toString方法</p><div class="tabs" id="727f800b-6c4a-4517-9c6a-07a7da490435"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#727f800b-6c4a-4517-9c6a-07a7da490435-1"><i class="fas fa-cat"></i>Animal</button></li><li class="tab"><button type="button" data-href="#727f800b-6c4a-4517-9c6a-07a7da490435-2"><i class="fas fa-horse"></i>Bird</button></li><li class="tab"><button type="button" data-href="#727f800b-6c4a-4517-9c6a-07a7da490435-3"><i class="fas fa-dove"></i>Dove</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="727f800b-6c4a-4517-9c6a-07a7da490435-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Animal&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="727f800b-6c4a-4517-9c6a-07a7da490435-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bird</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bird&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="727f800b-6c4a-4517-9c6a-07a7da490435-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dove</span> <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dove</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dove&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;level=&quot;</span> + level +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="980249a4-bd6e-48f8-bf7a-c8c4181217c7-2"><p>定义三个比较器</p><div class="tabs" id="a5441306-54f5-41b3-bb13-ede7d566bea9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a5441306-54f5-41b3-bb13-ede7d566bea9-1"><i class="fas fa-award"></i>name比较</button></li><li class="tab"><button type="button" data-href="#a5441306-54f5-41b3-bb13-ede7d566bea9-2"><i class="fas fa-baseball-ball"></i>age比较</button></li><li class="tab"><button type="button" data-href="#a5441306-54f5-41b3-bb13-ede7d566bea9-3"><i class="fas fa-bone"></i>level比较</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a5441306-54f5-41b3-bb13-ede7d566bea9-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comprator1</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Animal&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Animal o1, Animal o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.name.compareTo(o2.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5441306-54f5-41b3-bb13-ede7d566bea9-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comprator2</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Bird&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Bird o1, Bird o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.age- o2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5441306-54f5-41b3-bb13-ede7d566bea9-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Comprator3</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Dove&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dove o1, Dove o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.level-o2.level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="980249a4-bd6e-48f8-bf7a-c8c4181217c7-3"><p>定义一个泛型为Bird的<code>TreeSet&lt;Bird&gt; treeSet</code></p><div class="tabs" id="5ac88f59-38e2-4e51-b355-8b0c2c0ec129"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5ac88f59-38e2-4e51-b355-8b0c2c0ec129-1"><i class="fas fa-cat"></i>使用name比较器</button></li><li class="tab"><button type="button" data-href="#5ac88f59-38e2-4e51-b355-8b0c2c0ec129-2"><i class="fas fa-horse"></i>使用age比较器</button></li><li class="tab"><button type="button" data-href="#5ac88f59-38e2-4e51-b355-8b0c2c0ec129-3"><i class="fas fa-dove"></i>level比较器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5ac88f59-38e2-4e51-b355-8b0c2c0ec129-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Bird&gt; treeSet =<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comprator1</span>());</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;amy&quot;</span>,<span class="number">22</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;frank&quot;</span>,<span class="number">35</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;jim&quot;</span>,<span class="number">15</span>));</span><br><span class="line">treeSet.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Bird&#123;age</span>=<span class="string">22, name=&#x27;amy&#x27;&#125;</span></span><br><span class="line"><span class="attr">Bird&#123;age</span>=<span class="string">35, name=&#x27;frank&#x27;&#125;</span></span><br><span class="line"><span class="attr">Bird&#123;age</span>=<span class="string">20, name=&#x27;jerry&#x27;&#125;</span></span><br><span class="line"><span class="attr">Bird&#123;age</span>=<span class="string">15, name=&#x27;jim&#x27;&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5ac88f59-38e2-4e51-b355-8b0c2c0ec129-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;Bird&gt; treeSet =<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comprator2</span>());</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;amy&quot;</span>,<span class="number">22</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;frank&quot;</span>,<span class="number">35</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&quot;jim&quot;</span>,<span class="number">15</span>));</span><br><span class="line">treeSet.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Bird&#123;age</span>=<span class="string">15, name=&#x27;jim&#x27;&#125;</span></span><br><span class="line"><span class="attr">Bird&#123;age</span>=<span class="string">20, name=&#x27;jerry&#x27;&#125;</span></span><br><span class="line"><span class="attr">Bird&#123;age</span>=<span class="string">22, name=&#x27;amy&#x27;&#125;</span></span><br><span class="line"><span class="attr">Bird&#123;age</span>=<span class="string">35, name=&#x27;frank&#x27;&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5ac88f59-38e2-4e51-b355-8b0c2c0ec129-3"><p>不能传入Comprator3，根本原因我们使用的是下限通配符。</p><p><code>TreeSet&lt;Bird&gt; treeSet =new TreeSet&lt;&gt;(new Comprator3());</code></p><p>我们在构建子类对象的时候，必然会先去构建父类对象。这个时候父类成员就已经被初始化了，所以我们传父类实现比较器，那么是能够成立的。</p><p>创建Bird时，并不能创建子类对象Dove，所以传递子类实现比较器，是会产生空引用的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="5-类型擦除">5. 类型擦除</h2><p>泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是泛型代码能够很好地和之前版本的代码兼容。那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，我们称之为–<code>类型擦除</code>。</p><p>先来看一个例子，我声明了两个集合，一个类型参数为<code>Integer</code>,一个类型参数为<code>String</code>,那我们会下意识认为这两个集合是不同的类型。可事实却非常反直觉，判断两个集合的Class是否相等，结果竟然为true，仿佛集合的类型参数不存在一般，这就是类型擦除的一种体现。在编译阶段，编译器会进行类型检测，比如我们传递了一个错误的类型，那就会编译失败，可一但通过了编译，编译器就会将泛型给擦除掉。到了运行阶段，对于JVM来说，便没有了泛型类型的对象，所有的对象都属于普通类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    System.out.println(intList.getClass().getSimpleName());  <span class="comment">// ArrayList</span></span><br><span class="line">    System.out.println(strList.getClass().getSimpleName());  <span class="comment">// ArrayList</span></span><br><span class="line">    System.out.println(intList.getClass() == strList.getClass()); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个泛型类或一个泛型方法 ，经过类型擦除后，其中的泛型参数都会被替换成它的第一个上界，没有边界时自然就是替换成顶层父类 Object。</p><p>这种擦掉泛型参数后的类型，我们称之为<code>原始类型</code>。</p><p>类型擦除后的代码和 Java 1.5 之前还没有泛型时的代码是一致的，没错，这就是类型擦除的目的：向低版本兼容，为了保证已有的代码和类文件依然合法，且能继续保持原有的含义，Java 就选择了类型擦除这一种简单粗暴的方式。</p><p>如此实现泛型是简单了，可用的人就不爽了。类型擦除给我们使用者带来了许多局限和麻烦之处，其中几个最直观的弊端就是：</p><ul><li>泛型参数不支持基本类型，只支持引用类型。因为泛型最终会被擦除成具体类型，而Object又不能存储基本数据类型的值</li><li>运行时你只能对<code>原始类型</code>进行类型检测，无法判断带泛型的类型，其原因就是最开始举的那个例子，压根就没有什么<code>ArrayList&lt;String&gt;</code>类,也就不存在有什么 <code>ArrayList&lt;String&gt;.class</code>这种东西,就只有一个原始类型ArrayList</li><li>不能实例化类型参数<code>T t =new T()</code>。因为在运行时无法确定具体类型，也无法知道T是不是存在无参构造器</li><li>不能实例化泛型数组，因为数组本身也是有类型的</li></ul><mark class="hl-label blue">分类</mark> <div class="tabs" id="50716709-218f-40ad-af05-34274cb5c368"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#50716709-218f-40ad-af05-34274cb5c368-1"><i class="fas fa-cat"></i>无限制类型擦除</button></li><li class="tab"><button type="button" data-href="#50716709-218f-40ad-af05-34274cb5c368-2"><i class="fas fa-horse"></i>有限制类型擦除</button></li><li class="tab"><button type="button" data-href="#50716709-218f-40ad-af05-34274cb5c368-3"><i class="fas fa-dove"></i>擦除方法中类型定义的参数</button></li><li class="tab"><button type="button" data-href="#50716709-218f-40ad-af05-34274cb5c368-4"><i class="fas fa-dragon"></i>桥接方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="50716709-218f-40ad-af05-34274cb5c368-1"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518124935934.png" alt="image-20230518124935934" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="50716709-218f-40ad-af05-34274cb5c368-2"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518125256566.png" alt="image-20230518125256566" style="zoom:67%;" /><p>T extends Number 表示声明一个类型变量 T，它是 Number 的一个具体子类。不能写 T super Number，因为这样是没有任何意义的。原因是所有泛型在编译时都会被擦除，T 所代表的是一个 Number 的超类，但是具体是哪个类却是在运行时被决定的，编译器为了类型安全，只能做最大限度的包容，因此所有的 T 类型都会在编译器变为 Object。所以，写 T super Number 等同于写 Object，因此不支持 T super 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="50716709-218f-40ad-af05-34274cb5c368-3"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518125234914.png" alt="image-20230518125234914" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="50716709-218f-40ad-af05-34274cb5c368-4"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518125220904.png" alt="image-20230518125220904" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label green">验证</mark> <div class="tabs" id="8c7242df-5baa-4789-af6f-502f23d3fe57"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8c7242df-5baa-4789-af6f-502f23d3fe57-1"><i class="fas fa-cat"></i>泛型类</button></li><li class="tab"><button type="button" data-href="#8c7242df-5baa-4789-af6f-502f23d3fe57-2"><i class="fas fa-horse"></i>反射验证</button></li><li class="tab"><button type="button" data-href="#8c7242df-5baa-4789-af6f-502f23d3fe57-3"><i class="fas fa-cookie-bite"></i>字节码验证</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8c7242df-5baa-4789-af6f-502f23d3fe57-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Erasure</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKey</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c7242df-5baa-4789-af6f-502f23d3fe57-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Erasure&lt;Integer&gt; erasure =<span class="keyword">new</span> <span class="title class_">Erasure</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 利用反射，获取Erasure类的字节码的Class类对象</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Erasure</span>&gt; clz = erasure.getClass();</span><br><span class="line">    <span class="comment">// 获取所有的成员变量</span></span><br><span class="line">    Field[] declaredFields = clz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">        <span class="comment">// 打印成员变量的名称和类型</span></span><br><span class="line">        System.out.println( declaredField.getName()+<span class="string">&quot;:&quot;</span>+declaredField.getType().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p>key:Object<br>name:String</p><p>将<code>Erasure&lt;T&gt;</code>更改为<code>Erasure&lt;T extends Number&gt;</code>后，再次运行，输出</p><p>key:Integer<br>name:String</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c7242df-5baa-4789-af6f-502f23d3fe57-3"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518151159812.png" alt="image-20230518151159812" style="zoom:50%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518151204374.png" alt="image-20230518151204374" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>注意</p></blockquote><p>泛型中的类型在编译时被擦除，运行时会被替换为原生类型，所以<code>List&lt; Integer &gt;</code>、<code>List&lt; String &gt;</code>在运行期就是同一个类型，编译器就理所当然地阻止编译了。</p><p>所以不允许重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="6-变型">6. 变型</h2><h3 id="6-1-什么是变型">6.1 什么是变型</h3><p>变型主要有三个规则：协变、逆变和不变。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518204014970.png" alt="image-20230518204014970" style="zoom: 50%;" /><p>这些规则描述了<code>类型构造器</code>如何影响父子类型之间的关系。</p><p>举个🌰：</p><div class="tabs" id="738969c1-172d-4d1d-87ec-e7b7474469d5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#738969c1-172d-4d1d-87ec-e7b7474469d5-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#738969c1-172d-4d1d-87ec-e7b7474469d5-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#738969c1-172d-4d1d-87ec-e7b7474469d5-3"><i class="fas fa-dove"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="738969c1-172d-4d1d-87ec-e7b7474469d5-1"><p><code>Dog</code>类继承了<code>Animal</code>类，那<code>Dog</code>就是<code>Animal</code>的子类。我们可以用<code>≤</code>来表示两个类型的基础关系。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518205129886.png" alt="image-20230518205129886" style="zoom: 40%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="738969c1-172d-4d1d-87ec-e7b7474469d5-2"><p>用f来表示<code>类型构造器</code>，一个已知的类型被类型构造器f处理后，就是一个崭新的类型。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518205638268.png" alt="image-20230518205638268" style="zoom:40%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="738969c1-172d-4d1d-87ec-e7b7474469d5-3"><p>协变，就是指f(Dog)是f(Animal) 的子类</p><p>逆变，就是指f(Animal)是f(Dog) 的子类</p><p>不变，就是指f(Dog)和f(Animal)之间没有关系，既不是协变也不是逆变。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518205835727.png" alt="image-20230518205835727" style="zoom:40%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>这个<code>类型构造器</code>f，它可以是泛型，也可以是数组，也可以是函数。</p><p>那泛型演示</p><p>如果<code>List&lt;Animal&gt;</code>能接收<code>List&lt;Dog&gt;</code>,那就是协变。</p><p>如果<code>List&lt;Dog&gt;</code>能接收<code>List&lt;Animal&gt;</code>,那就是逆变。</p><p>如果两者都不行，那就是不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Animal&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;(); <span class="comment">//协变</span></span><br><span class="line">List&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;()    <span class="comment">//逆变</span></span><br></pre></td></tr></table></figure><p>很多人会认为<code>List&lt;Animal&gt; animals = new ArrayList&lt;Dog&gt;();</code> ，<code>List&lt;Dog&gt;</code>赋值给<code>List&lt;Animal&gt;</code>是没有问题的，然而事实却恰恰相反，这行代码会编译失败。因为JAVA泛型是默认是禁止协变的。</p><p>其实很好理解：</p><p>如果支持协变，那我后面再放入一个其它类型的对象，比如Cat，那<code>List&lt;Dog&gt;</code>中的元素不就错了,所以为了类型安全考虑，<span class='p red'>泛型默认是不变的</span>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Animal&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;(); <span class="comment">// 假如支持协变</span></span><br><span class="line">animals.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">animals.add(<span class="keyword">new</span> <span class="title class_">Cat</span>()); <span class="comment">// 类型错误</span></span><br></pre></td></tr></table></figure><p>那 Java 为了安全，为啥数组却支持协变呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dog[] dogs = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">5</span>];</span><br><span class="line">Animal[] animals = dogs;</span><br><span class="line"><span class="comment">// dog类&lt;=animal类 对应的 dog[] &lt;= animal[] 数组是协变类型</span></span><br></pre></td></tr></table></figure><p>这是因为在 Java 1.0 版本时还没有泛型,而 Java 设计者又希望能数组进行通用处理，如果数组不支持协变的话，那很多方法就得为每一种类型编写逻辑了。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518211458591.png" alt="image-20230518211458591" style="zoom:33%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518211510435.png" alt="image-20230518211510435" style="zoom:33%;" /><p>但是支持协变就带来了安全隐患，如果将一个数组协变后，那在赋值元素时就可能会抛出运行时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal[] animals = <span class="keyword">new</span> <span class="title class_">Dog</span>[<span class="number">5</span>];</span><br><span class="line">animals[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">animals[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">//ArrayStoreException</span></span><br></pre></td></tr></table></figure><blockquote><p>面试题</p></blockquote><p>这一段代码，哪里错了，为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">Object[] b = a;</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">b[<span class="number">1</span>] = Integer.valueOf(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>第四行会抛出运行时异常，因为它本身是一个String数组，无法存储不同类型的数据。</p><p>如果禁止数组协变，在第二行就报编译错误了。</p><hr><h3 id="6-2-泛型之协变-上界">6.2 泛型之协变-上界</h3><blockquote><p>为什么要让泛型支持协变，泛型支持协变后有什么好处</p></blockquote><p>最直观的好处当然就是多态，拿集合这个最常用的泛型类来说，我想接收各种子类的集合进行统一的处理，这种需求再常见不过了。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518225214861.png" alt="image-20230518225214861" style="zoom:33%;" /><p>如果泛型只能像现在这样禁止协变，那我们就得为所有类型的集合单独编写一个方法，这显然是不现实的，所以，必须得让泛型支持协变。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518225325165.png" alt="image-20230518225325165" style="zoom: 33%;" /><p>在Java中，只需在类型参数前加上？extends 关键字，即可让泛型支持协变，这样一来就能接收各种子类的集合了。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518225649735.png" alt="image-20230518225649735" style="zoom:33%;" /><p>这个？我们称之为通配符，用来表示不确定的类型，extends关键字和通配符结合起来，就声明了类型的上限（上界），表示泛型可接收的类型只能是指定的类型，或者是该类型的子类。</p><p>在上面提到过协变会有类型安全隐患，就像数组在协变后，添加其它类型就会引发运行时异常，泛型为了杜绝这种隐患选择了一刀切的方式。即，只要声明了上界，除了 null 之外，无论你是安全的类型还是不安全类型，一律不准传入给泛型，否则就会编译失败。说白了，就是只准你读取，不准你写入。只读不写，当然就安全了。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518225932843.png" alt="image-20230518225932843" style="zoom:33%;" /><blockquote><p>Java集合接口中的add方法，参数是集合的泛型参数E,而contains和remove方法的参数确实Object，为啥这两个方法不声明为E呢</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计的原因就是刚才说的安全限制，一但参数是E，那声明了上界之后，别人调用参数为E的方法就会引发编译错误，像contains和remove这种不会破坏类型安全的方法，自然就不能声明为E，否则集合协变后，这些方法就废了，集合也跟着废了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; animals = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">animals.add(dog); <span class="comment">//编译错误</span></span><br><span class="line">animals.contains(dog); <span class="comment">//编译正确，如果参数声明为E，则该行就会编译错误</span></span><br><span class="line">animals.contains(dog); <span class="comment">//编译正确，如果参数声明为E，则该行就会编译错误</span></span><br></pre></td></tr></table></figure><blockquote><p>好处</p></blockquote><p>我们也可以在定义泛型类或泛型方法时，通过 extends 关键字来限定类型参数，限定之后，别人要使用你的泛型类时就只能声明指定的类型，如果是其它类型的话则会发生编译错误。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519093741428.png" alt="image-20230519093741428" style="zoom: 33%;" /><p>除了限定类型这一好处外，还一个好处就是我们能够在泛型类中，访问上界类型的方法，这是因为不声明上界的话，所有类型参数都很被擦除成Object，自然就只能访问Object方法。声明了上界后，擦除就只会擦除到第一个上界，我们自然也就能够安全访问上界类型的方法。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519093900825.png" alt="image-20230519093900825" style="zoom:40%;" /><hr><h3 id="6-3-泛型之逆变-下界">6.3 泛型之逆变-下界</h3><p>我们已经知道了泛型协变后只准读不准写，我们不禁会产生疑问：比如一个集合都不能添加元素了，那这个集合还有什么用？还有没有办法添加元素呢？这些问题用一个应用场景就可以得到回答。</p><p>还是拿经典的猫叫狗叫动物叫来举例:</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519094950884.png" alt="image-20230519094950884" style="zoom:40%;" /><p>Dog和Cat类都继承了Animal类，并且有一些狗狗继承了Dog，Dog类中有一个isHappy方法，来表示狗狗是否开心。</p><blockquote><p>需求来了：假设我需要一个工具方法，能够将一个 Dog 集合中开心的狗狗，复制到另一个集合中,那这个方法该怎么定义和实现呢?</p></blockquote><p>我在方法上定义两个参数，一个 dest 用来表示目标集合，一个 src 用来表示源集合，然后遍历 src 将符合条件的元素，添加到 dest 中不就搞定了。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519095143653.png" alt="image-20230519095143653" style="zoom:67%;" /><p>这样当然能完成需求，不过目前这个方法只能接 Dog 类型的集合。如果将 Dog 子类的集合传入到 src 中就会编译失败，这样显然是不合理的，因为将子类型赋值给父类型是再正常不过的操作。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519095427527.png" alt="image-20230519095427527" style="zoom:67%;" /><p>为了让方法更灵活，我们可以将 src 声明上界让其支持协变，这样 src 就能接收Dog 的子类集合了。因为我们只会对src 做获取元素的操作，所以协变不能新增元素这一限制，不会对我们造成困扰。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519095759650.png" alt="image-20230519095759650" style="zoom:67%;" /><p>现在 src 参数扩展性是很好了，可 dest 参数的问题还没有解决，dest 参数目前只能接收 Dog 类型的集合，如果传递 Dog父类的集合就会编译失败。这样也显然是不合理的，因为将对象放入父类集合中同样是很常见的操作，那该怎么解决这个问题呢？</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519100222442.png" alt="image-20230519100222442" style="zoom: 67%;" /><p>我们可以使用？通配符加 super 关键字，来声明泛型的下界，这样将泛型逆变后，就可以接收本类型或者父类型的泛型类，之前的编译错误自然也就不存在了。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519100406281.png" alt="image-20230519100406281" style="zoom:67%;" /><p>正是由于最多只能接收父类型泛型，所以逆变可以添加元素，因为它不会有类型转换失败的风险。 这里要注意一点，虽然泛型类可以接收父类型的泛型，但给逆变泛型添加元素时，还是只能添加指定类型或指定类型的子类，不要将接收泛型类和添加元素给弄混了。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519100623271.png" alt="image-20230519100623271" style="zoom:67%;" /><p>逆变虽然没有协变只读不写的限制，但有利则有弊，正是由于逆变是接收父类型的泛型类，所以在读取元素时不能保证元素具体是什么类型，只能用 Object 来获取对象，仿佛泛型失效了一般。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519100814028.png" alt="image-20230519100814028" style="zoom:67%;" /><blockquote><p>总结</p></blockquote><p>可以发现，逆变和协变正好相反，协变是只读不写，逆变是只写不读，两者一对比，各自的应用场景其实也就呼之欲出了，当我想对泛型只读不写时，我就用协变嘛，当我想对泛型只写不读时，我就用逆变嘛。有人此时可能会问，那我又想读又想写呢，那此时你要的就不该是协变逆变，而是准确的泛型类型。</p><p>泛型的协变逆变一般只用于在方法上，声明形参来接收调用者传递的实参，之前我直接声明变量来接收各种泛型类，是为了方便演示实际中没必要这么做。</p><hr><h3 id="6-4-PECS法则">6.4 PECS法则</h3><p>PECS原则的全拼是&quot;Producer Extends Consumer Super&quot;。</p><ul><li>如果你想从一个数据类型里获取数据，使用 ? extends 通配符</li><li>如果你想把对象写入一个数据结构里，使用 ? super 通配符</li><li>如果你既想存，又想取，那就别用通配符。</li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230519101250671.png" alt="image-20230519101250671" style="zoom:67%;" /><blockquote><p>Java语言规范定义：</p></blockquote><p>jls7: 4.5.1: unlike ordinary type varables declared in a method signature, no type inference is required when using a wildcard.</p><p>&lt;不同于普通的类型变量声明，通配符方式并不会进行类型推断&gt;</p><p>说明：不进行类型推断的话实际上就限制了数据的放入和取出。简而言之，需要明确的告诉编译器此数据的上界和下界，否则编译时报错。</p><p>jls7:The null reference can always be assigned or cast to any reference type</p><p>从上面的Java语言规范中可以得出：</p><p>Java中所有类的顶级父类是Object，可以认为Null是所有类的子类。</p><p><code>? extends T</code>：通配符？的类型在Null和T之间。 <code>? extends </code>只能作为消费者，而不能放入类型的原因就在这里，编译器不能确定放入的是什么类型，Null可以转化为任意类型；换一种说法，编译器不知道类型的上界，只清楚类型的下界。如下图</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230518092225731.png" alt="image-20230518092225731" style="zoom:67%;" /><p>怎么看待这个上限和下限呢</p><p>对于<code>? extends T</code> 来说，集合里的元素应该是什么类型呢？应该是T类型，因为你添加的是T或者T的子类，设置为T就可以激发多态了。是了，所以你也只能从这个集合中取出T类型，因为它里面的元素本来设置的就是T类型，你赋值进去只不过是将T的子类赋值给了T，多态。但是呢，你就不能给这个集合里添加元素了，因为这个集合里元素的类型是T，假如可以添加元素，你初始化的时候初始化成T的一个子类，然后添加值的时候，却添加的另一个子类，事实上是可以添加的，因为集合元素类型是T，但里面就有了多种T的子类，好了，你初始化的时候是这个子类，你取出元素的时候肯定也想着取出的是可以给这个子类赋值的类型，但很有可能取出来的是T的另一个子类，你没法赋值，因为你允许添加另一个子类。所以一开始就禁止添加元素是对的。</p><p><code>? super T</code>里面的元素，应该设置为什么呢？显然应该是object，因为系统不知道你会把?当成什么，不知道具体是哪个父类型，所以只能设置成object，所以你取出元素的时候，取出的是object类。可不可以添加元素呢？可以，因为下限有保证，所以可以添加T和T的子类。你初始化的时候，初始化的是T的某个父类，好了，你现在取元素，你希望取出的是你初始化的那个父类，因为你只能添加T和T的子类，所以你取出的元素，肯定可以赋值给那个父类。</p><p>综上，<code>? extends T</code>不可以添加元素，但可以取出类型为T的元素。<code>? super T</code>可以添加T或者T的子类，取出的一定是object类。</p><p>extendsT只出不进，属于生产者一类。</p><p>superT只进不出，属于消费者。</p><p>这也就有了我们上面所提到的“Producer Extends Consumer Super”，也就是PECS原则。</p><h2 id="7-课后问题">7. 课后问题</h2><p>1、什么是类型擦除（Type Erasure）？</p><p>2、什么是类型参数（Type Parameter）？  T K V 等符号</p><p>3、什么是泛型的上下界？</p><p>4、<code>List</code>、<code>List&lt; Object &gt;</code> 、<code>List&lt; ? &gt;</code>有什么区别？</p><blockquote><p>5、？和T 的区别</p></blockquote><p><code>?</code> 是通配符</p><p><code>T</code> 是类型变量</p><p><code>?</code>通常用于方法参数类型、集合类型等需要灵活处理类型的场景。</p><p><code>T</code>通常用于泛型类或泛型方法中，它允许我们在编写泛型代码时指定类型。</p><p>T 则与问号不同，它只能用于声明处。</p>]]></content>
    
    
    <summary type="html">泛型类、泛型方法、泛型接口、泛型擦除、PECS法则</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBootWeb开发</title>
    <link href="https://wuwawawa.github.io/posts/3fc60a15.html"/>
    <id>https://wuwawawa.github.io/posts/3fc60a15.html</id>
    <published>2023-05-04T07:21:40.000Z</published>
    <updated>2023-05-16T05:28:21.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-功能支持">1. 功能支持</h2><p>Spring Boot为Spring MVC提供了自动配置，大多场景都无需自定义配置</p><ul><li>内容协商视图解析器 ContentNegotiatingViewResolver 和 BeanName 视图解析器 BeanNameViewResolver</li><li>支持静态资源（包括 webjars）和静态 index.html 页支持</li><li>自动注册相关类：Converter、GenericConverter、Formatter</li><li>内容协商处理器：HttpMessageConverters</li><li>国际化：MessageCodesResolver</li></ul><p>开发规范：</p><ul><li>使用 <code>@Configuration</code> + <code>WebMvcConfigurer</code> 自定义规则，不使用 <code>@EnableWebMvc</code> 注解</li><li>声明 <code>WebMvcRegistrations</code> 的实现类改变默认底层组件</li><li>使用 <code>@EnableWebMvc</code> + <code>@Configuration</code> + <code>DelegatingWebMvcConfiguration</code> 全面接管 SpringMVC</li></ul><hr><h2 id="2-静态资源">2. 静态资源</h2><h3 id="2-1-访问规则">2.1 访问规则</h3><p>使用了Spring MVC中的<code>ResourceHttpRequestHandler</code></p><p>默认的静态资源路径是 classpath 下的，优先级由高到低为：</p><ul><li><code>/META-INF/resources</code></li><li><code>/resources</code></li><li><code>/static</code></li><li><code>/public</code></li></ul><p>的包内，<code>/</code> 表示当前项目的根路径</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230502154538517.png" alt="image-20230502154538517" style="zoom:50%;" /><p>请求方式： <code>/ + 静态资源名</code></p><p>处理原理：请求先去寻找 Controller 处理，不能处理的请求就会交给静态资源处理器，静态资源也找不到就响应 404 页面</p><div class="tabs" id="8c8c2f44-af52-4ecf-b88d-770f470b8a9e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8c8c2f44-af52-4ecf-b88d-770f470b8a9e-1"><i class="fas fa-cat"></i>修改默认资源路径</button></li><li class="tab"><button type="button" data-href="#8c8c2f44-af52-4ecf-b88d-770f470b8a9e-2"><i class="fas fa-horse"></i>修改静态资源访问前缀</button></li><li class="tab"><button type="button" data-href="#8c8c2f44-af52-4ecf-b88d-770f470b8a9e-3"><i class="fas fa-dove"></i>webjar访问资源</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8c8c2f44-af52-4ecf-b88d-770f470b8a9e-1"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations::</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure><p>默认的静态资源路径将找不到了</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c8c2f44-af52-4ecf-b88d-770f470b8a9e-2"><p>默认是 <code>/**</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/resources/**</span></span><br></pre></td></tr></table></figure><p>访问 URL：<a href="http://localhost:8080/resources/">http://localhost:8080/resources/</a> + 静态资源名</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c8c2f44-af52-4ecf-b88d-770f470b8a9e-3"><p>把一些静态资源做成jar包，访问</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问地址：<a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js%EF%BC%8C%E5%90%8E%E9%9D%A2%E5%9C%B0%E5%9D%80%E8%A6%81%E6%8C%89%E7%85%A7%E4%BE%9D%E8%B5%96%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84">http://localhost:8080/webjars/jquery/3.5.1/jquery.js，后面地址要按照依赖里面的包路径</a></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230502155735696.png" alt="image-20230502155735696" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="2-2-欢迎页面">2.2 欢迎页面</h3><ul><li><p>静态资源路径下  index.html。</p><ul><li>可以配置静态资源路径</li><li>但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="comment">#  mvc:</span></span><br><span class="line"><span class="comment">#    static-path-pattern: /res/**   这个会导致welcome page功能失效</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span> [<span class="string">classpath:/haha/</span>]</span><br></pre></td></tr></table></figure><ul><li>controller能处理/index。</li></ul><p>网页标签上的小图标可以自定义规则，把资源重命名为 favicon.ico 放在静态资源目录下即可</p><hr><h3 id="2-3-源码分析">2.3 源码分析</h3><ul><li>SpringBoot启动默认加载 xxxAutoConfiguration类（自动配置类）</li><li>SpringMVC功能的自动配置类<code>WebMvcAutoConfiguration</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//当前项目的根路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVLET_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="3b8ad86e-8e1b-4e01-a278-58bd0497dd4a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3b8ad86e-8e1b-4e01-a278-58bd0497dd4a-1"><i class="fas fa-award"></i>内部类</button></li><li class="tab"><button type="button" data-href="#3b8ad86e-8e1b-4e01-a278-58bd0497dd4a-2"><i class="fas fa-baseball-ball"></i>静态资源映射规则</button></li><li class="tab"><button type="button" data-href="#3b8ad86e-8e1b-4e01-a278-58bd0497dd4a-3"><i class="fas fa-bone"></i>欢迎页</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3b8ad86e-8e1b-4e01-a278-58bd0497dd4a-1"><p>内部类 WebMvcAutoConfigurationAdapter构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="comment">// 绑定 spring.mvc、spring.web、spring.resources 相关的配置属性</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class,ResourceProperties.class, WebProperties.class &#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>, ServletContextAware &#123;</span><br><span class="line"><span class="comment">//有参构造器所有参数的值都会从容器中确定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebMvcAutoConfigurationAdapter</span><span class="params">(<span class="comment">/*参数*/</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.resourceProperties = resourceProperties.hasBeenCustomized() ? resourceProperties</span><br><span class="line">: webProperties.getResources();</span><br><span class="line"><span class="built_in">this</span>.mvcProperties = mvcProperties;</span><br><span class="line"><span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line"><span class="built_in">this</span>.messageConvertersProvider = messageConvertersProvider;</span><br><span class="line"><span class="built_in">this</span>.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();</span><br><span class="line"><span class="built_in">this</span>.dispatcherServletPath = dispatcherServletPath;</span><br><span class="line"><span class="built_in">this</span>.servletRegistrations = servletRegistrations;</span><br><span class="line"><span class="built_in">this</span>.mvcProperties.checkConfiguration();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要的参数：</p><ul><li>ResourceProperties resourceProperties：获取和 spring.resources 绑定的所有的值的对象</li><li>WebMvcProperties mvcProperties：获取和 spring.mvc 绑定的所有的值的对象</li><li>ListableBeanFactory beanFactory：Spring 的 beanFactory</li><li>HttpMessageConverters：找到所有的 HttpMessageConverters</li><li>ResourceHandlerRegistrationCustomizer：找到 资源处理器的自定义器。</li><li>DispatcherServletPath：项目路径</li><li>ServletRegistrationBean：给应用注册 Servlet、Filter</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3b8ad86e-8e1b-4e01-a278-58bd0497dd4a-2"><p>两种静态资源映射规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">//配置文件设置 spring.resources.add-mappings: false，禁用所有静态资源</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);<span class="comment">//被禁用</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册webjars静态资源的映射规则映射路径</span></span><br><span class="line">    addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    <span class="comment">//注册静态资源路径的映射规则 默认映射 staticPathPattern = &quot;/**&quot; </span></span><br><span class="line">    addResourceHandler(registry, <span class="built_in">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">        <span class="comment">//staticLocations = CLASSPATH_RESOURCE_LOCATIONS</span></span><br><span class="line">        registration.addResourceLocations(<span class="built_in">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ServletContextResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(<span class="built_in">this</span>.servletContext, SERVLET_LOCATION);</span><br><span class="line">            registration.addResourceLocations(resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebProperties</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line">    <span class="comment">//默认资源路径，优先级从高到低</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="string">&quot;classpath:/META-INF/resources/&quot;</span>,</span><br><span class="line">                                                 <span class="string">&quot;classpath:/resources/&quot;</span>, </span><br><span class="line">                                                 <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span> &#125;</span><br><span class="line">        <span class="keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">        <span class="comment">//可以进行规则重写</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStaticLocations</span><span class="params">(String[] staticLocations)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.staticLocations = appendSlashIfNecessary(staticLocations);</span><br><span class="line"><span class="built_in">this</span>.customized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3b8ad86e-8e1b-4e01-a278-58bd0497dd4a-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//spring.web 属性</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(WebProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(<span class="comment">/*参数*/</span>)</span> &#123;</span><br><span class="line">        <span class="type">WelcomePageHandlerMapping</span> <span class="variable">welcomePageHandlerMapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WelcomePageHandlerMapping</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TemplateAvailabilityProviders</span>(applicationContext), </span><br><span class="line">            applicationContext, getWelcomePage(),</span><br><span class="line">            <span class="comment">//staticPathPattern = &quot;/**&quot;</span></span><br><span class="line">            <span class="built_in">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">        <span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">WelcomePageHandlerMapping(<span class="comment">/*参数*/</span>) &#123;</span><br><span class="line">    <span class="comment">//所以限制 staticPathPattern 必须为 /** 才能启用该功能</span></span><br><span class="line">    <span class="keyword">if</span> (welcomePage != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage);</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">        setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WelcomePageHandlerMapping，访问 / 能访问到 index.html</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><hr><h2 id="3-Rest映射">3. Rest映射</h2><p>开启 Rest 功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure><p>源码分析，注入了 HiddenHttpMethodFilte 解析 Rest 风格的访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;)</span></span><br><span class="line"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title function_">hiddenHttpMethodFilter</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedHiddenHttpMethodFilter</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-内嵌容器">4. 内嵌容器</h2><p>SpringBoot 嵌入式 Servlet 容器，默认支持的 WebServe：Tomcat、Jetty、Undertow</p><p>配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span> <span class="comment">&lt;!--必须要把内嵌的 Tomcat 容器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Web 应用启动，SpringBoot 导入 Web 场景包 tomcat，创建一个 Web 版的 IOC 容器：</p><ul><li><p><code>SpringApplication.run(BootApplication.class, args)</code>：应用启动</p></li><li><p><code>ConfigurableApplicationContext.run()</code>：</p><ul><li><p><code>context = createApplicationContext()</code>：<strong>创建容器</strong></p><ul><li><p><code>applicationContextFactory = ApplicationContextFactory.DEFAULT</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContextFactory</span> <span class="variable">DEFAULT</span> <span class="operator">=</span> (webApplicationType) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (webApplicationType) &#123;</span><br><span class="line">            <span class="keyword">case</span> SERVLET:</span><br><span class="line">                <span class="comment">// Servlet 容器，继承自 ServletWebServerApplicationContext</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">case</span> REACTIVE:</span><br><span class="line">                <span class="comment">// 响应式编程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigReactiveWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 普通 Spring 容器</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>applicationContextFactory.create(this.webApplicationType)</code>：根据应用类型创建容器</p></li></ul></li><li><p><code>refreshContext(context)</code>：容器启动刷新</p></li></ul></li></ul><p>内嵌容器工作流程：</p><ul><li><p>Spring 容器启动逻辑中，在实例化非懒加载的单例 Bean 之前有一个方法 <strong>onRefresh()</strong>，留给子类去扩展，Web 容器就是重写这个方法创建 WebServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//省略....</span></span><br><span class="line">createWebServer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getWebServerFactory();</span><br><span class="line">    <span class="built_in">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">    createWebServer.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 WebServer 工厂 ServletWebServerFactory，并且获取的数量不等于 1 会报错，Spring 底层有三种：</p><p><code>TomcatServletWebServerFactory</code>、<code>JettyServletWebServerFactory</code>、<code>UndertowServletWebServerFactory</code></p></li><li><p><strong>自动配置类 ServletWebServerFactoryAutoConfiguration</strong> 导入了 ServletWebServerFactoryConfiguration（配置类），根据条件装配判断系统中到底导入了哪个 Web 服务器的包，创建出服务器并启动</p></li><li><p>默认是 web-starter 导入 tomcat 包，容器中就有 TomcatServletWebServerFactory，创建出 Tomcat 服务器并启动，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TomcatWebServer</span><span class="params">(Tomcat tomcat, <span class="type">boolean</span> autoStart, Shutdown shutdown)</span> &#123;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">   initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化方法 initialize 中有启动方法：<code>this.tomcat.start()</code></p></li></ul><hr><hr><h2 id="5-自定义">5. 自定义</h2><h4 id="定制规则">定制规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="comment">//进行一些方法重写，来实现自定义的规则</span></span><br><span class="line">            <span class="comment">//比如添加一些解析器和拦截器，就是对原始容器功能的增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//也可以不加 @Bean，直接从这里重写方法进行功能增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="定制容器">定制容器</h4><p>@EnableWebMvc：全面接管 SpringMVC，所有规则全部自己重新配置</p><ul><li><p>@EnableWebMvc + WebMvcConfigurer + @Bean  全面接管SpringMVC</p></li><li><p>@Import(DelegatingWebMvcConfiguration.<strong>class</strong>)，该类继承 WebMvcConfigurationSupport，自动配置了一些非常底层的组件，只能保证 SpringMVC 最基本的使用</p></li></ul><p>原理：自动配置类 <strong>WebMvcAutoConfiguration</strong> 里面的配置要能生效，WebMvcConfigurationSupport 类不能被加载，所以 @EnableWebMvc 导致配置类失效，从而接管了 SpringMVC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>注意：一般不适用此注解</p>]]></content>
    
    
    <summary type="html">SpringBoot web开发场景</summary>
    
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/tags/Spring/"/>
    
    <category term="SpringMVC" scheme="https://wuwawawa.github.io/tags/SpringMVC/"/>
    
    <category term="SpringBoot" scheme="https://wuwawawa.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置原理</title>
    <link href="https://wuwawawa.github.io/posts/ec6e45b4.html"/>
    <id>https://wuwawawa.github.io/posts/ec6e45b4.html</id>
    <published>2023-05-03T14:26:54.000Z</published>
    <updated>2023-05-16T05:27:42.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-底层注解">1. 底层注解</h2><h3 id="1-1-组件添加">1.1 组件添加</h3><div class="tabs" id="ded05754-ee65-4d86-9ba1-c4e945edc966"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ded05754-ee65-4d86-9ba1-c4e945edc966-1"><i class="fas fa-atom"></i>Configuration</button></li><li class="tab"><button type="button" data-href="#ded05754-ee65-4d86-9ba1-c4e945edc966-2"><i class="far fa-sun"></i>Condition</button></li><li class="tab"><button type="button" data-href="#ded05754-ee65-4d86-9ba1-c4e945edc966-3"><i class="fas fa-wind"></i>其他</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ded05754-ee65-4d86-9ba1-c4e945edc966-1"><p>@Configuration：设置当前类为配置类</p><ul><li>proxyBeanMethods = true：Full 全模式，每个 @Bean 方法被调用多少次返回的组件都是单实例的，默认值，类组件之间<span class='p green'>有依赖关系</span>，方法会被调用得到之前单实例组件</li><li>proxyBeanMethods = false：Lite 轻量级模式，每个 @Bean 方法被调用多少次返回的组件都是新创建的，类组件之间<span class='p blue'>无依赖关系</span>用 Lite 模式加速容器启动过程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的 id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ded05754-ee65-4d86-9ba1-c4e945edc966-2"><p>条件装配：满足Conditional指定的条件，则进行组件注入</p><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">功能说明</th></tr></thead><tbody><tr><td style="text-align:left">@ConditionalOnBean</td><td style="text-align:left">仅在当前上下文中存在某个bean时，才会实例化这个Bean</td></tr><tr><td style="text-align:left">@ConditionalOnClass</td><td style="text-align:left">某个class位于类路径上，才会实例化这个Bean</td></tr><tr><td style="text-align:left">@ConditionalOnExpression</td><td style="text-align:left">当表达式为true的时候，才会实例化这个Bean</td></tr><tr><td style="text-align:left">@ConditionalOnMissingBean</td><td style="text-align:left">仅在当前上下文中不存在某个bean时，才会实例化这个Bean</td></tr><tr><td style="text-align:left">@ConditionalOnMissingClass</td><td style="text-align:left">某个class在类路径上不存在的时候，才会实例化这个Bean</td></tr><tr><td style="text-align:left">@ConditionalOnNotWebApplication</td><td style="text-align:left">不是web应用时才会实例化这个Bean</td></tr><tr><td style="text-align:left">@AutoConfigureAfter</td><td style="text-align:left">在某个bean完成自动配置后实例化这个bean</td></tr><tr><td style="text-align:left">@AutoConfigureBefore</td><td style="text-align:left">在某个bean完成自动配置前实例化这个bean</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ded05754-ee65-4d86-9ba1-c4e945edc966-3"><p>@Bean、@Component、@Controller、@Service、@Repository和Spring中相同就不在介绍</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="1-2-原生配置文件引入">1.2 原生配置文件引入</h3><p>比如，公司使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，@ImportResource粉墨登场。</p><div class="tabs" id="b86eff17-ac9c-4c8c-86af-bc6296b6457e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b86eff17-ac9c-4c8c-86af-bc6296b6457e-1"><i class="fas fa-seedling"></i>bean.xml</button></li><li class="tab"><button type="button" data-href="#b86eff17-ac9c-4c8c-86af-bc6296b6457e-2"><i class="fas fa-leaf"></i>使用方法</button></li><li class="tab"><button type="button" data-href="#b86eff17-ac9c-4c8c-86af-bc6296b6457e-3"><i class="fab fa-apple"></i>测试类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b86eff17-ac9c-4c8c-86af-bc6296b6457e-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">...</span>&quot;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b86eff17-ac9c-4c8c-86af-bc6296b6457e-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b86eff17-ac9c-4c8c-86af-bc6296b6457e-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">haha</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hehe</span> <span class="operator">=</span> run.containsBean(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;haha：&quot;</span>+haha);<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;hehe：&quot;</span>+hehe);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="1-3-配置绑定">1.3 配置绑定</h3><p>我们习惯于把经常变化的一个东西配到配置文件里面。比如把数据库的一些链接地址、账号、密码包括数据库连接池的大小等等这些属性配到properties配置文件里面，然后为了方便 , 因为我们未来可能要创建数据库连接池，我们会把这个配置文件里面的内容又一一解析到我们数据库连接池(比如javaBean我们这个对象里面)，所以我们这个实现场景就是把properties里面的所有配置绑定JavaBean里面。</p><div class="tabs" id="a3219530-2c0b-448a-a9a1-4dc2982e356b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a3219530-2c0b-448a-a9a1-4dc2982e356b-1"><i class="fas fa-cat"></i>JavaBean</button></li><li class="tab"><button type="button" data-href="#a3219530-2c0b-448a-a9a1-4dc2982e356b-2"><i class="fas fa-horse"></i>properties</button></li><li class="tab"><button type="button" data-href="#a3219530-2c0b-448a-a9a1-4dc2982e356b-3"><i class="fas fa-dove"></i>方式一</button></li><li class="tab"><button type="button" data-href="#a3219530-2c0b-448a-a9a1-4dc2982e356b-4"><i class="fas fa-dragon"></i>方式二</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a3219530-2c0b-448a-a9a1-4dc2982e356b-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBrand</span><span class="params">()</span>&#123;<span class="keyword">return</span> brand;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String brand)</span>&#123;<span class="built_in">this</span>.brand = brand;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getPrice</span><span class="params">()</span>&#123;<span class="keyword">return</span> price;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(Integer price)</span>&#123;<span class="built_in">this</span>.price = price;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> + </span><br><span class="line">                <span class="string">&quot;brand = &quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> + </span><br><span class="line">                <span class="string">&quot;, price = &quot;</span> + price + </span><br><span class="line">                <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a3219530-2c0b-448a-a9a1-4dc2982e356b-2"><p>假设有配置文件<code>application.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mycar.brand</span>=<span class="string">BYD</span></span><br><span class="line"><span class="attr">mycar.price</span>=<span class="string">100000</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a3219530-2c0b-448a-a9a1-4dc2982e356b-3"><p><mark class="hl-label green">@ConfigurationProperties+@Component</mark></p><p>这种方式比较适用于一些自定义的配置</p><p>编写一个需要绑定属性的Car类,然后在Car上使用这两个注解，prefix的值与配置文件中的首个值对应（可随意命名）；只有将bean放入到Spring容器中，才能使用SpringBoot的强大工程，因为必须要使用@Component将其注入到容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a3219530-2c0b-448a-a9a1-4dc2982e356b-4"><p><mark class="hl-label blue">@ConfigurationProperties+@EnableConfigurationProperties</mark></p><p>这种方式比较适用于引入第三方组件的时候，如果引入这个第三方组件并没有使用@Component注解将其注入到容器中</p><p>这种方式通常是借助与一个配置类来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="2-装配原理">2. 装配原理</h2><p>自动装配，简单来说就是自动把第三方组件的Bean装载到Spring IOC器里面，不需要开发人员再去写Bean的装配配置。</p><p>在Spring Boot应用里面，只需要在启动类加上<code>@SpringBootApplication</code>注解就可以实现自动装配。<span class='p green'>@SpringBootApplication是一个复合注解，真正实现自动装配的注解是 @EnableAutoConfiguration。</span>自动装配的实现主要依靠三个核心关键技术。</p><ol><li><p>引入Starter启动依赖组件的时候，这个组件里面必须要包含<code>@Configuration配置类</code>，在这个配置类里面通过@Bean注解声明需要装配到IOC容器的Bean对象。</p></li><li><p>这个配置类是放在第三方的jar包里面，然后通过SpringBoot中的<code>约定优于配置思想</code>，把这个配置类的全路径放在<code>classpath:/META-INF/spring.factories</code>文件中。这样SpringBoot就可以知道第三方jar包里面的配置类的位置，这个步骤主要是用到了Spring里面的SpringFactoriesLoader来完成的。</p></li><li><p>SpringBoot拿到所第三方jar包里面声明的配置类以后，再通过Spring提供的<code>ImportSelector</code>接口，实现对这些配置类的动态加载。</p></li></ol><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230501155237141.png" alt="image-20230501155237141" style="zoom:67%;" /><p><code>@SpringBootApplication</code>注解是 <code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合</p><h3 id="2-1-SpringBootConfiguration">2.1 @SpringBootConfiguration</h3><p>代表是一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"><span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-ComponentScan">2.2 @ComponentScan</h3><p>默认扫描当前类所在包及其子级包下的所有文件</p><p>在<code>ConfigurationClassParser#doProcessConfigurationClass</code>开始ComponentScan</p><p><code>Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =        this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</code></p><div class="tabs" id="657de342-5735-44c4-a46e-14abe8543c80"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#657de342-5735-44c4-a46e-14abe8543c80-1"><i class="fas fa-cat"></i>basePackages设置</button></li><li class="tab"><button type="button" data-href="#657de342-5735-44c4-a46e-14abe8543c80-2"><i class="fas fa-horse"></i>扫描位置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="657de342-5735-44c4-a46e-14abe8543c80-1"><p>查看源码<code>ComponentScanAnnotationParser#parse</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line">&#125;</span><br><span class="line">  scanner.doScan(StringUtils.toStringArray(basePackages));</span><br></pre></td></tr></table></figure><p>basePackages设置的正是启动类</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230501184021671.png" alt="image-20230501184021671" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="657de342-5735-44c4-a46e-14abe8543c80-2"><p>查看源码<code>ClassPathScanningCandidateComponentProvider#scanCandidateComponents</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br></pre></td></tr></table></figure><p>packageSearchPath被设定为<code>&quot;classpath*:com/atguigu/boot/**/*.class&quot;</code>，启动类所在包及其子包</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>@ComponentScan和@EnableAutoConfiguration比较</p></blockquote><div class="tabs" id="7d3c7868-8dd3-400f-908b-d10e2e8e170b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7d3c7868-8dd3-400f-908b-d10e2e8e170b-1"><i class="fas fa-cat"></i>作用不同</button></li><li class="tab"><button type="button" data-href="#7d3c7868-8dd3-400f-908b-d10e2e8e170b-2"><i class="fas fa-horse"></i>扫描范围不同</button></li><li class="tab"><button type="button" data-href="#7d3c7868-8dd3-400f-908b-d10e2e8e170b-3"><i class="fas fa-dove"></i>扫描目的不同</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7d3c7868-8dd3-400f-908b-d10e2e8e170b-1"><ul><li>@ComponentScan注解用于指定要扫描的包及其子包中带有特定注解的类(@Controller,@Service,@Respority,@Component)，并将这些类注册到Spring的IOC容器中。</li><li>@EnableAutoConfiguration注解用于启用Spring Boot的自动配置功能，根据classpath下的jar包、配置文件等信息，自动配置应用程序所需的bean和其他组件。而spring.factories文件，则是用来记录项目包外需要注册的bean类名。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7d3c7868-8dd3-400f-908b-d10e2e8e170b-2"><ul><li>@ComponentScan注解只扫描指定的包及其子包中带有特定注解的类，并将其注册到IOC容器中。</li><li>@EnableAutoConfiguration注解会扫描classpath下的所有jar包，并自动配置应用程序所需的bean和其他组件。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7d3c7868-8dd3-400f-908b-d10e2e8e170b-3"><ul><li>@ComponentScan注解的目的是将指定的包及其子包中带有特定注解的类注册到IOC容器中。</li><li>@EnableAutoConfiguration注解的目的是根据应用程序的classpath、jar包和配置文件等信息，自动配置应用程序所需的bean和其他组件。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="2-3-SPI机制">2.3 SPI机制</h3><p>SPI：Service Provider Interface</p><p>服务提供者接口，学名为服务发现机制，它通过在ClassPath路径下的<code>META-INF/services</code>文件夹中查找文件，并自动加载文件里所定义的类。</p><blockquote><p>有什么用呢？不用行不行？到底用来解决什么问题？为何被吹捧的如此厉害？</p></blockquote><mark class="hl-label blue">列举这样一个场景：Java中连接数据库</mark> <div class="tabs" id="43c90029-eada-4f12-a525-da2ed38ed50b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#43c90029-eada-4f12-a525-da2ed38ed50b-1"><i class="fas fa-cat"></i>存在问题</button></li><li class="tab"><button type="button" data-href="#43c90029-eada-4f12-a525-da2ed38ed50b-2"><i class="fas fa-horse"></i>解决方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="43c90029-eada-4f12-a525-da2ed38ed50b-1"><p>在项目中我们通过JDBC，向数据库发送命令去执行，一般的做法是，先加载数据库驱动，然后通过driverManager对象获取connection连接对象，再创建Statement执行SQL语句，最后再处理结果集。而不同的数据库驱动由不同的数据库厂商提供，比如 MySQL驱动，Oracle驱动， SQL Server驱动或者一些其它驱动。但现在有一个问题是，java中提供的驱动是一个接口，而具体的实现类是由各个数据库厂商提供的，而接口是不可以进行实例化的，当你要实例化一个接口时必须得知道这个接口的全限定名。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230501150254996.png" alt="image-20230501150254996" style="zoom: 60%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="43c90029-eada-4f12-a525-da2ed38ed50b-2"><p>其实需要解决的根本问题是：你得告诉我这个接口实现类的全限定名，然后就可以通过反射或者其它的方式，构造出这个接口的实例进而就可以调用具体的方法。</p><p>于是 java 开发者们想了这样一种方法，在项目下的 ClassPath目录中创建<code>META-INF/services</code>文件,并在这个里面创建以接口名为文件名以实现类全限定名为文件内容的文件,然后就可以通过IO获取到所有的全限定名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过IO获取到所有的全限定名</span></span><br><span class="line">List&lt;String&gt; calssNameList = IoUtil.spiLoad(Driver.class)；</span><br><span class="line"><span class="comment">//创建一个容器存储实例</span></span><br><span class="line">List&lt;Driver&gt; providers = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//循环遍历，将class实例化，并添加到容器中</span></span><br><span class="line"><span class="keyword">for</span> (String className : calssNameList) &#123;</span><br><span class="line">    Class&lt;?&gt; c = Class.forName(className);</span><br><span class="line">    providers.add(c.newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230501151440654.png" alt="image-20230501151440654" style="zoom: 60%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>SPI这种方式就可以很好的解决不同框架之间的扩展问题。在<code>java.util.ServiceLoader#load(Class clazz)</code>完成了spi的实现，具体的思路跟上述流程类似。</p><mark class="hl-label green">SPI的变种：SpringBoot自动装配原理</mark> <div class="tabs" id="d2bb1a0b-4b17-4fe7-a714-daafc0259d37"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d2bb1a0b-4b17-4fe7-a714-daafc0259d37-1"><i class="fas fa-bug"></i>存在问题</button></li><li class="tab"><button type="button" data-href="#d2bb1a0b-4b17-4fe7-a714-daafc0259d37-2"><i class="fas fa-cannabis"></i>解决方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d2bb1a0b-4b17-4fe7-a714-daafc0259d37-1"><p>在一个SpringBoot项目中肯定会依赖一些其它框架，比如我们熟悉的mybatis-plus框架而StringBoot默认会将当前包及其子包下的bean注入到ioc中。但此时如果其它框架需要将bean注入到ioc中。因为包名是不想同的，所以不能通过扫描注入。而且在注入的过程中，要和项目尽可能的解耦。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230501153354655.png" alt="image-20230501153354655" style="zoom: 67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d2bb1a0b-4b17-4fe7-a714-daafc0259d37-2"><p>为了解决这个问题，SpringBoot 参考了spi机制的设计思想：规定了在 classPath目录下<code>META-INF</code>文件中可以定义<code>spring.factories</code>的文件,在项目启动的时候会遍历所有jar包下的<code>spring.factories</code>文件,这样就可以将spring.factories文件中定义的类,加载到 ioc 中。</p><div class="fj-gallery"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230501154019068.png" alt="image-20230501154019068" style="zoom:45%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230501154035913.png" alt="image-20230501154035913" style="zoom:45%;" />          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>总结</p><ol><li><p>SPI机制能够使接口与具体的实现类解耦，可以根据实际的业务情况启用或替换具体组件。</p></li><li><p>SPI机制为很多框架的扩展提供了可能。</p></li><li><p>SPI机制更多的是一种思想。</p></li></ol><hr><h3 id="2-4-EnableAutoConfiguration">2.4 @EnableAutoConfiguration</h3><p>启用 SpringBoot 的自动配置机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableAutoConfiguration</code>注解是 <code>@AutoConfigurationPackage</code>、<code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code> 注解的集合</p><p><code>@AutoConfigurationPackage</code>注解的作用是将使用了@SpringBootApplication注解的类所在的包及其子包下的所有使用了@Configuration注解的类都纳入到Spring Boot自动配置的扫描范围内，从而让这些类的Bean定义能够被自动装配。</p><p>而<code>@Import(AutoConfigurationImportSelector.class)</code>注解的作用则是将Spring Boot默认的自动配置类引入到IOC容器中，这些自动配置类都是使用@Configuration注解标注的，通过自动扫描和条件化配置的方式，根据用户的配置和环境来选择性地将特定的Bean定义注入到IOC容器中，以满足应用程序的需求。</p><div class="tabs" id="a10aab32-5823-4cb0-a142-4f021b92d486"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a10aab32-5823-4cb0-a142-4f021b92d486-1"><i class="fas fa-bug"></i>AutoConfigurationPackage</button></li><li class="tab"><button type="button" data-href="#a10aab32-5823-4cb0-a142-4f021b92d486-2"><i class="fas fa-cannabis"></i>⭐️Import({AutoConfigurationImportSelector.class})</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a10aab32-5823-4cb0-a142-4f021b92d486-1"><p>标签名直译为：自动配置包，指定了默认的包规则。将指定的包名注册为Spring Boot自动配置的基本包，从而使Spring Boot自动配置功能能够扫描到这个包中的所有配置类。</p><p>为什么需要自动配置包呢？这是因为Spring Boot自动配置机制是通过在自动配置包及其子包中查找标注了@Configuration注解的类，并解析其中的@Bean注解来实现的。如果没有指定自动配置包，Spring Boot就无法确定应该在哪些包中查找自动配置类。而指定自动配置包，就可以让Spring Boot自动扫描指定包及其子包中的所有配置类，并对它们进行条件化装配，从而实现自动配置的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationPackages.Registrar.class)</span><span class="comment">// 利用 Registrar 给容器中导入组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123; </span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Registrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">register(registry, <span class="keyword">new</span> <span class="title class_">PackageImports</span>(metadata).getPackageNames().toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> <span class="title class_">PackageImports</span>(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230430162512630.png" alt="image-20230430162512630" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(BeanDefinitionRegistry registry, String... packageNames)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">BEAN</span> <span class="operator">=</span> AutoConfigurationPackages.class.getName();</span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> registry.getBeanDefinition(BEAN);</span><br><span class="line">        <span class="type">ConstructorArgumentValues</span> <span class="variable">constructorArguments</span> <span class="operator">=</span> beanDefinition.getConstructorArgumentValues();</span><br><span class="line">        constructorArguments.addIndexedArgumentValue(<span class="number">0</span>, addBasePackages(constructorArguments, packageNames));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">GenericBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">        beanDefinition.setBeanClass(AutoConfigurationPackages.BasePackages.class);</span><br><span class="line">        beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, packageNames);</span><br><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        registry.registerBeanDefinition(BEAN, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过打断点得知，<code>packageNames</code>传的就是启动类所在的包名，然后这个方法就是判断容器是否注入了<code>BasePackagesBeanDefinition</code>。如果注入了就从容器获取，并将包名赋值给他的<code>basePackages</code>属性，然后执行这块的时候其实是并没有注册的，所以直接执行else。else就是直接创建一个<code>BasePackagesBeanDefinition</code>对象，然后将包名赋值给他的<code>basePackages</code>属性。</p><p><code>basePackages</code>是个set集合，但是容器当中始终只有一个<code>BasePackagesBeanDefinition</code>对象，也就是只要代码当中添加<code>@AutoConfigurationPackage</code>注解，就会将注解所在的包名添加到<code>basePackages</code>集合当中。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a10aab32-5823-4cb0-a142-4f021b92d486-2"><p>AutoConfigurationImportSelector类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给容器中导入组件</span></span><br><span class="line">    <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果自动配置没有启用，则返回空的AutoConfigurationEntry对象</span></span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取注解属性</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 获取所有符合条件的自动配置类，并去除重复</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">// 获取所有排除的自动配置类，并检查是否存在重复</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 从候选的自动配置类中移除所有排除的自动配置类，并过滤掉不符合条件的自动配置类</span></span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    <span class="comment">// 触发自动配置导入事件，通知所有自动配置导入监听器自动配置的情况</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 创建并返回一个AutoConfigurationEntry对象，该对象包含应用的自动配置类和排除的自动配置类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、利用<code>getAutoConfigurationEntry(annotationMetadata);</code>给容器中批量导入一些组件<br>2、调用<code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)</code>获取到所有需要导入到容器中的配置类<br>3、利用工厂加载 <code>Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；</code>得到所有的组件<br>4、从<code>META-INF/spring.factories</code>位置来加载一个文件。</p><p>默认扫描jar包里面所有META-INF/spring.factories位置的文件</p><p>spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories，文件里面写死了spring-boot一启动就要给容器中加载的所有配置类</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/SpringBoot-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" style="zoom:50%;" /><blockquote><p>筛选前size=130 vs筛选后size=26</p></blockquote><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230430172712413.png" alt="image-20230430172712413" style="zoom: 25%;" /><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230430172756327.png" alt="image-20230430172756327" style="zoom: 25%;" /><p>虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration<br>按照条件装配规则（@Conditional），最终会按需配置。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230430174625456.png" alt="image-20230430174625456" style="zoom:50%;" /><ul><li></li></ul><p>以DispatcherServletAutoConfiguration为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span> <span class="comment">// 指定该自动配置类的顺序，优先级最高</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">// 声明该类是一个Spring配置类，不使用代理bean的方式</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span> <span class="comment">// 仅在Web应用程序中使用</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span> <span class="comment">// 仅当类路径中存在指定的类DispatcherServlet时才应用此配置类</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)</span> <span class="comment">// 在ServletWebServerFactoryAutoConfiguration自动配置之后应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@Conditional(org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(ServletRegistration.class)</span></span><br><span class="line">    <span class="meta">@EnableConfigurationProperties(WebMvcProperties.class)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean(name = &quot;dispatcherServlet&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">(WebMvcProperties webMvcProperties)</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个DispatcherServlet对象</span></span><br><span class="line">            <span class="type">DispatcherServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">            <span class="comment">// 配置DispatcherServlet属性</span></span><br><span class="line">            dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line">            dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());</span><br><span class="line">            dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class="line">            dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());</span><br><span class="line">            dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());</span><br><span class="line">            <span class="keyword">return</span> dispatcherServlet; <span class="comment">// 返回DispatcherServlet对象</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnBean(MultipartResolver.class)</span> <span class="comment">// 容器中有这个类型的组件</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean(name = &quot;multipartResolver&quot;)</span> <span class="comment">//容器中没有这个名字multipartResolver的组件  </span></span><br><span class="line">        <span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> &#123;</span><br><span class="line">            <span class="comment">// 当容器中存在MultipartResolver对象且没有指定名字为DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME时，返回该对象</span></span><br><span class="line">            <span class="comment">// 主要用于检测用户是否已创建一个MultipartResolver但名称不正确</span></span><br><span class="line">            <span class="keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SpringBoot默认会在底层配好所有的组件。但是如果用户自己配置了以用户的优先</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>Spring Boot 通过 <code>@EnableAutoConfiguration</code> 开启自动装配，通过 SpringFactoriesLoader 加载 <code>META-INF/spring.factories</code> 中的自动配置类实现自动装配，自动配置类其实就是通过 <code>@Conditional</code> 注解按需加载的配置类，想要其生效必须引入 <code>spring-boot-starter-xxx</code> 包实现起步依赖</p><ul><li>SpringBoot 先加载所有的自动配置类 xxxxxAutoConfiguration</li><li>每个自动配置类进行条件装配，默认都会绑定配置文件指定的值（xxxProperties 和配置文件进行了绑定）</li><li>SpringBoot 默认会在底层配好所有的组件，如果用户自己配置了以用户的优先</li><li>定制化配置：<ul><li>用户可以使用 @Bean 新建自己的组件来替换底层的组件</li><li>用户可以去看这个组件是获取的配置文件前缀值，在配置文件中修改</li></ul></li></ul><blockquote><p>如何查看自动配置了哪些</p></blockquote><p>application.properties中debug=true开启自动配置报告。可以显示哪些生效哪些没生效 Negative不生效\Positive生效</p><hr><hr><h2 id="3-启动流程">3. 启动流程</h2><p>如果想debug查看SpringBoot自动装配的流程，可以在下面方法打上断点</p><blockquote><ul><li><p>SpringApplication#refreshContext(context);</p></li><li><p>AbstractApplicationContext#invokeBeanFactoryPostProcessors(beanFactory);</p></li><li><p>PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</p></li><li><p>ConfigurationClassPostProcessor#processConfigBeanDefinitions(BeanDefinitionRegistry registry);</p><ul><li>parser.parse(candidates);<ul><li>this.deferredImportSelectorHandler.process();<ul><li>handler.processGroupImports(); 解析AutoConfigurationImportSelector.class</li></ul></li></ul></li><li>this.reader.loadBeanDefinitions(configClasses);</li></ul></li></ul></blockquote><p>应用启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动代码</span></span><br><span class="line">        SpringApplication.run(BootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpringApplication 构造方法</code></p><ul><li><p><code>this.resourceLoader = resourceLoader</code>：资源加载器，初始为 null</p></li><li><p><code>this.webApplicationType = WebApplicationType.deduceFromClasspath()</code>：判断当前应用的类型，是响应式还是 Web 类</p></li><li><p><code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code></p><ul><li><p><code>Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</code></p></li><li><p>导入<code>META-INF/spring.factories</code> ，并存入缓存，下面会用到</p></li></ul></li></ul><p><code>(new SpringApplication(primarySources)).run(args)</code></p><div class="tabs" id="9e15277e-9f6e-4253-b9c1-05e40b94a476"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#9e15277e-9f6e-4253-b9c1-05e40b94a476-1"><i class="fas fa-cannabis"></i>1</button></li><li class="tab"><button type="button" data-href="#9e15277e-9f6e-4253-b9c1-05e40b94a476-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#9e15277e-9f6e-4253-b9c1-05e40b94a476-3"><i class="fas fa-tree"></i>4</button></li><li class="tab"><button type="button" data-href="#9e15277e-9f6e-4253-b9c1-05e40b94a476-4"><i class="fas fa-cookie-bite"></i>5⭐️</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="9e15277e-9f6e-4253-b9c1-05e40b94a476-1"><p><mark class="hl-label blue">SpringApplication#run方法</mark></p><p>创建 IOC 容器并实现了自动装配</p><ul><li><p><code>StopWatch stopWatch = new StopWatch()</code>：停止监听器，<span class='p green'>监控整个应用的启停</span></p></li><li><p><code>stopWatch.start()</code>：记录应用的启动时间</p></li><li><p><code>printedBanner = printBanner(environment)</code>：打印 SpringBoot 标志</p></li><li><p><code>context = createApplicationContext()</code>：<span class='p red'>创建 IOC 容器</span></p><p><code>switch (this.webApplicationType)</code>：根据当前应用的类型创建 IOC 容器</p><ul><li><code>case SERVLET</code>：Web 应用环境对应 AnnotationConfigServletWebServerApplicationContext</li><li><code>case REACTIVE</code>：响应式编程对应 AnnotationConfigReactiveWebServerApplicationContext</li><li><code>default</code>：默认为 Spring 环境 AnnotationConfigApplicationContext</li></ul></li><li><p><code>context.setApplicationStartup(this.applicationStartup)</code>：设置一个启动器</p></li><li><p><code>prepareContext()</code>：<span class='p green'>配置 IOC 容器的基本信息</span></p><ul><li><code>beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);</code>：向单例池中添加springBootBanner</li><li><code>load(context, sources.toArray(new Object[0]));</code>：向beanDefinitionMap添加启动类</li></ul></li><li><p><code>refreshContext(context)</code>：<span class='p green'>刷新 IOC 容器，Spring 的容器启动流程</span></p><ul><li><p><code>refresh(context);</code></p><ul><li><p><code>prepareRefresh();</code>：准备刷新应用上下文</p></li><li><p><code>prepareBeanFactory(beanFactory);</code>：设置一些BeanClassLoader和BeanPostProcessor</p></li><li><p><code>invokeBeanFactoryPostProcessors(beanFactory)</code>：实例化并调用所有注册的BeanFactoryPostProcessor bean，如果给定，则遵循显式顺序。<span class='p red'>在此处实现了自动装配</span>  <mark class="hl-label green">详见2</mark></p></li><li><p><code>registerBeanPostProcessors(beanFactory);</code>：向容器中添加BeanPostProcessor</p></li><li><p>…</p></li></ul></li></ul></li><li><p><code>afterRefresh(context, applicationArguments)</code>：留给用户自定义容器刷新完成后的处理逻辑</p></li><li><p><code>stopWatch.stop()</code>：记录应用启动完成的时间</p></li><li><p><code>listeners.started(context)</code>：所有的运行监听器调用 started() 方法</p></li><li><p><code>listeners.running(context)</code>：所有的运行监听器调用 running() 方法</p><ul><li>获取容器中的 ApplicationRunner、CommandLineRunner</li><li><code>AnnotationAwareOrderComparator.sort(runners)</code>：合并所有 runner 并且按照 @Order 进行排序</li><li><code>callRunner()</code>：遍历所有的 runner，调用 run 方法</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9e15277e-9f6e-4253-b9c1-05e40b94a476-2"><p><mark class="hl-label blue">PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors方法</mark></p><p>//分为两类</p><ul><li><code>List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();</code></li><li><code>List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();</code></li></ul><br/><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的 BeanFactoryPostProcessor</span></span><br><span class="line"><span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">    <span class="comment">// 判断是否为 BeanDefinitionRegistryPostProcessor 类型</span></span><br><span class="line">    <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">        <span class="comment">// 将当前的 BeanFactoryPostProcessor 转换为 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">            (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">        <span class="comment">// 调用 BeanDefinitionRegistryPostProcessor 的方法对 BeanDefinitionRegistry 进行处理</span></span><br><span class="line">        registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        <span class="comment">// 将处理后的 BeanDefinitionRegistryPostProcessor 添加到 registryProcessors 集合中</span></span><br><span class="line">        registryProcessors.add(registryProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将普通的 BeanFactoryPostProcessor 添加到 regularPostProcessors 集合中</span></span><br><span class="line">        regularPostProcessors.add(postProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</p><ul><li><p><code>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</code></p><ul><li><p><code>currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</code><span class='p red'>getBean方法实例化BeanDefinitionRegistryPostProcessor</span></p></li><li><p><code>invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</code></p><ul><li><span class='p red'>ConfigurationClassPostProcessor执行</span> <mark class="hl-label green">跳转到4</mark></li></ul></li></ul></li></ul><p>// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</p><p>// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9e15277e-9f6e-4253-b9c1-05e40b94a476-3"><p><mark class="hl-label blue">ConfigurationClassPostProcessor</mark></p><p>用来解析配置类，如果类上面加入了@Configuration，@CompentScan等，它就会你的这些配置解析出来</p><p>解析处理@PropertySource 注解<br>解析@ComponentScan注解,扫描@Configuration、@Service、@Controller、@Repository和@Component注解并注册BeanDefinition<br>解析@Import注解,然后进行实例化,并执行ImportBeanDefinitionRegistrar的registerBeanDefinitions逻辑,或者ImportSelector的selectImports逻辑<br>解析@ImportResource注解,并加载相关配置信息<br>解析方法级别@Bean注解并将返回值注册成BeanDefinition<br>注册ImportRegistry到容器中,用于处理ImportAware</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//获取bdmap所有的beanName</span></span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有候选的 bean 名称</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">    <span class="comment">// 获取该 bean 的 BeanDefinition 对象</span></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断该 bean 是否已被标记为配置类</span></span><br><span class="line">    <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果已被标记，则在调试模式下记录日志信息</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">        <span class="comment">// 如果该 bean 满足配置类的候选条件，则将其添加到配置类的候选集合中</span></span><br><span class="line">        configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断逻辑：checkConfigurationClassCandidate，判断完成后只有启动类被加入到了configCandidates集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从metadata中获取Confuguration注解</span></span><br><span class="line">Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line"><span class="comment">// 根据metadata中的注解判断是full匹配还是lite匹配。</span></span><br><span class="line"><span class="keyword">if</span> (config != <span class="literal">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">&quot;proxyBeanMethods&quot;</span>))) &#123;</span><br><span class="line">    beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="literal">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">    beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类解析的核心代码：遍历候选的 <code>BeanDefinition</code> 对象来解析 <code>@Configuration</code> 类，从而生成对应的 <code>BeanDefinition</code> 对象。在解析完一批候选的 <code>@Configuration</code> 类之后，会检查容器中是否还有新的候选 <code>@Configuration</code> 类需要解析，如果有，则会继续对新的候选 <code>@Configuration</code> 类进行解析，直到容器中没有新的候选 <code>@Configuration</code> 类为止。最终，容器中的所有 <code>@Configuration</code> 类都会被解析并转换为对应的 <code>BeanDefinition</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 候选BeanDefinition的解析器</span></span><br><span class="line"><span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">        <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"><span class="comment">// 需要解析的BeanDefinitionHolder容器，初始值为configCandidates</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line"><span class="comment">// 已经解析过的ConfigurationClass容器</span></span><br><span class="line">Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 解析候选BeanDefinition中的@Configuration类</span></span><br><span class="line">    parser.parse(candidates);</span><br><span class="line">    <span class="comment">// 验证@Configuration类的依赖关系和重复导入</span></span><br><span class="line">    parser.validate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有被解析的@Configuration类</span></span><br><span class="line">    Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">    <span class="comment">// 从解析过的@Configuration类中剔除已经被处理过的</span></span><br><span class="line">    configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据@Configuration类的信息，读取其内容并创建BeanDefinition</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">                registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">                <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ⭐️⭐️⭐️ ③导入根据import解析出来的AutoConfiguration类中里面的bean</span></span><br><span class="line">    <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">    <span class="comment">// 将已经解析过的@Configuration类加入已处理集合</span></span><br><span class="line">    alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空当前的候选集合</span></span><br><span class="line">    candidates.clear();</span><br><span class="line">    <span class="comment">// 如果当前BeanDefinition数量大于候选集合中的数量，则需要重新扫描新的BeanDefinition</span></span><br><span class="line">    <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">        <span class="comment">// 更新候选BeanDefinition的名称集合</span></span><br><span class="line">        String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">        <span class="comment">// 将旧的候选名称集合转换为HashSet，便于查询</span></span><br><span class="line">        Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">        <span class="comment">// 将已经解析过的@Configuration类的名称加入Set集合</span></span><br><span class="line">        Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">            alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历所有新的候选名称</span></span><br><span class="line">        <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">            <span class="comment">// 如果该名称不在旧的候选名称中，则加入候选集合</span></span><br><span class="line">            <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                <span class="comment">// 获取该BeanDefinition对象</span></span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">                <span class="comment">// 如果该BeanDefinition符合@Configuration类的条件，并且没有被解析过，则加入候选集合</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                        !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                    candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新候选名称集合</span></span><br><span class="line">        candidateNames = newCandidateNames;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (!candidates.isEmpty());</span><br></pre></td></tr></table></figure><p><code>parser.parse(candidates);</code>具体的解析过程核心逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历每一个候选的 BeanDefinitionHolder，对其进行解析</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断是否是 AnnotatedBeanDefinition 类型，如果是则解析注解元数据</span></span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 判断是否是 AbstractBeanDefinition 类型且已经设置 BeanClass，如果是则解析注解元数据</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 否则解析 BeanClassName 对应的类的注解元数据</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="comment">// 如果解析异常则直接抛出 BeanDefinitionStoreException</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 如果解析异常则抛出 BeanDefinitionStoreException，给出失败的类名</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐️⭐️⭐️②导入了需要解析的配置类 此处执行了AutoConfigurationImportSelector#process方法</span></span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doProcessConfigurationClass  <mark class="hl-label green">详见5</mark>   重点</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9e15277e-9f6e-4253-b9c1-05e40b94a476-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 ConfigurationClass 使用了 @Component 注解，则先递归处理所有嵌套类</span></span><br><span class="line"><span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">    processMemberClasses(configClass, sourceClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 @PropertySource 注解</span></span><br><span class="line"><span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">        org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">        processPropertySource(propertySource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 @ComponentScan 注解  basePackages设置的正是启动类</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">        sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">        !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">        <span class="comment">// 如果当前配置类被 @ComponentScan 注解，则立即执行扫描</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">                <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">        <span class="comment">// 检查扫描到的 BeanDefinition 集合中是否有配置类，如果有则递归解析</span></span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">            <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">                bdCand = holder.getBeanDefinition();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动类上两个import</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230502104957759.png" alt="image-20230502104957759"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ①处理 @Import 注解</span></span><br><span class="line">processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 @ImportResource 注解</span></span><br><span class="line"><span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line"><span class="keyword">if</span> (importResource != <span class="literal">null</span>) &#123;</span><br><span class="line">    String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">        configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 @Bean 方法</span></span><br><span class="line">Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">    configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接口中的默认方法</span></span><br><span class="line">processInterfaces(configClass, sourceClass);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="4-事件监听">4. 事件监听</h2><p>SpringBoot 在项目启动时，会对几个监听器进行回调，可以实现监听器接口，在项目启动时完成一些操作</p><p><code>ApplicationContextInitializer</code>、<code>SpringApplicationRunListener</code>、<code>CommandLineRunner</code>、<code>ApplicationRunner</code></p><div class="tabs" id="bf7c81bb-1e37-4601-af56-417721997df7"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#bf7c81bb-1e37-4601-af56-417721997df7-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#bf7c81bb-1e37-4601-af56-417721997df7-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#bf7c81bb-1e37-4601-af56-417721997df7-3"><i class="fas fa-dove"></i>3</button></li><li class="tab"><button type="button" data-href="#bf7c81bb-1e37-4601-af56-417721997df7-4"><i class="fas fa-dragon"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="bf7c81bb-1e37-4601-af56-417721997df7-1"><p>MyApplicationRunner</p><p>自定义监听器的启动时机：MyApplicationRunner 和 MyCommandLineRunner 都是当项目启动后执行，使用 @Component 放入容器即可使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当项目启动后执行run方法</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationRunner...run&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.asList(args.getSourceArgs()));<span class="comment">//properties配置信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bf7c81bb-1e37-4601-af56-417721997df7-2"><p>MyCommandLineRunner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CommandLineRunner...run&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.asList(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bf7c81bb-1e37-4601-af56-417721997df7-3"><p>MyApplicationContextInitializer 的启用要在 resource 文件夹下添加 META-INF/spring.factories</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.springbootlistener.listener.MyApplicationContextInitializer</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationContextInitializer....initialize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bf7c81bb-1e37-4601-af56-417721997df7-4"><p>MySpringApplicationRunListener 的使用要添加构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySpringApplicationRunListener</span> <span class="keyword">implements</span> <span class="title class_">SpringApplicationRunListener</span> &#123;</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySpringApplicationRunListener</span><span class="params">(SpringApplication sa, String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;starting...项目启动中&quot;</span>);<span class="comment">//输出SPRING之前</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;environmentPrepared...环境对象开始准备&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;contextPrepared...上下文对象开始准备&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;contextLoaded...上下文对象开始加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;started...上下文对象加载完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...项目启动完成，开始运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;failed...项目启动失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="5-配置文件">5. 配置文件</h2><p>SpringBoot 是基于约定的，很多配置都有默认值，如果想使用自己的配置替换默认配置，可以使用application.properties或者 application.yml（application.yaml）进行配置</p><ul><li>默认配置文件名称：application</li><li>在同一级目录下优先级为：properties &gt; yml &gt; yaml</li></ul><h3 id="4-1-yaml语法">4.1 yaml语法</h3><p>基本语法：</p><ul><li><p>大小写敏感</p></li><li><p>数据值前边必须有空格，作为分隔符</p></li><li><p>使用缩进表示层级关系</p></li><li><p>缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应空格数目可能不同，导致层次混乱）</p></li><li><p>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p></li><li><p>‘’#&quot; 表示注释，从这个字符一直到行尾，都会被解析器忽略</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line"><span class="attr">port:</span> <span class="number">8080</span>  </span><br><span class="line">    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></li></ul><p>数据格式：</p><div class="tabs" id="8c706fa9-4b8b-4bfb-aac6-92a8c17c7be7"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8c706fa9-4b8b-4bfb-aac6-92a8c17c7be7-1"><i class="fas fa-award"></i>纯量</button></li><li class="tab"><button type="button" data-href="#8c706fa9-4b8b-4bfb-aac6-92a8c17c7be7-2"><i class="fas fa-baseball-ball"></i>对象</button></li><li class="tab"><button type="button" data-href="#8c706fa9-4b8b-4bfb-aac6-92a8c17c7be7-3"><i class="fas fa-bone"></i>数组</button></li><li class="tab"><button type="button" data-href="#8c706fa9-4b8b-4bfb-aac6-92a8c17c7be7-4"><i class="fas fa-anchor"></i>参数引用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8c706fa9-4b8b-4bfb-aac6-92a8c17c7be7-1"><p>单个的、不可再分的值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">msg1:</span> <span class="string">&#x27;hello \n world&#x27;</span>  <span class="comment"># 单引忽略转义字符</span></span><br><span class="line"><span class="attr">msg2:</span> <span class="string">&quot;hello \n world&quot;</span>  <span class="comment"># 双引识别转义字符</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c706fa9-4b8b-4bfb-aac6-92a8c17c7be7-2"><p>键值对集合，Map、Hash</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span>  </span><br><span class="line">   <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">   <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">person:</span> &#123;<span class="attr">name:</span> <span class="string">zhangsan</span>&#125;</span><br></pre></td></tr></table></figure><p>注意：不建议使用 JSON，应该使用 yaml 语法</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c706fa9-4b8b-4bfb-aac6-92a8c17c7be7-3"><p>一组按次序排列的值，List、Array</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">address:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">beijing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">shanghai</span></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">beijing</span>,<span class="string">shanghai</span>]</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">allPerson</span><span class="comment">#List&lt;Person&gt;</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="string">name:lisi</span>, <span class="string">age:18</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="string">name:wangwu</span>, <span class="string">age:20</span>&#125;</span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">allPerson:</span> [&#123;<span class="string">name:lisi</span>, <span class="string">age:18</span>&#125;, &#123;<span class="string">name:wangwu</span>, <span class="string">age:20</span>&#125;]</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c706fa9-4b8b-4bfb-aac6-92a8c17c7be7-4"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">lisi</span> </span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">$&#123;name&#125;</span> <span class="comment"># 引用上边定义的name值</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="4-2-获取配置">4.2 获取配置</h3><p>三种获取配置文件的方式：</p><div class="tabs" id="2db43a24-e20c-4b2a-aa39-fd15c4f39ae0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2db43a24-e20c-4b2a-aa39-fd15c4f39ae0-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#2db43a24-e20c-4b2a-aa39-fd15c4f39ae0-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#2db43a24-e20c-4b2a-aa39-fd15c4f39ae0-3"><i class="fab fa-apple"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2db43a24-e20c-4b2a-aa39-fd15c4f39ae0-1"><p>注解 @Value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;address[0]&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;msg1&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;msg2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String msg2;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有的数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2db43a24-e20c-4b2a-aa39-fd15c4f39ae0-2"><p>Evironment 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;person.name&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;address[0]&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2db43a24-e20c-4b2a-aa39-fd15c4f39ae0-3"><p>注解 @ConfigurationProperties 配合 @Component 使用</p><p>注意：参数 prefix 一定要指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//不扫描该组件到容器内，无法完成自动装配</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String[] address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Person person;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(person);</span><br><span class="line">    <span class="comment">//Person&#123;name=&#x27;zhangsan&#x27;, age=20, address=[beijing, shanghai]&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; hello Spring Boot !&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="6-自定义Starter">6. 自定义Starter</h2><p>spring boot 在配置上相比spring要简单许多, 其核心在于spring-boot-starter, 在使用spring boot来搭建一个项目时, 只需要引入官方提供的starter, 就可以直接使用, 免去了各种配置。starter简单来讲就是引入了一些相关依赖和一些初始化的配置。</p><h3 id="6-1-案例一">6.1 案例一</h3><mark class="hl-label blue">开发starter</mark> <div class="tabs" id="f449984b-9e18-4b00-b258-d815a8483b62"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#f449984b-9e18-4b00-b258-d815a8483b62-1"><i class="fas fa-seedling"></i>第一步</button></li><li class="tab"><button type="button" data-href="#f449984b-9e18-4b00-b258-d815a8483b62-2"><i class="fas fa-leaf"></i>第二步</button></li><li class="tab"><button type="button" data-href="#f449984b-9e18-4b00-b258-d815a8483b62-3"><i class="fab fa-apple"></i>第三步</button></li><li class="tab"><button type="button" data-href="#f449984b-9e18-4b00-b258-d815a8483b62-4"><i class="fas fa-tree"></i>第四步</button></li><li class="tab"><button type="button" data-href="#f449984b-9e18-4b00-b258-d815a8483b62-5"><i class="fas fa-heartbeat"></i>第五步</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="f449984b-9e18-4b00-b258-d815a8483b62-1"><p>创建starter工程hello-spring-boot-starter并配置pom.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">                             http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f449984b-9e18-4b00-b258-d815a8483b62-2"><p>创建配置属性类HelloProperties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *读取配置文件转换为bean</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HelloProperties&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f449984b-9e18-4b00-b258-d815a8483b62-3"><p>创建服务类HelloService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloService</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;你好！我的名字叫 &quot;</span> + name + <span class="string">&quot;，我来自 &quot;</span> + address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f449984b-9e18-4b00-b258-d815a8483b62-4"><p>创建自动配置类HelloServiceAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 配置类，基于Java代码的bean配置</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造方法注入配置属性对象HelloProperties</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloServiceAutoConfiguration</span><span class="params">(HelloProperties helloProperties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.helloProperties = helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化HelloService并载入Spring IoC容器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> HelloService <span class="title function_">helloService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloService</span>(helloProperties.getName(),helloProperties.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f449984b-9e18-4b00-b258-d815a8483b62-5"><p>在resources目录下创建META-INF/spring.factories</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">cn.itcast.config.HelloServiceAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>至此starter已经开发完成了，可以将当前starter安装到本地maven仓库供其他应用来使用。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label green">使用starter</mark> <div class="tabs" id="dd433e8a-b1b4-46a3-8443-6088615e447a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dd433e8a-b1b4-46a3-8443-6088615e447a-1"><i class="fas fa-cat"></i>第一步</button></li><li class="tab"><button type="button" data-href="#dd433e8a-b1b4-46a3-8443-6088615e447a-2"><i class="fas fa-horse"></i>第二步</button></li><li class="tab"><button type="button" data-href="#dd433e8a-b1b4-46a3-8443-6088615e447a-3"><i class="fas fa-dove"></i>第三步</button></li><li class="tab"><button type="button" data-href="#dd433e8a-b1b4-46a3-8443-6088615e447a-4"><i class="fas fa-dragon"></i>第四步</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dd433e8a-b1b4-46a3-8443-6088615e447a-1"><p>创建maven工程myapp并配置pom.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myapp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--导入自定义starter--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dd433e8a-b1b4-46a3-8443-6088615e447a-2"><p>创建application.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">hello:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">xiaoming</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">beijing</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dd433e8a-b1b4-46a3-8443-6088615e447a-3"><p>创建HelloController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="comment">//HelloService在我们自定义的starter中已经完成了自动配置，所以此处可以直接注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/say&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dd433e8a-b1b4-46a3-8443-6088615e447a-4"><p>创建启动类HelloApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(HelloApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行启动类main方法，访问地址http://localhost:8080/hello/say</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20200310103528648.png" alt="image-20200310103528648"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="6-2-案例二">6.2 案例二</h3><p>在前面的案例一中我们通过定义starter，自动配置了一个HelloService实例。本案例我们需要通过自动配置来创建一个拦截器对象，通过此拦截器对象来实现记录日志功能。我们可以在案例一的基础上继续开发案例二。</p><mark class="hl-label blue">开发starter</mark> <div class="tabs" id="421b7b5d-e977-4116-b671-5a181d0ca04c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#421b7b5d-e977-4116-b671-5a181d0ca04c-1"><i class="fas fa-atom"></i>第一步</button></li><li class="tab"><button type="button" data-href="#421b7b5d-e977-4116-b671-5a181d0ca04c-2"><i class="far fa-sun"></i>第二步</button></li><li class="tab"><button type="button" data-href="#421b7b5d-e977-4116-b671-5a181d0ca04c-3"><i class="fas fa-wind"></i>第三步</button></li><li class="tab"><button type="button" data-href="#421b7b5d-e977-4116-b671-5a181d0ca04c-4"><i class="fas fa-fire-alt"></i>第四步</button></li><li class="tab"><button type="button" data-href="#421b7b5d-e977-4116-b671-5a181d0ca04c-5"><i class="fas fa-cookie-bite"></i>第五步</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="421b7b5d-e977-4116-b671-5a181d0ca04c-1"><p>在hello-spring-boot-starter的pom.xml文件中追加如下maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="421b7b5d-e977-4116-b671-5a181d0ca04c-2"><p>自定义MyLog注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">desc</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="421b7b5d-e977-4116-b671-5a181d0ca04c-3"><p>自定义日志拦截器MyLogInterceptor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日志拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; startTimeThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, </span></span><br><span class="line"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod)handler;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();<span class="comment">//获得被拦截的方法对象</span></span><br><span class="line">        <span class="type">MyLog</span> <span class="variable">myLog</span> <span class="operator">=</span> method.getAnnotation(MyLog.class);<span class="comment">//获得方法上的注解</span></span><br><span class="line">        <span class="keyword">if</span>(myLog != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//方法上加了MyLog注解，需要进行日志记录</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            startTimeThreadLocal.set(startTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, </span></span><br><span class="line"><span class="params">                           Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> (HandlerMethod)handler;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> handlerMethod.getMethod();<span class="comment">//获得被拦截的方法对象</span></span><br><span class="line">        <span class="type">MyLog</span> <span class="variable">myLog</span> <span class="operator">=</span> method.getAnnotation(MyLog.class);<span class="comment">//获得方法上的注解</span></span><br><span class="line">        <span class="keyword">if</span>(myLog != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//方法上加了MyLog注解，需要进行日志记录</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> startTimeThreadLocal.get();</span><br><span class="line">            <span class="type">long</span> <span class="variable">optTime</span> <span class="operator">=</span> endTime - startTime;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">requestUri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + </span><br><span class="line">                method.getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodDesc</span> <span class="operator">=</span> myLog.desc();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;请求uri：&quot;</span> + requestUri);</span><br><span class="line">            System.out.println(<span class="string">&quot;请求方法名：&quot;</span> + methodName);</span><br><span class="line">            System.out.println(<span class="string">&quot;方法描述：&quot;</span> + methodDesc);</span><br><span class="line">            System.out.println(<span class="string">&quot;方法执行时间：&quot;</span> + optTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="421b7b5d-e977-4116-b671-5a181d0ca04c-4"><p>创建自动配置类MyLogAutoConfiguration，用于自动配置拦截器、参数解析器等web组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.log.MyLogInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类，用于自动配置拦截器、参数解析器等web组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="comment">//注册自定义日志拦截器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyLogInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="421b7b5d-e977-4116-b671-5a181d0ca04c-5"><p>在spring.factories中追加MyLogAutoConfiguration配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">cn.itcast.config.HelloServiceAutoConfiguration,\</span></span><br><span class="line"><span class="string">cn.itcast.config.MyLogAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>注意：我们在hello-spring-boot-starter中追加了新的内容，需要重新打包安装到maven仓库。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <mark class="hl-label green">使用starter</mark> <p>在myapp工程的Controller方法上加入@MyLog注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.log.MyLog;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="comment">//HelloService在我们自定义的starter中已经完成了自动配置，所以此处可以直接注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyLog(desc = &quot;sayHello方法&quot;)</span> <span class="comment">//日志记录注解</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/say&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问地址：<a href="http://localhost:8080/hello/say%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%EF%BC%9A">http://localhost:8080/hello/say，查看控制台输出：</a></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">请求uri：/hello/say</span></span><br><span class="line"><span class="attr">请求方法名：cn.itcast.controller.HelloController.sayHello</span></span><br><span class="line"><span class="attr">方法描述：sayHello方法</span></span><br><span class="line"><span class="attr">方法执行时间：36ms</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">自动装配流程详解、自定义Starter</summary>
    
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://wuwawawa.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot概述</title>
    <link href="https://wuwawawa.github.io/posts/4e03c5a1.html"/>
    <id>https://wuwawawa.github.io/posts/4e03c5a1.html</id>
    <published>2023-05-02T10:30:30.000Z</published>
    <updated>2023-05-16T05:27:32.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-Boot概述">1. Spring Boot概述</h2><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的创建、运行、调试、部署等。使用Spring Boot可以做到专注于Spring应用的开发，而无需过多关注XML的配置。Spring Boot使用“约定大于配置”的理念，简单来说，它提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题。使用Spring Boot可以不用或者只需要很少的Spring配置就可以让企业项目快速运行起来。</p><p>Spring Boot是开发者和Spring 本身框架的中间层，帮助开发者统筹管理应用的配置，提供基于实际开发中常见配置的默认处理（<span class='p red'>约定大于配置</span>），简化应用的开发，简化应用的运维；总的来说，其目的Spring Boot就是为了对Java web 的开发进行“简化”和加“快”速度，简化开发过程中引入或启动相关Spring 功能的配置。这样带来的好处就是降低开发人员对于框架的关注点，可以把更多的精力放在自己的业务代码上。</p><hr><hr><h2 id="2-为什么使用SpringBoot">2. 为什么使用SpringBoot</h2><blockquote><p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p><p>能快速创建出生产级别的Spring应用</p></blockquote><h3 id="2-1-SpringBoot优点">2.1. SpringBoot优点</h3><ol><li>独立运行的 Spring 项目</li></ol><p>Spring Boot 可以以 jar 包的形式独立运行，Spring Boot 项目只需通过命令“ java–jar xx.jar” 即可运行。</p><ol start="2"><li>内嵌 Servlet 容器</li></ol><p>Spring Boot 使用嵌入式的 Servlet 容器（例如 Tomcat、Jetty 或者 Undertow 等），应用无需打成 WAR 包 。</p><ol start="3"><li>提供 starter 简化 Maven 配置</li></ol><p>Spring Boot 提供了一系列的“starter”项目对象模型（POMS）来简化 Maven 配置。</p><ol start="4"><li>提供了大量的自动配置</li></ol><p>Spring Boot 提供了大量的默认自动配置，来简化项目的开发，开发人员也通过配置文件修改默认配置。</p><ol start="5"><li>自带应用监控</li></ol><p>Spring Boot 可以对正在运行的项目提供监控。</p><ol start="6"><li>无代码生成和 xml 配置</li></ol><p>Spring Boot 不需要任何 xml 配置即可实现 Spring 的所有配置。</p><blockquote><p>SpringBoot是整合Spring技术栈的一站式框架。SpringBoot是简化Spring技术栈的快速开发脚手架</p></blockquote><h3 id="2-2-SpringBoot缺点">2.2. SpringBoot缺点</h3><ul><li>人称版本帝，迭代快，需要时刻关注变化</li><li>封装太深，内部原理复杂，不容易精通</li></ul><hr><hr><h2 id="3-SpringBoot入门案例">3. SpringBoot入门案例</h2><div class="tabs" id="af6bffe9-6ec7-427e-ab96-5aa3b94e35fb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-1"><i class="fas fa-seedling"></i>导入依赖</button></li><li class="tab"><button type="button" data-href="#af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-2"><i class="fas fa-leaf"></i>创建主程序</button></li><li class="tab"><button type="button" data-href="#af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-3"><i class="fab fa-apple"></i>编写业务</button></li><li class="tab"><button type="button" data-href="#af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-4"><i class="fas fa-tree"></i>设置配置</button></li><li class="tab"><button type="button" data-href="#af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-5"><i class="fas fa-heartbeat"></i>运行&测试</button></li><li class="tab"><button type="button" data-href="#af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-6"><i class="fas fa-cookie-bite"></i>打包部署</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-4"><p>maven工程的resource文件夹中创建application.properties文件。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties-server">更多配置信息</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-5"><ul><li>运行<code>MainApplication</code>类</li><li>浏览器输入<code>http://localhost:8888/hello</code>，将会输出<code>Hello, Spring Boot!</code>。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="af6bffe9-6ec7-427e-ab96-5aa3b94e35fb-6"><p>在pom.xml添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在IDEA的Maven插件上点击运行 clean 、package，把helloworld工程项目的打包成jar包，</p><p>打包好的jar包被生成在helloworld工程项目的target文件夹内。</p><p>用cmd运行<code>java -jar boot-01-helloworld-1.0-SNAPSHOT.jar</code>，既可以运行helloworld工程项目。</p><p>将jar包直接在目标服务器执行即可。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="4-SpringBoot依赖管理特性">4. SpringBoot依赖管理特性</h2><blockquote><p>父项目做依赖管理</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面项目的父项目如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制</p><blockquote><p>开发导入starter场景启动器</p></blockquote><ol><li>见到很多 spring-boot-starter-* ： *就某种场景</li><li>只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">更多SpringBoot所有支持的场景</a></li><li>见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</li></ol><mark class="hl-label blue">所有场景启动器最底层的依赖</mark> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>无需关注版本号，自动版本仲裁</p><ol><li>引入依赖默认都可以不写版本</li><li>引入非版本仲裁的jar，要写版本号。</li></ol></li><li><p>可以修改默认版本号</p><ol><li>查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</li><li>在当前项目里面重写配置，如下面的代码。</li></ol></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><hr><h2 id="5-SpringBoot自动配置特性">5. SpringBoot自动配置特性</h2><p>通过上面的入门案例</p><ul><li>自动配好Tomcat<ul><li>引入Tomcat依赖。</li><li>配置Tomcat</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>自动配好SpringMVC</p><ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件（功能）</li></ul></li><li><p>自动配好Web常见功能，如：字符编码问题</p><ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">    String[] names = run.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认的包结构<ul><li>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</li><li>无需以前的包扫描配置</li><li>想要改变扫描路径<ul><li>@SpringBootApplication(scanBasePackages=“com.atguigu.boot”)</li><li>@ComponentScan 指定扫描路径</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等同于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br></pre></td></tr></table></figure><ul><li>各种配置拥有默认值<ul><li>默认配置最终都是映射到某个类上，如：<code>MultipartProperties</code></li><li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li></ul></li><li>按需加载所有自动配置项<ul><li>非常多的starter</li><li>引入了哪些场景这个场景的自动配置才会开启</li><li>SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</li></ul></li><li>…</li></ul>]]></content>
    
    
    <summary type="html">为什么使用SpringBoot、SpringBoot入门案例</summary>
    
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://wuwawawa.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="https://wuwawawa.github.io/posts/ae0f95e0.html"/>
    <id>https://wuwawawa.github.io/posts/ae0f95e0.html</id>
    <published>2023-05-01T01:32:14.000Z</published>
    <updated>2023-05-16T05:27:22.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SpringMVC简介">1. SpringMVC简介</h2><h3 id="1-1-SpringMVC概述">1.1 SpringMVC概述</h3><p>SpringMVC是一个基于Spring开发的MVC轻量级框架，Spring3.0后发布的组件，SpringMVC和Spring可以无缝整合，使用<code>DispatcherServlet</code>作为前端控制器，且内部提供了<code>处理器映射器</code>、<code>处理器适配器</code>、<code>视图解析器</code>等组件，可以简化JavaBean封装，Json转化、文件上传等操作。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427101142279.png" alt="image-20230427101142279"></p><hr><h3 id="1-2-SpringMVC快速入门">1.2 SpringMVC快速入门</h3><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427101429465.png" alt="image-20230427101429465" style="zoom: 50%;" /><div class="tabs" id="7d28f7cb-0e19-432e-b68e-e2756885d4e9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7d28f7cb-0e19-432e-b68e-e2756885d4e9-1"><i class="fas fa-seedling"></i>导入坐标</button></li><li class="tab"><button type="button" data-href="#7d28f7cb-0e19-432e-b68e-e2756885d4e9-2"><i class="fas fa-leaf"></i>配置前端控制器</button></li><li class="tab"><button type="button" data-href="#7d28f7cb-0e19-432e-b68e-e2756885d4e9-3"><i class="fas fa-tree"></i>配置spring-mvc.xml</button></li><li class="tab"><button type="button" data-href="#7d28f7cb-0e19-432e-b68e-e2756885d4e9-4"><i class="fab fa-apple"></i>编写控制器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7d28f7cb-0e19-432e-b68e-e2756885d4e9-1"><p>导入Spring整合SpringMVC的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7d28f7cb-0e19-432e-b68e-e2756885d4e9-2"><p>在web.xml中配置SpringMVC的前端控制器ServletDispatcher</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定springMVC配置文件位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--服务器启动就创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7d28f7cb-0e19-432e-b68e-e2756885d4e9-3"><p>创建springMVC的核心配置文件 spring-mvc.xml，并配置组件扫描web层</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7d28f7cb-0e19-432e-b68e-e2756885d4e9-4"><p>编写一个控制器Controller，配置映射信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/show&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show 执行....&quot;</span>);</span><br><span class="line">        <span class="comment">//视图跳转到index.jsp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="1-3-Controller访问容器Bean">1.3 Controller访问容器Bean</h3><p><code>DispatcherServlet</code>在进行初始化时，加载的spring-mvc.xml配置文件创建的SpringMVC容器，那么web层Controller被扫描进入到了容器中，而之前Spring容器中的Service是否可以获取到呢？下面搭建Spring的web环境进行验证</p><div class="tabs" id="35c07813-7047-4374-96bb-22a4522e4cea"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#35c07813-7047-4374-96bb-22a4522e4cea-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#35c07813-7047-4374-96bb-22a4522e4cea-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#35c07813-7047-4374-96bb-22a4522e4cea-3"><i class="fas fa-dove"></i>3</button></li><li class="tab"><button type="button" data-href="#35c07813-7047-4374-96bb-22a4522e4cea-4"><i class="fas fa-dragon"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="35c07813-7047-4374-96bb-22a4522e4cea-1"><p>创建一个applicationContext.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描非web层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除com.itheima包下使用@Controller注解的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="35c07813-7047-4374-96bb-22a4522e4cea-2"><p>在web.xml中配置ContextLoaderListener</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置ContextLoaderListener--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applictionContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="35c07813-7047-4374-96bb-22a4522e4cea-3"><p>编写UserService和UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserServiceImpl show running ... ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="35c07813-7047-4374-96bb-22a4522e4cea-4"><p>修改UserController，从Spring容器中匹配Service进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/show&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show 执行....&quot;</span>);</span><br><span class="line">        <span class="comment">//调用userService的show方法</span></span><br><span class="line">        userService.show();</span><br><span class="line">        <span class="comment">//视图跳转到index.jsp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="1-4-SpringMVC关键组件浅析">1.4 SpringMVC关键组件浅析</h3><p>上面已经完成的快速入门的操作，也在不知不觉中完成的Spring和SpringMVC的整合，我们只需要按照规则去定义Controller和业务方法就可以。但是在这个过程中，肯定是很多核心功能类参与到其中，这些核心功能类，一般称为组件。当请求到达服务器时，是哪个组件接收的请求，是哪个组件帮我们找到的Controller，是哪个组件帮我们调用的方法，又是哪个组件最终解析的视图？</p><p><span id="jump1"></span></p><table><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">描述</th><th style="text-align:left">常用组</th></tr></thead><tbody><tr><td style="text-align:left">处理器映射器：HandlerMapping</td><td style="text-align:left">匹配映射路径对应的Handler，返回可执行的处理器链对象HandlerExecutionChain对象</td><td style="text-align:left">RequestMappingHandlerMapping</td></tr><tr><td style="text-align:left">处理器适配器：HandlerAdapter</td><td style="text-align:left">匹配HandlerExecutionChain对应的适配器进行处理器调用，返回视图模型对象</td><td style="text-align:left">RequestMappingHandlerAdapter</td></tr><tr><td style="text-align:left">视图解析器：ViewResolver</td><td style="text-align:left">对视图模型对象进行解析</td><td style="text-align:left">InternalResourceViewResolver</td></tr></tbody></table><p>先简单了解一下以上三个重要组件的关系<a href="#jump2">点击跳转↓↓↓↓</a></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427103049084.png" alt="image-20230427103049084" style="zoom:80%;" /><p>SpringMVC的默认组件，SpringMVC在前端控制器DispatcherServlet加载时，就会进行初始化操作，在进行初始化时，就会加载SpringMVC默认指定的一些组件，这些默认组件配置在<code>DispatcherServlet.properties</code>文件中，该文件存在与spring-webmvc-5.3.7.jar包下的org\springframework\web\servlet\DispatcherServlet.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.web.servlet.HandlerMapping</span>=<span class="string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.function.support.RouterFunctionMapping</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.springframework.web.servlet.HandlerAdapter</span>=<span class="string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</span></span><br><span class="line"><span class="string">org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceViewResolver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#省略其他代码</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>BeanNameUrlHandlerMapping：</li></ol><p><code>BeanNameUrlHandlerMapping</code> 是 Spring MVC 框架中最简单的处理器映射器之一，它是将请求的 URL 映射到 Spring 容器中的 Bean 名称上。当用户发送一个请求到 Spring MVC 框架时，<code>BeanNameUrlHandlerMapping</code> 会根据请求的 URL 找到对应的处理器 Bean。</p><ol start="2"><li>RequestMappingHandlerMapping：</li></ol><p><code>RequestMappingHandlerMapping</code> 是 Spring MVC 框架中常用的处理器映射器，它通过注解 <code>@RequestMapping</code> 和处理器方法的参数来确定请求的处理器。它可以将一个或多个 <code>@RequestMapping</code> 注解和一个处理器方法映射在一起，同时也支持 Ant 风格和正则表达式匹配请求路径。</p><ol start="3"><li>RouterFunctionMapping：</li></ol><p><code>RouterFunctionMapping</code> 是 Spring WebFlux 框架中的处理器映射器，它基于函数式编程模型来定义请求处理器的路由，支持 Reactive Streams 规范，可以处理大量并发请求。在 Spring WebFlux 中，我们可以使用 <code>RouterFunction</code> 来定义请求的处理路由，<code>RouterFunctionMapping</code> 会根据请求的路径和 HTTP 方法来匹配对应的 <code>RouterFunction</code>，最终返回一个匹配的处理器函数。与 Spring MVC 不同，Spring WebFlux 不需要将请求处理器映射到具体的 Java 方法上，而是可以基于函数式编程风格来实现业务逻辑。</p></blockquote><p>这些默认的组件是在<code>DispatcherServlet</code>中进行初始化加载的，在DispatcherServlet中存在集合存储着这些组件， SpringMVC的默认组件会在<code>DispatcherServlet</code>中进行维护，<span class='p red'>但是并没有存储在与SpringMVC的容器中</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line">    <span class="comment">//存储处理器映射器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">    <span class="comment">//存储处理器适配器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">    <span class="comment">//存储视图解析器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    <span class="comment">// ... 省略其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置组件代替默认组件，如果不想使用默认组件，可以将替代方案使用Spring Bean的方式进行配置，例如，在spring-mvc.xml中配置<code>RequestMappingHandlerMapping</code></p><p><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></p><p>当我们在Spring容器中配置了HandlerMapping，则就不会在加载默认的HandlerMapping策略了，原理比较简单， DispatcherServlet 在进行HandlerMapping初始化时，先从SpringMVC容器中找是否存在HandlerMapping，如果存在直接取出容器中的HandlerMapping，在存储到 DispatcherServlet 中的handlerMappings集合中去。</p><hr><hr><h2 id="2-SpringMVC的请求处理">2. SpringMVC的请求处理</h2><h3 id="2-1-请求映射路径的配置">2.1 请求映射路径的配置</h3><p>配置映射路径，映射器处理器才能找到Controller的方法资源，目前主流映射路径配置方式就是@RequestMapping</p><table><thead><tr><th style="text-align:left">相关注解</th><th style="text-align:left">作用</th><th style="text-align:left">使用位置</th></tr></thead><tbody><tr><td style="text-align:left">@RequestMapping</td><td style="text-align:left">设置控制器方法的访问资源路径，可以接收任何请求</td><td style="text-align:left">方法和类上</td></tr><tr><td style="text-align:left">@GetMapping</td><td style="text-align:left">设置控制器方法的访问资源路径，可以接收GET请求</td><td style="text-align:left">方法和类上</td></tr><tr><td style="text-align:left">@PostMapping</td><td style="text-align:left">设置控制器方法的访问资源路径，可以接收POST请求</td><td style="text-align:left">方法和类上</td></tr></tbody></table><p>@RequestMapping注解，主要使用在控制器的方法上，用于标识客户端访问资源路径，常用的属性有value、path 、method、headers、params等。当@RequestMapping只有一个访问路径需要指定时，使用value属性、path属性或省略value和path，当有多个属性时，value和path不能省略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/show&quot;)</span><span class="comment">//使用value属性指定一个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(value = &#123;&quot;/show&quot;,&quot;/haohao&quot;,&quot;/abc&quot;&#125;)</span><span class="comment">//使用value属性指定多个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/show&quot;)</span><span class="comment">//使用path属性指定一个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(path = &#123;&quot;/show&quot;,&quot;/haohao&quot;,&quot;/abc&quot;&#125;)</span><span class="comment">//使用path属性指定多个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/show&quot;)</span><span class="comment">//如果只设置访问路径时，value和path可以省略</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&#123;&quot;/show&quot;,&quot;/haohao&quot;,&quot;/abc&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当@RequestMapping 需要限定访问方式时，可以通过method属性设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求地址是/show,且请求方式必须是POST才能匹配成功</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/show&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>method的属性值是一个枚举类型，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">    GET,</span><br><span class="line">    HEAD,</span><br><span class="line">    POST,</span><br><span class="line">    PUT,</span><br><span class="line">    PATCH,</span><br><span class="line">    DELETE,</span><br><span class="line">    OPTIONS,</span><br><span class="line">    TRACE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">RequestMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@GetMapping，当请求方式是GET时，我们可以使用@GetMapping替代@RequestMapping</p><p>@PostMapping，当请求方式是POST时，我们可以使用@PostMapping替代@RequestMapping</p><p>@RequestMapping 在类上使用，@RequestMapping 、@GetMapping、@PostMapping还可以使用在Controller类上，使用在类上后，该类所有方法都公用该@RequestMapping设置的属性，访问路径则为类上的映射地址+方法上的映射地址，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/xxx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, ServletContextAware &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/aaa&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">aaa</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ModelAndViewDefiningException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的访问路径为：/xxx/aaa</p><hr><h3 id="2-2-请求数据的接收">2.2 请求数据的接收</h3><h4 id="2-2-1-普通数据接收">2.2.1 普通数据接收</h4><div class="tabs" id="ecb55e13-9f27-42be-bc95-be55bab0db3e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ecb55e13-9f27-42be-bc95-be55bab0db3e-1"><i class="fas fa-award"></i>普通请求数据</button></li><li class="tab"><button type="button" data-href="#ecb55e13-9f27-42be-bc95-be55bab0db3e-2"><i class="fas fa-baseball-ball"></i>数组或集合数据</button></li><li class="tab"><button type="button" data-href="#ecb55e13-9f27-42be-bc95-be55bab0db3e-3"><i class="fas fa-bone"></i>实体JavaBean属性数据</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ecb55e13-9f27-42be-bc95-be55bab0db3e-1"><blockquote><p>接收普通请求数据，当客户端提交的数据是普通键值对形式时，直接使用同名形参接收即可</p></blockquote><p><code>username=haohao&amp;age=35</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String username, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(username+<span class="string">&quot;==&quot;</span>+age); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接收普通请求数据，当请求参数的名称与方法参数名不一致时，可以使用@RequestParam注解进行标注</p></blockquote><p><code>username=haohao&amp;age=35</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestParam(name = &quot;username&quot;,required = true)</span> String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">&quot;==&quot;</span>+age); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ecb55e13-9f27-42be-bc95-be55bab0db3e-2"><blockquote><p>接收数组或集合数据，客户端传递多个同名参数时，可以使用数组接收</p></blockquote><p><code>hobbies=eat&amp;hobbies=sleep</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String[] hobbies)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String hobby : hobbies) &#123;</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端传递多个同名参数时，<span class='p blue'>也可以使用单列集合接收，但是需要使用@RequestParam</span>，告知框架传递的参数是要同名设置的，不是对象属性设置的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hobbies)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String hobby : hobbies) &#123;</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接收数组或集合数据，客户端传递多个不同命参数时，也可以使用Map&lt;String,Object&gt; 进行接收，同样需要用@RequestParam 进行修饰</p></blockquote><p><code>username=haohao&amp;age=18</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestParam</span> Map&lt;String,Object&gt; params)</span>&#123;</span><br><span class="line">    params.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.println(key+<span class="string">&quot;==&quot;</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ecb55e13-9f27-42be-bc95-be55bab0db3e-3"><blockquote><p>接收实体JavaBean属性数据，单个JavaBean数据：提交的参数名称只要与Java的属性名一致，就可以进行自动封装</p></blockquote><p><code>username=haohao&amp;age=35&amp;hobbies=eat&amp;hobbies=sleep</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String[] hobbies;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">//... 省略get和set方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(user); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收实体JavaBean属性数据，嵌套JavaBean数据：提交的参数名称用<code>.</code>去描述嵌套对象的属性关系即可</p><p><code>username=haohao&amp;address.city=tianjin&amp;address.area=jinghai</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h4 id="2-2-2-Json数据接收">2.2.2 Json数据接收</h4><blockquote><p>请求数据的接收接收Json数据格式数据，<span class='p blue'>Json数据都是以请求体的方式提交的</span>，且不是原始的键值对格式的，<span class='p green'>所以我们要使用@RequestBody注解整体接收该数据。</span></p></blockquote><p>开发测试时，可以使用Postman进行测试</p><div class="tabs" id="0630c36b-b8e8-4a06-a39d-4af3b9da3164"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0630c36b-b8e8-4a06-a39d-4af3b9da3164-1"><i class="fas fa-atom"></i>接收Json数据</button></li><li class="tab"><button type="button" data-href="#0630c36b-b8e8-4a06-a39d-4af3b9da3164-2"><i class="far fa-sun"></i>使用Json工具进行转换</button></li><li class="tab"><button type="button" data-href="#0630c36b-b8e8-4a06-a39d-4af3b9da3164-3"><i class="fas fa-wind"></i>配置RequestMappingHandlerAdapter</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0630c36b-b8e8-4a06-a39d-4af3b9da3164-1"><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;haohao&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;hobbies&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;eat&quot;</span><span class="punctuation">,</span><span class="string">&quot;sleep&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;birthday&quot;</span><span class="punctuation">:</span><span class="string">&quot;1986-01-01&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;tj&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span><span class="string">&quot;binhai&quot;</span></span><br><span class="line">     <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show6</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span>&#123;</span><br><span class="line">    System.out.println(body); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0630c36b-b8e8-4a06-a39d-4af3b9da3164-2"><p>使用Json工具（ jackson ）将Json格式的字符串转化为JavaBean进行操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(body);</span><br><span class="line">    <span class="comment">//获得ObjectMapper</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="comment">//将json格式字符串转化成指定的User</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(body, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0630c36b-b8e8-4a06-a39d-4af3b9da3164-3"><p>配置<code>RequestMappingHandlerAdapter</code>，指定消息转换器，就不用手动转换json格式字符串了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收Json数据格式数据，使用Map接收json格式字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestBody</span> Map map)</span>&#123;</span><br><span class="line">    System.out.println(map); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h4 id="2-2-3-接收Restful风格数据">2.2.3 接收Restful风格数据</h4><p>什么是Rest风格？<br>Rest（Representational State Transfer）表象化状态转变（表述性状态转变），在2000年被提出，基于HTTP、URI 、xml、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。是Web服务的一种新网络应用程序的设计风格和开发方式。</p><p>Restful风格的请求，常见的规则有如下三点：</p><p>用URI表示某个模块资源，资源名称为名词；</p><table><thead><tr><th style="text-align:left">模块</th><th style="text-align:left">URI资源</th></tr></thead><tbody><tr><td style="text-align:left">用户模块user</td><td style="text-align:left"><code>http://localhost/user</code></td></tr><tr><td style="text-align:left">商品模块product</td><td style="text-align:left"><code>http://localhost/product</code></td></tr><tr><td style="text-align:left">账户模块account</td><td style="text-align:left"><code>http://localhost/account</code></td></tr><tr><td style="text-align:left">日志模块log</td><td style="text-align:left"><code>http://localhost/log</code></td></tr></tbody></table><p>用请求方式表示模块具体业务动作，例如：GET表示查询、POST表示插入、PUT表示更新、DELETE表示删除</p><table><thead><tr><th style="text-align:left">URI资源</th><th style="text-align:left">请求方式</th><th style="text-align:left">参数</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>http://localhost/user/100</code></td><td style="text-align:left">GET</td><td style="text-align:left">存在URL地址中：100</td><td style="text-align:left">查询id=100的User数据</td></tr><tr><td style="text-align:left"><code>http://localhost/user</code></td><td style="text-align:left">POST</td><td style="text-align:left">存在请求体中Json：{“username”:“haohao”,“age”:18}</td><td style="text-align:left">插入User数据</td></tr><tr><td style="text-align:left"><code>http://localhost/user</code></td><td style="text-align:left">PUT</td><td style="text-align:left">存在请求体中Json：{“id”:100,“username”:“haohao”,“age”:18}</td><td style="text-align:left">修改id=100的User数据</td></tr><tr><td style="text-align:left"><code>http://localhost/user/100</code></td><td style="text-align:left">DELETE</td><td style="text-align:left">存在URL地址中：100</td><td style="text-align:left">删除id=100的User数据</td></tr><tr><td style="text-align:left"><code>http://localhost/product/5</code></td><td style="text-align:left">GET</td><td style="text-align:left">存在URL地址中：5</td><td style="text-align:left">查询id=5的Product数据</td></tr><tr><td style="text-align:left"><code>http://localhost/product</code></td><td style="text-align:left">POST</td><td style="text-align:left">存在请求体中Json：{“proName”:“小米手机”,“price”:1299}</td><td style="text-align:left">插入Product数据</td></tr><tr><td style="text-align:left"><code>http://localhost/product</code></td><td style="text-align:left">PUT</td><td style="text-align:left">存在请求体中Json：{“id”:5,“proName”:“小米手机”,“price”:1299}</td><td style="text-align:left">修改id=5的Product数据</td></tr><tr><td style="text-align:left"><code>http://localhost/product/5</code></td><td style="text-align:left">DELETE</td><td style="text-align:left">存在URL地址中：5</td><td style="text-align:left">删除id=5的Product数据</td></tr></tbody></table><p>用HTTP响应状态码表示结果，国内常用的响应包括三部分：状态码、状态信息、响应数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;haohao&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;执行错误&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接收Restful风格数据，Restful请求数据一般会在URL地址上携带，可以使用注解 @PathVariable(占位符参数名称)</p><p>不加注解会以为是前面键值对的形式。</p><p><code>http://localhost/user/100</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求URL资源地址包含多个参数情况</p><p><code>http://localhost/user/haohao/18</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user/&#123;username&#125;/&#123;age&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUserByUsernameAndAge</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span> String username,<span class="meta">@PathVariable(&quot;age&quot;)</span> Integer age)</span>&#123;</span><br><span class="line">    System.out.println(username+<span class="string">&quot;==&quot;</span>+age); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-2-4-接收文件数据">2.2.4 接收文件数据</h4><p>接收文件上传的数据，文件上传的表单需要一定的要求，如下：</p><ul><li>表单的提交方式必须是POST</li><li>表单的enctype属性必须是multipart/form-data</li><li>文件上传项需要有name属性</li></ul><div class="tabs" id="337f457c-7cf8-407b-9d5b-2b5e3ba1d172"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#337f457c-7cf8-407b-9d5b-2b5e3ba1d172-1"><i class="fas fa-bug"></i>前端</button></li><li class="tab"><button type="button" data-href="#337f457c-7cf8-407b-9d5b-2b5e3ba1d172-2"><i class="fas fa-cannabis"></i>服务器端配置</button></li><li class="tab"><button type="button" data-href="#337f457c-7cf8-407b-9d5b-2b5e3ba1d172-3"><i class="fas fa-candy-cane"></i>接收代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="337f457c-7cf8-407b-9d5b-2b5e3ba1d172-1"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="337f457c-7cf8-407b-9d5b-2b5e3ba1d172-2"><p>服务器端，由于映射器适配器需要文件上传解析器，而该解析器默认未被注册，所以手动注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置文件上传解析器，注意：id的名字是固定写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span><span class="comment">&lt;!--文件的编码格式 默认是ISO8859-1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1048576&quot;</span>/&gt;</span><span class="comment">&lt;!--上传的每个文件限制的大小 单位字节--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3145728&quot;</span>/&gt;</span><span class="comment">&lt;!--上传文件的总大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1048576&quot;</span>/&gt;</span><span class="comment">&lt;!--上传文件的缓存大小--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而CommonsMultipartResolver底层使用的Apache的是Common-fileuplad等工具API进行的文件上传</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="337f457c-7cf8-407b-9d5b-2b5e3ba1d172-3"><p>使用MultipartFile类型接收上传文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/fileUpload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">fileUpload</span><span class="params">(<span class="meta">@RequestBody</span> MultipartFile myFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(myFile);</span><br><span class="line">    <span class="comment">//获得上传的文件的流对象</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> myFile.getInputStream(); <span class="comment">//使用commons-io存储到C:\haohao\abc.txt位置</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\haohao\\&quot;</span>+myFile.getOriginalFilename());</span><br><span class="line">    IOUtils.copy(inputStream,outputStream);</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    inputStream.close();</span><br><span class="line">    outputStream.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="2-2-5-接收请求头数据">2.2.5 接收请求头数据</h4><p>接收Http请求头数据，接收指定名称的请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/headers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headers</span><span class="params">(<span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String acceptEncoding)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Accept-Encoding:&quot;</span>+acceptEncoding); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收所有的请求头信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/headersMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headersMap</span><span class="params">(<span class="meta">@RequestHeader</span> Map&lt;String,String&gt; map)</span>&#123;</span><br><span class="line">    map.forEach((k,v)-&gt;&#123;</span><br><span class="line">        System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-2-6-接收Cookie信息">2.2.6 接收Cookie信息</h4><p>获得客户端携带的Cookie数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/cookies&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cookies</span><span class="params">(<span class="meta">@CookieValue(value = &quot;JSESSIONID&quot;,defaultValue = &quot;&quot;)</span> String jsessionid)</span>&#123;</span><br><span class="line">    System.out.println(jsessionid); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-2-7-接收Request域信息">2.2.7 接收Request域信息</h4><p>获得转发Request域中数据，在进行资源之间转发时，有时需要将一些参数存储到request域中携带给下一个资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/request1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request1</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="comment">//存储数据</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;haohao&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/request2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/request2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request2</span><span class="params">(<span class="meta">@RequestAttribute(&quot;username&quot;)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(username); </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-2-8-请求参数乱码的解决方案">2.2.8 请求参数乱码的解决方案</h4><p>请求参数乱码的解决方案，Spring已经提供好的CharacterEncodingFilter来进行编码过滤</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置全局的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-3-Javaweb常用对象获取">2.3 Javaweb常用对象获取</h3><p>获得Javaweb常见原生对象，有时在我们的Controller方法中需要用到Javaweb的原生对象，例如：Request、 Response等，我们只需要将需要的对象以形参的形式写在方法上，SpringMVC框架在调用Controller方法时，会自动传递实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/javawebObject&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">javawebObject</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpSession session)</span>&#123;</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-4-请求静态资源">2.4 请求静态资源</h3><p>静态资源请求失效的原因，当DispatcherServlet的映射路径配置为 / 的时候，那么就覆盖的Tomcat容器默认的缺省Servlet，在Tomcat的config目录下有一个web.xml 是对所有的web项目的全局配置，其中有如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>url-pattern配置为 / 的Servlet我们称其为缺省的Servlet，作用是当其他Servlet都匹配不成功时，就找缺省的Servlet ，静态资源由于没有匹配成功的Servlet，所以会找缺省的DefaultServlet，该DefaultServlet具备二次去匹配静态资源的功能。但是我们配置DispatcherServlet后就将其覆盖掉了，而DispatcherServlet会将请求的静态资源的名称当成Controller的映射路径去匹配，即静态资源访问不成功了！</p><mark class="hl-label blue">静态资源请求的三种解决方案</mark> <div class="tabs" id="d96bf84b-004a-4603-b9eb-da53a7fe2732"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d96bf84b-004a-4603-b9eb-da53a7fe2732-1"><i class="fas fa-candy-cane"></i>1</button></li><li class="tab"><button type="button" data-href="#d96bf84b-004a-4603-b9eb-da53a7fe2732-2"><i class="fas fa-child"></i>2</button></li><li class="tab"><button type="button" data-href="#d96bf84b-004a-4603-b9eb-da53a7fe2732-3"><i class="fas fa-cookie-bite"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d96bf84b-004a-4603-b9eb-da53a7fe2732-1"><p>第一种方案，可以再次激活Tomcat的DefaultServlet，Servlet的url-pattern的匹配优先级是：精确匹配&gt;目录匹配&gt;扩展名匹配&gt;缺省匹配，所以可以指定某个目录下或某个扩展名的资源使用DefaultServlet进行解析：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d96bf84b-004a-4603-b9eb-da53a7fe2732-2"><p>第二种方式，在spring-mvc.xml中去配置静态资源映射，匹配映射路径的请求到指定的位置去匹配资源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapping是映射资源路径，location是对应资源所在的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/html/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/html/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d96bf84b-004a-4603-b9eb-da53a7fe2732-3"><p>第三种方式，在spring-mvc.xml中去配置&lt; mvc:default-servlet-handler &gt;，该方式是注册了一个DefaultServletHttpRequestHandler 处理器，静态资源的访问都由该处理器去处理，这也是开发中使用最多的</p><p><code>&lt;mvc:default-servlet-handler/&gt;</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="2-5-注解驱动标签">2.5 注解驱动标签</h3><p>静态资源配置的第二第三种方式我们可以正常访问静态资源了，但是Controller又无法访问了，报错404，即找不到对应的资源</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427115829513.png" alt="image-20230427115829513"></p><p>第二种方式是通过SpringMVC去解析mvc命名空间下的resources标签完成的静态资源解析。</p><p>第三种方式式通过SpringMVC去解析mvc命名空间下的default-servlet-handler标签完成的静态资源解析，根据前面所学习的自定义命名空间的解析的知识，可以发现不管是以上哪种方式，最终都会注册SimpleUrlHandlerMapping</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext context)</span> &#123;</span><br><span class="line">    <span class="comment">//创建SimpleUrlHandlerMapping类型的BeanDefinition</span></span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">handlerMappingDef</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(SimpleUrlHandlerMapping.class);</span><br><span class="line">    <span class="comment">//注册SimpleUrlHandlerMapping的BeanDefinition</span></span><br><span class="line">    context.getRegistry().registerBeanDefinition(beanName, handlerMappingDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又结合组件浅析知识点，一旦SpringMVC容器中存在 HandlerMapping 类型的组件时，前端控制器DispatcherServlet在进行初始化时，就会从容器中获得HandlerMapping ，不在加载 dispatcherServlet.properties中默认处理器映射器策略，那也就意味着RequestMappingHandlerMapping不会被加载到了。</p><mark class="hl-label green">解决方法</mark> <p>手动将RequestMappingHandlerMapping也注册到SpringMVC容器中就可以了，这样DispatcherServlet在进行初始化时，就会从容器中同时获得RequestMappingHandlerMapping存储到DispatcherServlet中名为handlerMappings的List集合中，对@RequestMapping 注解进行解析。</p><p><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></p><p>根据上面的讲解，可以总结一下，要想使用@RequestMapping正常映射到资源方法，同时静态资源还能正常访问，还可以将请求json格式字符串和JavaBean之间自由转换，我们就需要在spring-mvc.xml中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示配置RequestMappingHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 显示配置RequestMappingHandlerAdapter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这么复杂繁琐的配置，是不是看上去有点头大？Spring是个&quot;暖男&quot;，将上述配置浓缩成了一个简单的配置标签，那就是mvc的注解驱动，该标签内部会帮我们注册RequestMappingHandlerMapping、注册RequestMappingHandlerAdapter并注入Json消息转换器等，上述配置就可以简化成如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>PS：<code>&lt;mvc:annotation-driven&gt;</code>标签在不同的版本中，帮我们注册的组件不同，Spring 3.0.X 版本注册是DefaultAnnotationHandlerMapping 和 AnnotationMethodHandlerAdapter，由于框架的发展，从Spring 3.1.X 开始注册组件变为 RequestMappingHandlerMapping和RequestMappingHandlerAdapter</p><hr><hr><h2 id="3-SpringMVC的响应处理">3. SpringMVC的响应处理</h2><p>Spring的接收请求的部分我们讲完了，下面在看一下Spring怎么给客户端响应数据，响应数据主要分为两大部分：</p><ul><li>传统同步方式：准备好模型数据，在跳转到执行页面进行展示，此方式使用越来越少了，基于历史原因，一些旧项目还在使用；</li><li>前后端分离异步方式：前端使用Ajax技术+Restful风格与服务端进行Json格式为主的数据交互，目前市场上几乎都是此种方式了。</li></ul><hr><h3 id="3-1-传统同步业务数据响应">3.1 传统同步业务数据响应</h3><p>传统同步业务在数据响应时，SpringMVC又涉及如下四种形式：</p><ul><li>请求资源转发；</li><li>请求资源重定向；</li><li>响应模型数据；</li><li>直接回写数据给客户端；</li></ul><div class="tabs" id="1b606fda-ba79-4ab2-a97d-bf3bdc7032b8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1b606fda-ba79-4ab2-a97d-bf3bdc7032b8-1"><i class="fas fa-seedling"></i>请求资源转发</button></li><li class="tab"><button type="button" data-href="#1b606fda-ba79-4ab2-a97d-bf3bdc7032b8-2"><i class="fas fa-leaf"></i>请求资源重定向</button></li><li class="tab"><button type="button" data-href="#1b606fda-ba79-4ab2-a97d-bf3bdc7032b8-3"><i class="fab fa-apple"></i>响应模型数据</button></li><li class="tab"><button type="button" data-href="#1b606fda-ba79-4ab2-a97d-bf3bdc7032b8-4"><i class="fas fa-tree"></i>直接回写数据给客户端</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1b606fda-ba79-4ab2-a97d-bf3bdc7032b8-1"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427130024927.png" alt="image-20230427130024927"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1b606fda-ba79-4ab2-a97d-bf3bdc7032b8-2"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427130126669.png" alt="image-20230427130126669"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1b606fda-ba79-4ab2-a97d-bf3bdc7032b8-3"><p>响应模型数据，响应模型数据本质也是转发，在转发时可以准备模型数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/forward5&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">forward5</span><span class="params">(ModelAndView modelAndView)</span>&#123;</span><br><span class="line">    <span class="comment">//准备JavaBean模型数据</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;haohao&quot;</span>);</span><br><span class="line">    <span class="comment">//设置模型</span></span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line">    <span class="comment">//设置视图</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1b606fda-ba79-4ab2-a97d-bf3bdc7032b8-4"><p>直接回写数据，直接通过方法的返回值返回给客户端的字符串，但是SpringMVC默认的方法返回值是视图，可以通过@ResponseBody 注解显示的告知此处的返回值不要进行视图处理，是要以响应体的方式处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/response2&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">response2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello haohao!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="3-2-前后端分离异步业务数据响应">3.2 前后端分离异步业务数据响应</h3><p>其实此处的回写数据，跟上面回写数据给客户端的语法方式一样，只不过有如下一些区别：</p><ul><li>同步方式回写数据，是将数据响应给浏览器进行页面展示的，而异步方式回写数据一般是回写给Ajax引擎的，即谁访问服务器端，服务器端就将数据响应给谁</li><li>同步方式回写的数据，一般就是一些无特定格式的字符串，而异步方式回写的数据大多是Json格式字符串</li></ul><p>回写普通数据使用@ResponseBody标注方法，直接返回字符串即可，此处不在说明；</p><div class="tabs" id="ab67edd5-269d-496f-bff8-15db18faca6b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ab67edd5-269d-496f-bff8-15db18faca6b-1"><i class="fas fa-cat"></i>回写Json格式的字符串</button></li><li class="tab"><button type="button" data-href="#ab67edd5-269d-496f-bff8-15db18faca6b-2"><i class="fas fa-horse"></i>回写JavaBean</button></li><li class="tab"><button type="button" data-href="#ab67edd5-269d-496f-bff8-15db18faca6b-3"><i class="fas fa-dove"></i>ResponseBody注解使用优化</button></li><li class="tab"><button type="button" data-href="#ab67edd5-269d-496f-bff8-15db18faca6b-4"><i class="fas fa-dragon"></i>RestController注解进一步优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ab67edd5-269d-496f-bff8-15db18faca6b-1"><p>回写Json格式的字符串，即将直接拼接Json格式的字符串或使用工具将JavaBean转换成Json格式的字符串回写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/response3&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">response3</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;haohao\&quot;,\&quot;age\&quot;:18&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/response4&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">response4</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">//创建JavaBean</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;haohao&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="comment">//使用Jackson转换成json格式的字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(user); </span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab67edd5-269d-496f-bff8-15db18faca6b-2"><p>在讲解SringMVC接收请求数据时，客户端提交的Json格式的字符串，也是使用Jackson进行的手动转换成JavaBean ，可以当我们使用了@RequestBody时，直接用JavaBean就接收了Json格式的数据，原理其实就是SpringMVC底层帮我们做了转换，此处@ResponseBody也可以将JavaBean自动给我们转换成Json格式字符串回响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/response5&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">response5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建JavaBean</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); user.setUsername(<span class="string">&quot;haohao&quot;</span>); </span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="comment">//直接返回User对象</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab67edd5-269d-496f-bff8-15db18faca6b-3"><p>@ResponseBody注解使用优化，在进行前后端分离开发时，Controller的每个方法都是直接回写数据的，所以每个方法上都得写@ResponseBody，<span class='p blue'>可以将@ResponseBody写到Controller上</span>，那么该Controller中的所有方法都具备了返回响应体数据的功能了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/response7&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">response7</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/response5&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">response5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略其他方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab67edd5-269d-496f-bff8-15db18faca6b-4"><p><span class='p green'>进一步优化，可以使用@RestController替代@Controller和@ResponseBody，@RestController内部具备的这两个注解的功能</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/response7&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">response7</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/response5&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">response5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略其他方法 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="4-SpringMVC的拦截器">4. SpringMVC的拦截器</h2><h3 id="4-1-拦截器-Interceptor-简介">4.1 拦截器 Interceptor 简介</h3><p>SpringMVC的拦截器Interceptor规范，主要是对Controller资源访问时进行拦截操作的技术，当然拦截后可以进行权限控制，功能增强等都是可以的。拦截器有点类似 Javaweb 开发中的Filter，Interceptor与Filter的区别如下图：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230428215535084.png" alt="image-20230428215535084" style="zoom:67%;" /><p>由上图，对<code>Filter</code>和<code>Interceptor</code>做个对比：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Filter技术</th><th style="text-align:left">Interceptor技术</th></tr></thead><tbody><tr><td style="text-align:left">技术范畴</td><td style="text-align:left">Javaweb原生技术</td><td style="text-align:left">SpringMVC框架技术</td></tr><tr><td style="text-align:left">拦截/过滤资源</td><td style="text-align:left">可以对所有请求都过滤，包括任何Servlet、Jsp、其他资源等</td><td style="text-align:left">只对进入了SpringMVC管辖范围的才拦截，主要拦截Controller请求</td></tr><tr><td style="text-align:left">执行时机</td><td style="text-align:left">早于任何Servlet执行</td><td style="text-align:left">晚于DispatcherServlet执行</td></tr></tbody></table><span class='p blue'>实现了HandlerInterceptor接口，且被Spring管理的Bean都是拦截器</span><p>接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerInterceptor接口方法的作用及其参数、返回值详解如下：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">作用</th><th style="text-align:left">参数</th><th style="text-align:left">返回值</th></tr></thead><tbody><tr><td style="text-align:left">preHandle</td><td style="text-align:left">对拦截到的请求进行预处理，返回true放行执行处理器方法，false不放行</td><td style="text-align:left">Handler是拦截到的Controller方法处理器</td><td style="text-align:left">一旦返回false，代表终止向后执行，所有后置方法都不执行，最终方法只执行对应preHandle返回了true的</td></tr><tr><td style="text-align:left">postHandle</td><td style="text-align:left">在处理器的方法执行后，对拦截到的请求进行后处理，可以在方法中对模型数据和视图进行修改</td><td style="text-align:left">Handler是拦截到的Controller方法处理器；modelAndView是返回的模型视图对象</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left">afterCompletion</td><td style="text-align:left">视图渲染完成后(整个流程结束之后)，进行最后的处理，如果请求流程中有异常，可以处理异常对象</td><td style="text-align:left">Handler是拦截到的Controller方法处理器；ex是异常对象</td><td style="text-align:left">无</td></tr></tbody></table><hr><h3 id="4-2-拦截器快速入门">4.2 拦截器快速入门</h3><div class="tabs" id="177b295e-598d-472a-ab76-335a04e1c870"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#177b295e-598d-472a-ab76-335a04e1c870-1"><i class="fas fa-heartbeat"></i>编写MyInterceptor01实现HandlerInterceptor接口</button></li><li class="tab"><button type="button" data-href="#177b295e-598d-472a-ab76-335a04e1c870-2"><i class="fas fa-cookie-bite"></i>配置Interceptor</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="177b295e-598d-472a-ab76-335a04e1c870-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor01</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller方法执行之前...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller方法执行之后...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;渲染视图结束，整个流程完毕...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="177b295e-598d-472a-ab76-335a04e1c870-2"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptors.MyInterceptor1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="4-3-拦截器执行顺序">4.3 拦截器执行顺序</h3><p>拦截器三个方法的执行顺序<br>当每个拦截器都是放行状态时，三个方法的执行顺序如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230428221116031.png" alt="image-20230428221116031" style="zoom:67%;" /><p>当Interceptor1和Interceptor2处于放行，Interceptor3处于不放行时，三个方法的执行顺序如下：</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230428221434011.png" alt="image-20230428221434011" style="zoom:67%;" /><p>拦截器执行顺序取决于 interceptor 的配置顺序</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/target&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><span id="jump2"></span></p><hr><h3 id="4-4-拦截器执行原理">4.4 拦截器执行原理</h3><p><a href="#jump1">点击跳转↑↑↑↑</a></p><div class="tabs" id="73c56bbf-a064-4950-b013-efd9d1f432e7"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#73c56bbf-a064-4950-b013-efd9d1f432e7-1"><i class="fas fa-atom"></i>1</button></li><li class="tab"><button type="button" data-href="#73c56bbf-a064-4950-b013-efd9d1f432e7-2"><i class="far fa-sun"></i>2</button></li><li class="tab"><button type="button" data-href="#73c56bbf-a064-4950-b013-efd9d1f432e7-3"><i class="fas fa-wind"></i>3</button></li><li class="tab"><button type="button" data-href="#73c56bbf-a064-4950-b013-efd9d1f432e7-4"><i class="fas fa-fire-alt"></i>4</button></li><li class="tab"><button type="button" data-href="#73c56bbf-a064-4950-b013-efd9d1f432e7-5"><i class="fas fa-cookie-bite"></i>5</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="73c56bbf-a064-4950-b013-efd9d1f432e7-1"><p>请求到来时先会使用组件<code>HandlerMapping</code>去匹配Controller的方法（Handler）和符合拦截路径的Interceptor， Handler和多个Interceptor被封装成一个<code>HandlerExecutionChain</code>的对象<code>HandlerExecutionChain</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line">    <span class="comment">//映射的Controller的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line">    <span class="comment">//当前Handler匹配的拦截器集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line">    <span class="comment">// ... 省略其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="73c56bbf-a064-4950-b013-efd9d1f432e7-2"><p>在DispatcherServlet的doDispatch方法中执行拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">//根据请求信息获得HandlerExecutionChain</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandler(request);</span><br><span class="line">    <span class="comment">//获得处理器适配器</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">//执行Interceptor的前置方法，前置方法如果返回false，则该流程结束</span></span><br><span class="line">    <span class="keyword">if</span> (!mappedHandler.applyPreHandle(request, response)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行handler，一般是HandlerMethod</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">//执行后置方法</span></span><br><span class="line">    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    <span class="comment">//执行最终方法</span></span><br><span class="line">    <span class="built_in">this</span>.triggerAfterCompletion(processedRequest, response, mappedHandler, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="73c56bbf-a064-4950-b013-efd9d1f432e7-3"><p>跟踪 HandlerExecutionChain的applyPreHandle方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//对interceptorList进行遍历,正向遍历,与此同时使用interceptorIndex进行计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.interceptorList.size(); <span class="built_in">this</span>.interceptorIndex = i++) &#123;</span><br><span class="line">        <span class="comment">//取出每一个Interceptor对象</span></span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> (HandlerInterceptor)<span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        <span class="comment">//调用Interceptor的preHandle方法，如果返回false，则直接执行Interceptor的最终方法</span></span><br><span class="line">        <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">            <span class="comment">//执行Interceptor的最终方法</span></span><br><span class="line">            <span class="built_in">this</span>.triggerAfterCompletion(request, response, (Exception)<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="73c56bbf-a064-4950-b013-efd9d1f432e7-4"><p>跟踪 HandlerExecutionChain的applyPostHandle方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> ModelAndView mv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//对interceptorList进行遍历，逆向遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//取出每一个Interceptor</span></span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> (HandlerInterceptor)<span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        <span class="comment">//执行Interceptor的postHandle方法</span></span><br><span class="line">        interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="73c56bbf-a064-4950-b013-efd9d1f432e7-5"><p>跟踪HandlerExecutionChain的triggerAfterCompletion方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> Exception ex)</span> &#123;</span><br><span class="line">    <span class="comment">//逆向遍历interceptorList，遍历的个数为执行的applyPreHandle次数-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">//取出每一个Interceptor</span></span><br><span class="line">        <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> (HandlerInterceptor)<span class="built_in">this</span>.interceptorList.get(i);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行Interceptor的afterCompletion方法</span></span><br><span class="line">            interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230428221714196.png" alt="image-20230428221714196" style="zoom:67%;" /><hr><hr><h2 id="5-SpringMVC的全注解开发">5. SpringMVC的全注解开发</h2><h3 id="5-1-消除spring-mvc-xml组件">5.1 消除spring-mvc.xml组件</h3><div class="tabs" id="15e4bd8b-7d33-4da6-bec9-4983cdcf9b98"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-1"><i class="fas fa-cat"></i>1</button></li><li class="tab"><button type="button" data-href="#15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-2"><i class="fas fa-horse"></i>2</button></li><li class="tab"><button type="button" data-href="#15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-3"><i class="fas fa-dove"></i>3</button></li><li class="tab"><button type="button" data-href="#15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-4"><i class="fas fa-dragon"></i>4</button></li><li class="tab"><button type="button" data-href="#15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-5"><i class="fas fa-heartbeat"></i>5</button></li><li class="tab"><button type="button" data-href="#15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-6"><i class="fas fa-cookie-bite"></i>6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-1"><p>跟之前全注解开发思路一致， xml配置文件使用核心配置类替代，xml中的标签使用对应的注解替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描web层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置文件上传解析器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-2"><ul><li>组件扫描，可以通过@ComponentScan注解完成；</li><li>文件上传解析器multipartResolver可以通过非自定义Bean的注解配置方式，即@Bean注解完成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CommonsMultipartResolver</span> <span class="variable">multipartResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">        multipartResolver.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        multipartResolver.setMaxUploadSize(<span class="number">5000000</span>);</span><br><span class="line">        <span class="keyword">return</span> multipartResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-3"><p><code>&lt;mvc:annotation-driven&gt;</code>、<code>&lt;mvc:default-servlet-handler /&gt;</code> 和 <code>&lt;mvc:interceptor &gt; </code>怎么办呢？SpringMVC 提供了一个注解<code>@EnableWebMvc</code>，我们看一下源码，内部通过@Import 导入了<code>DelegatingWebMvcConfiguration</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WebMvcConfigurerComposite</span> <span class="variable">configurers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurerComposite</span>();</span><br><span class="line">    <span class="comment">//从容器中注入WebMvcConfigurer类型的Bean</span></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebMvcConfigurer类型的Bean会被注入进来，然后被自动调用。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-4"><p>所以可以实现WebMvcConfigurer接口，完成一些解析器、默认Servlet等的指定，WebMvcConfigurer接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//配置默认Servet处理器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//添加拦截器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//添加资源处理器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//添加视图控制器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//配置视图解析器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//添加参数解析器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">//... 省略其他代码 ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-5"><p>创建MyWebMvcConfigurer实现WebMvcConfigurer接口，实现addInterceptors 和configureDefaultServletHandling方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        <span class="comment">//开启默认的Servlet处理器，可以处理静态资源了</span></span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//添加一个拦截器，并配置拦截路径</span></span><br><span class="line">        <span class="comment">//Interceptor的执行顺序也取决于添加顺序</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor1</span>()).addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="15e4bd8b-7d33-4da6-bec9-4983cdcf9b98-6"><p>最后，在SpringMVC核心配置类上添加@EnableWebMvc注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.controller&quot;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CommonsMultipartResolver</span> <span class="variable">multipartResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">        multipartResolver.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        multipartResolver.setMaxUploadSize(<span class="number">5000000</span>);</span><br><span class="line">        <span class="keyword">return</span> multipartResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="5-2-DispatcherServlet配置类">5.2 DispatcherServlet配置类</h3><div class="tabs" id="8be97b62-9b86-45b2-aa60-c48a9fd18aeb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8be97b62-9b86-45b2-aa60-c48a9fd18aeb-1"><i class="fas fa-cat"></i>xml配置</button></li><li class="tab"><button type="button" data-href="#8be97b62-9b86-45b2-aa60-c48a9fd18aeb-2"><i class="fas fa-horse"></i>注解配置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8be97b62-9b86-45b2-aa60-c48a9fd18aeb-1"><p>DispatcherServlet在进行SpringMVC配置文件加载时，使用的是以下方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定springMVC配置文件位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--服务器启动就创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8be97b62-9b86-45b2-aa60-c48a9fd18aeb-2"><p>现在是使用SpringMVCConfig核心配置类提替代的spring-mvc.xml，怎么加载呢？参照Spring的ContextLoaderListener加载核心配置类的做法，定义了一个AnnotationConfigWebApplicationContext，通过代码注册核心配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationConfigWebApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AnnotationConfigWebApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAnnotationConfigWebApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//注册核心配置类</span></span><br><span class="line">        <span class="built_in">super</span>.register(SpringMVCConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定springMVC的applicationContext全限定名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itheima.config.MyAnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="5-3-消除web-xml">5.3 消除web.xml</h3><div class="tabs" id="9213ea2e-edef-4166-931e-30d4de02cc8d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#9213ea2e-edef-4166-931e-30d4de02cc8d-1"><i class="fas fa-award"></i>web.xml</button></li><li class="tab"><button type="button" data-href="#9213ea2e-edef-4166-931e-30d4de02cc8d-2"><i class="fas fa-baseball-ball"></i>解决思路</button></li><li class="tab"><button type="button" data-href="#9213ea2e-edef-4166-931e-30d4de02cc8d-3"><i class="fas fa-bone"></i>注解配置</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="9213ea2e-edef-4166-931e-30d4de02cc8d-1"><p>目前，几乎消除了配置文件，但是web工程的入口还是使用的web.xml进行配置的，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC前端控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--指定springMVC的applicationContext全限定名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itheima.config.MyAnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--服务器启动就创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9213ea2e-edef-4166-931e-30d4de02cc8d-2"><ul><li>Servlet3.0环境中，web容器提供了javax.servlet.ServletContainerInitializer接口，实现了该接口后，在对应的类加载路径的META-INF/services 目录创建一个名为javax.servlet.ServletContainerInitializer的文件，文件内容指定具体的ServletContainerInitializer实现类，那么，当web容器启动时就会运行这个初始化器做一些组件内的初始化工作；</li><li>基于这个特性，Spring就定义了一个SpringServletContainerInitializer实现了ServletContainerInitializer接口;</li><li>而SpringServletContainerInitializer会查找实现了WebApplicationInitializer的类，Spring又提供了一个WebApplicationInitializer的基础实现类AbstractAnnotationConfigDispatcherServletInitializer，当我们编写类继承AbstractAnnotationConfigDispatcherServletInitializer时，容器就会自动发现我们自己的类，在该类中我们就可以配置Spring和SpringMVC的入口了。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9213ea2e-edef-4166-931e-30d4de02cc8d-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationConfigDispatcherServletInitializer</span> <span class="keyword">extends</span></span><br><span class="line">        <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//提供Spring容器核心配置类</span></span><br><span class="line">    <span class="comment">//返回的带有@Configuration注解的类用来配置ContextLoaderListener</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载核心配置类创建ContextLoaderListener&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ApplicationContextConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供SpringMVC容器核心配置类</span></span><br><span class="line">    <span class="comment">//返回的带有@Configuration注解的类用来配置DispatcherServlet</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载核心配置类创建DispatcherServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMVCConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供前端控制器的映射路径</span></span><br><span class="line">    <span class="comment">//将一个或多个路径映射到DispatcherServlet上</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><hr><h2 id="6-SpringMVC的组件原理剖析">6. SpringMVC的组件原理剖析</h2><h3 id="6-1-前端控制器初始化">6.1 前端控制器初始化</h3><p>前端控制器DispatcherServlet是SpringMVC的入口，也是SpringMVC的大脑，主流程的工作都是在此完成的，梳理一下DispatcherServlet 代码。DispatcherServlet 本质是个Servlet，当配置了 load-on-startup 时，会在服务器启动时就执行创建和执行初始化init方法，每次请求都会执行service方法。<br>DispatcherServlet的初始化主要做了两件事：</p><ul><li><p>获得了一个 SpringMVC 的ApplicationContext容器；</p></li><li><p>注册了 SpringMVC的九大组件。</p></li></ul><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/DispatcherServlet1.png" alt="DispatcherServlet1" style="zoom:67%;" /><div class="tabs" id="ca3a4e03-2303-45ae-916c-f64e2a303cdc"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ca3a4e03-2303-45ae-916c-f64e2a303cdc-1"><i class="fas fa-bug"></i>1</button></li><li class="tab"><button type="button" data-href="#ca3a4e03-2303-45ae-916c-f64e2a303cdc-2"><i class="fas fa-cannabis"></i>2</button></li><li class="tab"><button type="button" data-href="#ca3a4e03-2303-45ae-916c-f64e2a303cdc-3"><i class="fas fa-candy-cane"></i>3</button></li><li class="tab"><button type="button" data-href="#ca3a4e03-2303-45ae-916c-f64e2a303cdc-4"><i class="fas fa-child"></i>4</button></li><li class="tab"><button type="button" data-href="#ca3a4e03-2303-45ae-916c-f64e2a303cdc-5"><i class="fas fa-heartbeat"></i>5</button></li><li class="tab"><button type="button" data-href="#ca3a4e03-2303-45ae-916c-f64e2a303cdc-6"><i class="fas fa-cookie-bite"></i>6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ca3a4e03-2303-45ae-916c-f64e2a303cdc-1"><p>SpringMVC 的ApplicationContext容器创建时机，Servlet 规范的 init(ServletConfig config) 方法经过子类重写 ，最终会调用 FrameworkServlet 抽象类的initWebApplicationContext() 方法，该方法中最终获得 一个根Spring容器（Spring产生的），一个子Spring容器（SpringMVC产生的）</p><p>HttpServletBean 的初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameworkServlet的initServletBean方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.webApplicationContext = <span class="built_in">this</span>.initWebApplicationContext();<span class="comment">//初始化ApplicationContext </span></span><br><span class="line">    <span class="built_in">this</span>.initFrameworkServlet();<span class="comment">//模板设计模式，供子类覆盖实现，但是子类DispatcherServlet没做使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca3a4e03-2303-45ae-916c-f64e2a303cdc-2"><p>在initWebApplicationContext方法中体现的父子容器的逻辑关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//初始化ApplicationContext是一个及其关键的代码</span></span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获得根容器，其实就是通过ContextLoaderListener创建的ApplicationContext</span></span><br><span class="line">    <span class="comment">//如果配置了ContextLoaderListener则获得根容器，没配置获得的是null</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">            WebApplicationContextUtils.getWebApplicationContext(<span class="built_in">this</span>.getServletContext());</span><br><span class="line">    <span class="comment">//定义SpringMVC产生的ApplicationContext子容器</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//==&gt;创建SpringMVC的子容器，创建同时将Spring的创建的rootContext传递了过去</span></span><br><span class="line">        wac = <span class="built_in">this</span>.createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将SpringMVC产生的ApplicationContext子容器存储到ServletContext域中</span></span><br><span class="line">    <span class="comment">//key名是：org.springframework.web.servlet.FrameworkServlet.CONTEXT.DispatcherServlet</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContextAttributeName();</span><br><span class="line">        <span class="built_in">this</span>.getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca3a4e03-2303-45ae-916c-f64e2a303cdc-3"><p>跟进创建子容器的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="comment">//实例化子容器ApplicationContext</span></span><br><span class="line">    <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">    <span class="comment">//设置传递过来的ContextLoaderListener的rootContext为父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="comment">//获得web.xml配置的classpath:spring-mvc.xml</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> <span class="built_in">this</span>.getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//为子容器设置配置加载路径</span></span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化子容器(就是加载spring-mvc.xml配置的Bean)</span></span><br><span class="line">    <span class="built_in">this</span>.configureAndRefreshWebApplicationContext(wac);</span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca3a4e03-2303-45ae-916c-f64e2a303cdc-4"><p>子容器中的parent维护着父容器的引用</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427153645421.png" alt="image-20230427153645421"></p><p>父容器和子容器概念和关系：</p><ul><li>父容器：Spring 通过ContextLoaderListener为入口产生的applicationContext容器，内部主要维护的是applicationContext.xml（或相应配置类）配置的Bean信息；</li><li>子容器：SpringMVC通过DispatcherServlet的init() 方法产生的applicationContext容器，内部主要维护的是spring-mvc.xml（或相应配置类）配置的Bean信息，且内部还通过parent属性维护这父容器的引用。</li><li>Bean的检索顺序：根据上面子父容器的概念，可以知道Controller存在与子容器中，而Controller中要注入Service时，会先从子容器本身去匹配，匹配不成功时在去父容器中去匹配，于是最终从父容器中匹配到的UserService，这样子父容器就可以进行联通了。但是父容器只能从自己容器中进行匹配，不能从子容器中进行匹配。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca3a4e03-2303-45ae-916c-f64e2a303cdc-5"><p>注册 SpringMVC的 九大组件，在初始化容器initWebApplicationContext方法中执行了onRefresh方法，进而执行了初始化策略initStrategies方法，注册了九个解析器组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DispatcherServlet初始化SpringMVC九大组件</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initMultipartResolver(context);<span class="comment">//1、初始化文件上传解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initLocaleResolver(context);<span class="comment">//2、初始化国际化解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initThemeResolver(context);<span class="comment">//3、初始化模板解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initHandlerMappings(context);<span class="comment">//4、初始化处理器映射器</span></span><br><span class="line">    <span class="built_in">this</span>.initHandlerAdapters(context);<span class="comment">//5、初始化处理器适配器</span></span><br><span class="line">    <span class="built_in">this</span>.initHandlerExceptionResolvers(context);<span class="comment">//6、初始化处理器异常解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initRequestToViewNameTranslator(context);<span class="comment">//7、初始化请求视图转换器</span></span><br><span class="line">    <span class="built_in">this</span>.initViewResolvers(context);<span class="comment">//8、初始化视图解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initFlashMapManager(context);<span class="comment">//9、初始化lashMapManager策略组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ca3a4e03-2303-45ae-916c-f64e2a303cdc-6"><p>以 this.initHandlerMappings(context) 为例，进一步看一下初始化处理器映射器的细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义List容器存储HandlerMapping</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line"><span class="comment">//初始化HandlerMapping的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;<span class="comment">//初始化集合为null</span></span><br><span class="line">    <span class="comment">//detectAllHandlerMappings默认为true，代表是否从所有容器中(父子容器)检测HandlerMapping</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">        <span class="comment">//从Spring容器中去匹配HandlerMapping</span></span><br><span class="line">        Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context,</span><br><span class="line">                HandlerMapping.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//如果从容器中获取的HandlerMapping不为null就加入到事先定义好的handlerMappings容器中</span></span><br><span class="line">        <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(matchingBeans.values());</span><br><span class="line">            AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果从容器中没有获得HandlerMapping，意味着handlerMappings集合是空的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加载默认的HandlerMapping，就是加载DispatcherServlet.properties文件中的键值对</span></span><br><span class="line">            <span class="built_in">this</span>.handlerMappings = <span class="built_in">this</span>.getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427154215264.png" alt="image-20230427154215264"></p><p>初始化后，映射信息就已经被封装到HandlerMapping中了，可以在获取matchingBeans处打断点验证</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="6-2-前端控制器执行主流程">6.2 前端控制器执行主流程</h3><p>上面讲解了一下，当服务器启动时，DispatcherServlet 会执行初始化操作，接下来，每次访问都会执行service方法，我们先宏观的看一下执行流程，在去研究源码和组件执行细节</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230429111137565.png" alt="image-20230429111137565" style="zoom:67%;" /><div class="tabs" id="3437a5f1-ec27-476f-9b69-58f18848f585"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3437a5f1-ec27-476f-9b69-58f18848f585-1"><i class="fas fa-cat"></i>processRequest</button></li><li class="tab"><button type="button" data-href="#3437a5f1-ec27-476f-9b69-58f18848f585-2"><i class="fas fa-horse"></i>doService</button></li><li class="tab"><button type="button" data-href="#3437a5f1-ec27-476f-9b69-58f18848f585-3"><i class="fas fa-dove"></i>⭐️doDispatch</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3437a5f1-ec27-476f-9b69-58f18848f585-1"><p>FrameworkServlet 复写了service(HttpServletRequest request, HttpServletResponse response) 、 doGet(HttpServletRequest request, HttpServletResponse response)、doPost(HttpServletRequest request, HttpServletResponse response)等方法，这些方法都会调用processRequest方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.doService(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3437a5f1-ec27-476f-9b69-58f18848f585-2"><p>进一步调用了doService方法，该方法内部又调用了doDispatch方法，而SpringMVC 主流程最核心的方法就是doDispatch 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.doDispatch(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3437a5f1-ec27-476f-9b69-58f18848f585-3"><p>doDispatch方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="comment">// 对原始的请求进行处理，比如 URL 的编码</span></span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> checkMultipart(request);</span><br><span class="line">    <span class="comment">//定义处理器执行链对象</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//定义模型视图对象</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//匹配处理器映射器HandlerMapping，返回处理器执行链对象</span></span><br><span class="line">    mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line">    <span class="comment">//匹配处理器适配器HandlerAdapter，返回处理器适配器对象</span></span><br><span class="line">    <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">//执行Interceptor的前置方法preHandle</span></span><br><span class="line">    mappedHandler.applyPreHandle(processedRequest, response);</span><br><span class="line">    <span class="comment">//处理器适配器执行控制器Handler，返回模型视图对象</span></span><br><span class="line">    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">//执行Interceptor的后置方法postHandle</span></span><br><span class="line">    mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">    <span class="comment">//获取视图渲染视图</span></span><br><span class="line">    <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="6-2-1-getHandler方法详解">6.2.1 getHandler方法详解</h4><p>doDispatch() 中调用 getHandler 方法获取所有的映射器</p><p>总体流程：</p><ul><li>所有的请求映射都在 HandlerMapping 中，<span class='p green'>RequestMappingHandlerMapping 处理 @RequestMapping 注解的映射规则</span></li><li>遍历所有的 HandlerMapping 看是否可以匹配当前请求，匹配成功后返回，匹配失败设置 HTTP 404 响应码</li><li>用户可以自定义的映射处理，也可以给容器中放入自定义 HandlerMapping</li></ul><p>访问 URL：<a href="http://localhost:8080/hello">http://localhost:8080/hello</a></p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/gethandler2.jpg" alt="gethandler2" style="zoom: 33%;" /><div class="tabs" id="aaad200b-ee69-49ad-912a-ba4b279fb02d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#aaad200b-ee69-49ad-912a-ba4b279fb02d-1"><i class="fas fa-seedling"></i>1.getHandler()</button></li><li class="tab"><button type="button" data-href="#aaad200b-ee69-49ad-912a-ba4b279fb02d-2"><i class="fas fa-leaf"></i>2.getHandler()</button></li><li class="tab"><button type="button" data-href="#aaad200b-ee69-49ad-912a-ba4b279fb02d-3"><i class="fab fa-apple"></i>3.getHandlerInterna()</button></li><li class="tab"><button type="button" data-href="#aaad200b-ee69-49ad-912a-ba4b279fb02d-4"><i class="fas fa-tree"></i>4.lookupHandlerMethod()</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="aaad200b-ee69-49ad-912a-ba4b279fb02d-1"><p>HandlerMapping 处理器映射器，保存了所有 <code>@RequestMapping</code> 和 <code>handler</code> 的映射规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的 HandlerMapping</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">            <span class="comment">// 尝试去每个 HandlerMapping 中匹配当前请求的处理 </span></span><br><span class="line">            <span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);<span class="comment">// 跳转到2</span></span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230430111413036.png" alt="image-20230430111413036" style="zoom: 50%;" /><p>有 5 个 Mapping ，查看 RequestMappingHandlerMapping ，可以查看请求映射的注册：/error、/hello，这里就可以找到对应的处理方法：com.yuyu.demo.controller.DemoController.test()</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230430111649469.png" alt="image-20230430111649469" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="aaad200b-ee69-49ad-912a-ba4b279fb02d-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取映射器，底层调用 RequestMappingInfoHandlerMapping 类的方法，又调用 AbstractHandlerMethodMapping#getHandlerInternal</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getHandlerInternal(request); <span class="comment">// 跳转到3</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">        handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure presence of cached lookupPath for interceptors and others</span></span><br><span class="line">    <span class="keyword">if</span> (!ServletRequestPathUtils.hasCachedPath(request)) &#123;</span><br><span class="line">        initLookupPath(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为当前请求和方法构建为一个拦截器链</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">executionChain</span> <span class="operator">=</span> getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executionChain; <span class="comment">//返回到1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="aaad200b-ee69-49ad-912a-ba4b279fb02d-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 地址栏的 uri，这里的 lookupPath 为 /hello</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> initLookupPath(request);</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="built_in">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过路径从映射注册器里找到对应的映射</span></span><br><span class="line">        <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> lookupHandlerMethod(lookupPath, request); <span class="comment">// 跳转到4</span></span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="literal">null</span> ? handlerMethod.createWithResolvedBean() : <span class="literal">null</span>); <span class="comment">//返回2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="aaad200b-ee69-49ad-912a-ba4b279fb02d-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取当前的映射器与当前请求的 URI 有关的所有映射规则</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="built_in">this</span>.mappingRegistry.getMappingsByDirectPath(lookupPath);</span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配某个映射规则</span></span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 返回找到的最匹配的 处理方法</span></span><br><span class="line">    <span class="keyword">return</span> bestMatch.getHandlerMethod(); <span class="comment">//返回到3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230430114056174.png" alt="image-20230430114056174" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="6-2-2-参数处理原理">6.2.2 参数处理原理</h4><p>doDispatch中</p><ul><li>HandlerMapping中找到能处理请求的Handler(controller.method())</li><li>为当前Handler找一个适配器HandlerAdapter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//匹配处理器映射器HandlerMapping，返回处理器执行链对象</span></span><br><span class="line">  mappedHandler = <span class="built_in">this</span>.getHandler(processedRequest);</span><br><span class="line">  <span class="comment">//匹配处理器适配器HandlerAdapter，返回处理器适配器对象</span></span><br><span class="line">  <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure><div class="tabs" id="2b53a8bd-c0b4-4fed-bb79-497cd459a76a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2b53a8bd-c0b4-4fed-bb79-497cd459a76a-1"><i class="fas fa-seedling"></i>getHandlerAdapter</button></li><li class="tab"><button type="button" data-href="#2b53a8bd-c0b4-4fed-bb79-497cd459a76a-2"><i class="fas fa-leaf"></i>handle</button></li><li class="tab"><button type="button" data-href="#2b53a8bd-c0b4-4fed-bb79-497cd459a76a-3"><i class="fab fa-apple"></i>invokeHandlerMethod</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2b53a8bd-c0b4-4fed-bb79-497cd459a76a-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line"><span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line"><span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;No adapter for handler [&quot;</span> + handler +</span><br><span class="line"><span class="string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大多数找到的都是第一个<code>RequestMappingHandlerAdapter</code>,找到适配器后返回改适配器。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230505150121343.png" alt="image-20230505150121343" style="zoom:67%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b53a8bd-c0b4-4fed-bb79-497cd459a76a-2"><p><code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code></p><p>利用前面找到的HandlerAdapter，把目标Handler，以及Request和Response全部传进去，来执行目标方法。</p><p>内部的处理细节就到了</p><p><code>RequestMappingHandlerAdapter</code>#<code>handleInternal(request, response, handlerMethod)</code>方法中</p><p>在该方法里</p><p><code>mav = invokeHandlerMethod(request, response, handlerMethod);</code>执行目标方法</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b53a8bd-c0b4-4fed-bb79-497cd459a76a-3"><p>在该方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line"><span class="comment">//设置参数解析器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">    invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置返回值处理器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">    invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">// 调用处理器方法并处理返回值</span></span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br></pre></td></tr></table></figure><div class="tabs" id="7deda36b-990c-4db1-b08b-716deabfeee1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7deda36b-990c-4db1-b08b-716deabfeee1-1"><i class="fas fa-cat"></i>参数解析器</button></li><li class="tab"><button type="button" data-href="#7deda36b-990c-4db1-b08b-716deabfeee1-2"><i class="fas fa-horse"></i>返回值处理器</button></li><li class="tab"><button type="button" data-href="#7deda36b-990c-4db1-b08b-716deabfeee1-3"><i class="fas fa-dove"></i>执行目标方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7deda36b-990c-4db1-b08b-716deabfeee1-1"><p><code>argumentResolvers</code>参数解析器：确定将要执行的目标方法的每一个参数的值是什么</p><p>参数解析器共有26个，SpringMVC目标方法能写多少种参数类型。取决于参数解析器。</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230505152933897.png" alt="image-20230505152933897" style="zoom: 50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7deda36b-990c-4db1-b08b-716deabfeee1-2"><p>返回值处理器共有15种</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230505153622226.png" alt="image-20230505153622226" style="zoom:50%;" /><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7deda36b-990c-4db1-b08b-716deabfeee1-3"><p>把参数解析器和返回值处理器都设置到<code>invocableMethod</code>中后就可以进行方法执行了</p><p>在<code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code>方法中，真正执行了Controller中的方法</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">请求处理、响应处理、拦截器、全注解开发、组件原理剖析</summary>
    
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/tags/Spring/"/>
    
    <category term="SpringMVC" scheme="https://wuwawawa.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring整合Web</title>
    <link href="https://wuwawawa.github.io/posts/6b43be99.html"/>
    <id>https://wuwawawa.github.io/posts/6b43be99.html</id>
    <published>2023-04-30T01:31:36.000Z</published>
    <updated>2023-05-16T05:27:11.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring整合web环境">1. Spring整合web环境</h2><h3 id="1-1-Javaweb三大组件及环境特点">1.1 Javaweb三大组件及环境特点</h3><p>在Java语言范畴内，web层框架都是基于Javaweb基础组件完成的，所以有必要复习一下Javaweb组件的特点</p><table><thead><tr><th style="text-align:left">组件</th><th style="text-align:left">作用</th><th style="text-align:left">特点</th></tr></thead><tbody><tr><td style="text-align:left">Servlet</td><td style="text-align:left">服务端小程序，负责接收客户端请求并作出响应的</td><td style="text-align:left">单例对象，默认第一次访问创建，可以通过配置指定服务器启动就创建，Servlet创建完毕会执行初始化init方法。每个Servlet有一个service方法，每次访问都会执行service方法，但是缺点是一个业务功能就需要配置一个Servlet</td></tr><tr><td style="text-align:left">Filter</td><td style="text-align:left">过滤器，负责对客户端请求进行过滤操作的</td><td style="text-align:left">单例对象，服务器启动时就创建，对象创建完毕执行init方法，对客户端的请求进行过滤，符合要求的放行，不符合要求的直接响应客户端，执行过滤的核心方法doFilter</td></tr><tr><td style="text-align:left">Listener</td><td style="text-align:left">监听器，负责对域对象的创建和属性变化进行监听的</td><td style="text-align:left">根据类型和作用不同，又可分为监听域对象创建销毁和域对象属性内容变化的，根据监听的域不同，又可以分为监听Request域的，监听Session域的，监听ServletContext域的</td></tr></tbody></table><mark class="hl-label green">Servlet知识补充</mark> <div class="tabs" id="ba4120be-81c6-4c79-8d1d-62ec49c11029"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ba4120be-81c6-4c79-8d1d-62ec49c11029-1"><i class="fas fa-cat"></i>实现方式</button></li><li class="tab"><button type="button" data-href="#ba4120be-81c6-4c79-8d1d-62ec49c11029-2"><i class="fas fa-dove"></i>执行原理</button></li><li class="tab"><button type="button" data-href="#ba4120be-81c6-4c79-8d1d-62ec49c11029-3"><i class="fas fa-dragon"></i>生命周期</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ba4120be-81c6-4c79-8d1d-62ec49c11029-1"><p>Servlet实现方式</p><ul><li>实现Servlet接口</li><li>继承GenericServelt抽象类（这个类是Servlet接口的一级实现类）</li><li>继承HttpServlet抽象类就可以间接的实现Servlet接口（位于javax.servlet.http包中的HttpServlet抽象类继承自GenericServlet类，是Servlet接口的二级实现类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line">    ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/874710-20170216094438629-1196159083.png" alt="img" style="zoom:50%;" /><p>在HttpServlet的API中，新增了两个特殊的方法doGet和doPost，这两个方法是对servlet方法的拆分，目的是希望不同的请求方式使用不同的方法处理。而service方法可以处理任何类型的请求。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ba4120be-81c6-4c79-8d1d-62ec49c11029-2"><ol><li>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</li><li>查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</li><li>如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</li><li>tomcat会将字节码文件加载进内存，并且创建其对象</li><li>调用其Service方法</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ba4120be-81c6-4c79-8d1d-62ec49c11029-3"><ul><li>加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</li><li>初始化：在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次</li><li>请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。</li><li>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="1-2-整合web环境思路及实现">1.2 整合web环境思路及实现</h3><p>在进行Java开发时要遵循三层架构+MVC，Spring操作最核心的就是Spring容器，web层需要注入Service，service层需要注入Dao（Mapper），web层使用Servlet技术充当的话，需要在Servlet中获得Spring容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ApplicationContextConfig.class);</span><br><span class="line"><span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> (AccountService)applicationContext.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">accountService.transferMoney(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;lucy&quot;</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>Web层代码如果都去编写创建AnnotationConfigApplicationContext的代码，那么配置类重复被加载了， Spring容器也重复被创建了，不能每次想从容器中获得一个Bean都得先创建一次容器，这样肯定是不允许。所以，我们现在的诉求很简单，如下：</p><ul><li><code>ApplicationContext</code>创建一次，配置类加载一次;</li><li>最好web服务器启动时，就执行第1步操作，后续直接从容器中获取Bean使用即可;</li><li><code>ApplicationContext</code>的引用需要在web层任何位置都可以获取到。</li></ul><span class='p green'>针对以上诉求我们给出解决思路，如下</span><ul><li>在<code>ServletContextListener</code>的<code>contextInitialized</code>方法中执行<code>ApplicationContext</code>的创建。或在Servlet的init方法中执行<code>ApplicationContext</code>的创建，并给Servlet的load-on-startup属性一个数字值，确保服务器启动Servlet就创建;</li><li>将创建好的<code>ApplicationContext</code>存储到<code>ServletContext</code>域中，这样整个web层任何位置就都可以获取到了</li></ul><blockquote><p>自定义代码完成上述ContextLoaderListener和WebApplicationContextUtils（见代码）</p></blockquote><div class="tabs" id="985af088-6b5b-4ddc-844e-be0c5d5b5dec"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#985af088-6b5b-4ddc-844e-be0c5d5b5dec-1"><i class="fas fa-seedling"></i>ContextLoaderListener</button></li><li class="tab"><button type="button" data-href="#985af088-6b5b-4ddc-844e-be0c5d5b5dec-2"><i class="fab fa-apple"></i>配置Listener到web.xml中</button></li><li class="tab"><button type="button" data-href="#985af088-6b5b-4ddc-844e-be0c5d5b5dec-3"><i class="fas fa-leaf"></i>获取Spring容器</button></li><li class="tab"><button type="button" data-href="#985af088-6b5b-4ddc-844e-be0c5d5b5dec-4"><i class="fas fa-tree"></i>存在的问题</button></li><li class="tab"><button type="button" data-href="#985af088-6b5b-4ddc-844e-be0c5d5b5dec-5"><i class="fas fa-cookie-bite"></i>解决方式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="985af088-6b5b-4ddc-844e-be0c5d5b5dec-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建Spring容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 将容器存储到ServletContext域中</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;applicationContext&quot;</span>,app);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="985af088-6b5b-4ddc-844e-be0c5d5b5dec-2"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.itheima.listener.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="985af088-6b5b-4ddc-844e-be0c5d5b5dec-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) servletContext.getAttribute(<span class="string">&quot;applicationContext&quot;</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="985af088-6b5b-4ddc-844e-be0c5d5b5dec-4"><p>配置文件名字和获取Spring容器key写死</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="985af088-6b5b-4ddc-844e-be0c5d5b5dec-5"><div class="tabs" id="a76920d6-2ba5-4775-ac57-231a39a2183d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a76920d6-2ba5-4775-ac57-231a39a2183d-1"><i class="fas fa-cat"></i>定义配置文件全局参数</button></li><li class="tab"><button type="button" data-href="#a76920d6-2ba5-4775-ac57-231a39a2183d-2"><i class="fas fa-horse"></i>获取配置文件名称</button></li><li class="tab"><button type="button" data-href="#a76920d6-2ba5-4775-ac57-231a39a2183d-3"><i class="fas fa-dove"></i>解耦方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a76920d6-2ba5-4775-ac57-231a39a2183d-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义全局参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.itheima.listener.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a76920d6-2ba5-4775-ac57-231a39a2183d-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String CONTEXT_CONFIG_LOCATION= <span class="string">&quot;contextConfigLocation&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//0. 获取contextConfigLocation配置文件名称</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        <span class="comment">//解析配置文件名字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextConfigLocation</span> <span class="operator">=</span> servletContext.getInitParameter(CONTEXT_CONFIG_LOCATION);</span><br><span class="line">        contextConfigLocation= contextConfigLocation.substring(<span class="string">&quot;classpath:&quot;</span>.length());</span><br><span class="line">        <span class="comment">//1. 创建Spring容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(contextConfigLocation);</span><br><span class="line">        <span class="comment">//2. 将容器存储到ServletContext域中</span></span><br><span class="line"></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;applicationContext&quot;</span>,app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a76920d6-2ba5-4775-ac57-231a39a2183d-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplicationContextUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getWebApplicationContext</span><span class="params">(ServletContext servletContext)</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext) servletContext.getAttribute(<span class="string">&quot;applicationContext&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="1-3-Web开发组件spring-web">1.3 Web开发组件spring-web</h3><p>到此，就将一开始的诉求都解决了，当然我们能想到的Spring 框架自然也会想到，Spring其实已经为我们定义好了一个<code>ContextLoaderListener</code>，使用方式跟我们上面自己定义的大体一样，但是功能要比我们强百倍，所以 ，遵循Spring “拿来主义” 的精神，我们直接使用Spring提供的就可以了。开发如下：</p><div class="tabs" id="b05494f3-2fe1-4bf0-935f-436241e8a631"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b05494f3-2fe1-4bf0-935f-436241e8a631-1"><i class="fas fa-seedling"></i>导入坐标</button></li><li class="tab"><button type="button" data-href="#b05494f3-2fe1-4bf0-935f-436241e8a631-2"><i class="fas fa-leaf"></i>配置web.xml</button></li><li class="tab"><button type="button" data-href="#b05494f3-2fe1-4bf0-935f-436241e8a631-3"><i class="fab fa-apple"></i>使用</button></li><li class="tab"><button type="button" data-href="#b05494f3-2fe1-4bf0-935f-436241e8a631-4"><i class="fas fa-tree"></i>补充</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b05494f3-2fe1-4bf0-935f-436241e8a631-1"><p>先导入Spring-web的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b05494f3-2fe1-4bf0-935f-436241e8a631-2"><p>在web.xml中去配置<code>ContextLoaderListener</code>，并指定配置文件的位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义全局参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置Listener--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b05494f3-2fe1-4bf0-935f-436241e8a631-3"><p>在Servlet中直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/accountServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> app.getBean(AccountService.class);</span><br><span class="line">        accountService.transferMoney(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;lucy&quot;</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b05494f3-2fe1-4bf0-935f-436241e8a631-4"><p>如果核心配置类使用的是注解形式的，那么Spring容器是<code>AnnotationConfigWebApplicationContext</code>，如下配置方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationConfigWebApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AnnotationConfigWebApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAnnotationConfigWebApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//注册核心配置类</span></span><br><span class="line">        <span class="built_in">super</span>.register(ApplicationContextConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itheima.web.MyAnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="2-Web层MVC框架思想与设计思路">2. Web层MVC框架思想与设计思路</h2><p>Java程序员在开发一般都是MVC+三层架构，MVC是web开发模式，传统的Javaweb技术栈实现的MVC如下</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427202851806.png" alt="image-20230427202851806" style="zoom: 50%;" /><p>原始Javaweb开发中，Servlet充当Controller的角色，Jsp充当View角色，JavaBean充当模型角色，后期Ajax异步流行后，在加上现在前后端分离开发模式成熟后，View就被原始Html+Vue替代。原始Javaweb开发中， Service充当Controller有很多弊端，显而易见的有如下几个：</p><table><thead><tr><th style="text-align:left">Servlet作为Controller的问题</th><th style="text-align:left">解决思路和方案</th></tr></thead><tbody><tr><td style="text-align:left">每个业务功能请求都对应一个Servlet</td><td style="text-align:left">根据业务模块去划分Controller</td></tr><tr><td style="text-align:left">每个Servlet的业务操作太繁琐</td><td style="text-align:left">将通用的行为，功能进行抽取封装</td></tr><tr><td style="text-align:left">Servlet获得Spring容器的组件只能通过客户端代码去获取，不能优雅的整合</td><td style="text-align:left">通过Spring的扩展点，去封装一个框架，从原有的Servlet完全接手过来web层的业务</td></tr></tbody></table><p>分析前端控制器基本功能如下：</p><p>1、具备可以映射到业务Bean的能力</p><p>2、具备可以解析请求参数、封装实体等共有功能</p><p>3、具备响应视图及响应其他数据的功能</p><span class='p green'>负责共有行为</span>的Servlet称之为`前端控制器`<span class='p blue'>负责业务行为</span>的JavaBean称之为`控制器Controller`<img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427100450596.png" alt="image-20230427100450596" style="zoom: 67%;" />]]></content>
    
    
    <summary type="html">Spring整合web环境、Web层MVC框架思想与设计思路</summary>
    
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/tags/Spring/"/>
    
    <category term="SpringMVC" scheme="https://wuwawawa.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>基于AOP的申明式事务控制</title>
    <link href="https://wuwawawa.github.io/posts/8f292d64.html"/>
    <id>https://wuwawawa.github.io/posts/8f292d64.html</id>
    <published>2023-04-29T13:33:55.000Z</published>
    <updated>2023-05-16T05:26:56.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring事务编程概述">1. Spring事务编程概述</h2><p>事务是开发中必不可少的东西，使用JDBC开发时，我们使用connnection对事务进行控制，使用MyBatis时，我们使用<code>SqlSession</code>对事务进行控制，缺点显而易见，当我们切换数据库访问技术时，事务控制的方式总会变化， Spring 就将这些技术基础上，提供了统一的控制事务的接口。Spring的事务分为：<code>编程式事务控制</code>和<code>声明式事务控制</code></p><table><thead><tr><th>事务控制方式</th><th>解释</th></tr></thead><tbody><tr><td>编程式事务控制</td><td>Spring提供了事务控制的类和方法，使用编码的方式对业务代码进行事务控制，事务控制代码和业务操作代码耦合到了一起，开发中不使用</td></tr><tr><td>声明式事务控制</td><td>Spring将事务控制的代码封装，对外提供了Xml和注解配置方式，通过配置的方式完成事务的控制，可以达到事务控制与业务操作代码解耦合，开发中推荐使用</td></tr></tbody></table><p>Spring事务编程相关的类主要有如下三个</p><table><thead><tr><th style="text-align:left">事务控制相关类</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">平台事务管理器<br/><code>PlatformTransactionManager</code></td><td style="text-align:left">是一个接口标准，实现类都具备事务提交、回滚和获得事务对象的功能，不同持久层框架可能会有不同实现方案</td></tr><tr><td style="text-align:left">事务定义<br/><code>TransactionDefinition</code></td><td style="text-align:left">封装事务的隔离级别、传播行为、过期时间等属性信息</td></tr><tr><td style="text-align:left">事务状态<br/><code>TransactionStatus</code></td><td style="text-align:left">存储当前事务的状态信息，如果事务是否提交、是否回滚、是否有回滚点等</td></tr></tbody></table><p>虽然编程式事务控制我们不学习，但是编程式事务控制对应的这些类我们需要了解一下，因为我们在通过配置的方式进行声明式事务控制时也会看到这些类的影子</p><hr><h2 id="2-搭建测试环境">2. 搭建测试环境</h2><p>搭建一个转账的环境，dao层一个转出钱的方法，一个转入钱的方法，service层一个转账业务方法，内部分别调用dao层转出钱和转入钱的方法，准备工作如下：</p><ul><li><p>数据库准备一个账户表tb_account;</p></li><li><p>dao层准备一个AccountMapper，包括incrMoney和decrMoney两个方法；</p></li><li><p>service层准备一个transferMoney方法，分别调用incrMoney和decrMoney方法；</p></li><li><p>在applicationContext文件中进行Bean的管理配置；</p></li><li><p>测试正常转账与异常转账。</p></li></ul><hr><h2 id="3-基于xml声明式事务控制">3. 基于xml声明式事务控制</h2><p>结合上面我们学习的AOP的技术，很容易就可以想到，可以使用AOP对Service的方法进行事务的增强。</p><ul><li><p>目标类：AccountServiceImpl</p></li><li><p>切点：service业务类中的所有业务方法</p></li><li><p>通知类：Spring提供的，通知方法已经定义好，只需要配置即可</p></li></ul><p>我们分析：</p><p>目标类是我们自己定义的；</p><ul><li><p>通知类是Spring提供的，需要导入Spring事务的相关的坐标；</p></li><li><p>配置目标类AccountServiceImpl；</p></li><li><p>使用advisor标签配置切面。</p></li></ul><p>导入Spring事务的相关的坐标，spring-jdbc坐标已经引入的spring-tx坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230426103319358.png" alt="image-20230426103319358"></p><p>配置目标类AccountServiceImpl</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.AccoutServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用advisor标签配置切面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;Spring提供的通知类&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>疑问：Spring提供的通知类是谁？是谁？</p><p>是spring-tx包下的advice标签配置提供的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; </span><br><span class="line">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring提供的事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transferMoney&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;READ_COMMITTED&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--平台事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对上述配置进行详解一下<br>首先，平台事务管理器PlatformTransactionManager是Spring提供的封装事务具体操作的规范接口，封装了事务的提交和回滚方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的持久层框架事务操作的方式有可能不同，所以不同的持久层框架有可能会有不同的平台事务管理器实现，例如，MyBatis作为持久层框架时，使用的平台事务管理器实现是DataSourceTransactionManager。 Hibernate作为持久层框架时，使用的平台事务管理器是HibernateTransactionManager。</p><p>其次，事务定义信息配置，每个事务有很多特性，例如：隔离级别、只读状态、超时时间等，这些信息在开发时可以通过connection进行指定，而此处要通过配置文件进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;方法名称&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;隔离级别&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;传播行为&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;只读状态&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;超时时间&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，name属性名称指定哪个方法要进行哪些事务的属性配置，此处需要区分的是切点表达式指定的方法与此处指定的方法的区别？切点表达式，是过滤哪些方法可以进行事务增强；事务属性信息的name，是指定哪个方法要进行哪些事务属性的配置</p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230427092027314.png" alt="image-20230427092027314" style="zoom:67%;" /><p>第一层筛选是符合切面表达式的方法</p><p>第二层是对方法指定事务的属性</p><p>方法名在配置时，也可以使用 * 进行模糊匹配，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;myAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--精确匹配transferMoney方法--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transferMoney&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--模糊匹配以Service结尾的方法--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*Service&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--模糊匹配以insert开头的方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--模糊匹配以update开头的方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--模糊匹配任意方法，一般放到最后作为保底匹配--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>isolation属性：指定事务的隔离级别，事务并发存在三大问题：脏读、不可重复读、幻读/虚读。可以通过设置事务的隔离级别来保证并发问题的出现，常用的是READ_COMMITTED 和REPEATABLE_READ</p><table><thead><tr><th style="text-align:left">isolation属性</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">DEFAULT</td><td style="text-align:left">默认隔离级别，取决于当前数据库隔离级别，例如MySQL默认隔离级别是REPEATABLE_READ</td></tr><tr><td style="text-align:left">READ_UNCOMMITTED</td><td style="text-align:left">A事务可以读取到B事务尚未提交的事务记录，不能解决任何并发问题，安全性最低，性能最高</td></tr><tr><td style="text-align:left">READ_COMMITTED</td><td style="text-align:left">A事务只能读取到其他事务已经提交的记录，不能读取到未提交的记录。可以解决脏读问题，但是不能解决不可重复读和幻读</td></tr><tr><td style="text-align:left">REPEATABLE_READ</td><td style="text-align:left">A事务多次从数据库读取某条记录结果一致，可以解决不可重复读，不可以解决幻读</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td style="text-align:left">串行化，可以解决任何并发问题，安全性最高，但是性能最低</td></tr></tbody></table><p>read-only属性：设置当前的只读状态，如果是查询则设置为true，可以提高查询性能，如果是更新（增删改）操作则设置为false</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一般查询相关的业务操作都会设置为只读模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>timeout属性：设置事务执行的超时时间，单位是秒，如果超过该时间限制但事务还没有完成，则自动回滚事务 ，不在继续执行。默认值是-1，即没有超时时间限制</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置查询操作的超时时间是3秒 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>propagation属性：设置事务的传播行为，主要解决是A方法调用B方法时，事务的传播方式问题的，例如：使用单方的事务，还是A和B都使用自己的事务等。事务的传播行为有如下七种属性值可配置</p><table><thead><tr><th style="text-align:left">事务传播行为</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">REQUIRED（默认值）</td><td style="text-align:left">A调用B，B需要事务，如果A有事务B就加入A的事务中，如果A没有事务，B就自己创建一个事务</td></tr><tr><td style="text-align:left">REQUIRED_NEW</td><td style="text-align:left">A调用B，B需要新事务，如果A有事务就挂起，B自己创建一个新的事务</td></tr><tr><td style="text-align:left">SUPPORTS</td><td style="text-align:left">A调用B，B有无事务无所谓，A有事务就加入到A事务中，A无事务B就以非事务方式执行</td></tr><tr><td style="text-align:left">NOT_SUPPORTS</td><td style="text-align:left">A调用B，B以无事务方式执行，A如有事务则挂起</td></tr><tr><td style="text-align:left">NEVER</td><td style="text-align:left">A调用B，B以无事务方式执行，A如有事务则抛出异常</td></tr><tr><td style="text-align:left">MANDATORY</td><td style="text-align:left">A调用B，B要加入A的事务中，如果A无事务就抛出异常</td></tr><tr><td style="text-align:left">NESTED</td><td style="text-align:left">A调用B，B创建一个新事务，A有事务就作为嵌套事务存在，A没事务就以创建的新事务执行</td></tr></tbody></table><p>xml方式声明式事务控制的原理浅析一下</p><p><code>&lt;tx:advice&gt;</code>标签使用的命名空间处理器是<code>TxNamespaceHandler</code>，内部注册的是解析器是<code>TxAdviceBeanDefinitionParser</code></p><p><code>this.registerBeanDefinitionParser(&quot;advice&quot;, new TxAdviceBeanDefinitionParser());</code></p><p><code>TxAdviceBeanDefinitionParser</code>中指定了要注册的BeanDefinition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">    <span class="keyword">return</span> TransactionInterceptor.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TxAdviceBeanDefinitionParser</code>二级父类AbstractBeanDefinitionParser的parse方法将<code>TransactionInterceptor</code>以配置的名称(myAdvice)注册到了Spring容器中</p><p><code>parserContext.registerComponent(componentDefinition);</code></p><p>TransactionInterceptor实现了MethodInterceptor接口：AOP的另一种配置方式，该方式需要通知类实现Advice的子功能接口。相当于环绕通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, Serializable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">        <span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">        <span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">        Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">        <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TransactionInterceptor</code>中的invoke方法会被执行，跟踪invoke方法，最终会看到事务的开启和提交</p><ul><li>在AbstractPlatformTransactionManager开启的事务；</li><li>在TransactionAspectSupport提交了事务。</li></ul><hr><h2 id="4-基于注解声明式事务控制">4. 基于注解声明式事务控制</h2><p>注解就是对xml的替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccoutServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    <span class="comment">//&lt;tx:method name=&quot;*&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED“/&gt;</span></span><br><span class="line">    <span class="meta">@Transactional(isolation = Isolation.REPEATABLE_READ,propagation = Propagation.REQUIRED,readOnly = false,timeout = 5)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferMoney</span><span class="params">(String decrAccountName, String incrAccountName, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        accountMapper.decrMoney(decrAccountName,money); <span class="comment">//转出钱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>; <span class="comment">//模拟某些逻辑产生的异常</span></span><br><span class="line">        accountMapper.incrMoney(incrAccountName,money); <span class="comment">//转入钱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，使用的事务的注解，平台事务管理器仍然需要配置，还需要进行事务注解开关的开启</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务的注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用全注解的话，使用如下配置类的形式代替配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.service&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.itheima.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">tansactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略其他配置 ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Spring事务编程</summary>
    
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>基于注解配置的AOP</title>
    <link href="https://wuwawawa.github.io/posts/62726e73.html"/>
    <id>https://wuwawawa.github.io/posts/62726e73.html</id>
    <published>2023-04-28T13:33:28.000Z</published>
    <updated>2023-05-16T05:26:48.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-注解方式AOP基本使用">1. 注解方式AOP基本使用</h2><p>Spring的AOP也提供了注解方式配置，使用相应的注解替代之前的xml配置，xml配置AOP时，我们主要配置了三部分：<code>目标类被Spring容器管理</code>、<code>通知类被Spring管理</code>、<code>通知与切点的织入（切面）</code>，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.TargetImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;advices&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.Advices&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;advices&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.itheima.aop.*.*(..))&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目标类被Spring容器管理、通知类被Spring管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetImpl</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show Target running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前通知...&quot;</span>); </span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后通知...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置aop，其实配置aop主要就是配置通知类中的哪个方法（通知类型）对应的切点表达式是什么</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230426100037391.png" alt="image-20230426100037391"></p><p>注解@Aspect、@Around需要被Spring解析，所以在Spring核心配置文件中需要配置aspectj的自动代理</p><p><code>&lt;aop:aspectj-autoproxy/&gt;</code></p><p>如果核心配置使用的是配置类的话，需要配置注解方式的aop自动代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.aop&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>    <span class="comment">//第三步</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123; &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-注解方式AOP配置详解">2. 注解方式AOP配置详解</h2><p>各种注解方式通知类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//后置通知</span></span><br><span class="line"><span class="meta">@AfterReturning(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AfterReturning</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//环绕通知</span></span><br><span class="line"><span class="meta">@Around(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br><span class="line"><span class="comment">//异常通知</span></span><br><span class="line"><span class="meta">@AfterThrowing(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AfterThrowing</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//最终通知</span></span><br><span class="line"><span class="meta">@After(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">After</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>切点表达式的抽取，使用一个空方法，将切点表达式标注在空方法上，其他通知方法引用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//切点表达式抽取</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;AnnoAdvice.pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AfterReturning</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// ...  省略其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-注解方式AOP原理剖析">3. 注解方式AOP原理剖析</h2><p>之前在使用xml配置AOP时，是借助的Spring的外部命名空间的加载方式完成的，使用注解配置后，就抛弃了<code>&lt;aop:config&gt;</code>标签，而该标签最终加载了名为<code>AspectJAwareAdvisorAutoProxyCreator</code>的<code>BeanPostProcessor</code> ，最终，在该<code>BeanPostProcessor</code>中完成了代理对象的生成。同样，从aspectj-autoproxy标签的解析器入手</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启aop aspectj的自动代理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>this.registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser());</code></p><p>而<code>AspectJAutoProxyBeanDefinitionParser</code>代码内部，最终也是执行了和xml方式AOP一样的代码</p><p><code>registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source)</code></p><p>如果使用的是核心配置类的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.aop&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>查看<code>@EnableAspectJAutoProxy</code>源码，使用的也是@Import导入相关解析类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@Import导入的<code>AspectJAutoProxyRegistrar</code>源码，一路追踪下去，最终还是注册了<code>AnnotationAwareAspectJAutoProxyCreator</code> 这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(</span></span><br><span class="line"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">       <span class="comment">//省略部分代码。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230426102339961.png" alt="image-20230426102339961"></p>]]></content>
    
    
    <summary type="html">注解方式AOP使用</summary>
    
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
