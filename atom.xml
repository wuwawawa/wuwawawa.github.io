<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LuckyBoy🥝</title>
  
  
  <link href="https://wuwawawa.github.io/atom.xml" rel="self"/>
  
  <link href="https://wuwawawa.github.io/"/>
  <updated>2024-03-06T07:54:22.132Z</updated>
  <id>https://wuwawawa.github.io/</id>
  
  <author>
    <name>LuckyBoy🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql&amp;Redis面试题</title>
    <link href="https://wuwawawa.github.io/posts/a257a413.html"/>
    <id>https://wuwawawa.github.io/posts/a257a413.html</id>
    <published>2024-03-05T06:56:47.000Z</published>
    <updated>2024-03-06T07:54:22.132Z</updated>
    
    <content type="html"><![CDATA[<details class="folding-tag" cyan close><summary> SQL语句在MySQL中的执行过程 </summary>              <div class='content'>              <p>1.连接层 TCP三次握手建立连接 校验用户名密码 读取权限</p><p>2.服务层 缓存查询、Sql分析与优化（走什么索引）、生成执行计划</p><p>3.引擎层 真正的负责了MySQL中数据的存储和提取(日志)</p>              </div>            </details><hr><h2 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h2><details class="folding-tag" cyan close><summary> 索引及其优缺点 </summary>              <div class='content'>              <p><mark class="hl-label green">优点</mark> </p><p>提高数据检索的效率，降低<code>数据库的IO成本</code></p><p>唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code></p><p>加速表和表之间的连接，减少查询中分组和排序的时间</p><p><mark class="hl-label red">缺点</mark> </p><p>索引需要占<code>磁盘空间</code></p><p>创建索引和维护索引要<code>耗费时间</code></p><p>索引大大提高了查询速度，同时却会<code>降低更新表的速度</code></p>              </div>            </details><hr><details class="folding-tag" blue close><summary> 索引失效场景 </summary>              <div class='content'>              <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF.png" alt="1索引失效场景"></p><p><code>MySQL8.0版本</code>开始增加了索引跳跃扫描的功能，当第一列索引的唯一值较少时，即使 where 条件没有第一列索引，查询的时候也可以用到联合索引。比如我们使用的联合索引是 bcd 但是 b 中字段比较少 我们在使用联合索引的时候没有 使用 b 但是依然可以使用联合索引 <strong>MySQL 联合索引有时候遵循最左前缀匹配原则，有时候不遵循。</strong></p>              </div>            </details><hr><details class="folding-tag" yellow close><summary> 索引下推和覆盖索引 </summary>              <div class='content'>              <p><mark class="hl-label green">索引下推</mark> </p><p>索引下推（Index Condition Pushdown）可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><p><mark class="hl-label blue">覆盖索引</mark> </p><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 覆盖索引。</p>              </div>            </details><hr><details class="folding-tag" green close><summary> 哪些情况适合创建索引？哪些情况不适合创建索引 </summary>              <div class='content'>              <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1%E9%80%82%E5%90%88%E4%B8%8D%E9%80%82%E5%90%88%E7%B4%A2%E5%BC%95.png" alt="1适合不适合索引"></p>              </div>            </details><hr><details class="folding-tag" yellow close><summary> mysql索引为什么用B+树？ </summary>              <div class='content'>              <p>Hash索引等值查询效率高，面对范围查询时间复杂度会退化。而且数据的存储是<code>没有顺序的</code>，在 ORDER BY 的情况下，使用 Hash 索引还需要对数据重新排序。对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。</p><p>B+树是平衡和搜索树的结合。</p><p>B+树数据按顺序排列，可以使用「二分查找法」高效定位数据。</p><p>B+树  vs B树</p><p>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引。</p><p>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询</p>              </div>            </details><hr><details class="folding-tag" cyan close><summary> count(1)、 count(*)、 count(主键字段) </summary>              <div class='content'>              <p>count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。</p><p>所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。</p><p>再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。</p>              </div>            </details><hr><h2 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h2><details class="folding-tag" cyan close><summary> 事务的ACID特性 </summary>              <div class='content'>              <p>Atomicity 原子性 事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p><p>Consistency 一致性 事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code>。</p><p>Isolation 隔离性 一个事务的执行<code>不能被其他事务干扰</code>，即一个事务内部的操作及使用的数据对<code>并发</code>的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。</p><p>Durability 持久性 一个事务一旦被提交，它对数据库中数据的改变就是 永久性的。</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul>              </div>            </details><hr><details class="folding-tag" green close><summary> 数据并发问题和事务隔离级别 </summary>              <div class='content'>              <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20240306124025555.png" alt="image-20240306124025555"></p><p>幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>              </div>            </details><hr><details class="folding-tag" green close><summary> InnoDB存储引擎对MVCC的实现 </summary>              <div class='content'>              <p>MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p><p><mark class="hl-label green">MVCC整体操作流程</mark> </p><ol><li>首先获取事务自己的版本号，也就是事务 ID；</li><li>获取 ReadView；</li><li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</li><li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</li><li>最后返回符合规则的数据。</li></ol><p>使用<code>READ COMMITTED</code>隔离级别的事务在每次查询开始时都会生成一个独立的ReadView</p><p>使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个<code>ReadView</code>，之后的查询就不会重复生成了。</p>              </div>            </details><hr><details class="folding-tag" yellow close><summary> MVCC和Next-key Lock是如何在RR级别下防止幻读的？ </summary>              <div class='content'>              <p><mark class="hl-label blue">执行普通select，此时会以MVCC快照读的方式读取数据</mark> </p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</p><p><mark class="hl-label green">执行insert、update、delete等当前读</mark> </p><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete、select…for update，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。</p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用<code>Next-key Lock</code>（记录锁+间隙锁）来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。</p><p>但某些情况下还是会发生幻读。</p><p><a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97">幻读被完全解决了嘛？</a>   </p><p>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>              </div>            </details><hr><h2 id="Mysql锁"><a href="#Mysql锁" class="headerlink" title="Mysql锁"></a>Mysql锁</h2><details class="folding-tag" cyan close><summary> 间隙锁死锁 </summary>              <div class='content'>              <p>事务的间隙锁之间是相互兼容的，不会产生冲突。</p><p>间隙锁的意义只在于阻止区间被插入，因此是可以共存的。一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁。</p><p>如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/ab%E4%BA%8B%E5%8A%A1%E6%AD%BB%E9%94%81.drawio.png" alt="img" style="zoom:67%;" /></p>              </div>            </details><hr><h2 id="Mysql日志"><a href="#Mysql日志" class="headerlink" title="Mysql日志"></a>Mysql日志</h2><details class="folding-tag" cyan close><summary> undo log和redo log有什么用？ </summary>              <div class='content'>              <p><a href="https://www.xiaolincoding.com/mysql/log/how_update.html#mysql-%E6%97%A5%E5%BF%97-undo-log%E3%80%81redo-log%E3%80%81binlog-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">MySQL 日志：undo log、redo log、binlog 有什么用？</a></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20240306154509741.png" alt="image-20240306154509741"></p>              </div>            </details><hr><details class="folding-tag" green close><summary> 一条更新语句，日志是如何写入的？ </summary>              <div class='content'>              <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/15477e4c8e68ee00bc5e496ed287f3af.png" alt=""></p>              </div>            </details><hr><details class="folding-tag" blue close><summary> 为什么需要binlog？ </summary>              <div class='content'>              <p><a href="https://www.xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-binlog">为什么需要binlog</a></p>              </div>            </details><hr><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2>]]></content>
    
    
    <summary type="html">Mysql&amp;Redis面试题</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="面试题" scheme="https://wuwawawa.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java日志体系</title>
    <link href="https://wuwawawa.github.io/posts/b41723d6.html"/>
    <id>https://wuwawawa.github.io/posts/b41723d6.html</id>
    <published>2023-12-25T05:55:36.000Z</published>
    <updated>2024-03-05T07:01:48.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志框架类别"><a href="#日志框架类别" class="headerlink" title="日志框架类别"></a>日志框架类别</h2><h3 id="记录型日志框架"><a href="#记录型日志框架" class="headerlink" title="记录型日志框架"></a>记录型日志框架</h3><ol><li><code>Jul (Java Util Logging)</code>：JDK中的日志记录工具，也常称为JDKLog、jdk-logging，自Java1.4以来的官方日志实现。</li><li><code>Log4j</code>：Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一。</li><li><code>Log4j</code>：一个具体的日志实现框架，是Log4j 1的下一个版本，与Log4j 1发生了很大的变化，Log4j 2不兼容Log4j 1。</li><li><code>Logback</code>：一个具体的日志实现框架，和Slf4j是同一个作者，但其性能更好(<span class='p green'>推荐使用</span>) 。</li></ol><hr><h3 id="门面型日志框架"><a href="#门面型日志框架" class="headerlink" title="门面型日志框架"></a>门面型日志框架</h3><ol><li><code>JCL</code>：Apache基金会所属的项目，是一套Java日志接口，之前叫Jakarta Commons Logging，后更名为Commons Logging</li><li><code>SLF4J</code>：是一套简易Java日志门面，<span class='p green'>本身并无日志的实现</span>。（Simple Logging Facade for Java，缩写Slf4j）</li></ol><hr><h2 id="Java日志框架发展史"><a href="#Java日志框架发展史" class="headerlink" title="Java日志框架发展史"></a>Java日志框架发展史</h2><div class="tabs" id="429b6ca4-4b72-4496-bb40-135bd75ba457"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-1"><i class="fas fa-bug"></i>1</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-2"><i class="fas fa-cannabis"></i>2</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-3"><i class="fas fa-candy-cane"></i>3</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-4"><i class="fas fa-child"></i>4</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-5"><i class="fas fa-award"></i>5</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-6"><i class="fas fa-baseball-ball"></i>6</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-7"><i class="fas fa-anchor"></i>7</button></li><li class="tab"><button type="button" data-href="#429b6ca4-4b72-4496-bb40-135bd75ba457-8"><i class="fas fa-bone"></i>8</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="429b6ca4-4b72-4496-bb40-135bd75ba457-1"><p>2001年以前，Java是没有日志库的，打印日志全凭<code>System.out</code>和<code>System.err</code></p><p>缺点:</p><ol><li>产生大量的IO操作同时在生产环境中无法合理的控制是否需要输出</li><li>输出的内容不能保存到文件</li><li>只打印在控制台，打印完就过去了，也就是说除非你一直盯着程序跑</li><li>无法定制化，且日志粒度不够细</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-2"><p>2001年，一个<strong>ceki Gulcü</strong>的大佬搞了一个日志框架 log4j后来( log4j成为Apache项目，Ceki加入Apache组织 Apache还曾经建议Sun引入Log4j到Java的标准库中，但Sun拒绝了.</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/3bd956b4a3e905be00f003e0f3600fb4.png" alt="image-20211212211243016"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-3"><p>Sun有自己的小心思，2002年2月JDK1.4发布，Sun推出了自己的日志标准库JUL(Java Util Logging)，其实是照着Log4j抄的，而且还没抄好，还是在JDK1.5以后性能和可用性才有所提升。由于Log4j比JUL好用，并且成熟，所以Log4j在选择上占据了一定的优势。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-4"><p>2002年8月Apache推出了JCL(Jakarta Commons Logging)，也就是日志抽象层，支持运行时动态加载日志组件的实现，当然也提供一个默认实现Simple Log( ClassLoader 中进行查找，如果能找到Log4j则默认使用log4j实现，如果没有则使用JUL实现，再没有则使用JCL内部提供的 Simple Log实现)。</p><p>但是JUL有三个缺点:</p><p>1．效率较低。 </p><p>2．容易引发混乱。</p><p> 3．使用了自定义ClassLoader的程序中，使用JCL会引发内存泄露。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/bVbAMyv.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-5"><p>2006年巨佬Ceki( Log4j的作者）因为一些原因离开了Apache组织，之后Ceki觉得JCL不好用，自己搀了一套新的日志标准接口规范Slf4j (Simple Logging Facacfor Java)，也可以称为日志门面，很明显Slf4j是对标JCL，后面也证明了Slf4j比JCL更优秀。 巨佬Ceki提供了一系列的桥接包来帮助Slf4j接口与其他日志库建立关系，这种方式称桥接设计模式。 代码使用Slf4j接口，就可以实现日志的统一标准化，后续如果想要更换日志实现，只需引入Slf4j与相关的桥接包，再引入具体的日志标准库即可。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-6"><p>但是由于<code>Slf4j</code>出来的较晚，而且还只是一个日志接口，所以之前已经出现的日志产品，如<code>JUL</code>和<code>Log4j</code>都是没有实现这个接口的，所以尴尬的是光有一个接口，没有实现的产品也是很憋屈啊，就算开发者想用<code>Slf4j</code>也是用不了。</p><p>于是大佬<strong>Ceki Gülcü</strong>撸出了之前提到的桥接包，于是日志系统现在有了这样的结构</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/bVbAMzq.png" alt="image.png" style="zoom:50%;" /></p><p>但是其实之前很多<code>Java</code>应用应该依赖的<code>JCL</code>，所以光有日志产品桥接包，好像还不够<strong>Ceki Gülcü</strong>：没问题，不就是不够桥接包么，我写，我来证明Slf4j是最完美的。</p><p>于是有了<code>JCL</code>的桥接包</p><p><img src="https://segmentfault.com/img/bVbAMA9" alt="image.png" style="zoom:50%;" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-7"><p>由于使用<code>Slf4j</code>，需要一次桥接包，也就是之前的日志产品都不是正统的<code>Slf4j</code>的实现，因此，2006年，出自<strong>Ceki Gülcü</strong>之手的日志产品<code>Logback</code>应运而生</p><p><code>Logback</code>是完美实现了<code>Slf4j</code>，于是现在日志系统变成了</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/bVbAMUJ.png" alt="未命名文件 (4).png" style="zoom:50%;" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="429b6ca4-4b72-4496-bb40-135bd75ba457-8"><p>2012年，Apache直接推出新项目Log4j2(不兼容Log4j) , Log4j2全面借鉴Slf4j+Logback 。 Log4j2不仅仅具有Logback的所有特性，还做了分离设计，分为log4j-api和log4j-core，log4j-api是日志接口，log4j-core是日志标准库，并且Apache也为Log4j2提供了各种桥接包。</p><p>而且log4j2 的性能提升很大，而且支持异步日志打印。增加很多新的特性。</p><p><img src="https://segmentfault.com/img/bVcTphN" alt="img" style="zoom: 67%;" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="Slf4j的使用"><a href="#Slf4j的使用" class="headerlink" title="Slf4j的使用"></a>Slf4j的使用</h2><h3 id="Slf4j与其它日志组件的关系说明"><a href="#Slf4j与其它日志组件的关系说明" class="headerlink" title="Slf4j与其它日志组件的关系说明"></a>Slf4j与其它日志组件的关系说明</h3><p>Slf4j的设计思想比较简洁，使用了Facade设计模式，Slf4j本身只提供了一个<code>slf4j-api-version.jar</code>包，这个jar中主要是日志的抽象接口，jar中本身并没有对抽象出来的接口做实现。</p><p>对于不同的日志实现方案(例如Logback，Log4j…)，封装出不同的桥接组件(例如logback-classic-version.jar，slf4j-log4j12-version.jar)，这样使用过程中可以灵活的选取自己项目里的日志实现。</p><hr><h3 id="Slf4j与其它日志组件集成图"><a href="#Slf4j与其它日志组件集成图" class="headerlink" title="Slf4j与其它日志组件集成图"></a>Slf4j与其它日志组件集成图</h3><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20231225145318031.png" alt="image-20231225145318031" style="zoom:67%;" /></p><p>如图所示，应用调了sl4j-api，即<strong>日志门面接口</strong>。日志门面接口本身通常并没有实际的日志输出能力，它底层还是需要去调用具体的日志框架API的，也就是实际上它需要跟具体的日志框架结合使用。由于具体日志框架比较多，而且互相也大都不兼容，日志门面接口要想实现与任意日志框架结合可能需要对应的桥接器，上图红框中的组件即是对应的各种桥接器！</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>jar包名</strong></th><th style="text-align:center"><strong>说明</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>slf4j-log4j12-1.7.30.jar</strong></td><td style="text-align:center">Log4j1.2版本的桥接器，你需要将Log4j.jar加入Classpath。</td></tr><tr><td style="text-align:center"><strong>slf4j-jdk14-1.7.30.jar</strong></td><td style="text-align:center">java.util.logging的桥接器，Jdk原生日志框架。</td></tr><tr><td style="text-align:center"><strong>slf4j-nop-1.7.30.jar</strong></td><td style="text-align:center">NOP桥接器，默默丢弃一切日志。</td></tr><tr><td style="text-align:center"><strong>slf4j-simple-1.7.30.jar</strong></td><td style="text-align:center">一个简单实现的桥接器，该实现输出所有事件到System.err. 只有Info以及高于该级别的消息被打印，在小型应用中它也许是有用的。</td></tr><tr><td style="text-align:center"><strong>slf4j-jcl-1.7.30.jar</strong></td><td style="text-align:center">Jakarta Commons Logging 的桥接器. 这个桥接器将Slf4j所有日志委派给Jcl。</td></tr><tr><td style="text-align:center"><strong>logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar)</strong></td><td style="text-align:center">Slf4j的原生实现，Logback直接实现了Slf4j的接口，因此使用Slf4j与Logback的结合使用也意味更小的内存与计算开销</td></tr></tbody></table></div><hr><h2 id="Slf4j源码分析"><a href="#Slf4j源码分析" class="headerlink" title="Slf4j源码分析"></a>Slf4j源码分析</h2><blockquote><p>slf4j-api-version.jar中几个核心类与接口</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>类与接口</strong></th><th style="text-align:center"><strong>用途</strong></th></tr></thead><tbody><tr><td style="text-align:center">org.slf4j.LoggerFactory(class)</td><td style="text-align:center">给调用方提供的创建Logger的工厂类，在编译时绑定具体的日志实现组件</td></tr><tr><td style="text-align:center">org.slf4j.Logger(interface)</td><td style="text-align:center">给调用方提供的日志记录抽象方法，例如debug(String msg),info(String msg)等方法</td></tr><tr><td style="text-align:center">org.slf4j.ILoggerFactory(interface)</td><td style="text-align:center">获取的Logger的工厂接口，具体的日志组件实现此接口</td></tr><tr><td style="text-align:center">org.slf4j.helpers.NOPLogger(class)</td><td style="text-align:center">对org.slf4j.Logger接口的一个没有任何操作的实现，也是Slf4j的默认日志实现</td></tr><tr><td style="text-align:center">org.slf4j.impl.StaticLoggerBinder(class)</td><td style="text-align:center">与具体的日志实现组件实现的桥接类，具体的日志实现组件需要定义org.slf4j.impl包，并在org.slf4j.impl包下提供此类，注意在slf4j-api-version.jar中不存在org.slf4j.impl.StaticLoggerBinder，在源码包slf4j-api-version-source.jar中才存在此类</td></tr></tbody></table></div><hr><p><a href="https://juejin.cn/post/6905026199722917902#heading-19">https://juejin.cn/post/6905026199722917902#heading-19</a></p><p><a href="https://www.cnblogs.com/FlyAway2013/p/10691936.html">https://www.cnblogs.com/FlyAway2013/p/10691936.html</a></p><p><a href="https://juejin.cn/post/6939478456287625246">https://juejin.cn/post/6939478456287625246</a></p>]]></content>
    
    
    <summary type="html">Java日志体系</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JUC&amp;JVM面试题</title>
    <link href="https://wuwawawa.github.io/posts/c7a2e76a.html"/>
    <id>https://wuwawawa.github.io/posts/c7a2e76a.html</id>
    <published>2023-12-14T07:27:31.000Z</published>
    <updated>2024-03-04T11:56:53.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><div class="tag link"><a class="link-card" title="关键字: synchronized详解" href="https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/favicon.png"/></div><div class="right"><p class="text">关键字: synchronized详解</p><p class="url">https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</p></div></a></div><div class="tag link"><a class="link-card" title="锁进阶" href="/posts/3f9c0b8e.html#8-2-轻量级锁"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/favicon.png"/></div><div class="right"><p class="text">锁进阶</p><p class="url">/posts/3f9c0b8e.html#8-2-轻量级锁</p></div></a></div><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><details class="folding-tag" cyan close><summary> 线程池常见参数有哪些？ </summary>              <div class='content'>              <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20240302151707280.png" alt="image-20240302151707280" style="zoom:50%;" /></p>              </div>            </details><hr><details class="folding-tag" green close><summary> 线程池execute和submit有何区别？  出现异常时有何不同？ </summary>              <div class='content'>              <p>submit方法和execute方法最大的不同点在于submit方法可以获取到任务返回值或任务异常信息，execute方法不能获取任务返回值和异常信息。</p><p>执行 <code>execute</code> 方法，当任务抛出异常时，当前线程会终止，且会打印异常信息。</p><p>执行 <code>submit</code> 方法，当任务抛出异常时，当前线程不会终止，不会打印异常信息，只有在调用 get 方法的时候，才会打印异常信息。</p><p>解决方法:</p><blockquote><p>1.使用try-catch代码块</p></blockquote><p>在线程的 run() 方法中加入 try-catch 代码块，避免运行时异常，同时可以在 catch 块中记录异常日志。</p><p>线程池中的任务抛出的异常会被自身的 try-catch 代码块捕获，从而防止工作线程因异常而意外退出。这意味着 processWorkerExit 方法不会被执行。</p><blockquote><p>2.线程设置UncaughtExceptionHandler</p></blockquote><p>在第一个方法中，每个任务都需要手动添加 try-catch 代码块，这样做非常麻烦且不保险。如果有人忘记了添加 try-catch 代码块，在任务出现异常时，线程池会频繁删除异常的工作线程并创建新的工作线程，这样会严重影响线程池的性能。</p><p>可以使用 Thread.setDefaultUncaughtExceptionHandler 方法设置一个全局默认的未捕获异常处理器，该处理器会适用于所有线程。无论是主线程还是创建的其他线程，在发生未捕获异常时都将被该处理器处理。</p><p>但是该方法有两个问题：</p><ol><li>当 submit 方法提交的任务出现异常时，仍然无法处理该异常。</li><li>线程池仍然会删除异常的工作线程并创建新的工作线程，这并没有避免线程池的性能损耗。</li></ol><p>所以不推荐使用未捕获异常处理器来处理线程异常</p><blockquote><p>3.继承ThreadPoolExecutor重写afterExecute方法</p><p>4.实现ThreadFactory，自定义线程工厂类（推荐）</p></blockquote><p>自定义线程工厂方法，为每一个 run 方法添加 try-catch 代码块</p><p>显然，当使用 submit 方法提交的任务出现异常时，仍然无法进行处理。然而，我仍然推荐使用这种方式，因为它至少解决了在 execute 方法中任务出现异常的情况。对于 FutureTask 的异常，调用方需要自行处理，因为 FutureTask 设计的本意就是将结果交给调用方处理，这个结果也包含异常。</p>              </div>            </details><hr><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><details class="folding-tag" blue close><summary> Thread、ThreadLocal和ThreadLocalMap关系？ </summary>              <div class='content'>              <ul><li>Thread类中有一个ThreadLocal.ThreadLocalMap threadLocals = null的变量,这个ThreadLocal相当于是Thread类和ThreadLocalMap的桥梁,在ThreadLocal中有静态内部类ThreadLocalMap,ThreadLocalMap中有Entry数组</li><li><span class='p blue'>当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry，往当前线程的threadLocalMap中存放</span></li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230405210717894.png" alt="image-20230405210717894" style="zoom:50%;" /></p><p>ThreadLocalMap从字面上就可以看出这是一个保存ThreadLocal对象的map(其实是以ThreadLocal为Key)，不过是经过了两层包装的ThreadLocal对象。</p>              </div>            </details><hr><details class="folding-tag" blue close><summary> 为什么 ThreadLocalMap 的 Entry 中的 key 设置为弱引用？ </summary>              <div class='content'>              <p>强软弱虚</p><p>ThreadLocalMap的Entry对ThreadLocal的的引用为弱引用，避免了ThreadLocal对象无法被回收的问题。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230405230616586.png" alt="image-20230405230616586" style="zoom:50%;" /></p><p>value为强引用，如果不清理Entry可能会照成泄漏。</p><p>养成习惯用完就remove。</p>              </div>            </details><hr><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><details class="folding-tag" cyan close><summary> 类加载过程？类变量和类常量分别什么时候初始化和赋值？ </summary>              <div class='content'>                            </div>            </details><hr><details class="folding-tag" green close><summary> new一个对象的过程？ </summary>              <div class='content'>              <p>当虚拟机遇见new关键字的时候，首先判断该类是否已经加载，如果类没有加载，那么先执行类的加载机制，加载完成后再为对象分配空间、初始化等。详细过程如下：</p><p>　　1、加载阶段：</p><p>　　　　1）首先检查当前类是否被加载，如果没有被加载，执行类的加载机制</p><p>　　　　2）加载：就是将类的字节码文件，即class文件读入内存，并为之创建一个Class对象</p><p>　　　　3）验证：校验class文件是否符合虚拟机规范</p><p>　　　　4）准备：为静态变量赋默认值</p><p>　　　　5）解析：虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>　　　　6）初始化：给静态变量赋定义的值、执行静态代码块，如果存在父类，先对父类进行初始化</p><p>　　2、创建对象分配内存空间</p><p>　　　　1）首先为对象在堆中分配大小合适的内存空间</p><p>　　　　2）接着为实例变量赋默认值</p><p>　　　　3）设置对象的头信息、对象hash码、GC分代年龄、元数据信息等</p><p>　　　　4）属性的显示初始化、代码块中初始化、构造器中初始化</p>              </div>            </details><hr><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><details class="folding-tag" cyan close><summary> 栈、堆、方法区的交互关系 </summary>              <div class='content'>              <ol><li>Person 类的 .class 信息存放在方法区中</li><li>person 变量存放在 Java 栈的局部变量表中</li><li>真正的 person 对象存放在 Java 堆中</li><li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/b9f11764ee47b28d37f7764dfd9c9f55.png" style="zoom:50%;" /></p>              </div>            </details><hr><details class="folding-tag" green close><summary> 常量池、运行时常量池和字符串常量池   演进 itern() </summary>              <div class='content'>              <p>当类加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时常量池中，每个.class对应有一个运行时常量池。</p><p><mark class="hl-label red">JDK6</mark> </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1a3aa55257c3150d78327542e5ca230e.png" alt="image-20200708211541300" style="zoom:50%;" /></p><p><mark class="hl-label blue">JDK7</mark> </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/e0f65fc4228d9b6573ae1b23d9a1558b.png" alt="image-20200708211609911" style="zoom:50%;" /></p><p><mark class="hl-label pink">JDK8</mark> </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/c3ed969b0d2bad704c22481208e5dd10.png" alt="image-20200708211637952" style="zoom:50%;" /></p><p>jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p><ul><li>将String常量池 从 Perm 区移动到了 Java Heap区</li><li><code>String#intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象（而JDK6会创建）。</li></ul><p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p>              </div>            </details><hr><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><details class="folding-tag" cyan close><summary> 哪些对象可以作为 GC Roots 呢？ </summary>              <div class='content'>              <p>虚拟机栈(栈帧中的局部变量表)中引用的对象</p><p>本地方法栈(Native 方法)中引用的对象</p><p>方法区中类静态属性引用的对象</p><p>方法区中常量引用的对象</p><p>所有被同步锁持有的对象</p><p>JNI（Java Native Interface）引用的对象</p>              </div>            </details>]]></content>
    
    
    <summary type="html">JUC&amp;JVM面试题</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="面试题" scheme="https://wuwawawa.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java基础面试题</title>
    <link href="https://wuwawawa.github.io/posts/2e67a3f3.html"/>
    <id>https://wuwawawa.github.io/posts/2e67a3f3.html</id>
    <published>2023-12-14T05:45:41.000Z</published>
    <updated>2024-03-04T01:42:37.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><details class="folding-tag" cyan close><summary> 使用foreach内部进行删除，为什么会抛出异常 </summary>              <div class='content'>              <p>迭代器在遍历是直接访问集合中的内容，并且在遍历过程中使用了一个<code>modCount</code>变量。集合在被遍历期间，如果它的内容发生了变化，就会改变<code>modCount</code>变量的值。迭代器在使用<code>hashNext()/next()</code>遍历下一个元素之前，会检测<code>modCount</code>变量是否为预期值，是就返回遍历，否则抛出<code>ConcurrentModificationException</code>异常    </p><p>正确的方式是使用 迭代器 对元素进行删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="number">1</span>);</span><br><span class="line">        add(<span class="number">2</span>);</span><br><span class="line">        add(<span class="number">3</span>);</span><br><span class="line">        add(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">cur</span> <span class="operator">=</span> it.next();</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">2</span>) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="List集合的遍历方式" href="/posts/494ad091.html#List集合的遍历方式"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/favicon.png"/></div><div class="right"><p class="text">List集合的遍历方式</p><p class="url">/posts/494ad091.html#List集合的遍历方式</p></div></a></div><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230516205838333.png" alt="image-20230516205838333" style="zoom: 50%;" /></p>              </div>            </details><hr><details class="folding-tag" green close><summary> 增强for循环的底层实现原理 </summary>              <div class='content'>              <p>增强for循环是JAVA提供的语法糖，虽然增强for循环通过迭代器实现，但是删除元素还是得通过迭代器来进行删除。</p><p>以下代码进行反编译</p><div class="tabs" id="12d75644-1286-4f09-9156-e500ad2a10df"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#12d75644-1286-4f09-9156-e500ad2a10df-1"><i class="fas fa-seedling"></i>原代码</button></li><li class="tab"><button type="button" data-href="#12d75644-1286-4f09-9156-e500ad2a10df-2"><i class="fas fa-leaf"></i>反编译后</button></li><li class="tab"><button type="button" data-href="#12d75644-1286-4f09-9156-e500ad2a10df-3"><i class="fab fa-apple"></i>分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="12d75644-1286-4f09-9156-e500ad2a10df-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">   System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="12d75644-1286-4f09-9156-e500ad2a10df-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator(); iterator.hasNext(); System.out.println(i))&#123;</span><br><span class="line">   i = (Integer)iterator.next();        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="12d75644-1286-4f09-9156-e500ad2a10df-3"><p>反编译后的代码其实比较复杂，我们按照执行顺序拆解一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer i; 定义一个临时变量i</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator(); 获取List的迭代器</span><br><span class="line">iterator.hasNext(); 判断迭代器中是否有未遍历过的元素</span><br><span class="line">i = (Integer)iterator.next(); 获取第一个未遍历的元素，赋值给临时变量i</span><br><span class="line">System.out.println(i) 输出临时变量i的值</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><hr><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><details class="folding-tag" cyan close><summary> HashMap1.7数据结构、插入方式、扩容并发死链问题 </summary>              <div class='content'>              <p>数据结构：数组+单向链表</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-e326681a8e66e07a23e1cf45d4686001_1440w.webp" alt="img" style="zoom:33%;" /></p><p>插入方式：头插法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">//取出索引位置的元素</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">//将新的元素放置到索引位，同时将原节点的作为新元素的next，形成单向链表</span></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-b7d6d61af1a3887611c01e91a1ac5784_1440w.webp" alt="img" style="zoom:33%;" /></p><blockquote><p>正常情况下扩容</p></blockquote><p>HashMap正常情况下的扩容实现如下图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-ad1f36eb1b79f629ca500c73987c4531_1440w.webp" alt="img" style="zoom:33%;" /></p><p>旧HashMap的节点会依次转移到新HashMap中，旧HashMap转移的顺序是A、B、C，而新HashMap使用的是头插法，所以最终在新HashMap中的顺序是C、B、A，也就是上图展示的那样。</p><blockquote><p>并发扩容死链</p></blockquote><p><mark class="hl-label blue">步骤一</mark> </p><p>死循环是因为并发HashMap扩容导致的，并发扩容的第一步，线程T1和线程T2要对HashMap进行扩容操作，此时T1和T2指向的是链表的头结点元素A，而T1和T2的下一个节点，也就是T1.next和T2.next指向的是B节点，如下图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-e0b4f5ea00cb277bde490f315b9b387f_1440w.webp" alt="img" style="zoom:33%;" /></p><p><mark class="hl-label red">步骤二</mark> </p><p>死循环的第二步操作是，线程T2时间片用完进入休眠状态，而线程T1开始执行扩容操作，一直到线程T1扩容完成后，线程T2才被唤醒，扩容之后的场景如下图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-5f78d8ac8af1efc79e7d79a1f3fdc154_1440w.webp" alt="img" style="zoom:33%;" /></p><p>从上图可知线程T1执行之后，因为是头插法，所以HashMap的顺序已经发生了改变，但线程T2对于发生的一切是不可知的，所以它的指向元素依然没变，如上图展示的那样，T2指向的是A元素，T2.next指向的节点是B元素。</p><p><mark class="hl-label pink">步骤三</mark> </p><p>当线程T1执行完，而线程T2恢复执行时，死循环就建立了，如下图所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/v2-bd4a753db8c985119aa4dcd4356609cf_1440w.webp" alt="img" style="zoom:33%;" /></p><p>因为T1执行完扩容之后B节点的下一个节点是A，而T2线程指向的首节点是A，第二个节点是B，这个顺序刚好和T1扩完容完之后的节点顺序是相反的。<strong>T1执行完之后的顺序是B到A，而T2的顺序是A到B，这样A节点和B节点就形成死循环了</strong>，这就是HashMap死循环导致的原因。</p>              </div>            </details><hr><details class="folding-tag" cyan close><summary> HashMap1.8数据结构、插入方式、并发元素丢失 </summary>              <div class='content'>              <p>数据结构：数组+单向链表+红黑树+双向链表</p><p>插入方式：尾插法</p><p>并发元素丢失</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素时，会有数据覆盖丢失数据</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//此处，如果多个线程向同一个位置存入元素，会有值覆盖的问题，导致数丢失</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面代码省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容时，迁移数据的情况下，会有数据覆盖丢失的问题</span></span><br><span class="line"><span class="comment">// 多线程环境下，给同一个数组的相同位置赋值，会有数据覆盖的风险</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">    loTail.next = <span class="literal">null</span>;</span><br><span class="line">    newTab[j] = loHead;  <span class="comment">//将原始索引位的数据迁移到新数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="literal">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead; <span class="comment">//将新索引位的数据迁移到新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><hr><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><details class="folding-tag" cyan close><summary> HashMap、HashTable、ConcurrentHashMap区别 </summary>              <div class='content'>              <blockquote><p>HashMap</p></blockquote><p> HashMap 是线程不安全的，在多线程环境下，使用 Hashmap 进行 put 操作会引起死循环，导致 CPU 利用率接近 100%，所以在并发情况下不能使用 HashMap。</p><blockquote><p>HashTable</p></blockquote><p>HashTable 和 HashMap 的实现原理几乎一样，差别无非是</p><ul><li>HashTable 不允许 key 和 value 为 null</li><li>HashTable 是线程安全的 但是 HashTable 线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁。</li></ul><p>多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</p><blockquote><p>ConcurrentHashMap</p></blockquote><p>主要就是为了应对 <code>HashMap</code> 在并发环境下不安全而诞生的， <code>ConcurrentHashMap</code> 的设计与实现非常精巧，大量的利用了 <code>volatile</code>，<code>final</code>， <code>CAS</code> 等无锁技术来减少锁竞争对于性能的影响。</p>              </div>            </details><details class="folding-tag" green close><summary> 1.7、1.8 ConcurrentHashMap对比 </summary>              <div class='content'>              <div class="tabs" id="794a187f-5e35-4305-96f0-a006bcf78cf1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#794a187f-5e35-4305-96f0-a006bcf78cf1-1"><i class="fas fa-seedling"></i>JDK1.7</button></li><li class="tab"><button type="button" data-href="#794a187f-5e35-4305-96f0-a006bcf78cf1-2"><i class="fas fa-leaf"></i>JDK1.8</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="794a187f-5e35-4305-96f0-a006bcf78cf1-1"><p>在 JDK1.7 中 ConcurrentHashMap 采用了数组+Segment+分段锁的方式实现。</p><p><strong>1.Segment(分段锁)</strong><br> ConcurrentHashMap 中的分段锁称为 Segment，它即类似于 HashMap 的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表,同时又是一个 ReentrantLock（Segment 继承了 ReentrantLock）。</p><p><strong>2.内部结构</strong><br> ConcurrentHashMap 使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是 ConcurrentHashMap 的内部结构图：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20240228161103148.png" alt="image-20240228161103148" style="zoom: 33%;" /></p><p>从上面的结构我们可以了解到，ConcurrentHashMap 定位一个元素的过程需要进行两次 Hash 操作。第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部。</p><p><strong>3.该结构的优劣势</strong><br> <strong>坏处:</strong><br> 这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长<br> <strong>好处:</strong><br> 写操作的时候可以只对元素所在的 Segment 进行加锁即可，不会影响到其他的 Segment，这样，在最理想的情况下，ConcurrentHashMap 可以最高同时支 持 Segment 数量大小的写操作（刚好这些写操作都非常平均地分布在所有的 Segment 上）。</p><p>所以，通过这一种结构，ConcurrentHashMap 的并发能力可以大大的提高。</p><p>计算元素个数前，先不加锁计算两次，如果前后两次结果如一样，认为个数正确返回</p><p>如果不一样，进行重试，重试次数超过 3，将所有 segment 锁住，重新计算个数返回</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="794a187f-5e35-4305-96f0-a006bcf78cf1-2"><p>JDK8 中 ConcurrentHashMap 参考了 JDK8 HashMap 的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用 CAS 操作。</p><p>Java8 ConcurrentHashMap 结构基本上和 Java8 的 HashMap 一样，不过保证线程安全性。</p><p>其实可以看出 JDK1.8 版本的 ConcurrentHashMap 的数据结构已经接近 HashMap，相对而言，ConcurrentHashMap 只是增加了同步的操作来控制并发，从 JDK1.7 版本的 ReentrantLock+Segment+HashEntry，到 JDK1.8 版本中 synchronized+CAS+HashEntry+红黑树。</p><ol><li>数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</li><li>保证线程安全机制：JDK1.7 采用 segment 的分段锁机制实现线程安全，其中 segment 继承自 ReentrantLock。JDK1.8 采用 CAS+Synchronized 保证线程 安全。</li><li>锁的粒度：原来是对需要进行数据操作的 Segment 加锁，现调整为对每个数组元素加锁（Node）。</li><li>链表转化为红黑树:定位结点的 hash 算法简化会带来弊端,Hash 冲突加剧,因此在链表节点数量大于 8 时，会将链表转化为红黑树进行存储。</li><li>查询时间复杂度：从原来的遍历链表 O(n)，变成遍历红黑树O(logN)。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details>]]></content>
    
    
    <summary type="html">Java基础面试题</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="面试题" scheme="https://wuwawawa.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring面试题</title>
    <link href="https://wuwawawa.github.io/posts/489ef953.html"/>
    <id>https://wuwawawa.github.io/posts/489ef953.html</id>
    <published>2023-12-08T06:04:44.000Z</published>
    <updated>2024-03-05T03:39:54.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring-IOC"></a>Spring-IOC</h2><details class="folding-tag" blue close><summary> Spring refresh 流程 </summary>              <div class='content'>              <p>refresh 是 <code>AbstractApplicationContext</code> 中的一个方法，负责初始化 <code>ApplicationContext</code> 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：</p><ol><li><code>prepareRefresh</code></li><li><code>obtainFreshBeanFactory</code></li><li><code>prepareBeanFactory</code></li><li><code>postProcessBeanFactory</code></li><li><code>invokeBeanFactoryPostProcessors</code></li><li><code>registerBeanPostProcessors</code></li><li><code>initMessageSource</code></li><li><code>initApplicationEventMulticaster</code></li><li><code>onRefresh</code></li><li><code>registerListeners</code></li><li><code>finishBeanFactoryInitialization</code></li><li><code>finishRefresh</code></li></ol><p>1 为准备环境</p><p>2 3 4 5 6 为准备 <code>BeanFactory</code></p><p>7 8 9 10 12 为准备 <code>ApplicationContext</code></p><p>11 为初始化 <code>BeanFactory</code> 中非延迟单例 bean</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/refresh%E6%B5%81%E7%A8%8B.png" alt="refresh流程"></p>              </div>            </details><hr><details class="folding-tag" cyan close><summary> Bean的生命周期？ </summary>              <div class='content'>              <p>Instantiate 实例化</p><p>Initialize 初始化</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/2Bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="2Bean 生命周期"></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20240301114922096.png" alt="image-20240301114922096"></p>              </div>            </details><hr><details class="folding-tag" blue close><summary> set循环依赖、二级缓存就已经可以解决循环依赖了为什么还需要三级缓存呢？ </summary>              <div class='content'>              <p><a href="#jump">代理对象创建的时机↓↓↓</a></p><p><mark class="hl-label blue">一级缓存</mark> </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903100752165.png" alt="image-20210903100752165" style="zoom:80%;" /></p><p>作用是保证单例对象仅被创建一次</p><ul><li>第一次走 <code>getBean(&quot;a&quot;)</code> 流程后，最后会将成品 a 放入 singletonObjects 一级缓存</li><li>后续再走 <code>getBean(&quot;a&quot;)</code> 流程时，先从一级缓存中找，这时已经有成品 a，就无需再次创建</li></ul><p><mark class="hl-label blue">一级缓存与循环依赖</mark> </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903100914140.png" alt="image-20210903100914140" style="zoom:80%;" /></p><p>一级缓存无法解决循环依赖问题，分析如下</p><ul><li>无论是获取 bean a 还是获取 bean b，走的方法都是同一个 getBean 方法，假设先走 <code>getBean(&quot;a&quot;)</code></li><li>当 a 的实例对象创建，接下来执行 <code>a.setB()</code> 时，需要走 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 1</li><li>当 b 的实例对象创建，接下来执行 <code>b.setA()</code> 时，又回到了 <code>getBean(&quot;a&quot;)</code> 的流程，红色箭头 2</li><li>但此时 singletonObjects 一级缓存内没有成品的 a，陷入了死循环</li></ul><p><mark class="hl-label pink">二级缓存</mark> </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903101849924.png" alt="image-20210903101849924" style="zoom:80%;" /></p><p>解决思路如下：</p><ul><li>再增加一个 singletonFactories 缓存</li><li>在依赖注入前，即 <code>a.setB()</code> 以及 <code>b.setA()</code> 将 a 及 b 的半成品对象（未完成依赖注入和初始化）放入此缓存</li><li>执行依赖注入时，先看看 singletonFactories 缓存中是否有半成品的对象，如果有拿来注入，顺利走完流程</li></ul><p>对于上面的图</p><ul><li><code>a = new A()</code> 执行之后就会把这个半成品的 a 放入 singletonFactories 缓存，即 <code>factories.put(a)</code></li><li>接下来执行 <code>a.setB()</code>，走入 <code>getBean(&quot;b&quot;)</code> 流程，红色箭头 3</li><li>这回再执行到 <code>b.setA()</code> 时，需要一个 a 对象，有没有呢？有！</li><li><code>factories.get()</code> 在 singletonFactories  缓存中就可以找到，红色箭头 4 和 5</li><li>b 的流程能够顺利走完，将 b 成品放入 singletonObject 一级缓存，返回到 a 的依赖注入流程，红色箭头 6</li></ul><p><mark class="hl-label pink">二级缓存与创建代理</mark> </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903103030877.png" alt="image-20210903103030877" style="zoom:80%;" /></p><p>二级缓存的场景<span class='p red'>无法正确处理循环依赖并且包含有代理创建</span>，分析如下</p><ul><li>spring 默认要求，在 <code>a.init</code> 完成之后才能创建代理 <code>pa = proxy(a)</code></li><li>由于 a 的代理创建时机靠后，在执行 <code>factories.put(a)</code> 向 singletonFactories 中放入的还是原始对象</li><li>接下来箭头 3、4、5 这几步 b 对象拿到和注入的都是原始对a象</li></ul><p><mark class="hl-label red">三级缓存</mark> </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903103628639.png" alt="image-20210903103628639"></p><p>简单分析的话，只需要将代理的创建时机放在依赖注入之前即可，但 spring 仍然希望代理的创建时机在 init 之后，只有出现循环依赖时，才会将代理的创建时机提前。所以解决思路稍显复杂：</p><ul><li>图中 <code>factories.put(fa)</code> 放入的既不是原始对象，也不是代理对象而是工厂对象 fa</li><li>当检查出发生循环依赖时，fa 的产品就是代理 pa，没有发生循环依赖，fa 的产品是原始对象 a</li><li>假设出现了循环依赖，拿到了 singletonFactories 中的工厂对象，通过在依赖注入前获得了 pa，红色箭头 5</li><li>这回 <code>b.setA()</code> 注入的就是代理对象，保证了正确性，红色箭头 7</li><li>还需要把 pa 存入新加的 earlySingletonObjects 缓存，红色箭头 6</li><li><code>a.init</code> 完成后，无需二次创建代理，从哪儿找到 pa 呢？earlySingletonObjects 已经缓存，蓝色箭头 9</li></ul><p>当成品对象产生，放入 singletonObject 后，singletonFactories 和 earlySingletonObjects 就中的对象就没有用处，清除即可</p>              </div>            </details><hr><details class="folding-tag" yellow close><summary> 构造循环依赖如何解决？ 三级缓存能否解决？ </summary>              <div class='content'>              <p>无法用三级缓存解决</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903085906315.png" alt="image-20210903085906315"  /></p><p><mark class="hl-label blue">注入代理对象，通过代理对象访问</mark> </p><p>a 注入 b 的代理对象，这样能够保证 a 的流程走通。后续需要用到 b 的真实对象时，可以通过代理间接访问</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903091627659.png" alt="image-20210903091627659" style="zoom: 50%;" /></p><p>用 <code>@Lazy</code> 为构造方法参数生成代理</p><p>或<code>@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)</code></p><p><mark class="hl-label pink">注入工厂对象，延迟对象创建</mark> </p><p>a 注入 b 的工厂对象，让 b 的实例创建被推迟，这样能够保证 a 的流程先走通。后续需要用到 b 的真实对象时，再通过 ObjectFactory 工厂间接访问</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903091743366.png" alt="image-20210903091743366" style="zoom:50%;" /></p><p>用 ObjectProvider 延迟依赖对象的创建</p>              </div>            </details><hr><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring-AOP"></a>Spring-AOP</h2><details class="folding-tag" cyan close><summary> 什么是代理模式?聊聊JDK和CGLib动态代理实现和区别? </summary>              <div class='content'>              <p>代理模式是一种比较好理解的设计模式。 简单来说就是我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>Java中的代理按照代理类生成时机不同又分为<code>静态代理</code>和<code>动态代理</code>。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有<code>JDK代理</code>和<code>CGLib代理</code>两种。</p><hr><p><mark class="hl-label blue">JDK动态代理</mark> </p><p><code>JDK</code>的动态代理是基于<strong>反射</strong>实现。<code>JDK</code>通过反射，生成一个代理类，这个代理类实现了原来那个类的全部接口，并对接口中定义的所有方法进行了代理。当我们通过代理对象执行原来那个类的方法时，代理类底层会通过反射机制，回调我们实现的<code>InvocationHandler</code>接口的<code>invoke</code>方法。并且这个代理类是Proxy类的子类。这就是<code>JDK</code>动态代理大致的实现方式。</p><p>优点:</p><ol><li><code>JDK</code>动态代理是<code>JDK</code>原生的，不需要任何依赖即可使用；</li><li>通过反射机制生成代理类的速度要比<code>CGLib</code>操作字节码生成代理类的速度更快；</li></ol><p>缺点:</p><ol><li>如果要使用<code>JDK</code>动态代理，被代理的类必须实现了接口，否则无法代理()；</li><li><code>JDK</code>动态代理无法为没有在接口中定义的方法实现代理，假设我们有一个实现了接口的类，我们为它的一个不属于接口中的方法配置了切面，<code>Spring</code>仍然会使用<code>JDK</code>的动态代理，但是由于配置了切面的方法不属于接口，为这个方法配置的切面将不会被织入。</li><li><code>JDK</code>动态代理执行代理方法时，需要通过反射机制进行回调，此时方法执行的效率比较低；</li></ol><p>注：JDK代理，代理的是接口，既然代理的是接口，那如果没有实现类怎么办，能不能代理。答案是可以的，Mybatis就是这样的。</p><hr><p><mark class="hl-label green">CGLib动态代理</mark> </p><p><code>CGLib</code>实现动态代理的原理是，底层采用了<code>ASM</code>字节码生成框架，直接对需要代理的类的字节码进行操作，生成这个类的一个子类，并重写了类的所有可以重写的方法，在重写的过程中，将我们定义的额外的逻辑（简单理解为<code>Spring</code>中的切面）织入到方法中，对方法进行了增强。而通过字节码操作生成的代理类，和我们自己编写并编译后的类没有太大区别。</p><p>优点:</p><ol><li>使用<code>CGLib</code>代理的类，不需要实现接口，因为<code>CGLib</code>生成的代理类是直接继承自需要被代理的类；</li><li><code>CGLib</code>生成的代理类是原来那个类的子类，这就意味着这个代理类可以为原来那个类中，所有能够被子类重写的方法进行代理；</li><li><code>CGLib</code>生成的代理类，和我们自己编写并编译的类没有太大区别，对方法的调用和直接调用普通类的方式一致，所以<code>CGLib</code>执行代理方法的效率要高于<code>JDK</code>的动态代理；</li></ol><p>缺点:</p><ol><li>由于<code>CGLib</code>的代理类使用的是继承，这也就意味着如果需要被代理的类是一个<code>final</code>类，则无法使用<code>CGLib</code>代理；</li><li>由于<code>CGLib</code>实现代理方法的方式是重写父类的方法，所以无法对<code>final</code>方法，或者<code>private</code>方法进行代理，因为子类无法重写这些方法；</li><li><code>CGLib</code>生成代理类的方式是通过操作字节码，这种方式生成代理类的速度要比<code>JDK</code>通过反射生成代理类的速度更慢；</li></ol>              </div>            </details><hr><details class="folding-tag" green close><summary> 代理对象创建的时机? </summary>              <div class='content'>              <p><span id="jump"></span></p><p>Aspect = advice + pointcut ， 一个切面类中可能有一到多个通知方法。</p><p>advisor = 更细粒度的切面，包含一个通知和切点。</p><p>配置的切点、切面都会转换成一个个<code>Advisor</code>对象。</p><p>代理对象内部会保存关联的<code>Advisor</code>对象。</p><p><code>AnnotationAwareAspectJAutoProxyCreator#wrapIfNecessary()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 判断bean是否是切点、切面、通知 这些不进行增强</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create proxy if we have advice. 寻找匹配的切面</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line"><span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">     <span class="comment">// 返回代理对象</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">   <span class="comment">// 没有匹配的切面 不进行增强</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动代理后处理器在哪里会被调用到</p><p>创建阶段 如果传入了TargetSource （了解即可）</p><p>初始化阶段 后处理器代理</p><p>依赖注入阶段 产生了循环依赖 在单例工厂池中通过工厂对象间接调用到后处理器类创建代理</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20240301114922096.png" alt="image-20240301114922096"></p>              </div>            </details><hr><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring-事务"></a>Spring-事务</h2><details class="folding-tag" cyan close><summary> Spring事务失效场景 </summary>              <div class='content'>              <blockquote><p>配置问题</p></blockquote><p><mark class="hl-label blue">数据库不支持事务</mark> </p><p>事务本来就是数据库的功能，如果数据库本身不支持事务，那任凭代码上如何设置也是没用的。以MySQL为例，InnoDB引擎是支持事务的，而像MyISAM、MEMORY等是不支持事务的。从MySQL5.5.5开始默认的存储引擎是InnoDB，之前默认都是MyISAM。</p><hr><p><mark class="hl-label green">未开启事务</mark> </p><p>如果是SpringBoot项目，那么SpringBoot通过DataSourceTransactionManagerAutoConfiguration自动配置类帮我们开启了事务。如果是传统的Spring项目，则需要我们自己配置</p><hr><blockquote><p>Spring-AOP代理</p></blockquote><p><mark class="hl-label blue">事务方法被final或static关键字修饰</mark> </p><p>如果<code>Spring</code>使用了<code>Cglib</code>代理实现（比如你的代理类没有实现接口），而你的业务方法恰好使用了<code>final</code>或者<code>static</code>关键字，那么事务也会失败。更具体地说，它应该抛出异常，因为<code>Cglib</code>使用字节码增强技术生成被代理类的子类并重写被代理类的方法来实现代理。如果被代理的方法的方法使用<code>final</code>或<code>static</code>关键字，则子类不能重写被代理的方法。</p><p>如果<code>Spring</code>使用<code>JDK</code>动态代理实现，<code>JDK</code>动态代理是基于接口实现的，那么<code>final</code>和<code>static</code>修饰的方法也就无法被代理。</p><p>总而言之，方法连代理都没有，那么肯定无法实现事务回滚了。</p><p><strong>解决方案：</strong></p><p>去掉final或者static关键字</p><hr><p><mark class="hl-label green">方法的访问权限不是public</mark> </p><p>如果方法的访问权限不是<code>public</code>，<code>Spring</code>事务也会失败，因为<code>Spring</code>的事务管理源码<code>AbstractFallbackTransactionAttributeSource</code>中有判断<code>computeTransactionAttribute()。</code>如果目标方法不是公共的，则<code>TransactionAttribute</code>返回<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line"><span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p>是将当前方法访问级别更改为<code>public</code></p><hr><p><mark class="hl-label red">同一个类中，方法内部调用</mark> </p><p>事务是通过 <code>Spring AOP</code>代理来实现的，而在同一个类中，一个方法调用另一个方法时， 调用方法直接调用目标方法的代码，而不是通过代理类进行调用，因此事务不生效。</p><p><strong>解决方案：</strong></p><ol><li>依赖注入自己（代理），通过代理类来调用目标方法</li><li>开启<code>@EnableAspectJAutoProxy(exposeProxy = true)</code>，<code>AopContext.currentProxy())</code>得到代理对象，再调用目标方法</li></ol><hr><blockquote><p>错误的异常处理</p></blockquote><p><mark class="hl-label blue">抛出检查异常</mark> </p><p>比如你的事务控制代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>@Transactional</code> 没有特别指定，Spring 只会在遇到运行时异常RuntimeException或者error时进行回滚，而<code>IOException</code>等检查异常不会影响回滚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">rollbackOn</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p>知道原因后，解决方法也很简单。配置<code>rollbackFor</code>属性，例如<code>@Transactional(rollbackFor = Exception.class)</code>。</p><hr><p><mark class="hl-label green">业务方法本身捕获了异常</mark> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">            <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">                accountMapper.update(to, amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种场景下，事务失败的原因也很简单，事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知无法知悉。</p><p><strong>解决方案：</strong></p><ol><li>异常catch后再次抛出</li><li>手动设置 <code>TransactionInterceptor.currentTransactionstatus().setRolLbackOnly();</code></li></ol><hr><p><mark class="hl-label red">AOP切面顺序导致导致异常在切面处处理</mark> </p><p><code>Spring</code>的事务切面优先级最低，所以如果异常被别的切面捕获，Spring也不能正常处理事务，因为事务管理器无法捕获异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* transfer(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        LoggerUtils.get().debug(<span class="string">&quot;log:&#123;&#125;&quot;</span>, pjp.getTarget());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><ol><li>异常catch后再次抛出</li><li>手动设置 <code>TransactionInterceptor.currentTransactionstatus().setRolLbackOnly();</code></li><li>调整切面顺序，在 MyAspect 上添加 <code>@Order(Ordered.LOWEST_PRECEDENCE - 1)</code> （不推荐）</li></ol><hr><blockquote><p>@Transactional相关</p></blockquote><p><mark class="hl-label blue">使用了错误的事务传播机制</mark> </p><p><code>Spring</code>提供了七种事务传播机制，可根据“是否支持当前事务”的维度分为以下 3 类：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image.png" alt="image" style="zoom: 45%;" /></p><p>若propagation属性设置如下三种事务传播行为，事务将不会发生回滚。</p><ul><li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><hr><p><mark class="hl-label green">Transactional没有保证原子行为</mark> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service7</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(Service7.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fromBalance</span> <span class="operator">=</span> accountMapper.findBalanceBy(from);</span><br><span class="line">        logger.debug(<span class="string">&quot;更新前查询余额为: &#123;&#125;&quot;</span>, fromBalance);</span><br><span class="line">        <span class="keyword">if</span> (fromBalance - amount &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            accountMapper.update(from, -<span class="number">1</span> * amount);</span><br><span class="line">            accountMapper.update(to, amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBalance</span><span class="params">(<span class="type">int</span> accountNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findBalanceBy(accountNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实际上是有 bug 的，假设 from 余额为 1000，两个线程都来转账 1000，可能会出现扣减为负数的情况</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903120436365.png" alt="image-20210903120436365" style="zoom: 50%;" /></p><p>如上图所示，红色线程和蓝色线程的查询都发生在扣减之前，都以为自己有足够的余额做扣减</p><p><mark class="hl-label red">针对上面的问题，能否在方法上加synchronized锁来解决呢？</mark> </p><p>答案是不行，原因如下：</p><ul><li>synchronized 保证的仅是目标方法的原子性，环绕目标方法的还有 commit 等操作，它们并未处于 sync 块内</li><li>可以参考下图发现，蓝色线程的查询只要在红色线程提交之前执行，那么依然会查询到有 1000 足够余额来转账</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20210903120800185.png" alt="image-20210903120800185" style="zoom:50%;" /></p><ul><li><p>解法1：synchronized 范围应扩大至代理方法调用</p></li><li><p>解法2：使用 select … for update 替换 select</p></li></ul><hr><blockquote><p>多线程调用</p></blockquote><p>这是因为 <code>Spring</code>事务是基于线程绑定的， 每个线程都有自己的事务上下文，而多线程环境下可能会存在多个线程共享同一个事务上下文的情况，导致事务不生效。 <code>Spring</code>事务管理器通过使用线程本地变量（ <code>ThreadLocal</code>）来实现线程安全。在Spring事务管理器中，通过<code>TransactionSynchronizationManager</code>类来管理事务上下文。<code>TransactionSynchronizationManager</code>内部维护了一个<code>ThreadLocal</code>对象，用来存储当前线程的事务上下文。在事务开始时，<code>TransactionSynchronizationManager</code>会将事务上下文绑定到当前线程的<code>ThreadLocal</code>对象中，当事务结束时，<code>TransactionSynchronizationManager</code>会将事务上下文从<code>ThreadLocal</code>对象中移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">(User user)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子线程执行</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程执行</span></span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程都会将Connection连接放在自己的threadlocal里面，所以@Transactional获取不到子线程的连接，没法回滚</p><p><strong>解决方案：</strong></p><p>父子线程共用一个连接，子线程如果运行出错，要在主线程中获取到并抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomeThing</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.在主线程里获取数据库连接资源</span></span><br><span class="line">    <span class="type">ConnectionHolder</span> <span class="variable">conHolder</span> <span class="operator">=</span></span><br><span class="line">            (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);</span><br><span class="line">    <span class="comment">//子线程执行</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 2.子线程绑定主线程的数据库连接资源</span></span><br><span class="line">        TransactionSynchronizationManager.bindResource(dataSource, conHolder);</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 3.解绑</span></span><br><span class="line">        TransactionSynchronizationManager.unbindResource(dataSource);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//主线程执行</span></span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">    <span class="comment">// 阻塞等待子线程 并拿到子线程的异常 若抛出异常 则join后也会抛出异常</span></span><br><span class="line">    future.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><hr><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><details class="folding-tag" cyan close><summary> Jarlauncher的作用? </summary>              <div class='content'>              <p>在开发环境中通过运行idea中的run方式即可运行SpringBoot应用，也是在开发过程中最常见的一种方式。这种方式启动使用的类加载器为<code>AppClassLoader</code>，所有依赖的jar包都通过<code>-classpath</code>添加至启动参数。</p><p>在生产环境，将Maven插件将项目打成jar包后，可以通过运行命令函参数<code>java -jar</code>的方式运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes -- 应用程序</span><br><span class="line">│   └── lib --项目运行依赖的jar包</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF --清单文件</span><br><span class="line">│   └── maven</span><br><span class="line">└── org</span><br><span class="line">    └── springframework</span><br><span class="line">        └── boot</span><br><span class="line">            └── loader -- 通过打包插件打入</span><br></pre></td></tr></table></figure><p>在清单文件中<code>MANIFEST.MF</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Manifest-Version</span>: <span class="string">1.0</span></span><br><span class="line"><span class="attr">Created-By</span>: <span class="string">Maven JAR Plugin 3.2.2</span></span><br><span class="line"><span class="attr">Build-Jdk-Spec</span>: <span class="string">17</span></span><br><span class="line"><span class="attr">Main-Class</span>: <span class="string">org.springframework.boot.loader.JarLauncher </span></span><br><span class="line"><span class="attr">Start-Class</span>: <span class="string">com.whut.PortApplication </span></span><br><span class="line"><span class="attr">Spring-Boot-Version</span>: <span class="string">3.0.7</span></span><br><span class="line"><span class="attr">Spring-Boot-Classes</span>: <span class="string">BOOT-INF/classes/</span></span><br><span class="line"><span class="attr">Spring-Boot-Lib</span>: <span class="string">BOOT-INF/lib/</span></span><br><span class="line"><span class="attr">Spring-Boot-Classpath-Index</span>: <span class="string">BOOT-INF/classpath.idx</span></span><br><span class="line"><span class="attr">Spring-Boot-Layers-Index</span>: <span class="string">BOOT-INF/layers.idx</span></span><br></pre></td></tr></table></figure><ul><li><code>Main-Class</code>是<code>org.springframework.boot.loader.JarLauncher</code>，即jar启动的Main函数；</li><li><code>Start-Class</code>是<code>com.whut.PortApplication</code> ，即我们自己SpringBoot项目的启动类；</li></ul><p>因为org.springframework.boot.loader.JarLauncher类存在于org.springframework.boot:spring-boot-loader中，所以看源码之前需要先引入maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-loader<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="tabs" id="91a018db-47a9-47db-82d9-fbd971ee6736"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#91a018db-47a9-47db-82d9-fbd971ee6736-1"><i class="fas fa-seedling"></i>JarLauncher源码</button></li><li class="tab"><button type="button" data-href="#91a018db-47a9-47db-82d9-fbd971ee6736-2"><i class="fas fa-leaf"></i>Launcher#launch(args)方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="91a018db-47a9-47db-82d9-fbd971ee6736-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JarLauncher</span> <span class="keyword">extends</span> <span class="title class_">ExecutableArchiveLauncher</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EntryFilter</span> <span class="variable">NESTED_ARCHIVE_ENTRY_FILTER</span> <span class="operator">=</span> (entry) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line"><span class="keyword">return</span> entry.getName().equals(<span class="string">&quot;BOOT-INF/classes/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> entry.getName().startsWith(<span class="string">&quot;BOOT-INF/lib/&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JarLauncher</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">JarLauncher</span><span class="params">(Archive archive)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(archive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isPostProcessingClassPathArchives</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> NESTED_ARCHIVE_ENTRY_FILTER.matches(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">getArchiveEntryPathPrefix</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;BOOT-INF/&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">JarLauncher</span>().launch(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>JarLauncher#main()</code>中新建了<code>JarLauncher</code>并调用父类Launcher中的<code>launch()</code>方法启动程序；<br><code>isNestedArchive(Archinve.Entry entry)</code>方法用于判断FAT JAR资源的相对路径是否为<code>nestedArchive</code>嵌套文档。进而决定这些FAT JAR是否会被launch。当方法返回false时，说明FAT JAR被解压至文件目录</p><blockquote><p>Archive的概念</p></blockquote><p>archive即归档文件，这个概念在linux下比较常见；通常就是一个tar/zip格式的压缩包；而jar正是zip格式的。</p><p>SpringBoot抽象了Archive的概念，一个Archive可以是jar（JarFileArchive），也可以是文件目录（ExplodedArchive）；这样也就统一了访问资源的逻辑层；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Archive</span> <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;Archive.Entry&gt;, AutoCloseable &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Archive</code>继承自<code>Archive.Entry</code>，<code>Archive.Entry</code>有两种实现：</p><ul><li><code>JarFileArchive.JarFileEntry</code> —&gt; 基于<code>java.util.jar.JarEntry</code>实现，表示FAT JAR嵌入资源。</li><li><code>ExplodedArchive.FileEntry</code> —&gt; 基于文件系统实现；</li></ul><p>两者的主要差别是<code>ExplodedArchive</code>相比于JarFileArchive多了一个获取文件的getFile()方法；</p><p>也就是说一个在jar包环境下寻找资源，一个在文件夹目录下寻找资源</p><p><strong>当执行java -jar命令时，将调用/META-INF /MANIFEST.MF文件的Main-Class属性的main()方法，实际上调用的是JarLauncher#launch(args)方法；</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="91a018db-47a9-47db-82d9-fbd971ee6736-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isExploded()) &#123;</span><br><span class="line">        <span class="comment">// phase1：注册jar URL处理器</span></span><br><span class="line">        JarFile.registerUrlProtocolHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// phase2：创建ClassLoader</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> createClassLoader(getClassPathArchivesIterator());</span><br><span class="line">    <span class="type">String</span> <span class="variable">jarMode</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;jarmode&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">launchClass</span> <span class="operator">=</span> (jarMode != <span class="literal">null</span> &amp;&amp; !jarMode.isEmpty()) ? JAR_MODE_LAUNCHER : getMainClass();</span><br><span class="line">    <span class="comment">// phase3：反射调用实际的引导类launch</span></span><br><span class="line">    launch(args, launchClass, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，JDK提供的ClassLoader只能识别jar中的class文件以及加载classpath下的其他jar包中的class文件，对于jar in jar的包无法加载；<br>当SpringBoot FAT JAR被<code>java -jar</code>命令引导时，其内部的JAR文件无法被内嵌实现当做classPath，故需要定义了一套URLStreamHandler实现类和JarURLConnection实现类，用来加载jar in jar包的class类文件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>总结</p></blockquote><p>Spring Boot应用打包之后，生成一个<code>Fat jar</code>，包含了应用依赖的所有三方jar包和SpringBoot Loader相关的类。</p><p>Fat jar的启动Main函数是<code>JarLauncher</code>，它负责创建一个<code>LaunchedURLClassLoader</code>来加载<code>BOOT-INF/classes</code>目录以及<code>/BOOT-INF/lib下面的jar</code>，并利用反射获取<code>mainClass</code>类中的<code>main(Stirng[])</code>方法并调用。</p><p>即：运行JarLauncher实际上是在同进程、同线程内调用Start-Class类的main(Stirng[])方法，并且在调用前准备好ClassPath。</p>              </div>            </details><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>适配器模式</p><p>DisposableBeanAdapter</p><p>HeandlerAdapter</p><hr><p>享元模式(池化)</p><p>hikari连接池</p><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象</p><hr><p>责任链模式</p>]]></content>
    
    
    <summary type="html">Spring面试题</summary>
    
    
    
    <category term="Spring" scheme="https://wuwawawa.github.io/categories/Spring/"/>
    
    
    <category term="面试题" scheme="https://wuwawawa.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>区间最值问题与ST表</title>
    <link href="https://wuwawawa.github.io/posts/95223a9d.html"/>
    <id>https://wuwawawa.github.io/posts/95223a9d.html</id>
    <published>2023-10-17T05:22:19.000Z</published>
    <updated>2023-10-17T06:38:47.783Z</updated>
    
    <content type="html"><![CDATA[<p>我们先从一个简单的区间问题切入</p><p>给定一个长度为 N 的数列，和 M 次询问，求出每一次询问的区间[L , R] 内数字的最大值。</p><blockquote><p>示例</p></blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">下标：0<span class="number"> 1 </span>2<span class="number"> 3 </span>4<span class="number"> 5 </span>6 7</span><br><span class="line">数列：9<span class="number"> 3 </span>1<span class="number"> 7 </span>5<span class="number"> 6 </span>0 8</span><br><span class="line">询问：</span><br><span class="line">[0,5] -&gt; 9</span><br><span class="line">[4,5] -&gt; 6</span><br><span class="line">[3,5] -&gt; 7</span><br></pre></td></tr></table></figure><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><div class="tabs" id="f67643ba-62fd-4f13-a803-a1c293ff0cdb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#f67643ba-62fd-4f13-a803-a1c293ff0cdb-1"><i class="fas fa-atom"></i>暴力解法</button></li><li class="tab"><button type="button" data-href="#f67643ba-62fd-4f13-a803-a1c293ff0cdb-2"><i class="far fa-sun"></i>暴力打表</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="f67643ba-62fd-4f13-a803-a1c293ff0cdb-1"><p> 对于每次询问，都遍历一遍区间</p><p>O(NM)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt(), M = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        arr[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (M-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextInt(), r = sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="f67643ba-62fd-4f13-a803-a1c293ff0cdb-2"><p>定义数组 <code>ans[i][j]</code>  表示[i , j]区间的答案 使用动态规划的思想对数组进行填充</p><p>空间复杂度 O(n*n)</p><p>时间复杂度 O(n*n + m)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt(), M = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        arr[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表</span></span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) ans[i][i] = arr[i];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            ans[i][j] = Math.max(ans[i][j - <span class="number">1</span>], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (M-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextInt(), r = sc.nextInt();</span><br><span class="line">        System.out.println(ans[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h2 id="稀疏表优化"><a href="#稀疏表优化" class="headerlink" title="稀疏表优化"></a>稀疏表优化</h2><p>在暴力打表的解法中 我们把每个小区间都进行了存储，太过于紧凑，使得占用的空间过大</p><p>[0,1] [0,2] [0,3] [0,4] [0,5] [0,6] [0,7] </p><p>[1,2] [1,3] [1,4] [1,5] [1,6] [1,7]</p><p>[2,3] [2,4] [2,5] [2,6] [2,7]</p><p>……</p><hr><p>ST表则是基于动态规划 + 倍增的思想：</p><p>假如我们需要求[0 , x]区间的最大值，我们只需要知道[0 ,  x/2] 和 [x/2 + 1 , x]的最大值 反复减半直至区间长度为1</p><p>定义 <code>dp[i][j]</code> 表示 从 i 开始 ，长度为 2^j 的 区间最大值</p><p>base case </p><p><code>dp[i][0] = arr[i]</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于每次询问 [l , r] 区间最大值为 </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(R - L + <span class="number">1</span>) / Math.log(<span class="number">2</span>));</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(dp[L][j], dp[R - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>][j]);</span><br><span class="line"></span><br><span class="line">假设区间为[<span class="number">1</span>,<span class="number">8</span>]</span><br><span class="line">  那我们取的两个区间是[<span class="number">1</span>,<span class="number">8</span>] 和 [<span class="number">1</span>,<span class="number">8</span>]</span><br><span class="line">假设区间为[<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">  那我们取的两个区间是[<span class="number">1</span>,<span class="number">8</span>] 和 [<span class="number">2</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt(), M = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        arr[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(N) / Math.log(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][size + <span class="number">5</span>];</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) dp[i][<span class="number">0</span>] = arr[i];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= size; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; N; i++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (M-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> sc.nextInt(), R = sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(R - L + <span class="number">1</span>) / Math.log(<span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(dp[L][j], dp[R - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>][j]);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ST表不仅仅可以用来求max ，还可以用来求 min gcd(最大公约数) lcm(最小公倍数)</p><p>ST 表是一个静态表，只能处理一些离线问题，而不能处理在线问题。</p>]]></content>
    
    
    <summary type="html">sparse table 稀疏表</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法模版</title>
    <link href="https://wuwawawa.github.io/posts/bb13e2f5.html"/>
    <id>https://wuwawawa.github.io/posts/bb13e2f5.html</id>
    <published>2023-10-04T03:38:05.000Z</published>
    <updated>2023-12-14T04:28:05.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="经典模版题"><a href="#经典模版题" class="headerlink" title="经典模版题"></a>经典模版题</h3><p>关键词： 满足xxx条件（计算结果(加减乘除)、出现次数(cnt数组准备)、同时包含）长度最长/最短子串/子数组</p><p>注意点<br>1.if/while使用条件判断<br>2.right-left+1的重要性</p><div class="tabs" id="df3b0974-b073-4def-8595-8222f2f2897c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#df3b0974-b073-4def-8595-8222f2f2897c-1"><i class="fas fa-seedling"></i>209</button></li><li class="tab"><button type="button" data-href="#df3b0974-b073-4def-8595-8222f2f2897c-2"><i class="fas fa-leaf"></i>713</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="df3b0974-b073-4def-8595-8222f2f2897c-1"><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">长度最小的子数组</a></p><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> 。</p><p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = <span class="number">0</span> , len = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; len)&#123;</span><br><span class="line">        sum += nums[r];    </span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            res = Math.min(res , r - l + <span class="number">1</span>);</span><br><span class="line">            sum -= nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="df3b0974-b073-4def-8595-8222f2f2897c-2"><p><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">乘积小于 K 的子数组</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回子数组内所有元素的乘积严格小于 <code>k</code> 的连续子数组的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayProductLessThanK</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">1</span> , len = nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; len)&#123;</span><br><span class="line">        product *= nums[r];</span><br><span class="line">        r++;</span><br><span class="line">        <span class="keyword">while</span>(product &gt;= k &amp;&amp; l &lt; r)&#123;</span><br><span class="line">            product /= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 以nums[r] 结尾子数组个数</span></span><br><span class="line">        res += r - l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="两端滑动窗口套路模板题"><a href="#两端滑动窗口套路模板题" class="headerlink" title="两端滑动窗口套路模板题"></a>两端滑动窗口套路模板题</h3><p>正难则反，从两边拿难思考，最大化拿外面等价转换为最小化拿里面<br>由此变为模板题：从两端取数字等等，连续子数组，字串，可以想到滑动窗口解决</p><div class="tabs" id="174d806e-4979-4493-a287-fb02300675f0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#174d806e-4979-4493-a287-fb02300675f0-1"><i class="fas fa-seedling"></i>2516</button></li><li class="tab"><button type="button" data-href="#174d806e-4979-4493-a287-fb02300675f0-2"><i class="fas fa-leaf"></i>1423</button></li><li class="tab"><button type="button" data-href="#174d806e-4979-4493-a287-fb02300675f0-3"><i class="fab fa-apple"></i>1658</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="174d806e-4979-4493-a287-fb02300675f0-1"><p><a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/"> 每种字符至少取 K 个</a></p><p>给你一个由字符 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code>、<code>&#39;c&#39;</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p><p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回 <code>-1</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">takeCharacters</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cs.length;</span><br><span class="line">    <span class="comment">// 统计词频</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;a&#x27;</span>,-k);</span><br><span class="line">    map.put(<span class="string">&#x27;b&#x27;</span>,-k);</span><br><span class="line">    map.put(<span class="string">&#x27;c&#x27;</span>,-k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : cs) &#123;</span><br><span class="line">       map.merge(c,<span class="number">1</span>,Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 窗口</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">rc</span> <span class="operator">=</span> cs[r];</span><br><span class="line">        window.merge(rc, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">while</span> (window.get(rc) &gt; map.get(rc) &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">lc</span> <span class="operator">=</span> cs[l];</span><br><span class="line">            window.merge(lc, -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, r - l + <span class="number">1</span>);</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="174d806e-4979-4493-a287-fb02300675f0-2"><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/">可获得的最大点数</a></p><p>几张卡牌 <strong>排成一行</strong>，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code> 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 <code>k</code> 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 <code>cardPoints</code> 和整数 <code>k</code>，请你返回可以获得的最大点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(<span class="type">int</span>[] cardPoints, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cardPoints.length;</span><br><span class="line">    k = len - k;</span><br><span class="line">    <span class="comment">// 计算sum</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(cardPoints).sum();</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> cardPoints[r];</span><br><span class="line">        total += rx;</span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> == k + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lx</span> <span class="operator">=</span> cardPoints[l];</span><br><span class="line">            total -= lx;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">            ans = Math.min(ans, total);</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="174d806e-4979-4493-a287-fb02300675f0-3"><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">将 x 减到 0 的最小操作数</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>x</code> 。每一次操作时，你应当移除数组 <code>nums</code> 最左边或最右边的元素，然后从 <code>x</code> 中减去该元素的值。请注意，需要 <strong>修改</strong> 数组以供接下来的操作使用。</p><p>如果可以将 <code>x</code> <strong>恰好</strong> 减到 <code>0</code> ，返回 <strong>最小操作数</strong> ；否则，返回 <code>-1</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum - x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span> (x == sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在窗口内找到最长子数组 其和等于target</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> nums[r];</span><br><span class="line">        s += rx;</span><br><span class="line">        <span class="keyword">while</span> (s &gt; target &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lx</span> <span class="operator">=</span> nums[l];</span><br><span class="line">            s -= lx;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s == target) &#123;</span><br><span class="line">            res = Math.max(res, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == -<span class="number">1</span> ? -<span class="number">1</span> : len - res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="两个left计算区间个数"><a href="#两个left计算区间个数" class="headerlink" title="两个left计算区间个数"></a>两个left计算区间个数</h3><p>滑动窗口区间个数计算模板题（两个left计算区间个数）</p><p>主要解决的问题是利用滑动窗口的两个left计算区间个数的模板解决相关套路题。</p><p>题目中往往包含<span class='p green'>恰好字眼</span></p><blockquote><p>把「恰好」 转换成为 「最多」。</p><p>例如求恰好k个，就用最多k个 - 最多k-1个 = 恰好k个</p></blockquote><div class="tabs" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8c93d26e-1b54-4ffd-9dce-d4803af8693d-1"><i class="fas fa-seedling"></i>LC930</button></li><li class="tab"><button type="button" data-href="#8c93d26e-1b54-4ffd-9dce-d4803af8693d-2"><i class="fas fa-leaf"></i>LC1248</button></li><li class="tab"><button type="button" data-href="#8c93d26e-1b54-4ffd-9dce-d4803af8693d-3"><i class="fab fa-apple"></i>LC992</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d-1"><p><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">和相同的二元子数组</a></p><p>给你一个二元数组 <code>nums</code> ，<code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code>，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numSubarraysWithSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cal(nums, goal) - cal(nums, goal - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        s += x;</span><br><span class="line">        <span class="keyword">while</span> (s &gt; k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            s -= nums[left];</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d-2"><p><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/">统计优美子数组</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。如果某个连续子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p><p>请返回这个数组中 <strong>「优美子数组」</strong> 的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cal(nums, k) - cal(nums, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">countOdd</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        countOdd += ((x &amp; <span class="number">1</span>) == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (countOdd &gt; k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            countOdd -= ((nums[left] &amp; <span class="number">1</span>) == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8c93d26e-1b54-4ffd-9dce-d4803af8693d-3"><p><a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/"> K 个不同整数的子数组</a></p><p>给定一个正整数数组 <code>nums</code>和一个整数 <code>k</code>，返回 <code>nums</code> 中 「<strong>好子数组」</strong> 的数目。</p><p>如果 <code>nums</code> 的某个子数组中不同整数的个数恰好为 <code>k</code>，则称 <code>nums</code> 的这个连续、不一定不同的子数组为 <strong>「好子数组 」</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cal(nums, k) - cal(nums, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; len; right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rx</span> <span class="operator">=</span> nums[right];</span><br><span class="line">        map.merge(rx, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">while</span> (map.size() &gt; k &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lx</span> <span class="operator">=</span> nums[left];</span><br><span class="line">            map.merge(lx, -<span class="number">1</span>, Integer::sum);</span><br><span class="line">            <span class="keyword">if</span> (map.get(lx) == <span class="number">0</span>) &#123;</span><br><span class="line">                map.remove(lx);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="分组循环"><a href="#分组循环" class="headerlink" title="分组循环"></a>分组循环</h2><p><strong>适用场景</strong>：按照题目要求，数组会被分割成若干组，且每一组的判断/处理逻辑是一样的。</p><p><strong>核心思想</strong>：</p><ul><li>外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。</li><li>内层循环负责遍历组，找出这一组在哪结束。</li></ul><p>一般来说，分组循环的模板如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(nums)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; n:</span><br><span class="line">    start = i</span><br><span class="line">    <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> ...:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 从 start 到 i-1 是一组</span></span><br><span class="line">    <span class="comment"># 下一组从 i 开始，无需 i += 1</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/">最长奇偶子数组</a></p><p><a href="https://leetcode.cn/problems/consecutive-characters/">连续字符</a></p><p><a href="https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/">哪种连续子字符串更长</a></p><p><a href="https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/">使绳子变成彩色的最短时间</a></p><p><a href="https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/">所有元音按顺序排布的最长子字符串</a></p><h2 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h2><p>「双向 BFS」的基本实现思路如下：</p><p>创建「两个队列」分别用于两个方向的搜索；<br>创建「两个哈希表」用于「解决相同节点重复搜索」和「记录转换次数」；<br>为了尽可能让两个搜索方向“平均”，每次从队列中取值进行扩展时，先判断哪个队列容量较少；<br>如果在搜索过程中「搜索到对方搜索过的节点」，说明找到了最短路径。<br>「双向 BFS」基本思路对应的伪代码大致如下：</p><div class="tabs" id="019b1ae0-3bce-4c44-8e19-84a975519e1b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#019b1ae0-3bce-4c44-8e19-84a975519e1b-1"><i class="fas fa-seedling"></i>伪代码</button></li><li class="tab"><button type="button" data-href="#019b1ae0-3bce-4c44-8e19-84a975519e1b-2"><i class="fas fa-leaf"></i>示例代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="019b1ae0-3bce-4c44-8e19-84a975519e1b-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d1、d2 为两个方向的队列</span><br><span class="line">m1、m2 为两个方向的哈希表，记录每个节点距离起点的</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 只有两个队列都不空，才有必要继续往下搜索</span></span><br><span class="line"><span class="comment">// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点</span></span><br><span class="line"><span class="keyword">while</span>(!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d1.size() &lt; d2.size()) &#123;</span><br><span class="line">        update(d1, m1, m2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        update(d2, m2, m1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update 为将当前队列 d 中包含的元素取出，进行「一次完整扩展」的逻辑（按层拓展）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Deque d, Map cur, Map other)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="019b1ae0-3bce-4c44-8e19-84a975519e1b-2"><p><a href="https://leetcode.cn/problems/minimum-operations-to-convert-number/">转化数字的最小运算数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperations</span><span class="params">(<span class="type">int</span>[] _nums, <span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">    nums = _nums;</span><br><span class="line">    Deque&lt;Long&gt; d1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(), d2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Long, Integer&gt; m1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    d1.addLast(s * <span class="number">1L</span>);</span><br><span class="line">    d2.addLast(t * <span class="number">1L</span>);</span><br><span class="line">    m1.put(s * <span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">    m2.put(t * <span class="number">1L</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!d1.isEmpty() &amp;&amp; !d2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d1.size() &lt; d2.size()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> update(d1, m1, d2, m2, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans != -<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> update(d2, m2, d1, m1, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (ans != -<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(Deque&lt;Long&gt; d1, Map&lt;Long, Integer&gt; m1, Deque&lt;Long&gt; d2, Map&lt;Long, Integer&gt; m2, <span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> d1.size();</span><br><span class="line">    <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> d1.pollFirst();</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> m1.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="comment">// 正向搜索：进行出队检查，只有出队元素符合条件，才能使用出队元素往下拓展</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt;= cur &amp;&amp; cur &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                    <span class="type">long</span>[] result = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;cur + i, cur - i, cur ^ i&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">long</span> next : result) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (m2.containsKey(next)) <span class="keyword">return</span> step + <span class="number">1</span> + m2.get(next);</span><br><span class="line">                        <span class="keyword">if</span> (!m1.containsKey(next)) &#123;</span><br><span class="line">                            d1.addLast(next);</span><br><span class="line">                            m1.put(next, step + <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反向搜索：进行入队检查，只有拓展元素符合条件，才能将拓展元素入队</span></span><br><span class="line">                <span class="type">long</span>[] result = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;cur + i, cur - i, cur ^ i&#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">long</span> next : result) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= next &amp;&amp; next &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (m2.containsKey(next)) <span class="keyword">return</span> step + <span class="number">1</span> + m2.get(next);</span><br><span class="line">                        <span class="keyword">if</span> (!m1.containsKey(next)) &#123;</span><br><span class="line">                            d1.addLast(next);</span><br><span class="line">                            m1.put(next, step + <span class="number">1</span>);</span><br><span class="line">                        &#125;   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h2 id="换根DP"><a href="#换根DP" class="headerlink" title="换根DP"></a>换根DP</h2><hr><h2 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h2><p>将 n 转换成字符串 s，定义 <code>f(i,mask,isLimit,hasNum)</code> 表示构造第 i 位及其之后数位的合法方案数，其参数的含义为:</p><ul><li>mask 表示前面选过的数字集合，换句话说，第 i 位要选的数字不能在 mask 中。</li><li>isLimit 表示当前是否受到了 n 的约束（注意要构造的数字不能超过 n）。若为真，则第 i 位填入的数字至多为 s[i]，否则可以是 9。如果在受到约束的情况下填了 s[i]，那么后续填入的数字仍会受到 n 的约束。例如 n=123，那么 i=0 填的是 1 的话，i=1 的这一位至多填 2。</li><li>hasNum 表示 i 前面的数位是否填了数字。若为假，则当前位可以跳过（不填数字），或者要填入的数字至少为 1；若为真，则要填入的数字可以从 0 开始。例如 n=1233，在 i=0 时跳过的话，相当于后面要构造的是一个 9 以内的数字了，如果 i=1 不跳过，那么相当于构造一个 10 到 99 的两位数，如果 i=1 跳过，相当于构造的是一个 9 以内的数字。</li></ul><blockquote><p>如果一个正整数每一个数位都是 <strong>互不相同</strong> 的，我们称它是 <strong>特殊整数</strong> 。给你一个 <strong>正</strong> 整数 <code>n</code> ，请你返回区间 <code>[1, n]</code> 之间特殊整数的数目。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] memo;   <span class="comment">// memo[i][mask]记录当前选择顺位为i，已选状态为mask时，构造第i位及后面位的合法方案数</span></span><br><span class="line">    <span class="type">char</span>[] s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        参考灵神の数位DP记忆化DFS模板：</span></span><br><span class="line"><span class="comment">        注意这题与LC1012是一样的，不过这题更直接求每一位都不相同数字</span></span><br><span class="line"><span class="comment">        dfs(i, mask, isLimit, hasNum) 代表从左到右选到第i个数字时(i从0开始)，前面数字已选状态为mask时的合法方案数</span></span><br><span class="line"><span class="comment">        各个参数的含义如下:</span></span><br><span class="line"><span class="comment">        i:当前选择的数字位次，从0开始</span></span><br><span class="line"><span class="comment">        mask:前面已择数字的状态，是一个10位的二进制数，如:0000000010就代表前面已经选了1</span></span><br><span class="line"><span class="comment">        isLimit:boolean类型，代表当前位选择是否被前面位的选择限制了；</span></span><br><span class="line"><span class="comment">            如n=1234，前面选了12，选第3位的时候会被限制在0~3，isLimit=true；否则是0~9，isLimit=false</span></span><br><span class="line"><span class="comment">        hasNum:表示前面是否已经选择了数字，若选择了就为true(识别直接构造低位的情况)</span></span><br><span class="line"><span class="comment">        时间复杂度:O(1024*M*10) 空间复杂度:O(1024*M)</span></span><br><span class="line"><span class="comment">        记忆化DFS的时间复杂度=状态数*每一次枚举的情况数</span></span><br><span class="line"><span class="comment">        **记忆化本质就是减少前面已选状态一致的情况，将1eM的时间复杂度压缩至1&lt;&lt;M，效率非常高**</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        s = String.valueOf(n).toCharArray();    <span class="comment">// 转化为字符数组形式</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[m][<span class="number">1</span> &lt;&lt; <span class="number">10</span>];     <span class="comment">// i∈[0,m-1]，mask为一个10位二进制数</span></span><br><span class="line">        <span class="comment">// 初始化memo为-1代表该顺位下该已选状态还没进行计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(memo[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意一开始最高位是有限制的，isLimit=true</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs(i, mask, isLimit, hasNum) 代表从左到右选第i个数字时，前面已选状态为mask时的合法方案数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> mask, <span class="type">boolean</span> isLimit, <span class="type">boolean</span> hasNum)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="comment">// i越过最后一位，此时前面选了就算一个，没选的就不算，因为不选后面也没得选了</span></span><br><span class="line">        <span class="keyword">if</span> (i == s.length) <span class="keyword">return</span> hasNum ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 已经计算过该状态，并且该状态是有效的，直接返回该状态</span></span><br><span class="line">        <span class="comment">// 这一步是降低时间复杂度的关键，使得记忆化dfs的时间复杂度控制得很低</span></span><br><span class="line">        <span class="comment">// !isLimit表示没有被限制的才可以直接得出结果，否则还要根据后面的数字进行计算子问题计算</span></span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; hasNum &amp;&amp; memo[i][mask] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][mask];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 结果</span></span><br><span class="line">        <span class="comment">// 本位可以取0(可直接构造低位数)的情况，此时要加上构造低位数0xxx的方案数</span></span><br><span class="line">        <span class="comment">// 将是否选了数字作为分类条件是为了避免出现00010这样有多个0的就不能统计了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasNum) res = dfs(i + <span class="number">1</span>, mask, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 构造与当前顺位相同位数的数字就要枚举可选的数字进行DFS</span></span><br><span class="line">        <span class="comment">// 枚举的起点要视hasNum而定，如果前面选择了数字，那么现在可以选0；否则只能从1开始</span></span><br><span class="line">        <span class="comment">// 枚举得终点视isLimit而定，若被限制了只能到s[i]，否则可以到9</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> hasNum ? <span class="number">0</span> : <span class="number">1</span>, end = isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>; k &lt;= end; k++) &#123;</span><br><span class="line">            <span class="comment">// 如果该数字k还没有被选中，那猫就可以选该位数字</span></span><br><span class="line">            <span class="keyword">if</span> (((mask &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 方案数遵循加法原理</span></span><br><span class="line">                <span class="comment">// i:进行下一位的DFS，因此为i+1</span></span><br><span class="line">                <span class="comment">// mask:由于该位选中了k，mask掩膜传下去就要更新，已选状态加上k</span></span><br><span class="line">                <span class="comment">// isLimit:当且仅当前面的被限制了且该位被限制</span></span><br><span class="line">                <span class="comment">// hasNum:该位选了必定为true</span></span><br><span class="line">                res += dfs(i + <span class="number">1</span>, mask | (<span class="number">1</span> &lt;&lt; k), isLimit &amp;&amp; k == end, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isLimit &amp;&amp; hasNum) memo[i][mask] = res;    <span class="comment">// 如果前面没有限制，表明后面都是同质的，可以记录进memo中</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题单：</p><p><a href="https://leetcode.cn/problems/number-of-digit-one/">233. 数字 1 的个数</a></p><p><a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></p><p><a href="https://leetcode.cn/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a></p><p><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">902. 最大为 N 的数字组合</a></p><p><a href="https://leetcode.cn/problems/rotated-digits/">788. 旋转数字</a></p><p><a href="https://leetcode.cn/problems/numbers-with-repeated-digits/">1012. 至少有 1 位重复的数字</a></p><p><a href="https://leetcode.cn/problems/count-special-integers/">2376. 统计特殊整数</a></p><p><a href="https://leetcode.cn/problems/count-numbers-with-unique-digits/">357. 统计各位数字都不同的数字个数</a></p><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启了路径压缩和按大小合并的并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="type">int</span>[] size;</span><br><span class="line">    <span class="comment">// 当前连通分支数目</span></span><br><span class="line">    <span class="type">int</span> branchCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.branchCount = n;</span><br><span class="line">        <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> parent[x] == x ? x : (parent[x] = find(parent[x]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        x = find(x);</span><br><span class="line">        y = find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按大小合并</span></span><br><span class="line">        <span class="keyword">if</span> (size[x] &lt; size[y]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[y] = x;</span><br><span class="line">        size[x] += size[y];</span><br><span class="line">        --branchCount;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">branchCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> branchCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><hr><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><hr><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>定义<code>preSum[i][j]</code> 是从(0,0) 到 (i,j) 的 和</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1614615488-IBbfAx-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2.png" alt="二维区域和检索" style="zoom: 25%;" /></p><p><code>sumRegion(A,D)=sumRegion(O,D)−sumRegion(O,E)−sumRegion(O,F)+sumRegion(O,G)</code></p><div class="tabs" id="5a1f7b08-e592-46ea-9033-85f4cddc1583"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5a1f7b08-e592-46ea-9033-85f4cddc1583-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#5a1f7b08-e592-46ea-9033-85f4cddc1583-2"><i class="fas fa-leaf"></i>2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5a1f7b08-e592-46ea-9033-85f4cddc1583-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">// 二维前缀和</span></span><br><span class="line"><span class="type">int</span>[][] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        preSum[i][j] = preSum[i - <span class="number">1</span>][j] + preSum[i][j - <span class="number">1</span>] - preSum[i - <span class="number">1</span>][j - <span class="number">1</span>] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5a1f7b08-e592-46ea-9033-85f4cddc1583-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="comment">// 二维前缀和</span></span><br><span class="line">    <span class="type">int</span>[][] preSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[rows][cols];</span><br><span class="line">        preSum[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; cols;i++)&#123;</span><br><span class="line">            preSum[<span class="number">0</span>][i] = preSum[<span class="number">0</span>][i - <span class="number">1</span>] + matrix[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; rows;i++)&#123;</span><br><span class="line">            preSum[i][<span class="number">0</span>] = preSum[i - <span class="number">1</span>][<span class="number">0</span>] + matrix[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; cols;j++)&#123;</span><br><span class="line">                preSum[i][j] = preSum[i - <span class="number">1</span>][j] + preSum[i][j - <span class="number">1</span>] - preSum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i][j]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> preSum[row2][col2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> col1 - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : preSum[row2][col1 - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x3</span> <span class="operator">=</span> row1 - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : preSum[row1 - <span class="number">1</span>][col2];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x4</span> <span class="operator">=</span> (col1 - <span class="number">1</span> &lt; <span class="number">0</span> || row1 - <span class="number">1</span> &lt; <span class="number">0</span>) ? <span class="number">0</span> : preSum[row1 - <span class="number">1</span>][col1 - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> x1 - x2 - x3 + x4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>如果将矩阵的第 (i,j) 个单元格中的值增加 1，那么，若对矩阵求二维前缀和，那么下图 (a) 中的黄色区域的值都会增加 1。</p><p>如果要将矩阵中的 任意 矩形区域（如下图中 (b) 的蓝色区域）的值增加 1 呢？只需按照下图 (c) 来修改矩阵即可。修改后，若对矩阵求前缀和，那么，只会有蓝色的区域的值 +1，其它区域的值都不变。</p><p><img src="https://pic.leetcode-cn.com/1641658840-YrICJa-image.png" alt="image.png" style="zoom: 25%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] rangeAddQueries(<span class="type">int</span> n, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">    <span class="type">int</span>[][] diff = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] q : queries)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> q[<span class="number">0</span>] , y1 = q[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> q[<span class="number">2</span>] , y2 = q[<span class="number">3</span>];</span><br><span class="line">        diff[x1][y1]++;</span><br><span class="line">        diff[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>]++;</span><br><span class="line">        diff[x2 + <span class="number">1</span>][y1]--;</span><br><span class="line">        diff[x1][y2 + <span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 使用差分数组求前缀和</span></span><br><span class="line">    ans[<span class="number">0</span>][<span class="number">0</span>] = diff[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="comment">// 求第一行</span></span><br><span class="line">        ans[<span class="number">0</span>][i] = ans[<span class="number">0</span>][i - <span class="number">1</span>] + diff[<span class="number">0</span>][i];</span><br><span class="line">        <span class="comment">// 求第一列</span></span><br><span class="line">        ans[i][<span class="number">0</span>] = ans[i - <span class="number">1</span>][<span class="number">0</span>] + diff[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">            ans[i][j] = ans[i - <span class="number">1</span>][j] + ans[i][j - <span class="number">1</span>] - ans[i - <span class="number">1</span>][j - <span class="number">1</span>] + diff[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p>ST 表是用于解决 可重复贡献问题 的数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> sc.nextInt(), M = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        arr[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(N) / Math.log(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][size + <span class="number">5</span>];</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) dp[i][<span class="number">0</span>] = arr[i];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= size; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt; N; i++) &#123;</span><br><span class="line">            dp[i][j] = calculate(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (M-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> sc.nextInt(), R = sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.log(R - L + <span class="number">1</span>) / Math.log(<span class="number">2</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculate(dp[L][j], dp[R - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>][j]);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快速幂-amp-组合计数"><a href="#快速幂-amp-组合计数" class="headerlink" title="快速幂&amp;组合计数"></a>快速幂&amp;组合计数</h2><div class="tabs" id="657446ae-ec88-48e3-9f15-2c6218a8c84b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#657446ae-ec88-48e3-9f15-2c6218a8c84b-1"><i class="fas fa-seedling"></i>DP打表</button></li><li class="tab"><button type="button" data-href="#657446ae-ec88-48e3-9f15-2c6218a8c84b-2"><i class="fas fa-leaf"></i>Lucas</button></li><li class="tab"><button type="button" data-href="#657446ae-ec88-48e3-9f15-2c6218a8c84b-3"><i class="fab fa-apple"></i>exLucas</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="657446ae-ec88-48e3-9f15-2c6218a8c84b-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] comb = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        comb[i][<span class="number">0</span>] = comb[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            comb[i][j] = comb[i - <span class="number">1</span>][j] + comb[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            comb[i][j] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(comb[<span class="number">5</span>][<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="657446ae-ec88-48e3-9f15-2c6218a8c84b-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100002</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">long</span>) (<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span>[] fac = <span class="keyword">new</span> <span class="title class_">long</span>[N];</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化阶乘</span></span><br><span class="line">    fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">ksm</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n, <span class="type">long</span> mod)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans = ans * x % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">C</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> m, <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m || m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m * <span class="number">2</span> &gt; n) &#123;</span><br><span class="line">        m = n - m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fac[(<span class="type">int</span>) n] * ksm(fac[(<span class="type">int</span>) m] * fac[(<span class="type">int</span>) (n - m)] % p, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    计算 C(n,m)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">lucas</span><span class="params">(<span class="type">long</span> n, <span class="type">long</span> m, <span class="type">long</span> p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="657446ae-ec88-48e3-9f15-2c6218a8c84b-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="原地堆化"><a href="#原地堆化" class="headerlink" title="原地堆化"></a>原地堆化</h2><div class="tabs" id="e7e66a86-91ce-4f22-b37a-9e457c4b1f9d"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-1"><i class="fas fa-seedling"></i>最大堆</button></li><li class="tab"><button type="button" data-href="#e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-2"><i class="fas fa-leaf"></i>最小堆</button></li><li class="tab"><button type="button" data-href="#e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-3"><i class="fab fa-apple"></i>使用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地堆化（最大堆）</span></span><br><span class="line"> <span class="comment">// 堆化可以保证 h[0] 是堆顶元素，且 h[i] &gt;= max(h[2*i+1], h[2*i+2])</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">     <span class="comment">// 倒着遍历，从而保证 i 的左右子树一定是堆，那么 sink(h, i) 就可以把左右子树合并成一个堆</span></span><br><span class="line">     <span class="comment">// 下标 &gt;= h.length / 2 的元素是二叉树的叶子，无需下沉</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">         sink(h, i);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 把 h[i] 不断下沉，直到 i 的左右儿子都 &lt;= h[i]</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span>[] h, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> h.length;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// i 的左儿子</span></span><br><span class="line">         <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; h[j + <span class="number">1</span>] &gt; h[j]) &#123; <span class="comment">// i 的右儿子比 i 的左儿子大</span></span><br><span class="line">             j++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (h[j] &lt;= h[i]) &#123; <span class="comment">// 说明 i 的左右儿子都 &lt;= h[i]，停止下沉</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         swap(h, i, j); <span class="comment">// 下沉</span></span><br><span class="line">         i = j;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 交换 h[i] 和 h[j]</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] h, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> h[i];</span><br><span class="line">     h[i] = h[j];</span><br><span class="line">     h[j] = tmp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原地堆化（最小堆）</span></span><br><span class="line"><span class="comment">// 堆化可以保证 h[0] 是堆顶元素，且 h[i] &lt;= max(h[2*i+1], h[2*i+2])</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">    <span class="comment">// 倒着遍历，从而保证 i 的左右子树一定是堆，那么 sink(h, i) 就可以把左右子树合并成一个堆</span></span><br><span class="line">    <span class="comment">// 下标 &gt;= h.length / 2 的元素是二叉树的叶子，无需下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sink(h, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 h[i] 不断下沉，直到 i 的左右儿子都 &gt;= h[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span>[] h, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> h.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// i 的左儿子</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; h[j + <span class="number">1</span>] &lt; h[j]) &#123; <span class="comment">// i 的右儿子比 i 的左儿子大</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h[j] &gt;= h[i]) &#123; <span class="comment">// 说明 i 的左右儿子都 &lt;= h[i]，停止下沉</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(h, i, j); <span class="comment">// 下沉</span></span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换 h[i] 和 h[j]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] h, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> h[i];</span><br><span class="line">    h[i] = h[j];</span><br><span class="line">    h[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e7e66a86-91ce-4f22-b37a-9e457c4b1f9d-3"><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆顶元素 -&gt; h<span class="selector-attr">[0]</span></span><br><span class="line">更改后 <span class="built_in">sink</span>(h, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><a href="https://leetcode.cn/circle/discuss/H4aMOn/">https://leetcode.cn/circle/discuss/H4aMOn/</a></p><div class="tabs" id="9c7b8dd6-e778-4726-b122-cb09a92c4e26"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#9c7b8dd6-e778-4726-b122-cb09a92c4e26-1"><i class="fas fa-atom"></i>单点覆盖+区间求和+区间求最值</button></li><li class="tab"><button type="button" data-href="#9c7b8dd6-e778-4726-b122-cb09a92c4e26-2"><i class="far fa-sun"></i>区间加值+区间求和</button></li><li class="tab"><button type="button" data-href="#9c7b8dd6-e778-4726-b122-cb09a92c4e26-3"><i class="fas fa-wind"></i>区间覆盖+区间求最值</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="9c7b8dd6-e778-4726-b122-cb09a92c4e26-1"><p>单点修改或覆盖型没必要用上lazy标记，因为这是直接作用于某个点，没有范围可言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BinaryFunction</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原数组  下标从 0 开始</span></span><br><span class="line">    <span class="type">int</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] segTree;</span><br><span class="line"></span><br><span class="line">    BinaryFunction merger;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> unit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] data, BinaryFunction merger, <span class="type">int</span> unit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.merger = merger;</span><br><span class="line">        <span class="built_in">this</span>.unit = unit;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> data.length;</span><br><span class="line">        segTree = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        Arrays.fill(segTree, unit);</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下方方法调用中 root 1  left 1 right n</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            segTree[root] = data[left - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span>, left, mid);</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        segTree[root] = merger.apply(segTree[root &lt;&lt; <span class="number">1</span>], segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将cur位置值修改为val</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> cur, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            segTree[root] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt;= mid) &#123;</span><br><span class="line">            update(root &lt;&lt; <span class="number">1</span>, left, mid, cur, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, cur, val);</span><br><span class="line">        &#125;</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="comment">// 两个区间无重合</span></span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span> unit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完全包含</span></span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; to &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> segTree[root];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l_res</span> <span class="operator">=</span> query(root &lt;&lt; <span class="number">1</span>, left, mid, from, to);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r_res</span> <span class="operator">=</span> query(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to);</span><br><span class="line">        <span class="keyword">return</span> merger.apply(l_res, r_res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9c7b8dd6-e778-4726-b122-cb09a92c4e26-2"><p>对真正的区间操作就需要用到懒惰标记了，懒惰标记的作用在于多次更新，少量查询，就是在update()的时候先暂缓的记下来，最后query的时候一口气作用出来。</p><p>实现思路：</p><p>核心在与如何把单个val加入到一个区间的每个数字中，我们知道一个root代表一个区间，区间就有长度；那只需把val * length(root的区间) 即可；</p><p>可以理解为改区间里的每个点都有一个贡献的val，n个val相加，那就是n*val。同理，在pushDown()的时候也要计算该父节点对应左右孩子的长度；因此，这里的pushDown()还需要传入左右点的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] segTree;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> data.length;</span><br><span class="line">        segTree = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            segTree[root] = data[left - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span>, left, mid);</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        segTree[root] = (segTree[root &lt;&lt; <span class="number">1</span>] + segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> mid - left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLen</span> <span class="operator">=</span> right - mid;</span><br><span class="line">        <span class="keyword">if</span> (lazy[root] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// val 累计lazy*len</span></span><br><span class="line">            segTree[root &lt;&lt; <span class="number">1</span>] = (segTree[root &lt;&lt; <span class="number">1</span>] + lazy[root] * leftLen);</span><br><span class="line">            segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + lazy[root] * rightLen);</span><br><span class="line">            <span class="comment">// lazy 直接累计</span></span><br><span class="line">            lazy[root &lt;&lt; <span class="number">1</span>] = (lazy[root &lt;&lt; <span class="number">1</span>] + lazy[root]);</span><br><span class="line">            lazy[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = (lazy[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + lazy[root]);</span><br><span class="line"></span><br><span class="line">            lazy[root] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; right &lt;= to) &#123;</span><br><span class="line">            segTree[root] =</span><br><span class="line">                    (segTree[root] + val * (right - left + <span class="number">1</span>));</span><br><span class="line">            lazy[root] = (lazy[root] + val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown(root, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        update(root &lt;&lt; <span class="number">1</span>, left, mid, from, to, val);</span><br><span class="line">        update(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to, val);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; right &lt;= to) &#123;</span><br><span class="line">            <span class="keyword">return</span> segTree[root];</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown(root, left, right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (query(root &lt;&lt; <span class="number">1</span>, left, mid, from, to) +</span><br><span class="line">                query(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="9c7b8dd6-e778-4726-b122-cb09a92c4e26-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] segTree;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> data.length;</span><br><span class="line">        segTree = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="title class_">int</span>[n &lt;&lt; <span class="number">2</span>];</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            segTree[root] = data[left - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span>, left, mid);</span><br><span class="line">        build(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        segTree[root] = Math.max(segTree[root &lt;&lt; <span class="number">1</span>], segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(<span class="type">int</span> root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy[root] != <span class="number">0</span>) &#123;</span><br><span class="line">            segTree[root &lt;&lt; <span class="number">1</span>] = segTree[root];</span><br><span class="line">            segTree[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = segTree[root];</span><br><span class="line">            lazy[root &lt;&lt; <span class="number">1</span>] = lazy[root];</span><br><span class="line">            lazy[root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] = lazy[root];</span><br><span class="line">            lazy[root] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; right &lt;= to) &#123;</span><br><span class="line">            segTree[root] = val;</span><br><span class="line">            lazy[root] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pushDown(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        update(root &lt;&lt; <span class="number">1</span>, left, mid, from, to, val);</span><br><span class="line">        update(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to, val);</span><br><span class="line">        pushUp(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> from, <span class="type">int</span> to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from &gt; right || to &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (from &lt;= left &amp;&amp; right &lt;= to) &#123;</span><br><span class="line">            <span class="keyword">return</span> segTree[root];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pushDown(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(query(root &lt;&lt; <span class="number">1</span>, left, mid, from, to), query(root &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right, from, to));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>高效处理「前缀」查询，单点修改</p><p>通常使用树状数组是为了维护一些前缀，如前缀和、前缀最小值、前缀最大值。</p><p>但由于最小值和最大值不可逆，在大多数情况下是维护不了区间最小值和最大值的。</p><p><img src="https://pic.leetcode-cn.com/257e6c5742751f7cfdfd0704e7380ceccbd123335347a589165d74fa7ad11d40.png" alt="在这里插入图片描述" style="zoom: 33%;" /></p><div class="table-container"><table><thead><tr><th style="text-align:center">数组 <code>C</code> 的值由数组 <code>A</code> 的哪些元素而来</th><th style="text-align:center">数组 <code>A</code> 的元素个数</th></tr></thead><tbody><tr><td style="text-align:center">C[1] = A[1]</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">C[2] = A[1] + A[2]</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">C[3] = A[3]</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">C[4] = A[1] + A[2] + A[3] + A[4]</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">C[5] = A[5]</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">C[6] = A[5] + A[6]</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">C[7] = A[7]</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8]</td><td style="text-align:center">8</td></tr></tbody></table></div><p>通过图中不难看出，sum[7]=c[7]+c[6]+c[4] ,我们进一步发现,6=7-lowbit(7),4=6-lowbit(6)，所以我们可以通过不断的-lowbit操作来实现求和</p><p>在数据范围比较分散时，可以离散化数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LongBinaryFunction</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">apply</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongGenericBIT</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span>[] data;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> unit;</span><br><span class="line">    LongBinaryFunction merger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建大小A[1...n]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongGenericBIT</span><span class="params">(<span class="type">int</span> n, LongBinaryFunction merger, <span class="type">long</span> unit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">this</span>.merger = merger;</span><br><span class="line">        <span class="built_in">this</span>.unit = unit;</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lowBit</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询A[1]+A[2]+...+A[x]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> unit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &gt; <span class="number">0</span>; i -= lowBit(i)) &#123;</span><br><span class="line">            sum = merger.apply(sum, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询A[L]+A[L + 1]+...+A[R]</span></span><br><span class="line"><span class="comment">     * [L,R] = [1,R] - [1,L-1]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> unit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L - <span class="number">1</span>; i &gt; <span class="number">0</span>; i -= lowBit(i)) &#123;</span><br><span class="line">            l = merger.apply(l, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> unit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> R; i &gt; <span class="number">0</span>; i -= lowBit(i)) &#123;</span><br><span class="line">            r = merger.apply(r, data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将A[x]更新为A[x]+mod</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> mod)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= n; i += lowBit(i)) &#123;</span><br><span class="line">            data[i] = merger.apply(data[i], mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt;= n; i += lowBit(i)) &#123;</span><br><span class="line">            data[i] = unit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将A全部清0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        Arrays.fill(data, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            builder.append(query(i)).append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (builder.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            builder.setLength(builder.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h2><p>它的标准定义是：具有N个点N条边的连通图。如果不保证联通，它就会成为基环树森林。</p><p>内向基环树的定义是每个点有且只有一条出边。</p><p>外向基环树的定义是每个点有且只有一条入边。</p><p>从 i 向 to[i] 连边，可以得到一张有向图。由于每个大小为 k 的连通块都有 k 个点和 k 条边，所以<span class='p green'>每个连通块必定有且仅有一个环</span>，且由于每个点的出度均为 1，这样的有向图又叫做内向基环树 (pseudotree)，由基环树组成的森林叫基环树森林 (pseudoforest)。</p><p>每一个内向基环树（连通块）都由一个基环和其余指向基环的树枝组成。例如 以下示例 <code>to = [3,0,1,4,1]</code>  可以得到如下内向基环树，其基环由节点 0、1、3 和 4 组成，节点 2 为其树枝：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1641096462-IsWZUX-1-20231101095643697.png" alt="1.png" style="zoom: 67%;" /></p><p>常见的处理方式：拓扑排序去掉树枝</p><p><a href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/">参加会议的最多员工数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumInvitations</span><span class="params">(<span class="type">int</span>[] favorite)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> favorite.length;</span><br><span class="line">        <span class="type">int</span>[] deg = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> f : favorite) &#123;</span><br><span class="line">            deg[f]++; <span class="comment">// 统计基环树每个节点的入度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt;[] rg = <span class="keyword">new</span> <span class="title class_">List</span>[n]; <span class="comment">// 反图</span></span><br><span class="line">        Arrays.setAll(rg, e -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123; <span class="comment">// 拓扑排序，剪掉图上所有树枝</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> favorite[x]; <span class="comment">// x 只有一条出边</span></span><br><span class="line">            rg[y].add(x);</span><br><span class="line">            <span class="keyword">if</span> (--deg[y] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxRingSize</span> <span class="operator">=</span> <span class="number">0</span>, sumChainSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deg[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历基环上的点</span></span><br><span class="line">            deg[i] = <span class="number">0</span>; <span class="comment">// 将基环上的点的入度标记为 0，避免重复访问</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ringSize</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 基环长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> favorite[i]; x != i; x = favorite[x]) &#123;</span><br><span class="line">                deg[x] = <span class="number">0</span>; <span class="comment">// 将基环上的点的入度标记为 0，避免重复访问</span></span><br><span class="line">                ringSize++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ringSize == <span class="number">2</span>) &#123; <span class="comment">// 基环长度为 2</span></span><br><span class="line">                sumChainSize += rdfs(i, rg) + rdfs(favorite[i], rg); <span class="comment">// 累加两条最长链的长度</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxRingSize = Math.max(maxRingSize, ringSize); <span class="comment">// 取所有基环长度的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxRingSize, sumChainSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反图 rg 寻找树枝上最深的链</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">rdfs</span><span class="params">(<span class="type">int</span> x, List&lt;Integer&gt;[] rg)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> son : rg[x]) &#123;</span><br><span class="line">            maxDepth = Math.max(maxDepth, rdfs(son, rg) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="字典树-amp-二进制字典树"><a href="#字典树-amp-二进制字典树" class="headerlink" title="字典树&amp;二进制字典树"></a>字典树&amp;二进制字典树</h2><div class="tabs" id="0832b00f-ca2f-43ba-a0f6-65d4ce426d75"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0832b00f-ca2f-43ba-a0f6-65d4ce426d75-1"><i class="fas fa-bug"></i>字典树</button></li><li class="tab"><button type="button" data-href="#0832b00f-ca2f-43ba-a0f6-65d4ce426d75-2"><i class="fas fa-cannabis"></i>二进制字典树</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0832b00f-ca2f-43ba-a0f6-65d4ce426d75-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TireNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            node = node.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            node = node.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TireNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">public</span> TireNode[] next;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TireNode</span><span class="params">()</span> &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        next = <span class="keyword">new</span> <span class="title class_">TireNode</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0832b00f-ca2f-43ba-a0f6-65d4ce426d75-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie01</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_BIT</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TireNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie01</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MAX_BIT; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.next[bit] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.next[bit] = <span class="keyword">new</span> <span class="title class_">TireNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node.next[bit].cnt++;</span><br><span class="line">            node = node.next[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">TireNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> MAX_BIT; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            node.next[bit].cnt--;</span><br><span class="line">            node = node.next[bit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TireNode</span> &#123;</span><br><span class="line">    TireNode[] next;</span><br><span class="line">  <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TireNode</span><span class="params">()</span> &#123;</span><br><span class="line">        next = <span class="keyword">new</span> <span class="title class_">TireNode</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><mark class="hl-label blue">BKDR-HASH</mark> <p>把 <code>String</code> 当成一个 <code>X</code> 进制的数</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;123&quot;</span> -&gt; <span class="number">123</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;abz&quot;</span> -&gt; <span class="number">0</span> <span class="number">1</span> <span class="number">26</span>(<span class="number">26</span>)</span><br></pre></td></tr></table></figure><div class="tabs" id="62813119-1ef5-4a50-a4d6-d2ccbf7883b0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#62813119-1ef5-4a50-a4d6-d2ccbf7883b0-1"><i class="fas fa-seedling"></i>求整个字符串哈希</button></li><li class="tab"><button type="button" data-href="#62813119-1ef5-4a50-a4d6-d2ccbf7883b0-2"><i class="fas fa-leaf"></i>前缀和思想求每个子串哈希</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="62813119-1ef5-4a50-a4d6-d2ccbf7883b0-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;abc&quot;</span>.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">13331</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">hash_code</span> <span class="operator">=</span> cs[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">    hash_code = hash_code * x + cs[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="62813119-1ef5-4a50-a4d6-d2ccbf7883b0-2"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br><span class="line">h<span class="comment">[0]</span> = 1h<span class="comment">[1]</span> = 12h<span class="comment">[2]</span> = 123h<span class="comment">[3]</span> = 1234h<span class="comment">[4]</span> = 12345</span><br><span class="line"></span><br><span class="line">如何得到234的hash 即 234</span><br><span class="line">h<span class="comment">[3]</span> - h<span class="comment">[0]</span> ???</span><br><span class="line">h<span class="comment">[3]</span> - h<span class="comment">[0]</span> * 10^3</span><br></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char[] cs = <span class="string">&quot;abcdefe&quot;</span>.toCharArray();</span><br><span class="line">int len = cs.length;</span><br><span class="line">long[] h = new long[len];</span><br><span class="line">long[] x = new long[len];</span><br><span class="line">int <span class="symbol">X</span> = <span class="number">13331</span>;</span><br><span class="line">h[<span class="number">0</span>] = cs[<span class="number">0</span>];</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">for (int i = <span class="number">1</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * <span class="symbol">X</span> + cs[i];</span><br><span class="line">    x[i] = x[i - <span class="number">1</span>] * <span class="symbol">X</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算子字符串hash [<span class="symbol">L</span>,<span class="symbol">R</span>]</span><br><span class="line">int <span class="symbol">L</span>, <span class="symbol">R</span>;</span><br><span class="line">long hash = <span class="symbol">L</span> == <span class="number">0</span> ? h[<span class="symbol">R</span>] : h[<span class="symbol">R</span>] - h[<span class="symbol">L</span> - <span class="number">1</span>] * x[<span class="symbol">R</span> - <span class="symbol">L</span> + <span class="number">1</span>];</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><ol><li>全转小写：ch|=32</li><li>全转大写：ch&amp;=-33 (原理是32的补码（原码取反+1）再-1)</li><li>大小写对换（大写变小写，小写变大）ch^=32</li></ol><hr><h2 id="隔板法"><a href="#隔板法" class="headerlink" title="隔板法"></a>隔板法</h2><p><strong>隔板法</strong> 就是在n个元素间的（n-1）个空中插入k个板，可以把n个元素分成k+1组的方法</p><div class="tabs" id="adcb06f7-b745-4b55-b30a-26b14d08e162"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#adcb06f7-b745-4b55-b30a-26b14d08e162-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#adcb06f7-b745-4b55-b30a-26b14d08e162-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#adcb06f7-b745-4b55-b30a-26b14d08e162-3"><i class="fab fa-apple"></i>3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="adcb06f7-b745-4b55-b30a-26b14d08e162-1"><p>例1. 求方程 x+y+z=10的正整数解的个数。<br>分析：将10个球排成一排，球与球之间形成9个空隙，将两个隔板插入这些空隙中（每空至多插一块隔板），规定由隔板分成的左、中、右三部分的球数分别为x、y、z之值（如下图）。则隔法与解的个数之间建立了一一对立关系，故解的个数为C（9，2）=36（个）。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="adcb06f7-b745-4b55-b30a-26b14d08e162-2"><p>例2. 求方程 x+y+z=10的非负整数解的个数。 （添加球数用隔板法）<br>分析：注意到x、y、z可以为零，故例1解法中的限定“每空至多插一块隔板”就不成立了，怎么办呢？只要添加三个球，给x、y、z各添加一个球，这样原问题就转化为求 x+y+z=13的正整数解的个数了，易得解的个数为C（12，2）=66（个）。</p><p>令x1 = x + 1 , y1 = y + 1 , z1 = z + 1 ,则x1 ， y1 , z1 &gt;=1 </p><p>则 x1 + y1 + z1 = n + k </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="adcb06f7-b745-4b55-b30a-26b14d08e162-3"><p>例3. 将20个相同的小球放入编号分别为1，2，3，4的四个盒子中，要求每个盒子中的球数不少于它的编号数，求放法总数。（减少球数用隔板法）<br>分析：先在编号1，2，3，4的四个盒子内分别放0，1，2，3个球，剩下14个球，有1种方法；再把剩下的球分成4组，每组至少1个，由例1知方法有C（13，3）=286（种）。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">一些常用的算法模版</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>周赛复盘</title>
    <link href="https://wuwawawa.github.io/posts/e7135cd3.html"/>
    <id>https://wuwawawa.github.io/posts/e7135cd3.html</id>
    <published>2023-10-01T06:13:22.000Z</published>
    <updated>2023-11-12T09:11:35.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前缀最大值-后缀最大值"><a href="#前缀最大值-后缀最大值" class="headerlink" title="前缀最大值+后缀最大值"></a>前缀最大值+后缀最大值</h2><p><a href="https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/">有序三元组中的最大值</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>请你从所有满足 <code>i &lt; j &lt; k</code> 的下标三元组 <code>(i, j, k)</code> 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 <code>0</code> 。</p><p><strong>下标三元组</strong> <code>(i, j, k)</code> 的值等于 <code>(nums[i] - nums[j]) * nums[k]</code> 。</p><div class="tabs" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-1"><i class="fas fa-seedling"></i>示例1</button></li><li class="tab"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-2"><i class="fas fa-leaf"></i>示例2</button></li><li class="tab"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-3"><i class="fab fa-apple"></i>示例3</button></li><li class="tab"><button type="button" data-href="#e9e2c01f-875d-4e1c-9742-03b1bc516d2b-4"><i class="fas fa-tree"></i>数据范围</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-1"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[12,6,1,2,7]</span></span><br><span class="line">输出：77</span><br><span class="line">解释：下标三元组 (0, 2, 4) 的值是 (nums<span class="comment">[0]</span> - nums<span class="comment">[2]</span>) * nums<span class="comment">[4]</span> = 77 。</span><br><span class="line">可以证明不存在值大于 77 的有序下标三元组。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-2"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,10,3,4,19]</span></span><br><span class="line">输出：133</span><br><span class="line">解释：下标三元组 (1, 2, 4) 的值是 (nums<span class="comment">[1]</span> - nums<span class="comment">[2]</span>) * nums<span class="comment">[4]</span> = 133 。</span><br><span class="line">可以证明不存在值大于 133 的有序下标三元组。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-3"><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：0</span><br><span class="line">解释：唯一的下标三元组 (0, 1, 2) 的值是一个负数，(nums<span class="comment">[0]</span> - nums<span class="comment">[1]</span>) * nums<span class="comment">[2]</span> = -3 。因此，答案是 0 。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e9e2c01f-875d-4e1c-9742-03b1bc516d2b-4"><p>两题的数据只是数据范围存在不同</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="枚举J"><a href="#枚举J" class="headerlink" title="枚举J"></a>枚举J</h3><p>在枚举J的情况下，想要<code>(nums[i] - nums[j]) * nums[k]</code>尽量大，就是要让两个数都尽量大。</p><p>对于 <code>nums[j]</code> 来说，如果固定了 <code>j</code> 的位置，那我们需要知道</p><ul><li><code>nums[j + 1] ~ nums[n - 1]</code> 的最大值 即后缀最大值</li><li><code>nums[0] ~ nums[j - 1]</code> 的最大值 即前缀最大值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 后缀最大值</span></span><br><span class="line">    <span class="type">int</span>[] suf_max = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        suf_max[i] = Math.max(suf_max[i + <span class="number">1</span>] , nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前缀最大值</span></span><br><span class="line">    <span class="type">int</span>[] pre_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    pre_max[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        pre_max[i] = Math.max(pre_max[i - <span class="number">1</span>] , nums[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//枚举j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n - <span class="number">1</span>;j++)&#123;</span><br><span class="line">        ans = Math.max(ans,(<span class="type">long</span>)(pre_max[j - <span class="number">1</span>] - nums[j]) * suf_max[j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="枚举k"><a href="#枚举k" class="headerlink" title="枚举k"></a>枚举k</h3><p>一次遍历，从左到右遍历所有的 <code>nums[k]</code> </p><ul><li>那么就需要维护 <code>nums[i] - nums[j]</code>的最大值 max_diff</li><li>同时我们还需要知道左侧的最大值pre_max</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maximumTripletValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">max_diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre_max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">        <span class="comment">// 先把 x 当做 nums[k]</span></span><br><span class="line">        ans = Math.max(ans , max_diff * x);</span><br><span class="line">        <span class="comment">// 再把 x 当做 nums[j]</span></span><br><span class="line">        max_diff = Math.max(max_diff , pre_max - x);</span><br><span class="line">        <span class="comment">// 再把 x 当做 nums[i]</span></span><br><span class="line">        pre_max = Math.max(pre_max , x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三句话的顺序不能改变，因为题目严格要求<code>i &lt; j &lt; k</code></p><hr><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/">无限数组的最短子数组</a></p><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>下标从 <strong>0</strong> 开始的数组 <code>infinite_nums</code> 是通过无限地将 nums 的元素追加到自己之后生成的。</p><p>请你从 <code>infinite_nums</code> 中找出满足 <strong>元素和</strong> 等于 <code>target</code> 的 <strong>最短</strong>子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 <code>-1</code> 。</p><div class="tabs" id="3c20ef88-8338-403a-abf5-62b17d741a18"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-1"><i class="fas fa-seedling"></i>示例1</button></li><li class="tab"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-2"><i class="fas fa-leaf"></i>示例2</button></li><li class="tab"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-3"><i class="fab fa-apple"></i>示例3</button></li><li class="tab"><button type="button" data-href="#3c20ef88-8338-403a-abf5-62b17d741a18-4"><i class="fas fa-tree"></i>数据范围</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3c20ef88-8338-403a-abf5-62b17d741a18-1"><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="keyword">target</span> = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：在这个例子中 infinite_nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,...] 。</span><br><span class="line">区间 [<span class="number">1</span>,<span class="number">2</span>] 内的子数组的元素和等于 <span class="keyword">target</span> = <span class="number">5</span> ，且长度 length = <span class="number">2</span> 。</span><br><span class="line">可以证明，当元素和等于目标值 <span class="keyword">target</span> = <span class="number">5</span> 时，<span class="number">2</span> 是子数组的最短长度。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c20ef88-8338-403a-abf5-62b17d741a18-2"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1,1,1,2</span>,<span class="number">3</span>], target = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：在这个例子中 infinite_nums = [<span class="number">1,1,1,2</span>,<span class="number">3,1,1,1</span>,<span class="number">2,3,1,1</span>,...].</span><br><span class="line">区间 [<span class="number">4</span>,<span class="number">5</span>] 内的子数组的元素和等于 target = <span class="number">4</span> ，且长度 length = <span class="number">2</span> 。</span><br><span class="line">可以证明，当元素和等于目标值 target = <span class="number">4</span> 时，<span class="number">2</span> 是子数组的最短长度。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c20ef88-8338-403a-abf5-62b17d741a18-3"><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2,4,6,8</span>], target = <span class="number">3</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：在这个例子中 infinite_nums = [<span class="number">2,4,6,8</span>,<span class="number">2,4,6,8</span>,...] 。</span><br><span class="line">可以证明，不存在元素和等于目标值 target = <span class="number">3</span> 的子数组。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3c20ef88-8338-403a-abf5-62b17d741a18-4"><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= target &lt;= 109</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1696131371-UYYmoV-w365c-c.png" alt="img" style="zoom: 33%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSizeSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : nums) total += x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; <span class="number">2</span>*n)&#123;</span><br><span class="line">        sum += nums[right % n];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt; target % total)&#123;</span><br><span class="line">            sum -= nums[left % n];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target % total)&#123;</span><br><span class="line">            ans = Math.min(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans + (<span class="type">int</span>)(target / total) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-collect-elements/">收集元素的最少操作次数</a></p><p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>一次操作中，你可以将数组的最后一个元素删除，将该元素添加到一个集合中。</p><p>请你返回收集元素 <code>1, 2, ..., k</code> 需要的 <strong>最少操作次数</strong> 。</p><div class="tabs" id="6a55aa92-f333-4d58-8119-bccb9431f404"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-1"><i class="fas fa-seedling"></i>示例1</button></li><li class="tab"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-2"><i class="fas fa-leaf"></i>示例2</button></li><li class="tab"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-3"><i class="fab fa-apple"></i>示例3</button></li><li class="tab"><button type="button" data-href="#6a55aa92-f333-4d58-8119-bccb9431f404-4"><i class="fas fa-tree"></i>数据范围</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6a55aa92-f333-4d58-8119-bccb9431f404-1"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,5,4,2], k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：4 次操作后，集合中的元素依次添加了<span class="number"> 2 </span>，4 ，5 和<span class="number"> 1 </span>。此时集合中包含元素<span class="number"> 1 </span>和<span class="number"> 2 </span>，所以答案为<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a55aa92-f333-4d58-8119-bccb9431f404-2"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,5,4,2], k = 5</span><br><span class="line">输出：5</span><br><span class="line">解释：5 次操作后，集合中的元素依次添加了<span class="number"> 2 </span>，4 ，5 ，1 和<span class="number"> 3 </span>。此时集合中包含元素<span class="number"> 1 </span>到<span class="number"> 5 </span>，所以答案为<span class="number"> 5 </span>。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a55aa92-f333-4d58-8119-bccb9431f404-3"><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,5,3,1], k = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：4 次操作后，集合中的元素依次添加了<span class="number"> 1 </span>，3 ，5 和<span class="number"> 2 </span>。此时集合中包含元素<span class="number"> 1 </span>到<span class="number"> 3 </span> ，所以答案为<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6a55aa92-f333-4d58-8119-bccb9431f404-4"><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= nums.length</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li><li>输入保证你可以收集到元素 <code>1, 2, ..., k</code> 。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>由于元素范围在[1,50]，我们可以用一个 64 位整数表示集合，只要集合中有 1 到 k 就立刻返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位运算</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.size();</span><br><span class="line">    <span class="type">long</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 结束状态 mask 是 statsu 的子集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">// 更新status</span></span><br><span class="line">        status |= <span class="number">1L</span> &lt;&lt; nums.get(i);</span><br><span class="line">        <span class="keyword">if</span>((mask &amp; status) == mask)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - i;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><a href="https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/">找出满足差值条件的下标 II</a></p><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> ，以及整数 <code>indexDifference</code> 和整数 <code>valueDifference</code> 。</p><p>你的任务是从范围 <code>[0, n - 1]</code> 内找出 <strong>2</strong> 个满足下述所有条件的下标 <code>i</code> 和 <code>j</code> ：</p><ul><li><code>abs(i - j) &gt;= indexDifference</code> 且</li><li><code>abs(nums[i] - nums[j]) &gt;= valueDifference</code></li></ul><p>返回整数数组 <code>answer</code>。如果存在满足题目要求的两个下标，则 <code>answer = [i, j]</code> ；否则，<code>answer = [-1, -1]</code> 。如果存在多组可供选择的下标对，只需要返回其中任意一组即可。</p><p><strong>注意：</strong><code>i</code> 和 <code>j</code> 可能 <strong>相等</strong> 。</p><div class="tabs" id="a01cbf90-6b71-4b34-aac8-ad28ebabb777"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a01cbf90-6b71-4b34-aac8-ad28ebabb777-1"><i class="fas fa-seedling"></i>思路</button></li><li class="tab"><button type="button" data-href="#a01cbf90-6b71-4b34-aac8-ad28ebabb777-2"><i class="fas fa-leaf"></i>代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a01cbf90-6b71-4b34-aac8-ad28ebabb777-1"><p>拆绝对值</p><ul><li>j - i &gt;= id</li><li>| ai - aj | &gt;= vd</li></ul><p>一边枚举j ，一边维护j - id 之前的最大和最下值</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a01cbf90-6b71-4b34-aac8-ad28ebabb777-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findIndices(<span class="type">int</span>[] nums, <span class="type">int</span> indexDifference, <span class="type">int</span> valueDifference) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIdx</span> <span class="operator">=</span> <span class="number">0</span>, minIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> indexDifference; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j - indexDifference;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[maxIdx]) &#123;</span><br><span class="line">                maxIdx = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[minIdx]) &#123;</span><br><span class="line">                minIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[maxIdx] - nums[j] &gt;= valueDifference) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;maxIdx, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] - nums[minIdx] &gt;= valueDifference) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;minIdx, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>判断二次幂 + lowBit操作</p><p>~x + 1 相当于-x</p><p><a href="https://leetcode.cn/problems/minimum-impossible-or/">最小无法得到的或值</a></p><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p>可自顶向下思考 -&gt; 记忆化搜索</p><p>可自递向上思考 -&gt; 树形DP</p><p><a href="https://leetcode.cn/problems/maximum-points-after-collecting-coins-from-all-nodes/">收集所有金币可获得的最大积分</a></p><h2 id="子序列DP"><a href="#子序列DP" class="headerlink" title="子序列DP"></a>子序列DP</h2><p><a href="https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii/">最长相邻不相等子序列 II</a></p><mark class="hl-label DP">子序列</mark> <ul><li>子序列 + 不考虑相邻元素：选或不选。代表题目：<a href="https://leetcode.cn/problems/target-sum/">494. 目标和（0-1 背包）</a>。</li><li>子序列 + 考虑相邻元素：枚举选哪个。代表题目：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getWordsInLongestSubsequence</span><span class="params">(<span class="type">int</span> n, String[] words, <span class="type">int</span>[] groups)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(words[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] from = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[n -<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        from[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxId</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>;i &gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &gt; dp[i] &amp;&amp; groups[i] != groups[j] &amp;&amp; isDOne(words[i],words[j]))&#123;</span><br><span class="line">                    dp[i] = dp[j];</span><br><span class="line">                    from[i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; dp[maxId])&#123;</span><br><span class="line">                maxId = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dp[maxId];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">            res.add(words[maxId]);</span><br><span class="line">            maxId = from[maxId];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDOne</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">var</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != t.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                diff = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0-1背包</p><p><a href="https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/">和为目标值的最长子序列的长度</a></p><p>子序列DP 选或不选 + 状态机DP</p><p><a href="https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/">使数组变美的最小增量运算数</a></p><p>单调队列优化DP</p><p><a href="https://leetcode.cn/problems/constrained-subsequence-sum/">1425. 带限制的子序列和</a></p><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><a href="https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/">和带限制的子多重集合的数目</a></p><p>斜率优化 + 滚动数组 + 数据范围优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 多重背包</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubMultisets</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            cnt.merge(x, <span class="number">1</span>, Integer::sum);</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; l) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r = Math.min(r, sum);</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[r + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = cnt.getOrDefault(<span class="number">0</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        cnt.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : cnt.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="comment">// 次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            curMax = Math.min(curMax + x * c, r);</span><br><span class="line">            <span class="type">int</span>[] newDp = dp.clone();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> x; i &lt;= curMax; i++) &#123;</span><br><span class="line">                newDp[i] = (newDp[i] + newDp[i - x]) % MOD;</span><br><span class="line">                <span class="keyword">if</span> (i - (c + <span class="number">1</span>) * x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    newDp[i] = (newDp[i] - dp[i - (c + <span class="number">1</span>) * x] + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = newDp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; ++i) &#123;</span><br><span class="line">            ans = (ans + dp[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展欧几里得exgcd"><a href="#拓展欧几里得exgcd" class="headerlink" title="拓展欧几里得exgcd"></a>拓展欧几里得exgcd</h2><p>求解不定方程 ax + by = c</p><p><a href="https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/">合法分组的最少组数</a></p><h2 id="统计所有子数组"><a href="#统计所有子数组" class="headerlink" title="统计所有子数组"></a>统计所有子数组</h2><p><a href="https://leetcode.cn/problems/total-appeal-of-a-string/">字符串的总引力</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    使用变化量来思考</span></span><br><span class="line"><span class="comment">    示例：</span></span><br><span class="line"><span class="comment">    C   A   B   A   D   A</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2   1</span></span><br><span class="line"><span class="comment">    3   2   1</span></span><br><span class="line"><span class="comment">    2   1   2   1</span></span><br><span class="line"><span class="comment">    3   2   3   2   1</span></span><br><span class="line"><span class="comment">    3   2   2   1   2   1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">统计子串中的唯一字符</a></p><hr><h2 id="01字典树"><a href="#01字典树" class="headerlink" title="01字典树"></a>01字典树</h2><p><a href="https://leetcode.cn/problems/maximum-strong-pair-xor-ii/">找出强数对的最大异或值 II</a></p><p>遇到绝对值要想到排序拆绝对值 </p><p>滑动窗口 + 从字典树中删除 + 子数组最大异或<a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值</a></p><hr><h2 id="容斥定理"><a href="#容斥定理" class="headerlink" title="容斥定理"></a>容斥定理</h2><p><a href="https://leetcode.cn/problems/distribute-candies-among-children-ii/">给小朋友们分糖果 II</a></p><p><a href="https://leetcode.cn/problems/number-of-strings-which-can-be-rearranged-to-contain-substring/">重新排列后包含指定子字符串的字符串数目</a></p>]]></content>
    
    
    <summary type="html">LeetCode周赛</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最短路算法</title>
    <link href="https://wuwawawa.github.io/posts/5697d1d5.html"/>
    <id>https://wuwawawa.github.io/posts/5697d1d5.html</id>
    <published>2023-09-26T06:13:22.000Z</published>
    <updated>2023-10-01T09:00:02.859Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230926155902091.png" alt="image-20230926155902091"></p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>Dijkstra本质上是一种贪心算法，通过不断调整每个点的“当前距离”最终得到最优结果。</p><p>假设现在要求出从某一点s到其他所有点的最短距离，对于每个点v均维护一个“当前距离”（dist[v]）和“是否访问过”(visited[v])。首先将dist[s]初始化为0，将其他点的距离初始化为无穷，并将所有点初始化为未访问的。记u-&gt;v的边权为weight[u-&gt;v]。然后进行以下步骤：</p><ol><li>从所有未访问的点中，找出当前距离最小的，设为u，并将其标记为已访问的。</li><li>调整u的所有边（若是有向图则为出边）连接的并且<strong>未被访问过的</strong>点：若weight[u-&gt;v] + dist[u] &lt; dist[v], 则将dist[v]更新为dist[u]+weight[u-&gt;v]。</li><li>重复1和2步骤，直到所有点都被标记为已访问的，则dist[i]即s到i的最短距离。如果只想求从s到某一点的最短距离，那么当该点被标记为访问过之后可直接退出。</li><li>补充：如果除了最短距离之外还想求出具体的路径，只需建立一个pre数组，在步骤2后添加操作：pre[v] = u（前提是dist[v]被更新）。</li></ol><div class="tabs" id="e1220ca0-3a93-4dc3-aaa1-66a274d0966f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e1220ca0-3a93-4dc3-aaa1-66a274d0966f-1"><i class="fas fa-seedling"></i>邻接矩阵</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e1220ca0-3a93-4dc3-aaa1-66a274d0966f-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">110</span>, M = <span class="number">6010</span>;</span><br><span class="line">    <span class="comment">// 邻接矩阵数组：w[a][b] = c 代表从 a 到 b 有权重为 c 的边</span></span><br><span class="line">    <span class="type">int</span>[][] w = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">    <span class="comment">// dist[x] = y 代表从「源点/起点」到 x 的最短距离为 y</span></span><br><span class="line">    <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="comment">// 记录哪些点已经被更新过</span></span><br><span class="line">    <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line">    <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> n, src;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(<span class="type">int</span>[][] conn)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                w[i][j] = w[j][i] = i == j ? <span class="number">0</span> : INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] t : conn) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> t[<span class="number">0</span>], v = t[<span class="number">1</span>], c = t[<span class="number">2</span>];</span><br><span class="line">            w[u][v] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最短路</span></span><br><span class="line">        dijkstra();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dijkstra</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 起始先将所有的点标记为「未更新」和「距离为正无穷」</span></span><br><span class="line">        Arrays.fill(vis, <span class="literal">false</span>);</span><br><span class="line">        Arrays.fill(dist, INF);</span><br><span class="line">        <span class="comment">// 只有起点最短距离为 0</span></span><br><span class="line">        dist[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 迭代 n 次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt;= n; p++) &#123;</span><br><span class="line">            <span class="comment">// 每次找到「最短距离最小」且「未被更新」的点 t</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[i] &amp;&amp; (t == -<span class="number">1</span> || dist[i] &lt; dist[t])) t = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记点 t 为已更新</span></span><br><span class="line">            vis[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 用点 t 的「最小距离」更新其他点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                dist[i] = Math.min(dist[i], dist[t] + w[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>动态规划</p><p><code>dp[i][j]</code> 表示 <code>i-&gt;j</code> 的最短距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借用别的点求解</p>]]></content>
    
    
    <summary type="html">Dijkstra + SPFA + Bellman-Ford + Floyd</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>差分数组</title>
    <link href="https://wuwawawa.github.io/posts/f4bb8efc.html"/>
    <id>https://wuwawawa.github.io/posts/f4bb8efc.html</id>
    <published>2023-09-25T06:45:09.000Z</published>
    <updated>2023-09-25T09:37:30.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在介绍差分数组之前，先回顾一下「前缀和数组」</p><p>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</p><p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</p><p>使用场景：对于一个数组 <code>nums[]</code></p><ul><li>要求一：对 <code>num[2...4]</code> 全部 + 1</li><li>要求二：对 <code>num[1...3]</code> 全部 - 3</li><li>要求三：对 <code>num[0...4]</code> 全部 + 9</li></ul><p>看到上述情景，首先想到的肯定是遍历（bao li）。直接对数组循环 3 遍，每次在规定的区间上按要求进行操作，此时时间复杂度O(3n)</p><p>但是当这样的操作变得频繁后，时间复杂度也呈线性递增</p><p>所以针对这种场景，提出了「差分数组」的概念，举个简单的例子</p><p><img src="https://pic.leetcode-cn.com/1649302054-sjfBPU-1036101649298970IqiB0Himage-20220407103610070.png" alt="1036101649298970IqiB0Himage-20220407103610070.png"></p><p><code>diff[]</code> 和 <code>nums[]</code> 的关系：<code>diff[i] = nums[i] - nums[i - 1]</code>，<code>diff[0]</code> 除外</p><hr><h2 id="使用好处"><a href="#使用好处" class="headerlink" title="使用好处"></a>使用好处</h2><p>当我们需要对 <code>nums[]</code> 进行上述三个要求时，不需要一次一次的遍历整个数组了，而只需要对 <code>diff[]</code> 进行一次 <code>O(1)</code> 的操作即可</p><ul><li>要求一：对 <code>num[2...4]</code> 全部 + 1  -&gt; <code>diff[2] += 1</code></li><li>要求二：对 <code>num[1...3]</code> 全部 - 3  -&gt; <code>diff[1] += (-3); diff[3 + 1] -= (-3)</code> </li><li>要求三：对 <code>num[0...4]</code> 全部 + 9  -&gt; <code>diff[0] += 9</code></li></ul><p>总结：对于改变区间 <code>[i, j]</code> 的值，只需要进行如下操作 <code>diff[i] += val; diff[j + 1] -= val</code></p><p><strong>注</strong>：当 <code>j + 1 &gt;= diff.length</code> 时，不需要进行 <code>diff[j + 1] -= val</code> 操作</p><hr><h2 id="还原数据"><a href="#还原数据" class="headerlink" title="还原数据"></a>还原数据</h2><p>怎么通过 <code>diff[]</code> 得到更新后的数组呢？？？？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复原操作</span></span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="comment">// 下标为 0 的元素相等</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    res[i] = diff[i] + res[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="diff-原理"><a href="#diff-原理" class="headerlink" title="diff[] 原理"></a>diff[] 原理</h2><p>还原数据就相当于对diff数组求一个前缀和。</p><p>当我们需要对区间 <code>[i, j]</code> 进行 <code>+ val</code> 操作时，我们对 <code>diff[i] += val; diff[j + 1] -= val;</code></p><p>在复原操作时，当我们求 <code>res[i]</code> 时，<code>res[i - 1]</code> 没有变，而 <code>diff[i]</code> 增加了 3，所以 <code>res[i]</code> 增加 3</p><p>当我们求 <code>res[i + 1]</code> 时，<code>res[i]</code> 增加了 3，而 <code>diff[i + 1]</code> 没有变，故 <code>res[i + 1] = diff[i + 1] + res[i]</code> 增加 3。即：虽然 <code>diff[i + 1]</code> 没有变，但是 <code>res[i]</code> 对后面的 <code>res[i + 1]</code> 有一个累积作用</p><p>当我们求 <code>res[j + 1]</code> 时，<code>res[j]</code> 增加了 3，而 <code>diff[j + 1]</code> 减少了 3，故 <code>res[j + 1] = diff[j + 1] + res[j]</code> 增加没有变。即：我们在 j + 1 的时候，把上述的累积作用去除了，所以 j + 1 后面的元素不受影响</p><hr><h2 id="完整模版"><a href="#完整模版" class="headerlink" title="完整模版"></a>完整模版</h2><p>差分数组也可以不用原数组进行初始化，使用全为0的元素进行初始化，这样得到的结果数组就是偏移数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 差分数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化差分数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;</span><br><span class="line">        diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对区间 [i, j] 增加 val（val 可为负数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val val</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复原操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">差分数组</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>筛质数</title>
    <link href="https://wuwawawa.github.io/posts/996e4f07.html"/>
    <id>https://wuwawawa.github.io/posts/996e4f07.html</id>
    <published>2023-09-19T00:51:18.000Z</published>
    <updated>2023-12-09T12:25:39.835Z</updated>
    
    <content type="html"><![CDATA[<p>统计 [2,n] 中质数的数量是一个很常见的题目，也有很多巧妙高效的做法，接下来的部分只会讲述一些常见的做法。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>很直观的思路是我们枚举每个数判断其是不是质数。</p><p>考虑质数的定义：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。因此对于每个数 x，我们可以从小到大枚举 [2,x-1] 中的每个数 y，判断 y 是否为 x 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 O(n)，无法通过所有测试数据。</p><p>考虑到如果 y 是 x 的因数，那么 x/y 也必然是x 的因数，因此我们只要校验 y 或者 x/y 。不难发现我们只需要枚举 [2,$\sqrt{x}$]即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans += isPrime(i) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt;= x; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li><p>时间复杂度O(n$\sqrt{n}$)。单个数检查的时间复杂度为O($\sqrt{n}$)，一共要检查n个数。</p></li><li><p>空间复杂度O(1)</p></li></ul><hr><hr><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 x 的倍数 2x,3x,…… 一定不是质数，因此我们可以从这里入手。</p><p>我们创建一个数组 isPrime[n] , 其中 isPrime[i] 表示数 i 是不是质数。如果是质数则为 0 ，否则为 1 。</p><p>从小到大遍历每个数，如果这个数为质数，则将其所有倍数都标记为合数（除了该质数本身），这样在运行结束的时候我们就能知道质数的个数。</p><p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,…这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) i * i &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= n; j += i) &#123;</span><br><span class="line">                    isPrime[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度O(nloglog n)。</li><li>空间复杂度O(n)</li></ul><hr><hr><h2 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h2><p>埃氏筛其实还是存在冗余的标记操作，比如对于 45 这个数，它会同时被 3,5 两个数标记为合数，因此我们优化的目标是让每个合数只被标记一次，这样时间复杂度即能保证为 O(n)，这就是我们接下来要介绍的线性筛。</p><p>相较于埃氏筛，我们多维护一个 primes 数组表示当前得到的质数集合。我们从小到大遍历，如果当前的数 x 是质数，就将其加入 primes 数组。</p><p>另一点与埃氏筛不同的是，「标记过程」不再仅当 x 为质数时才进行，而是对每个整数 x 都进行。对于整数 x，我们不再标记其所有的倍数 x⋅x,x⋅(x+1),…，而是只标记质数集合中的数与 x 相乘的数，即 x⋅primes[0], x⋅primes[1] ….. ，且在发现 x mod primes[i] = 0 的时候结束当前标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> prime : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isPrime[i * prime] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primes.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="预处理质数"><a href="#预处理质数" class="headerlink" title="预处理质数"></a>预处理质数</h2><p>在有些题目中，我们需要预处理质数，省去一些重复计算。</p><div class="tabs" id="c23a3bbc-d05e-4e05-abcf-62948c072c4e"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c23a3bbc-d05e-4e05-abcf-62948c072c4e-1"><i class="fas fa-cat"></i>埃氏筛预处理</button></li><li class="tab"><button type="button" data-href="#c23a3bbc-d05e-4e05-abcf-62948c072c4e-2"><i class="fas fa-horse"></i>线性筛预处理</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c23a3bbc-d05e-4e05-abcf-62948c072c4e-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MX</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 0 表示是质数 1 表示是合数</span></span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[MX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= MX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) i * i &lt;= MX) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= MX; j += i) &#123;</span><br><span class="line">                    isPrime[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c23a3bbc-d05e-4e05-abcf-62948c072c4e-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MX</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ArrayList&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 0 表示是质数 1 表示是合数</span></span><br><span class="line">    <span class="type">int</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">int</span>[MX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= MX; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> prime : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime &gt; MX) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isPrime[i * prime] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">枚举、埃氏筛、线性筛</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://wuwawawa.github.io/posts/c517589e.html"/>
    <id>https://wuwawawa.github.io/posts/c517589e.html</id>
    <published>2023-09-14T01:33:46.000Z</published>
    <updated>2023-10-02T07:45:43.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>顾名思义，并查集支持两种操作：</p><ul><li>合并(Union)：合并两个元素所属集合（合并对应的树）</li><li>查询(Find)：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li></ul><hr><hr><h2 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h2><p>运用以下这三个函数可以构建并查集算法的基本框架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] cnt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化并查集的父节点数组，将每个元素的父节点都初始化为自己</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        N = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素x和元素y所在的集合合并成一个集合。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pra</span> <span class="operator">=</span> find(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">prb</span> <span class="operator">=</span> find(b);</span><br><span class="line">        <span class="keyword">if</span> (pra != prb) &#123;</span><br><span class="line">            parent[prb] = pra;</span><br><span class="line">            cnt[pra] += cnt[prb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素x的父节点，判断元素x属于哪个集合</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[x] != x) &#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 连通块个数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getBlockNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == find(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">并查集</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>大数运算</title>
    <link href="https://wuwawawa.github.io/posts/8878d18a.html"/>
    <id>https://wuwawawa.github.io/posts/8878d18a.html</id>
    <published>2023-09-09T05:44:29.000Z</published>
    <updated>2023-09-14T01:35:39.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h2><p>算法流程： 设定 i，j 两指针分别指向 num1，num2 尾部，模拟人工加法；</p><p>计算进位： 计算 carry = tmp // 10，代表当前位相加是否产生进位；</p><p>添加当前位： 计算 tmp = n1 + n2 + carry，并将当前位 tmp % 10 添加至 res 头部；</p><p>索引溢出处理： 当指针 i或j 走过数字首部后，给 n1，n2 赋值为 0，相当于给 num1，num2 中长度较短的数字前面填 0，以便后续计算。</p><p>当遍历完 num1，num2 后跳出循环，并根据 carry 值决定是否在头部添加进位 1，最终返回 res 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1 + n2 + carry;</span><br><span class="line">        res.append(tmp % <span class="number">10</span>);</span><br><span class="line">        carry = tmp / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        res.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="大数相乘"><a href="#大数相乘" class="headerlink" title="大数相乘"></a>大数相乘</h2><p>如果 <code>num1</code> 和 <code>num2</code> 之一是0 ，则直接将0作为结果返回即可。</p><p>如果 <code>num1</code> 和 <code>num2</code> 都不是0，则可以用过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果进行累加。</p><p>这道题中，被乘数是 <code>nums1</code> ,乘数是 <code>num2</code>。</p><p>需要注意的是，<code>num2</code> 除了最低位以外，其余的每一位的运算结果都需要补 0。 </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/sol1.png" alt="fig1" style="zoom:48%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> num1.length(), len2 = num2.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">curProduct</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 补0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len2 - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            curProduct.append(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum2</span> <span class="operator">=</span> num2.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用 curNum 去乘 num1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len1 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curNum1</span> <span class="operator">=</span> num1.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> curNum1 * curNum2 + carry;</span><br><span class="line"></span><br><span class="line">            curProduct.append(product % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = addStrings(ans,curProduct.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n1 + n2 + carry;</span><br><span class="line">        res.append(tmp % <span class="number">10</span>);</span><br><span class="line">        carry = tmp / <span class="number">10</span>;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">        res.append(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="大数相减"><a href="#大数相减" class="headerlink" title="大数相减"></a>大数相减</h2><p>1、执行计算前首先比较减数(num1)和被减数(num2)的大小，如果num1&gt;num2,那么就模拟num1-num2的过程，如果num1&lt;num2，那么结果就为-(num2-num1) 。当然可以为了稳定模拟时候一个大一个小，可将num1始终指向较大的那个数，少写一个if/else.</p><p>2、在比较两个数字大小的时候，因为是字符形式，首先比较两个字符串的长度，长的那个更大短的那个更小，如果两个字符串等大，那么就可以通过字典序从前往后进行比较(Java可直接使用compareTo方法)。</p><p>3、和加法不同的是，减法前面可能产生若干前缀0，这些0是需要你去掉的，例如”1100”-“1000”计算得到的结果为”0100”,你就要把前面的0去掉返回”100”。</p><p>4、具体实现的时候和加法相似，如果使用StringBuilder存储，需要逆置顺序，如果是个负数，前面还要加上’-‘.</p><p>5、每个位置正常进行减法运算，如果值小于0，那么就需要向上借位(+10),那么处理上一位进行减法时候还要将借位的处理一下。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4372098/mlwn6ygdwd.png" alt="img" style="zoom: 67%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num1.length() &lt; num2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num1.length() &gt; num2.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num1.compareTo(num2) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">subtractString</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="string">&#x27;+&#x27;</span>;<span class="comment">//正负号</span></span><br><span class="line">    <span class="comment">//让num1&gt;num2 如果num1&lt;num2 那么结果就是—(num2-num1)</span></span><br><span class="line">    <span class="comment">//可以先将num1和num2交换和前面情况统一</span></span><br><span class="line">    <span class="keyword">if</span> (!compare(num1, num2)) &#123;</span><br><span class="line">        sign = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">team</span> <span class="operator">=</span> num2;</span><br><span class="line">        num2 = num1;</span><br><span class="line">        num1 = team;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num2.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">borrow</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//借位</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? (num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? (num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> n1 - n2 - borrow;</span><br><span class="line">        borrow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)<span class="comment">//需要向前借位</span></span><br><span class="line">        &#123;</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">            num += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">        j--;</span><br><span class="line">        sb.append(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sb = sb.reverse();<span class="comment">//需要先翻转</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//去掉前面没用的’0‘</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; sb.length() &amp;&amp; sb.charAt(index) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果两个数相同 直接返回&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (index == sb.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="string">&#x27;+&#x27;</span>)<span class="comment">//如果正数</span></span><br><span class="line">        <span class="keyword">return</span> sb.substring(index);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sign + sb.substring(index);<span class="comment">//负数需要返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="大数相除"><a href="#大数相除" class="headerlink" title="大数相除"></a>大数相除</h2><p>对于大数a/b，一般最多要求求到其整数解或者余数，即a/b=c……d（a,b,c,d均为整）;也就是<strong>a里面有c个b</strong>，并且还剩下d。核心是先求c是多少，对于程序来说，可以通过枚举啊，将除法变成减法，从a中不断减d，一直到不能减为止。</p><p>但是有个问题，如果被除数a很大很大，可能有居多个b，那么这样时间复杂度太高了，不可能执行那么多次，那么需要怎么样去优化这个方法呢？</p><p>那就要加速寻找次数，减少这个减法的次数了，减法次数减小的一个最好方案就是能不能<strong>扩大除数b</strong>。如果b后面加个<code>&#39;0&#39;</code>，那么算出来的结果就乘以10，减法的次数变成原来十分之一。根据这个思想我们可以一直每次找到b的最大10的倍数(小于a)计算减的次数再换算成减b的总词数，将结果要以字符串方式保留，后面一直迭代到最后为止,这虽然是一道除法运算的题，但是也蕴含减法和加法(次数叠加到结果中)。</p>]]></content>
    
    
    <summary type="html">大数相加、大数相减、大数相乘、</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>限流算法</title>
    <link href="https://wuwawawa.github.io/posts/32609cb8.html"/>
    <id>https://wuwawawa.github.io/posts/32609cb8.html</id>
    <published>2023-09-02T05:04:36.000Z</published>
    <updated>2023-09-02T07:37:52.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="固定窗口算法"><a href="#固定窗口算法" class="headerlink" title="固定窗口算法"></a>固定窗口算法</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>固定窗口限流算法，也叫<span class='p green'>计数器限流算法</span>，是最简单的一种限流算法。</p><p><strong>实现原理是：</strong> 在一个固定长度的时间窗口内限制请求数量，每来一个请求，请求次数加一，如果请求数量超过最大限制，就拒绝该请求。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902132700830.png" alt="image-20230902132700830" style="zoom: 50%;" /></p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定窗口限流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixWindowLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10L</span>; <span class="comment">// 每个窗口的最大请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000L</span>; <span class="comment">// 窗口大小，单位ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">reqCount</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 窗口内的当前请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastTime</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 窗口开始时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限流方法，返回true表示限流</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 判断是否在当前时间窗口内，如果不在就开启一个新的时间窗口</span></span><br><span class="line">        <span class="keyword">if</span> (currentTime - lastTime &gt; windowUnit) &#123;</span><br><span class="line">            <span class="comment">// 重置计数器</span></span><br><span class="line">            reqCount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 开启新窗口</span></span><br><span class="line">            lastTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// // 判断是否超过最大请求量</span></span><br><span class="line">        <span class="keyword">if</span> (reqCount &lt; threshold) &#123;</span><br><span class="line">            reqCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong> 实现简单，容易理解。</p><p><strong>缺点：</strong></p><ol><li>限流不够平滑。例如：限流是每秒3个，在第一毫秒发送了3个请求，达到限流，窗口剩余时间的请求都将会被拒绝，体验不好。</li><li>无法处理窗口边界问题。因为是在某个时间窗口内进行流量控制，所以可能会出现窗口边界效应，即在时间窗口的边界处可能会有大量的请求被允许通过，从而导致突发流量。</li></ol><p>例如：限流是每秒3个，在第一秒的最后一毫秒发送了3个请求，在第二秒的第一毫秒又发送了3个请求。在这两毫米内处理了6个请求，但是并没有触发限流。如果出现突发流量，可能会压垮服务器。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902134743416.png" alt="image-20230902134743416" style="zoom: 50%;" /></p><hr><hr><h2 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>为了解决固定窗口算法统计精度太低的问题，引入了滑动窗口算法。在滑动窗口算法中，窗口的起止时间是动态的，窗口的大小固定。这种算法能够较好地处理窗口边界问题，但是实现相对复杂，需要记录每个请求的时间戳。</p><p><strong>实现原理是：</strong> 每来一个请求，就向后推一个时间窗口，计算这个窗口内的请求数量。如果请求数量超过限制就拒绝请求，否则就处理请求，并记录请求的时间戳。另外还需要一个任务清理过期的时间戳。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902135306151.png" alt="image-20230902135306151" style="zoom:50%;" /></p><hr><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 每个窗口的最大请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">windowUnit</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 窗口大小，1000ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Long&gt; requestList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//  请求集合，用来存储窗口内的请求数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限流方法，返回true表示拦截</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 统计当前窗口内，有效的请求数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeOfValid</span> <span class="operator">=</span> <span class="built_in">this</span>.sizeOfValid(currentTime);</span><br><span class="line">        <span class="comment">// 判断是否超过最大请求数量</span></span><br><span class="line">        <span class="keyword">if</span> (sizeOfValid &lt; threshold) &#123;</span><br><span class="line">            <span class="comment">// 把当前请求添加到请求集合里</span></span><br><span class="line">            requestList.add(currentTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计当前窗口内，有效的请求数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sizeOfValid</span><span class="params">(<span class="type">long</span> currentTime)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeOfValid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Long requestTime : requestList) &#123;</span><br><span class="line">            <span class="comment">// 判断是否在当前时间窗口内</span></span><br><span class="line">            <span class="keyword">if</span> (currentTime - requestTime &lt;= windowUnit) &#123;</span><br><span class="line">                sizeOfValid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sizeOfValid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理过期的请求（单独启动一个线程处理）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否超出当前时间窗口内</span></span><br><span class="line">        requestList.removeIf(requestTime -&gt; System.currentTimeMillis() - requestTime &gt; windowUnit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong> 解决了固定窗口算法的窗口边界问题，避免突发流量压垮服务器。</p><p><strong>缺点：</strong> 还是存在限流不够平滑的问题。例如：限流是每秒3个，在第一毫秒发送了3个请求，达到限流，剩余窗口时间的请求都将会被拒绝，体验不好。</p><hr><hr><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><p>漏桶限流算法是一种常用的流量整形（Traffic Shaping）和流量控制（Traffic Policing）的算法，它可以有效地控制数据的传输速率以及防止网络拥塞。</p><p>实现原理是：</p><ol><li>一个固定容量的漏桶，按照固定速率出水（处理请求）；</li><li>当流入水（请求数量）的速度过大会直接溢出（请求数量超过限制则直接拒绝）。</li><li>桶里的水（请求）不够则无法出水（桶内没有请求则不处理）。</li></ol><p>当请求流量正常或者较小的时候，请求能够得到正常的处理。当请求流量过大时，漏桶限流算法可以通过丢弃部分请求来防止系统过载。</p><p>这种算法的一个重要特性是，输出数据的速率始终是稳定的，无论输入的数据流量如何变化。这就确保了系统的负载不会超过预设的阈值。但是，由于漏桶的出口速度是固定的，所以无法处理突发流量。此外，如果入口流量过大，漏桶可能会溢出，导致数据丢失。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902144242297.png" alt="image-20230902144242297" style="zoom:50%;" /></p><hr><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucketLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 桶的最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 桶内当前水量(当前累计的请求数)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">leakRate</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 漏水速率(每秒系统能处理的请求数)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastLeakTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 上次漏水时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true，表示限流</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用漏水方法</span></span><br><span class="line">        <span class="built_in">this</span>.leak();</span><br><span class="line">        <span class="comment">// 判断是否超过最大请求数量</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; threshold) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 漏水方法，计算并更新这段时间内漏水量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leak</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取系统当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 计算这段时间内，需要流出的水量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">leakWater</span> <span class="operator">=</span> (currentTime - lastLeakTime) * leakRate / <span class="number">1000</span>;</span><br><span class="line">        count = Math.max(count - leakWater, <span class="number">0</span>);</span><br><span class="line">        lastLeakTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ol><li><strong>平滑流量。</strong>由于漏桶算法以固定的速率处理请求，可以有效地平滑和整形流量，避免流量的突发和波动（类似于消息队列的削峰填谷的作用）。</li><li><strong>防止过载。</strong>当流入的请求超过桶的容量时，可以直接丢弃请求，防止系统过载。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>无法处理突发流量</strong>：由于漏桶的出口速度是固定的，无法处理突发流量。面对突发流量的时候，漏桶算法还是循规蹈矩地处理请求，这不是我们想看到的。流量变突发时，我们肯定希望系统尽量快点处理请求，提升用户体验。</li><li><strong>可能会丢失数据</strong>：如果入口流量过大，超过了桶的容量，那么就需要丢弃部分请求。在一些不能接受丢失请求的场景中，这可能是一个问题。</li><li><strong>不适合速率变化大的场景</strong>：如果速率变化大，或者需要动态调整速率，那么漏桶算法就无法满足需求。</li></ol><hr><hr><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><p>令牌桶限流算法是一种常用的流量整形和速率限制算法。与漏桶算法一样，令牌桶算法也是用来控制发送到网络上的数据的数量。</p><p>实现原理：</p><ol><li>系统以固定的速率向桶中添加令牌；</li><li>当有请求到来时，会尝试从桶中移除一个令牌，如果桶中有足够的令牌，则请求可以被处理或数据包可以被发送；</li><li>如果桶中没有令牌，那么请求将被拒绝；</li><li>桶中的令牌数不能超过桶的容量，如果新生成的令牌超过了桶的容量，那么新的令牌会被丢弃。</li></ol><p>令牌桶算法的一个重要特性是，它能够应对突发流量。当桶中有足够的令牌时，可以一次性处理多个请求，这对于需要处理突发流量的应用场景非常有用。但是又不会无限制的增加处理速率导致压垮服务器，因为桶内令牌数量是有限制的。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230902150018034.png" alt="image-20230902150018034" style="zoom:50%;" /></p><hr><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucketLimiter</span> <span class="keyword">implements</span> <span class="title class_">Limiter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 桶的最大容量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 桶内当前的令牌数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">tokenRate</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 令牌生成速率（每秒5次）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">lastRefillTime</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 上次生成令牌的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回true表示限流</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">limit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用生成令牌方法</span></span><br><span class="line">        <span class="built_in">this</span>.refillTokens();</span><br><span class="line">        <span class="comment">// 判断桶内是否还有令牌</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成令牌方法，计算并更新这段时间内生成的令牌数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refillTokens</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 计算这段时间内，需要生成的令牌数量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">refillTokens</span> <span class="operator">=</span> (currentTime - lastRefillTime) * tokenRate / <span class="number">1000</span>;</span><br><span class="line">        count = Math.min(count + refillTokens, threshold);</span><br><span class="line">        lastRefillTime = currentTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ol><li><strong>可以处理突发流量</strong>：令牌桶算法可以处理突发流量。当桶满时，能够以最大速度处理请求。这对于需要处理突发流量的应用场景非常有用。</li><li><strong>限制平均速率</strong>：在长期运行中，数据的传输率会被限制在预定义的平均速率（即生成令牌的速率）。</li><li><strong>灵活性</strong>：与漏桶算法相比，令牌桶算法提供了更大的灵活性。例如，可以动态地调整生成令牌的速率。</li></ol><p><strong>缺点：</strong></p><ol><li><strong>可能导致过载</strong>：如果令牌产生的速度过快，可能会导致大量的突发流量，这可能会使网络或服务过载。</li><li><strong>需要存储空间</strong>：令牌桶需要一定的存储空间来保存令牌，可能会导致内存资源的浪费。</li><li><strong>实现稍复杂</strong>：相比于计数器算法，令牌桶算法的实现稍微复杂一些。</li></ol><hr><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>固定窗口算法</strong>实现简单，但是限流不够平滑，存在窗口边界问题，适用于需要简单实现限流的场景。</p><p><strong>滑动窗口算法</strong>解决了窗口边界问题，但是还是存在限流不够平滑的问题，适用于需要控制平均请求速率的场景。</p><p><strong>漏桶算法</strong>的优点是流量处理更平滑，但是无法应对突发流量，适用于需要平滑流量的场景。</p><p><strong>令牌桶算法</strong>既能平滑流量，又能处理突发流量，适用于需要处理突发流量的场景。</p>]]></content>
    
    
    <summary type="html">固定窗口、滑动窗口、漏桶和令牌桶限流</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="限流算法" scheme="https://wuwawawa.github.io/tags/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找-红蓝边界法</title>
    <link href="https://wuwawawa.github.io/posts/c1110203.html"/>
    <id>https://wuwawawa.github.io/posts/c1110203.html</id>
    <published>2023-08-11T06:49:12.000Z</published>
    <updated>2023-09-14T13:32:08.638Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找是一种在有序数组中查找某一特定元素的搜索算法。在很多人的印象里，二分查找是一种比较简单的算法。然而在实际中，二分查找经常容易写错，特别是在处理边界条件的时候。算法大神高德纳曾经说过，“虽然二分查找的基本思想相对简单直白，但是细节上却惊人的tricky”。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定有序数组<code>1 2 3 5 5 5 8 9</code>，有4个小问题分别是：</p><p>1) 找到第一个<code>&gt;=5</code>的元素</p><p>2) 找到最后一个<code>&lt;5</code>的元素</p><p>3) 找到第一个<code>&gt;5</code>的元素</p><p>4) 找到最后一个<code>&lt;=5</code>的元素</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230715195248912.png" alt="image-20230715195248912" style="zoom: 50%;" /></p><p>大家可以看到，对于这四个问题来说，它们表面上是比较相似的，但是细节上却有些微的不同，它们的答案也是完全不同的。</p><p>可想而知，如果我们用二分查找来解决这个问题，细节处理并不容易，一不小心可能就会出错。</p><hr><hr><h2 id="新的角度"><a href="#新的角度" class="headerlink" title="新的角度"></a>新的角度</h2><p>让我们暂时忘掉刚才的问题，从一个全新的角度来审视二分查找。</p><p>大家可以看到，这里有一个数组，里面一共有N个元素，这些元素的编号是0到N-1。在这N个元素里面，前K个元素颜色是蓝色，后面的元素是红色。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716093005464.png" alt="image-20230716093005464" style="zoom:80%;" /></p><p>然而，在这个问题中，蓝红边界的位置是未知的，即K是未知的。换句话说，在我们一开始拿到数组的时候，整个数组都是灰色的。这个问题的最终目标，是把蓝红边界找出来，即求出未知数K。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716093139742.png" alt="image-20230716093139742" style="zoom:80%;" /></p><hr><h2 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h2><p>在这里，我们假设一共有9个元素，前面5个元素是蓝色，后面4个元素是红色</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716093644294.png" alt="image-20230716093644294"></p><p>在我们一开始拿到数组的时候，整个数组都是灰色的。</p><p>我们可以设计一个蓝色指针，一开始指向最左面，随后不断向右移动，直到移动到蓝红边界。或者设计一个红色指针，一开始指向最右面，然后不断向左移动，直到移动到蓝红边界。</p><p>这样就求得了蓝红边界所在的位置。</p><p>当然，这种算法是非常低效的，它的算法复杂度是O(n）</p><hr><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>接下来我们看一下如何通过二分查找高效的寻找到蓝红边界，在刚才的朴素算法中，我们持续不断的将蓝色指针向右移动。对于这个过程，我们可以把它理解为蓝色区域不断被拓展。同理，红色指针不断向左移动，我们可以把这个过程理解为红色区域不断被拓展。</p><p>朴素算法之所以效率低下，是因为蓝色区域和红色区域的拓展是缓慢进行的，每次只能拓展一个元素。</p><hr><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><blockquote><p>那么，我们有没有什么办法来加速两个区域的拓展过程呢？</p></blockquote><div class="tabs" id="c747378e-3702-44cf-8e98-a9f5063d2056"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c747378e-3702-44cf-8e98-a9f5063d2056-1"><i class="fas fa-seedling"></i>循环次数1</button></li><li class="tab"><button type="button" data-href="#c747378e-3702-44cf-8e98-a9f5063d2056-2"><i class="fas fa-leaf"></i>循环次数2</button></li><li class="tab"><button type="button" data-href="#c747378e-3702-44cf-8e98-a9f5063d2056-3"><i class="fab fa-apple"></i>循环次数3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c747378e-3702-44cf-8e98-a9f5063d2056-1"><p>我们可以这样做，我们可以直接看一下灰色区域最中间的那个元素颜色。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094245363.png" alt="image-20230716094245363"></p><p>在这里，我们发现这个元素颜色为蓝色。它就意味着，这个元素，以及这个元素之前所有的元素都是蓝色。这样的话，我们便可以直援将蓝色区域拓展到这个元素所在位置。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094329526.png" alt="image-20230716094329526"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c747378e-3702-44cf-8e98-a9f5063d2056-2"><p>让我们继续这样的操作。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094455062.png" alt="image-20230716094455062"></p><p>观察灰色区域中最中间的那个元素颜色，我们发现它是红色，这也就说明了，这个元素以及这个元素后面的元素都是红色。这样的话，我们便可以直接将红色区域拓展到这个元素所在的位置。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094652765.png" alt="image-20230716094652765"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c747378e-3702-44cf-8e98-a9f5063d2056-3"><p>接下来，我们不断的重复这种操作</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094835833.png" alt="image-20230716094835833"></p><p>直到最后，我们便找到了蓝红边界</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716094859442.png" alt="image-20230716094859442"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h3><div class="tabs" id="33539071-8bba-4bca-a801-0931002f5bff"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-1"><i class="fas fa-seedling"></i>1</button></li><li class="tab"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-2"><i class="fas fa-leaf"></i>2</button></li><li class="tab"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#33539071-8bba-4bca-a801-0931002f5bff-4"><i class="fas fa-tree"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="33539071-8bba-4bca-a801-0931002f5bff-1"><p>一开始，我们设计L，R两个指针，L指向-1,R指向N</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095333538.png" alt="image-20230716095333538"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="33539071-8bba-4bca-a801-0931002f5bff-2"><p>当L+1！=R的时候，就会进入循环体。</p><p>然后，我们求得灰色区域中间的那个元素位置M，M=(L+R) /2并且向下取整。如果M的颜色是蓝色，我们就将L赋值为M，也就是将蓝色区域拓展到M。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095536554.png" alt="image-20230716095536554"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="33539071-8bba-4bca-a801-0931002f5bff-3"><p>如果M的颜色是红色，我们便将R赋值为M，也就是将红色区域拓展到M</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095650860.png" alt="image-20230716095650860"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="33539071-8bba-4bca-a801-0931002f5bff-4"><p>我们持续不断的重复这个过程，直到达成L+1=R这个条件，便退出循环。</p><p>此时，我们可以发现，L和R刚刚好指向蓝红边界，我们可以根据实际情况来决定返回L还是R。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716095837237.png" alt="image-20230716095837237"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><p>刚刚我绍的二分查找伪代码，可能和大家在其他地方所看到的版本有所不同。为了进一步证明算法的正确性，让我们看几个细节问题。</p><blockquote><p>为什么<span class='p blue'>L</span>的初始值为-1，<span class='p red'>R</span>的初始值为N?</p></blockquote><p>难道我们不能将L初始化为0，或者让R初始化为N-1么?</p><p>答案是不可以</p><p>试想一下，假如整个数组都是红色,那么如果让L初始化为0，L一开始便处于红色区域内，这也便会造成错误。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100233717.png" alt="image-20230716100233717"></p><p>同理，如果整个数组都是蓝色，那么如果让R初始化为N-1，R一开始便处于蓝色区域，也就造成了错误。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100344067.png" alt="image-20230716100344067"></p><p>所以，我们需要让L初始化为-1，R初始化为N。</p><hr><blockquote><p>更新指针时，能不能写成L=m+1，或者R=m-1?</p></blockquote><p>比如说，对于这样一种情况，在某次循环中，M刚刚好指向蓝色区域的最后一个元素。那么，如果我们让L变成M+1，就会让L指向红色区域，这样就造成了错误。 </p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100809314.png" alt="image-20230716100809314"></p><hr><h2 id="问题答案"><a href="#问题答案" class="headerlink" title="问题答案"></a>问题答案</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230716100920458.png" alt="image-20230716100920458"></p><hr><h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><ul><li>建模：划分<span class='p blue'>蓝</span><span class='p red'>红</span>区域，确定<code>isBlue()</code>函数</li><li>确定返回<span class='p blue'>L</span>还是<span class='p red'>R</span></li><li>套用算法模版</li><li>后处理逻辑</li></ul>]]></content>
    
    
    <summary type="html">二分查找</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://wuwawawa.github.io/posts/e8eb0480.html"/>
    <id>https://wuwawawa.github.io/posts/e8eb0480.html</id>
    <published>2023-08-10T02:28:21.000Z</published>
    <updated>2023-09-14T13:32:14.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寻找一个数-基本的二分查找"><a href="#寻找一个数-基本的二分查找" class="headerlink" title="寻找一个数(基本的二分查找)"></a>寻找一个数(基本的二分查找)</h2><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意点分析</p></blockquote><div class="tabs" id="5c9537ee-7214-4745-8b2a-37749be89f75"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5c9537ee-7214-4745-8b2a-37749be89f75-1"><i class="fas fa-seedling"></i>while循环退出条件</button></li><li class="tab"><button type="button" data-href="#5c9537ee-7214-4745-8b2a-37749be89f75-2"><i class="fas fa-leaf"></i>l和r更新</button></li><li class="tab"><button type="button" data-href="#5c9537ee-7214-4745-8b2a-37749be89f75-3"><i class="fab fa-apple"></i>缺陷</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5c9537ee-7214-4745-8b2a-37749be89f75-1"><p><mark class="hl-label blue">为什么while循环的条件中是&lt;=而不是&lt;</mark> </p><p>因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code></p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p><p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。</p><p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有索引既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[left, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5c9537ee-7214-4745-8b2a-37749be89f75-2"><p>什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断？</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？</p><p>当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> 对不对？因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5c9537ee-7214-4745-8b2a-37749be89f75-3"><p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="寻找第一个满足该条件的值"><a href="#寻找第一个满足该条件的值" class="headerlink" title="寻找第一个满足该条件的值"></a>寻找第一个满足该条件的值</h2><p>当 check(mid) == true 调整的是 r 时：计算 mid 的方式应该为 mid = l + r &gt;&gt; 1</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">int</span> l = <span class="number">0</span>, r = <span class="built_in">n</span> - <span class="number">1</span>;</span><br><span class="line">while (l &lt; r) &#123;</span><br><span class="line">       <span class="built_in">int</span> <span class="built_in">mid</span> = l + r &gt;&gt; <span class="number">1</span>; //推荐写法 <span class="built_in">int</span> <span class="built_in">mid</span> = l +( r - l) / <span class="number">2</span>;</span><br><span class="line">       <span class="built_in">if</span> (check(<span class="built_in">mid</span>)) &#123;</span><br><span class="line">           //偏移r, 求第一个满足该条件的值</span><br><span class="line">           r = <span class="built_in">mid</span>;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           l = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="寻找最后一个满足该条件的值"><a href="#寻找最后一个满足该条件的值" class="headerlink" title="寻找最后一个满足该条件的值"></a>寻找最后一个满足该条件的值</h2><p>当 check(mid) == true 调整的是 l 时：计算 mid 的方式应该为 mid = l + r + 1 &gt;&gt; 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;<span class="comment">//向上取整， +1 操作主要是为了避免发生「死循环」</span></span><br><span class="line">       <span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">           <span class="comment">//偏移l, 求最后一个满足该条件的值</span></span><br><span class="line">           l = mid;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           r = mid - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二分查找</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="https://wuwawawa.github.io/posts/f92eff5d.html"/>
    <id>https://wuwawawa.github.io/posts/f92eff5d.html</id>
    <published>2023-08-02T04:06:11.000Z</published>
    <updated>2023-09-14T01:35:44.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="划分k个相等的子集"><a href="#划分k个相等的子集" class="headerlink" title="划分k个相等的子集"></a>划分k个相等的子集</h2><div class="tabs" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-1"><i class="fas fa-seedling"></i>火柴拼正方形</button></li><li class="tab"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-2"><i class="fas fa-leaf"></i>划分为k个相等的子集</button></li><li class="tab"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-3"><i class="fab fa-apple"></i>3</button></li><li class="tab"><button type="button" data-href="#a5be2cec-b383-4537-9ec2-3406ea64a6ae-4"><i class="fas fa-tree"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-1"><div class="tag link"><a class="link-card" title="473. 火柴拼正方形" href="https://leetcode.cn/problems/matchsticks-to-square/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">473. 火柴拼正方形</p><p class="url">https://leetcode.cn/problems/matchsticks-to-square/</p></div></a></div><p>你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。</p><p>如果你能使这个正方形，则返回 true ，否则返回 false 。</p><div class="tabs" id="10b05bf4-7acc-4492-a4d8-1a859f0abe58"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#10b05bf4-7acc-4492-a4d8-1a859f0abe58-1"><i class="fas fa-cat"></i>解法一</button></li><li class="tab"><button type="button" data-href="#10b05bf4-7acc-4492-a4d8-1a859f0abe58-2"><i class="fas fa-horse"></i>解法二</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="10b05bf4-7acc-4492-a4d8-1a859f0abe58-1"><p>边界条件时不需要对每个桶是否都达到target进行判断。</p><p>若某个桶的长度小于target，那达到末尾时，就必然会有桶长度大于target。而这种情况不会进入下一次递归的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] matchsticks;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makesquare</span><span class="params">(<span class="type">int</span>[] _matchsticks)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(_matchsticks).sum();</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    target = sum/<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    matchsticks = Arrays.stream(_matchsticks).boxed().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span> , <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> idx ,<span class="type">int</span>[] edges)</span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(idx == matchsticks.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前的木棍放置到4个桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">        edges[i] += matchsticks[idx];</span><br><span class="line">        <span class="keyword">if</span>(edges[i] &lt;= target &amp;&amp; dfs(idx + <span class="number">1</span>,edges))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        edges[i] -= matchsticks[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="10b05bf4-7acc-4492-a4d8-1a859f0abe58-2"><p>状态压缩+记忆化</p><p>使用<code>curSum + matchsticks[i] &lt;= side</code>和<code>int newSum = (curSum + matchsticks[i]) % side;</code></p><p>两种方式巧妙实现单边的增长以及当达到side时进行下一条边的选择。</p><p>当sum&lt;side时，sum会一直累积。当刚好达到side时，清0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> side; <span class="comment">// 边长</span></span><br><span class="line"><span class="type">int</span>[] cache;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] matchsticks;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makesquare</span><span class="params">(<span class="type">int</span>[] _matchsticks)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(_matchsticks).sum();</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    side = sum / <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    matchsticks = Arrays.stream(_matchsticks).boxed().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue).toArray();</span><br><span class="line">    n = _matchsticks.length;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">    cache[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span> curSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[state] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[state] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((state &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; curSum + matchsticks[i] &lt;= side) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newSum</span> <span class="operator">=</span> (curSum + matchsticks[i]) % side;</span><br><span class="line">            <span class="keyword">if</span> (dfs(state | (<span class="number">1</span> &lt;&lt; i), newSum)) &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cache[state] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-2"><p><div class="tag link"><a class="link-card" title="698. 火柴拼正方形" href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/"><div class="left"><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/leetcode.jpg"/></div><div class="right"><p class="text">698. 火柴拼正方形</p><p class="url">https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</p></div>&lt;/a&gt;&lt;/div&gt;</p><p>给定一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p><p>同上一题写法</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="a5be2cec-b383-4537-9ec2-3406ea64a6ae-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">回溯</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从暴力递归到动态规划</title>
    <link href="https://wuwawawa.github.io/posts/1d80917d.html"/>
    <id>https://wuwawawa.github.io/posts/1d80917d.html</id>
    <published>2023-07-05T13:11:40.000Z</published>
    <updated>2023-09-14T01:35:54.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么暴力递归可以继续优化？"><a href="#什么暴力递归可以继续优化？" class="headerlink" title="什么暴力递归可以继续优化？"></a>什么暴力递归可以继续优化？</h3><p>有重复调用同一个子问题的解，这种递归可以优化</p><p>如果每一个子问题都是不同的解，无法优化也不用优化</p><hr><h3 id="暴力递归和动态规划的关系"><a href="#暴力递归和动态规划的关系" class="headerlink" title="暴力递归和动态规划的关系"></a>暴力递归和动态规划的关系</h3><p>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划</p><p>任何动态规划问题，都一定对应着某一个有重复过程的暴力递归</p><p>但不是所有的暴力递归，都一定对应着动态规划</p><hr><h3 id="如何找到问题的动态规划方式？"><a href="#如何找到问题的动态规划方式？" class="headerlink" title="如何找到问题的动态规划方式？"></a>如何找到问题的动态规划方式？</h3><ul><li>设计暴力递归：原则+4种常见尝试模型！</li><li>分析有没有重复解</li><li>用记忆化搜索-&gt;用严格表结构实现动态规划</li><li>看看能否继续优化</li></ul><hr><h3 id="设计暴力递归过程的原则"><a href="#设计暴力递归过程的原则" class="headerlink" title="设计暴力递归过程的原则"></a>设计暴力递归过程的原则</h3><p>1）每一个可变参数的类型，一定不要比int类型更加复杂</p><p>2）原则1）可以违反，让类型突破到一维线性结构，那必须是单一可变参数（贴纸问题）</p><p>3）如果发现原则1）被违反，但不违反原则2），只需要做到记忆化搜索即可</p><p>4）可变参数的个数，能少则少</p><p>一定要逼自己找到不违反原则情况下的暴力尝试！</p><p>如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！</p><p>如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%！</p><hr><h3 id="常见的4种尝试模型"><a href="#常见的4种尝试模型" class="headerlink" title="常见的4种尝试模型"></a>常见的4种尝试模型</h3><p>1）从左往右的尝试模型：关注i位置结尾，或者i位置开头的情况，或者看i联合i+1,i+2的情况，填表往往是上到下，或者下到上，左到右，右到左。</p><p>2）范围上的尝试模型：关注L和R的情况，填表格式非常固定，主对角，副对角，倒回来填</p><p>3）多样本位置全对应的尝试模型：2个样本，一个样本做行，一个样本做列，关注i和j对应位置的情况，先填边界，再填中间</p><p>4）寻找业务限制的尝试模型：比如走棋盘，固定的几个方向可以走，先填边界，再填中间。</p><hr><h3 id="暴力递归到动态规划的套路"><a href="#暴力递归到动态规划的套路" class="headerlink" title="暴力递归到动态规划的套路"></a>暴力递归到动态规划的套路</h3><p>1）你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用<br> 2）找到哪些参数的变化会影响返回值，对每一个列出变化范围<br> 3）参数间的所有的组合数量，意味着表大小<br> 4）记忆化搜索的方法就是傻缓存，非常容易得到<br> 5）规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解<br> 6）对于有枚举行为的决策过程，进一步优化</p><hr><h3 id="动态规划的进一步优化"><a href="#动态规划的进一步优化" class="headerlink" title="动态规划的进一步优化"></a>动态规划的进一步优化</h3><p>1）空间压缩<br>2）状态化简<br>3）四边形不等式</p><p>4）其他优化技巧</p><hr><hr><h2 id="从左往右的尝试模型"><a href="#从左往右的尝试模型" class="headerlink" title="从左往右的尝试模型"></a>从左往右的尝试模型</h2><p>关注i位置结尾，或者i位置开头的情况，或者看i联合i+1,i+2的情况，填表往往是上到下，或者下到上，左到右，右到左。</p><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p>假设有排成一行的N个位置，记为1~N，N 一定大于或等于2 </p><p>开始时机器人在其中的M位置上(M 一定是1~N 中的一个）</p><p> 如果机器人来到1位置，那么下一步只能往右来到2位置；</p><p>如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；</p><p>如果机器人来到中间位置，那么下一步可以往左走或者往右走；</p><p>规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个）的方法有多少种</p><p>给定四个参数N、M、K、P，返回方法数。</p><div class="tabs" id="6fc3a967-8198-4bf8-900f-bd039c7f5726"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-1"><i class="fas fa-seedling"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-2"><i class="fas fa-leaf"></i>重复解分析</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-3"><i class="fab fa-apple"></i>傻缓存法</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-4"><i class="fas fa-heartbeat"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#6fc3a967-8198-4bf8-900f-bd039c7f5726-5"><i class="fas fa-tree"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways1</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process1(start, K, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 机器人当前来到的位置是cur，</span></span><br><span class="line"><span class="comment">// 机器人还有rest步需要去走，</span></span><br><span class="line"><span class="comment">// 最终的目标是aim，</span></span><br><span class="line"><span class="comment">// 有哪些位置？1~N</span></span><br><span class="line"><span class="comment">// 返回：机器人从cur出发，走过rest步之后，最终停在aim的方法数，是多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> aim, <span class="type">int</span> N)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123; <span class="comment">// 如果已经不需要走了，走完了！</span></span><br><span class="line"><span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line"><span class="keyword">if</span> (cur == <span class="number">1</span>) &#123; <span class="comment">// 1 -&gt; 2</span></span><br><span class="line"><span class="keyword">return</span> process1(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line"><span class="keyword">if</span> (cur == N) &#123; <span class="comment">// N-1 &lt;- N</span></span><br><span class="line"><span class="keyword">return</span> process1(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line"><span class="keyword">return</span> process1(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N) + process1(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-2"><p>假如从7位置出发走到13，还有10步需要走，存在重复解。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230706110749520.png" alt="image-20230706110749520" style="zoom:67%;" /></p><p>cur和rest是决定返回值的key</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-3"><p>记忆化搜索（从顶向下的动态规划）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways2</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp就是缓存表</span></span><br><span class="line"><span class="comment">// dp[cur][rest] == -1 -&gt; process1(cur, rest)之前没算过！</span></span><br><span class="line"><span class="comment">// dp[cur][rest] != -1 -&gt; process1(cur, rest)之前算过！返回值，dp[cur][rest]</span></span><br><span class="line"><span class="comment">// N+1 * K+1</span></span><br><span class="line"><span class="keyword">return</span> process2(start, K, aim, N, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cur 范: 1 ~ N</span></span><br><span class="line"><span class="comment">// rest 范：0 ~ K</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> rest, <span class="type">int</span> aim, <span class="type">int</span> N, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[cur][rest] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dp[cur][rest];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之前没算过！</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">ans = cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">ans = process2(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">ans = process2(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ans = process2(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp) + process2(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N, dp);</span><br><span class="line">&#125;</span><br><span class="line">dp[cur][rest] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-4"><p>假设现在有5个位置，机器人当前在2位置，要前往4位置，有6步需要走</p><p>即N = 5，cur=2，aim=4，rest=6</p><div class="tabs" id="ada86bca-98db-41ea-ad53-a4296606c901"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ada86bca-98db-41ea-ad53-a4296606c901-1"><i class="fas fa-cat"></i>初始情况</button></li><li class="tab"><button type="button" data-href="#ada86bca-98db-41ea-ad53-a4296606c901-2"><i class="fas fa-horse"></i>basecase和ans</button></li><li class="tab"><button type="button" data-href="#ada86bca-98db-41ea-ad53-a4296606c901-3"><i class="fas fa-dove"></i>普遍位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ada86bca-98db-41ea-ad53-a4296606c901-1"><p>cur = 0位置是弃用的，cur只能是1-N</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E5%88%9D%E5%A7%8B%E6%83%85%E5%86%B51.png" alt="初始情况1"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ada86bca-98db-41ea-ad53-a4296606c901-2"><p>主函数中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">process1</span><span class="params">(start, K, aim, N)</span></span>;</span><br></pre></td></tr></table></figure><p>暴力递归函数中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123; <span class="comment">// 如果已经不需要走了，走完了！</span></span><br><span class="line"><span class="keyword">return</span> cur == aim ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当rest等于0时，只有cur==aim是，才是1，最终需要process(2,6)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/baseCase%E5%92%8Cans1.png" alt="baseCase和ans1"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ada86bca-98db-41ea-ad53-a4296606c901-3"><p>暴力递归中</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line">if (cur == <span class="number">1</span>) &#123; <span class="comment">// 1 -&gt; 2</span></span><br><span class="line">return <span class="built_in">process1</span>(<span class="number">2</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line">if (cur == N) &#123; <span class="comment">// N-1 &lt;- N</span></span><br><span class="line">return <span class="built_in">process1</span>(N - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (cur, rest)</span></span><br><span class="line">return <span class="built_in">process1</span>(cur - <span class="number">1</span>, rest - <span class="number">1</span>, aim, N) + <span class="built_in">process1</span>(cur + <span class="number">1</span>, rest - <span class="number">1</span>, aim, N);</span><br></pre></td></tr></table></figure><p>既不是第一行，也不最后一行，普遍位置依赖坐上角的值和坐下角的值</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%99%AE%E9%81%8D%E4%BD%8D%E7%BD%AE1.png" alt="普遍位置1"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6fc3a967-8198-4bf8-900f-bd039c7f5726-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways3</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> start, <span class="type">int</span> aim, <span class="type">int</span> K)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">2</span> || start &lt; <span class="number">1</span> || start &gt; N || aim &lt; <span class="number">1</span> || aim &gt; N || K &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line">dp[aim][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= K; rest++) &#123;</span><br><span class="line">dp[<span class="number">1</span>][rest] = dp[<span class="number">2</span>][rest - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">2</span>; cur &lt; N; cur++) &#123;</span><br><span class="line">dp[cur][rest] = dp[cur - <span class="number">1</span>][rest - <span class="number">1</span>] + dp[cur + <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[N][rest] = dp[N - <span class="number">1</span>][rest - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[start][K];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p>规定1和A对应、2和B对应、3和C对应…..</p><p>那么一个数字字符串比如”111”就可以转化为：”AAA”、”KA”和”AK”</p><p>给定一个只有数字字符组成的字符串str，返回有多少种转化结果</p><div class="tabs" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2b7683cc-3522-45ca-9ef3-7374aaed0b7a-1"><i class="fas fa-cat"></i>暴力尝试</button></li><li class="tab"><button type="button" data-href="#2b7683cc-3522-45ca-9ef3-7374aaed0b7a-2"><i class="fas fa-horse"></i>重复问题分析</button></li><li class="tab"><button type="button" data-href="#2b7683cc-3522-45ca-9ef3-7374aaed0b7a-3"><i class="fas fa-dragon"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str只含有数字字符0~9</span></span><br><span class="line"><span class="comment">// 返回多少种转化方案</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">number</span><span class="params">(String str)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[0..i-1]转化无需过问</span></span><br><span class="line"><span class="comment">// str[i.....]去转化，返回有多少种转化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i没到最后，说明有字符</span></span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 之前的决定有问题</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// str[i] != &#x27;0&#x27;</span></span><br><span class="line"><span class="comment">// 可能性一，i单转</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> process(str, i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">ways += process(str, i + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a-2"><p>假如str = “111”</p><p>两个1 解读为两个字符  p(0)-&gt;p(2)</p><p>两个1 解读为一个字符  p(0)-&gt;p(2)</p><p>存在重复问题</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b7683cc-3522-45ca-9ef3-7374aaed0b7a-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">dp[N] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> dp[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + str[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">ways += dp[i + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><div class="tabs" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-1"><i class="fas fa-bug"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-2"><i class="fas fa-cannabis"></i>重复解分析</button></li><li class="tab"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-3"><i class="fas fa-candy-cane"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#46bf3a18-2b78-4cc8-9cdb-5b3488599afc-4"><i class="fas fa-child"></i>严格位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有的货，重量和价值，都在w和v数组里</span></span><br><span class="line"><span class="comment">// 为了方便，其中没有负数</span></span><br><span class="line"><span class="comment">// bag背包容量，不能超过这个载重</span></span><br><span class="line"><span class="comment">// 返回：不超重的情况下，能够得到的最大价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length != v.length || w.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试函数！</span></span><br><span class="line"><span class="keyword">return</span> process(w, v, <span class="number">0</span>, bag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前考虑到了index号货物，index...所有的货物可以自由选择</span></span><br><span class="line"><span class="comment">// 做的选择不能超过背包容量</span></span><br><span class="line"><span class="comment">// 返回最大价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 不要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest);</span><br><span class="line">  <span class="comment">// 要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest - w[index]);</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = v[index] + next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-2"><p>w = [3,2,5…..]</p><p>v = [7,4,6…..]</p><p>bag = 15</p><p>要了0，1号货，没要2号货调用过程  p(0,15)-&gt;p(1,12)-p(2,10)-&gt;p(3,10)</p><p>没要0，1，但是要了2号货调用过程 p(0,15)-&gt;p(1,15)-&gt;p(2,15)-&gt;p(3,10)</p><p>存在重复调用</p><p>index rest 即为变量</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-3"><p>假设背包大小为10，共有4件物品</p><div class="tabs" id="e59b06c7-c7b9-4440-bffd-7640af43b5de"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#e59b06c7-c7b9-4440-bffd-7640af43b5de-1"><i class="fas fa-seedling"></i>basecase和ans</button></li><li class="tab"><button type="button" data-href="#e59b06c7-c7b9-4440-bffd-7640af43b5de-2"><i class="fas fa-leaf"></i>普遍位置分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="e59b06c7-c7b9-4440-bffd-7640af43b5de-1"><p>index 在递归中是可以到w.length的</p><p>最终需要process(0,bag)状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == w.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98basecase.png" alt="背包问题basecase"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="e59b06c7-c7b9-4440-bffd-7640af43b5de-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 不要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest);</span><br><span class="line"> <span class="comment">// 要当前的货</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(w, v, index + <span class="number">1</span>, rest - w[index]);</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = v[index] + next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设</p><p>w[1] = 2 v[1] = 4，则普遍位置？依赖如图所示</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%99%AE%E9%81%8D%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%96.png" alt="背包问题普遍位置依赖"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="46bf3a18-2b78-4cc8-9cdb-5b3488599afc-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] w, <span class="type">int</span>[] v, <span class="type">int</span> bag)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (w == <span class="literal">null</span> || v == <span class="literal">null</span> || w.length != v.length || w.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> w.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][bag + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= bag; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> rest - w[index] &lt; <span class="number">0</span> ? -<span class="number">1</span> : dp[index + <span class="number">1</span>][rest - w[index]];</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = v[index] + next;</span><br><span class="line">&#125;</span><br><span class="line">dp[index][rest] = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][bag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="零钱兑换问题"><a href="#零钱兑换问题" class="headerlink" title="零钱兑换问题"></a>零钱兑换问题</h3><h4 id="零钱兑换问题Ⅰ"><a href="#零钱兑换问题Ⅰ" class="headerlink" title="零钱兑换问题Ⅰ"></a>零钱兑换问题Ⅰ</h4><p>arr是货币数组，其中的值都是正数。再给定一个正数aim。</p><p>每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的。</p><p>返回组成aim的方法数</p><p>例如：art ={1,1,1} aim = 2</p><p>第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2 一共就3种方法，所以返回3</p><div class="tabs" id="183f6f4e-28dc-487b-81f9-db439f37ab9c"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#183f6f4e-28dc-487b-81f9-db439f37ab9c-1"><i class="fas fa-atom"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#183f6f4e-28dc-487b-81f9-db439f37ab9c-2"><i class="far fa-sun"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="183f6f4e-28dc-487b-81f9-db439f37ab9c-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinWays</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index....] 组成正好rest这么多的钱，有几种方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 没钱了！</span></span><br><span class="line"><span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, index + <span class="number">1</span>, rest) + process(arr, index + <span class="number">1</span>, rest - arr[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="183f6f4e-28dc-487b-81f9-db439f37ab9c-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest] + (rest - arr[index] &gt;= <span class="number">0</span> ? dp[index + <span class="number">1</span>][rest - arr[index]] : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h4 id="零钱兑换问题Ⅱ-斜率优化"><a href="#零钱兑换问题Ⅱ-斜率优化" class="headerlink" title="零钱兑换问题Ⅱ(斜率优化)"></a>零钱兑换问题Ⅱ(斜率优化)</h4><p>arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。</p><p>每个值都认为是一种面值，且认为张数是无限的，返回组成aim的方法数。</p><p>例如：arr ={1,2)， aim = 4</p><p>方法如下：1+1+1+1、1+1+2、2+2一共就3种方法，所以返回3</p><div class="tabs" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-1"><i class="fas fa-bug"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-2"><i class="fas fa-cannabis"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-3"><i class="fas fa-candy-cane"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-4"><i class="fas fa-child"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinsWay</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index....] 所有的面值，每一个面值都可以任意选择张数，组成正好rest这么多钱，方法数多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length) &#123; <span class="comment">// 没钱了</span></span><br><span class="line"><span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">ways += process(arr, index + <span class="number">1</span>, rest - (zhang * arr[index]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-2"><p>index = 2 时   面值为3</p><p>f(2,10) -&gt; f(3,10)  f(3,7)  f(3,4)  f(3,1)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A21111.png" alt="零钱兑换1111"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line">ways += dp[index + <span class="number">1</span>][rest - (zhang * arr[index])];</span><br><span class="line">&#125;</span><br><span class="line">dp[index][rest] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="cb88b2dc-c5ff-4cd0-bb1d-d08fe7f92cb1-4"><p>当一个格子没有枚举行为，只依赖有限的格子时，记忆化搜索和严格表结构一样的好</p><p>当一个格子有枚举行为，可以根据位置依赖严格表结构进行分析，进一步优化</p><p>index = 2 时   面值为3</p><p>p(2,10) = p(3,10) +p(3,7)+p(3,4) +p(3,1)</p><p>注意看</p><p>p(2,7) = p(3,7)+p(3,4) +p(3,1)</p><p>所以</p><p>p(2,10) = p(3,10) +p(2,7)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2222.png" alt="零钱兑换222"></p><p><mark class="hl-label blue">优化</mark> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[index][rest] += dp[index][rest - arr[index]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="零钱兑换问题Ⅲ-斜率优化"><a href="#零钱兑换问题Ⅲ-斜率优化" class="headerlink" title="零钱兑换问题Ⅲ(斜率优化)"></a>零钱兑换问题Ⅲ(斜率优化)</h4><p>arr是货币数组，其中的值都是正数。再给定一个正数aim。</p><p>每个值都认为是一张货币，认为值相同的货币没有任何不同，</p><p>返回组成aim的方法数</p><p>例如：arr={1,2,1,1,2,1,2)， aim = 4</p><p>方法：1+1+1+1、 1+1+2、 2+2 一共就3种方法，所以返回3</p><div class="tabs" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-1"><i class="fas fa-cat"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-2"><i class="fas fa-horse"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-3"><i class="fas fa-dove"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#ed4bd118-c42d-44f9-809e-8f2da4af85c0-4"><i class="fas fa-dragon"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinsWay</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts.containsKey(value)) &#123;</span><br><span class="line">            counts.put(value, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counts.put(value, counts.get(value) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> counts.size();</span><br><span class="line">    <span class="type">int</span>[] coins = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span>[] zhangs = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">        coins[index] = entry.getKey();</span><br><span class="line">        zhangs[index++] = entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(coins, zhangs, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// coins 面值数组，正数且去重</span></span><br><span class="line"><span class="comment">// zhangs 每种面值对应的张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span>[] zhangs, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == coins.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * coins[index] &lt;= rest &amp;&amp; zhang &lt;= zhangs[index]; zhang++) &#123;</span><br><span class="line">        ways += process(coins, zhangs, index + <span class="number">1</span>, rest - (zhang * coins[index]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-2"><p>假设aim = 13</p><p>货币数设处理后为</p><p>coins = [1,3,4]</p><p>zhangs = [1,2,3] </p><p>p(2,10) = a +b+c</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2444.png" alt="零钱兑换444"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-3"><pre><code>public static int dp1(int[] arr, int aim) {    if (arr == null || arr.length == 0 || aim &lt; 0) {        return 0;    }    Info info = getInfo(arr);    int[] coins = info.coins;    int[] zhangs = info.zhangs;    int N = coins.length;    int[][] dp = new int[N + 1][aim + 1];    dp[N][0] = 1;    for (int index = N - 1; index &gt;= 0; index--) {        for (int rest = 0; rest &lt;= aim; rest++) {            int ways = 0;            for (int zhang = 0; zhang * coins[index] &lt;= rest &amp;&amp; zhang &lt;= zhangs[index]; zhang++) {                ways += dp[index + 1][rest - (zhang * coins[index])];            }            dp[index][rest] = ways;        }    }    return dp[0][aim];}</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ed4bd118-c42d-44f9-809e-8f2da4af85c0-4"><p>p(2,10) = a+b+c</p><p>p(2,7) = b+c+d</p><p>p(2,10) = a+p(2,7)-d</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%A2%86%E5%8F%96%E5%85%91%E6%8D%A2333.png" alt="领取兑换333"></p><p><mark class="hl-label blue">优化</mark> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span> || aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> getInfo(arr);</span><br><span class="line"><span class="type">int</span>[] coins = info.coins;</span><br><span class="line"><span class="type">int</span>[] zhangs = info.zhangs;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> coins.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - coins[index] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[index][rest] += dp[index][rest - coins[index]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rest - coins[index] * (zhangs[index] + <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[index][rest] -= dp[index + <span class="number">1</span>][rest - coins[index] * (zhangs[index] + <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="零钱兑换问题Ⅳ-斜率优化"><a href="#零钱兑换问题Ⅳ-斜率优化" class="headerlink" title="零钱兑换问题Ⅳ(斜率优化)"></a>零钱兑换问题Ⅳ(斜率优化)</h4><p>ar是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。</p><p>每个值都认为是一种面值，且认为张数是无限的。</p><p>返回组成aim的最少货币数</p><div class="tabs" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-1"><i class="fas fa-cat"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-2"><i class="fas fa-horse"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-3"><i class="fas fa-dove"></i>严格表依赖</button></li><li class="tab"><button type="button" data-href="#69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-4"><i class="fas fa-dragon"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCoins</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index...]面值，每种面值张数自由选择，</span></span><br><span class="line"><span class="comment">// 搞出rest正好这么多钱，返回最小张数</span></span><br><span class="line"><span class="comment">// 拿Integer.MAX_VALUE标记怎么都搞定不了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">0</span> : Integer.MAX_VALUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> process(arr, index + <span class="number">1</span>, rest - zhang * arr[index]);</span><br><span class="line"><span class="keyword">if</span> (next != Integer.MAX_VALUE) &#123;</span><br><span class="line">ans = Math.min(ans, zhang + next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-2"><p>p(2,10) = min (a,b,c,d)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6%E9%92%B1666.png" alt="零钱666"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">dp[N][j] = Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="number">0</span>; zhang * arr[index] &lt;= rest; zhang++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][rest - zhang * arr[index]];</span><br><span class="line"><span class="keyword">if</span> (next != Integer.MAX_VALUE) &#123;</span><br><span class="line">ans = Math.min(ans, zhang + next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[index][rest] = ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="69bebcec-3ab2-400d-9c32-73b3d2ad7ffb-4"><p>p(2,10) = min (a,b+1,c+2,d+3)</p><p>p(2,7) = min(b,c+1,d+2)</p><p>p(2,10) = min(a,p(2,7)+1)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E9%9B%B6777.png" alt="零777"></p><p><mark class="hl-label blue">优化</mark> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> aim)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">dp[N][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">dp[N][j] = Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line"><span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span> </span><br><span class="line">&amp;&amp; dp[index][rest - arr[index]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="数字分割问题"><a href="#数字分割问题" class="headerlink" title="数字分割问题"></a>数字分割问题</h3><h4 id="数字分割问题Ⅰ-斜率优化"><a href="#数字分割问题Ⅰ-斜率优化" class="headerlink" title="数字分割问题Ⅰ(斜率优化)"></a>数字分割问题Ⅰ(斜率优化)</h4><p>将数num进行裂开，要求后面的数不能小于前面的数，返回裂开的方式数</p><p>例如</p><p>3 = 1+1+1 = 1+2  = 3</p><p>不能 2+1这样裂开</p><p>返回 3</p><div class="tabs" id="0ffe2f89-db64-4548-8e41-67e6895903cc"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-2"><i class="fas fa-baseball-ball"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-3"><i class="fas fa-bone"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#0ffe2f89-db64-4548-8e41-67e6895903cc-4"><i class="fas fa-anchor"></i>斜率优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0ffe2f89-db64-4548-8e41-67e6895903cc-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n为正数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一个拆出来的数是pre</span></span><br><span class="line"><span class="comment">// 还剩rest需要去拆</span></span><br><span class="line"><span class="comment">// 返回拆解的方法数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pre &gt; rest) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> pre; first &lt;= rest; first++) &#123;</span><br><span class="line">ways += process(first, rest - first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ffe2f89-db64-4548-8e41-67e6895903cc-2"><p>假设 num = 8</p><p>p(3,6) = p(3,3)+p(4,2)+p(5,1)+p(6,0)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E5%88%86%E5%89%B2%E6%95%B0%E5%AD%974.png" alt="分割数字4"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ffe2f89-db64-4548-8e41-67e6895903cc-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>; pre &lt;= n; pre++) &#123;</span><br><span class="line">dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[pre][pre] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> n - <span class="number">1</span>; pre &gt;= <span class="number">1</span>; pre--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> pre + <span class="number">1</span>; rest &lt;= n; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> pre; first &lt;= rest; first++) &#123;</span><br><span class="line">ways += dp[first][rest - first];</span><br><span class="line">&#125;</span><br><span class="line">dp[pre][rest] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0ffe2f89-db64-4548-8e41-67e6895903cc-4"><p>p(3,6) = p(3,3)+p(4,2)+p(5,1)+p(6,0)</p><p>p(4,6) = p(4,2)+p(5,1)+p(6,0)</p><p>p(3,6) = p(3,3)+p(4,6)</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E5%88%86%E5%89%B2%E6%95%B0%E5%AD%975.png" alt="分割数字5"></p><p><mark class="hl-label blue">优化</mark> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">1</span>; pre &lt;= n; pre++) &#123;</span><br><span class="line">dp[pre][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[pre][pre] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> n - <span class="number">1</span>; pre &gt;= <span class="number">1</span>; pre--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> pre + <span class="number">1</span>; rest &lt;= n; rest++) &#123;</span><br><span class="line">dp[pre][rest] = dp[pre + <span class="number">1</span>][rest];</span><br><span class="line">dp[pre][rest] += dp[pre][rest - pre];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h4 id="数字分割问题Ⅱ"><a href="#数字分割问题Ⅱ" class="headerlink" title="数字分割问题Ⅱ"></a>数字分割问题Ⅱ</h4><p>给定一个正数数组arr,请把arr中所有数分成两个集合，尽量让两个集合的累加和接近</p><p>返回：</p><p>最接近的情况下，较小集合的累加和</p><div class="tabs" id="0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-1"><i class="fas fa-seedling"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-2"><i class="fab fa-apple"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, sum / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[i...]可以自由选择，请返回累加和尽量接近rest，但不能超过rest的情况下，最接近的累加和是多少？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 还有数，arr[i]这个数</span></span><br><span class="line"><span class="comment">// 可能性1，不使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(arr, i + <span class="number">1</span>, rest);</span><br><span class="line"><span class="comment">// 可能性2，要使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= rest) &#123;</span><br><span class="line">p2 = arr[i] + process(arr, i + <span class="number">1</span>, rest - arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="0eff5d0c-f03d-475d-920c-1b6a8b3cc8e2-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= sum; rest++) &#123;</span><br><span class="line"><span class="comment">// 可能性1，不使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i + <span class="number">1</span>][rest];</span><br><span class="line"><span class="comment">// 可能性2，要使用arr[i]</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= rest) &#123;</span><br><span class="line">p2 = arr[i] + dp[i + <span class="number">1</span>][rest - arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">dp[i][rest] = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="数字分割问题Ⅲ"><a href="#数字分割问题Ⅲ" class="headerlink" title="数字分割问题Ⅲ"></a>数字分割问题Ⅲ</h4><p>给定一个正数数组arr，请把arr中所有的数分成两个集合</p><p>如果arr长度为偶数，两个集合包含数的个数要一样多</p><p>如果ar长度为奇数，两个集合包含数的个数必须只差一个</p><p>请尽量让两个集合的累加和接近。</p><p>返回：</p><p>最接近的情况下，较小集合的累加和</p><div class="tabs" id="141151c9-b391-4995-af55-9e30d6dfa3c4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#141151c9-b391-4995-af55-9e30d6dfa3c4-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#141151c9-b391-4995-af55-9e30d6dfa3c4-2"><i class="fas fa-baseball-ball"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="141151c9-b391-4995-af55-9e30d6dfa3c4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>, sum / <span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>, sum / <span class="number">2</span>), process(arr, <span class="number">0</span>, arr.length / <span class="number">2</span> + <span class="number">1</span>, sum / <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[i....]自由选择，挑选的个数一定要是picks个，累加和&lt;=rest, 离rest最近的返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> picks, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == arr.length) &#123;</span><br><span class="line"><span class="keyword">return</span> picks == <span class="number">0</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process(arr, i + <span class="number">1</span>, picks, rest);</span><br><span class="line"><span class="comment">// 就是要使用arr[i]这个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt;= rest) &#123;</span><br><span class="line">next = process(arr, i + <span class="number">1</span>, picks - <span class="number">1</span>, rest - arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = arr[i] + next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="141151c9-b391-4995-af55-9e30d6dfa3c4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum /= <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> (N + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][M + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= M; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= sum; k++) &#123;</span><br><span class="line">dp[i][j][k] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= sum; rest++) &#123;</span><br><span class="line">dp[N][<span class="number">0</span>][rest] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">picks</span> <span class="operator">=</span> <span class="number">0</span>; picks &lt;= M; picks++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>; rest &lt;= sum; rest++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i + <span class="number">1</span>][picks][rest];</span><br><span class="line"><span class="comment">// 就是要使用arr[i]这个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (picks - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[i] &lt;= rest) &#123;</span><br><span class="line">next = dp[i + <span class="number">1</span>][picks - <span class="number">1</span>][rest - arr[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (next != -<span class="number">1</span>) &#123;</span><br><span class="line">p2 = arr[i] + next;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][picks][rest] = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((arr.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][arr.length / <span class="number">2</span>][sum];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Math.max(dp[<span class="number">0</span>][arr.length / <span class="number">2</span>][sum], dp[<span class="number">0</span>][(arr.length / <span class="number">2</span>) + <span class="number">1</span>][sum]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><hr><h2 id="范围上的尝试模型"><a href="#范围上的尝试模型" class="headerlink" title="范围上的尝试模型"></a>范围上的尝试模型</h2><p>关注L和R的情况，填表格式非常固定，主对角，副对角，倒回来填</p><h3 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h3><p>给定一个整型数组arr，代表数值不同的纸牌排成一条线</p><p>玩家A和玩家B依次拿走每张纸牌</p><p>规定玩家A先拿，玩家B后拿</p><p>但是每个玩家每次只能拿走最左或最右的纸牌</p><p>玩家A和玩家B都绝顶聪明</p><p>请返回最后获胜者的分数。</p><div class="tabs" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-1"><i class="fas fa-atom"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-2"><i class="far fa-sun"></i>重复解分析</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-3"><i class="fas fa-wind"></i>傻缓存法</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-4"><i class="fas fa-heartbeat"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#de9695fd-ab57-44ba-b16d-b2a5e39619e1-5"><i class="fas fa-fire-alt"></i>严格表结构</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据规则，返回获胜者的分数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> f1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> g1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Math.max(first, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，先手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> arr[L] + g1(arr, L + <span class="number">1</span>, R);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> arr[R] + g1(arr, L, R - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // arr[L..R]，后手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">g1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f1(arr, L + <span class="number">1</span>, R); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f1(arr, L, R - <span class="number">1</span>); <span class="comment">// 对手拿走了R位置的数</span></span><br><span class="line"><span class="keyword">return</span> Math.min(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-2"><p>0-7号纸牌</p><p>对于先手来说，在f(0,7)做最优选择</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230706120741650.png" alt="image-20230706120741650" style="zoom:67%;" /></p><p>出现重叠</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] fmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="type">int</span>[][] gmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">fmap[i][j] = -<span class="number">1</span>;</span><br><span class="line">gmap[i][j] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> f2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, fmap, gmap);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> g2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, fmap, gmap);</span><br><span class="line"><span class="keyword">return</span> Math.max(first, second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]，先手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>[][] fmap, <span class="type">int</span>[][] gmap)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fmap[L][R] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> fmap[L][R];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">ans = arr[L];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> arr[L] + g2(arr, L + <span class="number">1</span>, R, fmap, gmap);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> arr[R] + g2(arr, L, R - <span class="number">1</span>, fmap, gmap);</span><br><span class="line">ans = Math.max(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">fmap[L][R] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // arr[L..R]，后手获得的最好分数返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">g2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>[][] fmap, <span class="type">int</span>[][] gmap)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (gmap[L][R] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> gmap[L][R];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (L != R) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f2(arr, L + <span class="number">1</span>, R, fmap, gmap); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f2(arr, L, R - <span class="number">1</span>, fmap, gmap); <span class="comment">// 对手拿走了R位置的数</span></span><br><span class="line">ans = Math.min(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line">gmap[L][R] = ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-4"><p>假如arr = [7,4,16,15,1]</p><div class="tabs" id="d26e497e-188d-4de1-9c81-a51e2769de01"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#d26e497e-188d-4de1-9c81-a51e2769de01-1"><i class="fas fa-award"></i>basease和ans</button></li><li class="tab"><button type="button" data-href="#d26e497e-188d-4de1-9c81-a51e2769de01-2"><i class="fas fa-baseball-ball"></i>普遍位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="d26e497e-188d-4de1-9c81-a51e2769de01-1"><p>f的basecase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>g的basecase</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终需要的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> f1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> g1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Math.max(first, second);</span><br></pre></td></tr></table></figure><p>即<code>Math.max(fmap[0][4],gmap[0][4]);</code></p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/basecase%E5%92%8Cans2.png" alt="basecase和ans2"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="d26e497e-188d-4de1-9c81-a51e2769de01-2"><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int p1 = arr[L] + g1(arr, <span class="class">L + 1, R);</span><span class="built_in"></span></span><br><span class="line"><span class="built_in">int </span>p2 = arr[R] + g1(arr, <span class="class">L, R - 1);</span></span><br></pre></td></tr></table></figure><p>fmap ？位置依赖</p><p>作gmap中？位置对称点？’，？位置依赖gmap中△ 位置。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%962-1.png" alt="位置依赖2-1"></p><p>同理分析gmap中？位置的依赖</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> p1 = f1(arr, L + <span class="number">1</span>, R); <span class="comment">// 对手拿走了L位置的数</span></span><br><span class="line"><span class="built_in">int</span> p2 = f1(arr, L, R - <span class="number">1</span>); <span class="comment">// 对手拿走了R位置的数</span></span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%962-2.png" alt="位置依赖2-2"></p><p>互推对角线</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="de9695fd-ab57-44ba-b16d-b2a5e39619e1-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">win3</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="type">int</span>[][] fmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="type">int</span>[][] gmap = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">fmap[i][i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> <span class="number">1</span>; startCol &lt; N; startCol++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> startCol;</span><br><span class="line"><span class="keyword">while</span> (R &lt; N) &#123;</span><br><span class="line">fmap[L][R] = Math.max(arr[L] + gmap[L + <span class="number">1</span>][R], arr[R] + gmap[L][R - <span class="number">1</span>]);</span><br><span class="line">gmap[L][R] = Math.min(fmap[L + <span class="number">1</span>][R], fmap[L][R - <span class="number">1</span>]);</span><br><span class="line">L++;</span><br><span class="line">R++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Math.max(fmap[<span class="number">0</span>][N - <span class="number">1</span>], gmap[<span class="number">0</span>][N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="最长回文子序列长度-带优化"><a href="#最长回文子序列长度-带优化" class="headerlink" title="最长回文子序列长度(带优化)"></a>最长回文子序列长度(带优化)</h3><p>给定一个字符串str，返回这个字符串的最长回文子序列长度</p><p>比如：str = “a12b3c43def2ghi1kpm”</p><p>最长回文子序列是 “1234321” 或者 “123c321”，返回长度7</p><blockquote><p>解法1</p></blockquote><p>生成str的逆序串</p><p>str逆 = “mpk1ihg2fed34cb21a”</p><p>原串和逆序串的最长公共子序列即为原串的最长回文子序列</p><blockquote><p>解法2：范围尝试模型</p></blockquote><div class="tabs" id="bd07aba8-9097-4e19-bd74-af70a8555478"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-1"><i class="fas fa-seedling"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-2"><i class="fab fa-apple"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-3"><i class="fas fa-leaf"></i>严格表结构</button></li><li class="tab"><button type="button" data-href="#bd07aba8-9097-4e19-bd74-af70a8555478-4"><i class="fas fa-heartbeat"></i>继续优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="bd07aba8-9097-4e19-bd74-af70a8555478-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl1</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="keyword">return</span> f(str, <span class="number">0</span>, str.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str[L..R]最长回文子序列长度返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L == R - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str[L] == str[R] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> f(str, L + <span class="number">1</span>, R - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f(str, L, R - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> f(str, L + <span class="number">1</span>, R);</span><br><span class="line"><span class="type">int</span> <span class="variable">p4</span> <span class="operator">=</span> str[L] != str[R] ? <span class="number">0</span> : (<span class="number">2</span> + f(str, L + <span class="number">1</span>, R - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> Math.max(Math.max(p1, p2), Math.max(p3, p4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd07aba8-9097-4e19-bd74-af70a8555478-2"><p>basecase </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L == R - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str[L] == str[R] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ans</p><p>f(0,str.length - 1)</p><p>从底往上填</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97222.png" alt="最长回文子序列222"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd07aba8-9097-4e19-bd74-af70a8555478-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl2</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">dp[N - <span class="number">1</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i] = <span class="number">1</span>;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> N - <span class="number">3</span>; L &gt;= <span class="number">0</span>; L--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + <span class="number">2</span>; R &lt; N; R++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[L+<span class="number">1</span>][R-<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[L][R-<span class="number">1</span>];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> dp[L+<span class="number">1</span>][R];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p4</span> <span class="operator">=</span> str[L] == stl[R] ? <span class="number">2</span> + dp[L + <span class="number">1</span>][R - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">dp[L][R] = Math.max(Math.max(p1,p2),Math.max(p3,p4));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="bd07aba8-9097-4e19-bd74-af70a8555478-4"><p>?格子要求出来依赖左、左下和下。并是取最大值。</p><p>那么？格子绝不比坐下和下格子小</p><p>在之前求左格子时，依赖它的左、左下和下</p><p>那么在图中，左格子不可能比左下格子小。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230706170257845.png" alt="image-20230706170257845"></p><p><mark class="hl-label blue">优化</mark> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lpsl2</span><span class="params">(String s)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line">dp[N - <span class="number">1</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">dp[i][i] = <span class="number">1</span>;</span><br><span class="line">dp[i][i + <span class="number">1</span>] = str[i] == str[i + <span class="number">1</span>] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> N - <span class="number">3</span>; L &gt;= <span class="number">0</span>; L--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> L + <span class="number">2</span>; R &lt; N; R++) &#123;</span><br><span class="line">dp[L][R] = Math.max(dp[L][R - <span class="number">1</span>], dp[L + <span class="number">1</span>][R]);</span><br><span class="line"><span class="keyword">if</span> (str[L] == str[R]) &#123;</span><br><span class="line">dp[L][R] = Math.max(dp[L][R], <span class="number">2</span> + dp[L + <span class="number">1</span>][R - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="多样本位置全对应的尝试模型"><a href="#多样本位置全对应的尝试模型" class="headerlink" title="多样本位置全对应的尝试模型"></a>多样本位置全对应的尝试模型</h2><p>多个样本，一个样本做行，一个样本做列，关注i和j对应位置的情况，先填边界，再填中间</p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p><div class="tabs" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2ce89215-5f65-4349-8cf3-c2ca8eb27f51-1"><i class="fas fa-bug"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#2ce89215-5f65-4349-8cf3-c2ca8eb27f51-2"><i class="fas fa-cannabis"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#2ce89215-5f65-4349-8cf3-c2ca8eb27f51-3"><i class="fas fa-candy-cane"></i>严格位置依赖</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence1</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line"><span class="comment">// 尝试</span></span><br><span class="line"><span class="keyword">return</span> process1(str1, str2, str1.length - <span class="number">1</span>, str2.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// str1[0...i]与str2[0...j]最长公共子序列多长？</span></span><br><span class="line"><span class="comment">// 返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(<span class="type">char</span>[] str1, <span class="type">char</span>[] str2, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> str1[i] == str2[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (str1[i] == str2[j]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// i != 0 &amp;&amp; j != 0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> process1(str1, str2, i - <span class="number">1</span>, j);</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> process1(str1, str2, i, j - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> str1[i] == str2[j] ? (<span class="number">1</span> + process1(str1, str2, i - <span class="number">1</span>, j - <span class="number">1</span>)) : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> Math.max(p1, Math.max(p2, p3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51-2"><p>假设str1 = “a12c3d”,str2 = “efg123xy”</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%9711.png" alt="最长公共子序列11"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2ce89215-5f65-4349-8cf3-c2ca8eb27f51-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence2</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s1 == <span class="literal">null</span> || s2 == <span class="literal">null</span> || s1.length() == <span class="number">0</span> || s2.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> str1.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> str2.length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][M];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = str1[<span class="number">0</span>] == str2[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = str1[<span class="number">0</span>] == str2[j] ? <span class="number">1</span> : dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = str1[i] == str2[<span class="number">0</span>] ? <span class="number">1</span> : dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> str1[i] == str2[j] ? (<span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">dp[i][j] = Math.max(p1, Math.max(p2, p3));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N - <span class="number">1</span>][M - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="表达式匹配TODO"><a href="#表达式匹配TODO" class="headerlink" title="表达式匹配TODO"></a>表达式匹配TODO</h3><hr><hr><hr><h2 id="寻找业务限制的尝试模型"><a href="#寻找业务限制的尝试模型" class="headerlink" title="寻找业务限制的尝试模型"></a>寻找业务限制的尝试模型</h2><p>比如走棋盘，固定的几个方向可以走，先填边界，再填中间。</p><h3 id="题目一-2"><a href="#题目一-2" class="headerlink" title="题目一"></a>题目一</h3><p>请同学们自行搜索或者想象一个象棋的棋盘，</p><p>然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置</p><p>那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域给你三个参数x，y，k</p><p>返回马从(0,0)位置出发，必须走k步</p><p>最后落在(x,y)上的方法数有多少种？</p><div class="tabs" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-2"><i class="fas fa-baseball-ball"></i>位置依赖分析</button></li><li class="tab"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-3"><i class="fas fa-bone"></i>严格位置分析</button></li><li class="tab"><button type="button" data-href="#8a6ec6f4-5750-429b-a121-5fd97fac79a3-4"><i class="fas fa-anchor"></i>4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前来到的位置是（x,y）</span></span><br><span class="line"><span class="comment">// 还剩下rest步需要跳</span></span><br><span class="line"><span class="comment">// 跳完rest步，正好跳到a，b的方法数是多少？</span></span><br><span class="line"><span class="comment">// 10 * 9</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(<span class="number">0</span>, <span class="number">0</span>, k, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rest, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (x == a &amp;&amp; y == b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> process(x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line">ways += process(x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>, a, b);</span><br><span class="line"><span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-2"><p>以xy为xy轴，rest为轴</p><p>以不同rest为不同层，同一层之间是不相互依赖的</p><p>从第0层推第一层。。。。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-3"><p>在递归时越界时，我们还能返回0。在数组中越界了可就报错了，所以写一个函数从数组中取出来。</p><p>越界了就返回0，没越界才给你去拿</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"><span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">9</span>][k + <span class="number">1</span>];</span><br><span class="line">dp[a][b][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; rest &lt;= k; rest++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; <span class="number">9</span>; y++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ways</span> <span class="operator">=</span> pick(dp, x + <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x + <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">1</span>, y + <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">2</span>, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x - <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x + <span class="number">1</span>, y - <span class="number">2</span>, rest - <span class="number">1</span>);</span><br><span class="line">ways += pick(dp, x + <span class="number">2</span>, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">dp[x][y][rest] = ways;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">pick</span><span class="params">(<span class="type">int</span>[][][] dp, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">9</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[x][y][rest];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8a6ec6f4-5750-429b-a121-5fd97fac79a3-4"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="题目二-空间优化"><a href="#题目二-空间优化" class="headerlink" title="题目二(空间优化)"></a>题目二(空间优化)</h3><p>给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和返回最小距离累加和</p><p>若<code>dp[i][j]</code>的意思表示为 从(i , j)点走到右下角，最省的路径和是多少。则<code>dp[0][0]</code>为最终答案</p><p>若<code>dp[i][j]</code>的意思表示为 从(0 , 0)点到(i , j)点，最省的路径和是多少。则<code>dp[row - 1][col - 1]</code>为最终答案</p><p>两种写法都可以</p><div class="tabs" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-1"><i class="fas fa-seedling"></i>空间依赖分析</button></li><li class="tab"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-2"><i class="fas fa-leaf"></i>严格表依赖</button></li><li class="tab"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-3"><i class="fab fa-apple"></i>空间优化分析</button></li><li class="tab"><button type="button" data-href="#da9a7f11-c005-4ef0-b17e-77c823fd07d9-4"><i class="fas fa-tree"></i>优化代码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-1"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84111.png" alt="最短路径111"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathSum1</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> m.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + m[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + m[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-3"><p>在我们推第17行的值时只需要16行的值，之前行的值已经不需要了。</p><p>在更新c的时候，左边已经是更新好的，当前位置还未跟新。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96111.png" alt="空间优化111"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="da9a7f11-c005-4ef0-b17e-77c823fd07d9-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minPathSum2</span><span class="params">(<span class="type">int</span>[][] m)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="literal">null</span> || m.length == <span class="number">0</span> || m[<span class="number">0</span>] == <span class="literal">null</span> || m[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> m.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> m[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[col];</span><br><span class="line">dp[<span class="number">0</span>] = m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[j] = dp[j - <span class="number">1</span>] + m[<span class="number">0</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>] += m[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + m[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="贴纸问题"><a href="#贴纸问题" class="headerlink" title="贴纸问题"></a>贴纸问题</h3><p>给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文</p><p>arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来</p><p>返回需要至少多少张贴纸可以完成这个任务</p><p>例子：str = “babac” ,arr={“ba”,”c”,”abcd”}</p><p>至少需要两张贴纸”ba”和”abcd”,因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2。</p><div class="tabs" id="c5e51d73-18c3-429e-bba5-5f04a785aca8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#c5e51d73-18c3-429e-bba5-5f04a785aca8-1"><i class="fas fa-award"></i>暴力递归</button></li><li class="tab"><button type="button" data-href="#c5e51d73-18c3-429e-bba5-5f04a785aca8-2"><i class="fas fa-baseball-ball"></i>词频表优化</button></li><li class="tab"><button type="button" data-href="#c5e51d73-18c3-429e-bba5-5f04a785aca8-3"><i class="fas fa-bone"></i>哈希表优化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="c5e51d73-18c3-429e-bba5-5f04a785aca8-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers1</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process1(stickers, target);</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有贴纸stickers，每一种贴纸都有无穷张</span></span><br><span class="line"><span class="comment">// target</span></span><br><span class="line"><span class="comment">// 最少张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process1</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (String first : stickers) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> minus(target, first);</span><br><span class="line"><span class="keyword">if</span> (rest.length() != target.length()) &#123;</span><br><span class="line">min = Math.min(min, process1(stickers, rest));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minus</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line"><span class="type">char</span>[] str1 = s1.toCharArray();</span><br><span class="line"><span class="type">char</span>[] str2 = s2.toCharArray();</span><br><span class="line"><span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str1) &#123;</span><br><span class="line">count[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str2) &#123;</span><br><span class="line">count[cha - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count[i]; j++) &#123;</span><br><span class="line">builder.append((<span class="type">char</span>) (i + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c5e51d73-18c3-429e-bba5-5f04a785aca8-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers2</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="comment">// 关键优化(用词频表替代贴纸数组)</span></span><br><span class="line"><span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">counts[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process2(counts, target);</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stickers[i] 数组，当初i号贴纸的字符统计 int[][] stickers -&gt; 所有的贴纸</span></span><br><span class="line"><span class="comment">// 每一种贴纸都有无穷张</span></span><br><span class="line"><span class="comment">// 返回搞定target的最少张数</span></span><br><span class="line"><span class="comment">// 最少张数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process2</span><span class="params">(<span class="type">int</span>[][] stickers, String t)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (t.length() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target做出词频统计</span></span><br><span class="line"><span class="comment">// target  aabbc  2 2 1..</span></span><br><span class="line"><span class="comment">//                0 1 2..</span></span><br><span class="line"><span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line"><span class="type">int</span>[] tcounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : target) &#123;</span><br><span class="line">tcounts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="comment">// 尝试第一张贴纸是谁</span></span><br><span class="line"><span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line"><span class="comment">// 最关键的优化(重要的剪枝!这一步也是贪心!)</span></span><br><span class="line"><span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> tcounts[j] - sticker[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums; k++) &#123;</span><br><span class="line">builder.append((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">min = Math.min(min, process2(stickers, rest));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="c5e51d73-18c3-429e-bba5-5f04a785aca8-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStickers3</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">char</span>[] str = stickers[i].toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : str) &#123;</span><br><span class="line">counts[i][cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">HashMap&lt;String, Integer&gt; dp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">dp.put(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> process3(counts, target, dp);</span><br><span class="line"><span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process3</span><span class="params">(<span class="type">int</span>[][] stickers, String t, HashMap&lt;String, Integer&gt; dp)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dp.containsKey(t)) &#123;</span><br><span class="line"><span class="keyword">return</span> dp.get(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>[] target = t.toCharArray();</span><br><span class="line"><span class="type">int</span>[] tcounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> cha : target) &#123;</span><br><span class="line">tcounts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> stickers.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="type">int</span>[] sticker = stickers[i];</span><br><span class="line"><span class="keyword">if</span> (sticker[target[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tcounts[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> tcounts[j] - sticker[j];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums; k++) &#123;</span><br><span class="line">builder.append((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">rest</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">min = Math.min(min, process3(stickers, rest, dp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> min + (min == Integer.MAX_VALUE ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">dp.put(t, ans);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> ]]></content>
    
    
    <summary type="html">暴力递归、记忆化搜索、严格表结构、斜率优化</summary>
    
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://wuwawawa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>运行时数据区</title>
    <link href="https://wuwawawa.github.io/posts/11595de.html"/>
    <id>https://wuwawawa.github.io/posts/11595de.html</id>
    <published>2023-07-04T02:36:49.000Z</published>
    <updated>2024-03-04T04:20:31.574Z</updated>
    
    <content type="html"><![CDATA[<p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/b5d91ce04cfef9a681bbed216732511a.png" alt="image-20200705111640511" style="zoom:67%;" /></p><p>当我们通过前面的：<code>类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</code> 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区。</p><p>我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/bbf59f2544890b06cdb69b2d7719c060.png" alt="image-20210509174543026" style="zoom:67%;" /></p><hr><hr><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a>PC寄存器介绍</h3><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/pcRegister.png" alt="pcRegister"></p><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，<span class='p red'>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</span></li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是<span class='p blue'>通过改变这个计数器的值来选取下一条需要执行的字节码指令。</span></li><li>它是<span class='p red'>唯一一个</span>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><hr><h3 id="PC寄存器作用"><a href="#PC寄存器作用" class="headerlink" title="PC寄存器作用"></a>PC寄存器作用</h3><p>PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230704110320570.png" alt="image-20230704110320570" style="zoom: 50%;" /></p><blockquote><p>使用 PC 寄存器存储字节码指令地址有什么用呢？</p><p>为什么使用 PC 寄存器记录当前线程的执行地址呢？</p></blockquote><ol><li><p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p></li><li><p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p></li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/68aa12d47725e4559e6b71489d91122e.png" alt="image-20200705161409533"></p><blockquote><p>PC 寄存器为什么被设定为私有的？</p></blockquote><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<span class='p green'>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器</span>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><mark class="hl-label blue">CPU时间片</mark> <p>CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/bbab7cdab74c493af70b423f06e6ff86.png" alt="image-20200705161849557"></p><hr><hr><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>虚拟机栈出现背景</p></blockquote><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p><p>优点是跨平台，指令集小，编译器容易实现</p><p>缺点是性能下降，实现同样的功能需要更多的指令</p><blockquote><p>内存中的栈与堆</p></blockquote><span class='p red'>栈是运行时的单位，而堆是存储的单位</span><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/2d195f3aafd8b1f426efad75f0a52478.png" alt="image-20200705163928652"></p><hr><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的<code>栈帧（Stack Frame）</code>，对应着一次次的 Java 方法调用，是<code>线程私有</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackTest</span>();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230704112513940.png" alt="image-20230704112513940" style="zoom: 33%;" /></p><div class="tabs" id="b83445ba-2a3a-4d66-a332-642943ddda1f"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b83445ba-2a3a-4d66-a332-642943ddda1f-1"><i class="fas fa-cat"></i>生命周期</button></li><li class="tab"><button type="button" data-href="#b83445ba-2a3a-4d66-a332-642943ddda1f-2"><i class="fas fa-horse"></i>作用</button></li><li class="tab"><button type="button" data-href="#b83445ba-2a3a-4d66-a332-642943ddda1f-3"><i class="fas fa-dove"></i>特点</button></li><li class="tab"><button type="button" data-href="#b83445ba-2a3a-4d66-a332-642943ddda1f-4"><i class="fas fa-dragon"></i>栈中可能出现的异常</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b83445ba-2a3a-4d66-a332-642943ddda1f-1"><p>生命周期和线程一致。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b83445ba-2a3a-4d66-a332-642943ddda1f-2"><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b83445ba-2a3a-4d66-a332-642943ddda1f-3"><ul><li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序序计数器。</p></li><li><p>JVM 直接对 Java 栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/d4e4445f4faee685dc98d54129344bb3.png" alt="image-20200705165025382"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b83445ba-2a3a-4d66-a332-642943ddda1f-4"><p>Java 虚拟机规范允许Java 栈的大小是动态的或者是固定不变的。</p><ul><li><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个<code>StackOverflowError异常</code>。</p></li><li><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<code>OutOfMemoryError异常</code>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抛出异常：Exception in thread&quot;main&quot;java.lang.StackoverflowError</span></span><br><span class="line"><span class="comment">//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</span></span><br></pre></td></tr></table></figure><p><mark class="hl-label blue">设置栈内存大小</mark> </p><p>我们可以使用参数 <code>-Xss</code>选项来设置<code>线程的最大栈空间</code>，栈的大小直接决定了函数调用的最大可达深度</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="存储单位栈帧"><a href="#存储单位栈帧" class="headerlink" title="存储单位栈帧"></a>存储单位栈帧</h3><mark class="hl-label blue">栈中存储什么？</mark> <p>每个线程都有自己的栈，栈中的数据都是以<code>栈帧（Stack Frame）</code>的格式存在。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><mark class="hl-label blue">栈运行原理</mark> <ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<span class='p green'>当前栈帧（Current Frame）</span>，与当前栈帧相对应的方法就是<span class='p green'>当前方法（Current Method）</span>，定义这个方法的类就是<span class='p green'>当前类（Current Class）</span></p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/893126a7a33507917e11377fd3e4b639.png" alt="image-20200705203142545"></p><ol><li><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p></li><li><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p></li><li><p>Java方法有两种返回函数的方式。一种是正常的函数返回，使用return指令；另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。但不管使用哪种方式，都会导致栈帧被弹出。</p></li></ol><mark class="hl-label blue">栈帧的内部结构</mark> <p>每个栈帧中存储着：</p><ul><li><span class='p red'>局部变量表（Local Variables）</span></li><li><span class='p red'>操作数栈（operand Stack）（或表达式栈）</span></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/0ed2029b435d547547f32540077bb082.png" alt="image-20200705204836977"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表和操作数栈决定的</p><hr><hr><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><h3 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h3><p>简单地讲，一个 Native Method 是一个 Java 调用非 Java 代码的接囗。一个 Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++中，你可以用 extern “c” 告知 c++编译器去调用一个 c 的函数。</p><p>A native method is a Java method whose implementation is provided by non-java code.</p><p>在定义一个 native method 时，并不提供实现体（有些像定义一个 Java interface），因为其实现体是由非 java 语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/7b36a8321e4c955f06220775c9c2cf4c.png" alt="image-20200706164139252"></p><hr><h3 id="本地方法栈-1"><a href="#本地方法栈-1" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>Java 虚拟机栈于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li></ul><p>本地方法是使用 C 语言实现的。</p><p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/b4aea15cec874411f749e336c8b5d8fd.png" alt="image-20200706174708418"></p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p><p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</p><hr><hr><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol><li>堆针对一个JVM进程来说是唯一的。也就是<span class='p red'>一个进程只有一个JVM实例</span>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li><li>但是<span class='p blue'>进程包含多个线程，他们是共享同一堆空间的</span>。</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/0be60cad417bedd46d651f710ae585ce.png" alt="image-20200706195127740"></p><ol><li><p>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p></li><li><p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。<span class='p green'>是 JVM 管理的最大一块内存空间</span>，堆内存的大小是可以调节的。</p></li><li><p>《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p></li><li>所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li><li>《Java 虚拟机规范》中对 Java 堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</li><li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li><li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。<ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul></li><li>堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/3ae9948d069bd58ccfcda730cc12bf0f.png" alt="image-20200706201904057"></p><hr><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>Java 7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区</p><ul><li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space 永久区 Perm</li></ul><p>Java 8 及之后堆内存逻辑上分为三部分：新生区+养老区+元空间</p><ul><li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Meta Space 元空间 Meta</li></ul><p>约定：新生区（代）&lt;=&gt;年轻代 、 养老区&lt;=&gt;老年区（代）、 永久区&lt;=&gt;永久代</p><div class="tabs" id="821a3913-ff13-4e1a-9b3a-93dd49ed7d14"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#821a3913-ff13-4e1a-9b3a-93dd49ed7d14-1"><i class="fas fa-award"></i>堆空间内部结构（JDK7）</button></li><li class="tab"><button type="button" data-href="#821a3913-ff13-4e1a-9b3a-93dd49ed7d14-2"><i class="fas fa-baseball-ball"></i>堆空间内部结构（JDK8）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="821a3913-ff13-4e1a-9b3a-93dd49ed7d14-1"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/deafdcce7cf88a496bc231820bb5b007.png" alt="image-20200706203419496" style="zoom:67%;" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="821a3913-ff13-4e1a-9b3a-93dd49ed7d14-2"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/ee2836af2e1d5387b4ac58f5eacabbb6.png" alt="image-20200706203835403" style="zoom:67%;" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="设置堆内存大小"><a href="#设置堆内存大小" class="headerlink" title="设置堆内存大小"></a>设置堆内存大小</h3><ol><li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置，-X 是jvm的运行参数，-X 是jvm的运行参数。</p><ul><li><code>-Xms</code>用于表示堆区（年轻代+老年代）的起始内存，等价于<code>-XX:InitialHeapSize</code></li><li><code>-Xmx</code>则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li></ul></li><li>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</li><li><p>通常会将-Xms和-Xmx两个参数配置相同的值</p><ul><li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li><li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li></ul></li><li><p>默认情况下:</p><ul><li>初始内存大小：物理电脑内存大小/64</li><li>最大内存大小：物理电脑内存大小/4</li></ul></li></ol><hr><h3 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h3><p>存储在 JVM 中的 Java 对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与 JVM 的生命周期保持一致</li></ul><p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/f3ee86daaf5076fe22265ffcaa831175.png" alt="image-20200707075847954"></p><p>新生代与老年代在堆结构的占比。</p><ul><li>默认<code>-XX:NewRatio=2</code>，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3</li><li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占 1，老年代占 4，新生代占整个堆的 1/5</li></ul><p>在 HotSpot 中，Eden 空间和另外两个 survivor 空间缺省所占的比例是 8：1：1</p><p>当然开发人员可以通过选项<code>-xx:SurvivorRatio</code>调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></p><p>几乎所有的 Java 对象都是在 Eden 区被 new 出来的。绝大部分的 Java 对象的销毁都在新生代进行了。</p><ul><li>IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的。</li></ul><p>可以使用选项<code>-Xmn</code>设置新生代最大内存大小，这个参数一般使用默认值就可以了。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/31fd90d99565ec8ce0682a4468076f94.png" alt="image-20210510105849497"></p><hr><h3 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h3><p>​    为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><ol><li><p>new 的对象先放伊甸园区。此区有大小限制。</p></li><li><p>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p></li><li><p>然后将伊甸园中的剩余对象移动到幸存者 0 区。</p></li><li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。</p></li><li><p>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</p></li><li><p>啥时候能去养老区呢？可以设置次数。默认是 15 次。</p><ul><li>可以设置参数：<code>-Xx:MaxTenuringThreshold= N</code>进行设置</li></ul></li><li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC：Major GC，进行养老区的内存清理</p></li><li><p>若养老区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常。</p></li></ol><mark class="hl-label blue">对象分配的特殊情况</mark> <ol><li>如果来了一个新对象，先看看 Eden 是否放的下？<ul><li>如果 Eden 放得下，则直接放到 Eden 区</li><li>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li></ul></li><li>将对象放到老年区又有两种情况：<ul><li>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</li><li>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM </li></ul></li><li>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/23b91eb543fc0072cb628365267f0089.png" alt="image-20200707091058346"></p><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><ol><li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></p></li><li><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p></li></ol><ul><li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li><strong>新生代收集</strong>（Minor GC/Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</li><li><strong>老年代收集</strong>（Major GC/Old GC）：只是老年代的垃圾收集。</li><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ul></li><li><p><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p></li></ul><p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p><hr><hr><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h3><ol><li>Person 类的 .class 信息存放在方法区中</li><li>person 变量存放在 Java 栈的局部变量表中</li><li>真正的 person 对象存放在 Java 堆中</li><li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/b9f11764ee47b28d37f7764dfd9c9f55.png" alt="image-20200708094747667"></p><hr><h3 id="方法区基本概述"><a href="#方法区基本概述" class="headerlink" title="方法区基本概述"></a>方法区基本概述</h3><blockquote><p>方法区在哪里</p></blockquote><ol><li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>所以，<span class='p red'>方法区可以看作是一块独立于Java堆的内存空间</span></li></ol><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/6a7f2350e0f4e0cde0ac246225e2acdd.png" alt="image-20200708095853544"></p><blockquote><p>方法区基本理解</p></blockquote><span class='p green'>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</span><ol><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ol><hr><h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><div class="tabs" id="19ef8671-1621-4661-a983-cba765878dba"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#19ef8671-1621-4661-a983-cba765878dba-1"><i class="fas fa-seedling"></i>jdk7及以前</button></li><li class="tab"><button type="button" data-href="#19ef8671-1621-4661-a983-cba765878dba-2"><i class="fas fa-leaf"></i>JDK8以后</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="19ef8671-1621-4661-a983-cba765878dba-1"><ul><li>通过<code>-XX:Permsize</code>来设置永久代初始分配空间。默认值是 20.75M</li><li>通过<code>-XX:MaxPermsize</code>来设定永久代最大可分配空间。32 位机器默认是 64M，64 位机器模式是 82M</li><li>当 JVM 加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code>。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="19ef8671-1621-4661-a983-cba765878dba-2"><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</li><li>默认值依赖于平台。windows 下，<code>-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1//即没有限制</code>。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的<code>-XX:MetaspaceSize</code>值为 21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h3><p>《深入理解 Java 虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/fbe3915506e7979c7d591d17c216fbb1.png" alt="image-20200708161856504"></p><div class="tabs" id="2bff9740-807b-47eb-bb97-ef0e276019eb"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-1"><i class="fas fa-award"></i>类型信息</button></li><li class="tab"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-2"><i class="fas fa-baseball-ball"></i>域（Field）信息</button></li><li class="tab"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-3"><i class="fas fa-bone"></i>方法（Method）信息</button></li><li class="tab"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-4"><i class="fas fa-anchor"></i>non-final的类变量</button></li><li class="tab"><button type="button" data-href="#2bff9740-807b-47eb-bb97-ef0e276019eb-5"><i class="fas fa-heartbeat"></i>运行时常量池</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2bff9740-807b-47eb-bb97-ef0e276019eb-1"><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bff9740-807b-47eb-bb97-ef0e276019eb-2"><p>也就是我们常说的成员变量，域信息是比较官方的称呼</p><ol><li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p></li><li><p>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bff9740-807b-47eb-bb97-ef0e276019eb-3"><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称</li><li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bff9740-807b-47eb-bb97-ef0e276019eb-4"><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li></ul><p>补充说明：全局常量（static final）</p><p>被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2bff9740-807b-47eb-bb97-ef0e276019eb-5"><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li><li>运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性。</li><li>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</li></ul><p>运行时常量池衍生自<code>.class</code>文件中的常量池，所以两者的内容差不多。</p><p>因此，每个.class对应有一个运行时常量池。当类加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时常量池中</p><p>jvm规范中如下描述:</p><p>The Java Virtual Machine maintains a run-time constant pool for each class and interface .</p><p>The<code>constant_pool</code>table in the binary representation of a class or interface (<a href="https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html%23jvms-4.4">§4.4</a>) is used to construct the run-time constant pool upon class or interface creation.</p><p>运行时常量池 VS 常量池</p><ol><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div> <hr><h3 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h3><ol><li>首先明确：只有 Hotspot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java 虚拟机规范》管束，并不要求统一</li><li>Hotspot 中方法区的变化：</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">JDK版本</th><th style="text-align:center">方法区变化</th></tr></thead><tbody><tr><td style="text-align:center">JDK1.6 及之前</td><td style="text-align:center">有永久代（permanet），静态变量存储在永久代上</td></tr><tr><td style="text-align:center">JDK1.7</td><td style="text-align:center">有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td style="text-align:center">JDK1.8</td><td style="text-align:center">无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table></div><p>字符串常量池存的是字符串本身，运行时常量池存的是字符串引用，指向字符串常量池。</p><blockquote><p>字符串常量池 StringTable 为什么要调整位置？</p></blockquote><ul><li><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p></li><li><p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p></li></ul><div class="tabs" id="2b96576e-c020-4117-a205-5c2dfca56393"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2b96576e-c020-4117-a205-5c2dfca56393-1"><i class="fas fa-seedling"></i>JDK6</button></li><li class="tab"><button type="button" data-href="#2b96576e-c020-4117-a205-5c2dfca56393-2"><i class="fas fa-leaf"></i>JDK7</button></li><li class="tab"><button type="button" data-href="#2b96576e-c020-4117-a205-5c2dfca56393-3"><i class="fab fa-apple"></i>JDK8</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2b96576e-c020-4117-a205-5c2dfca56393-1"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1a3aa55257c3150d78327542e5ca230e.png" alt="image-20200708211541300"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b96576e-c020-4117-a205-5c2dfca56393-2"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/e0f65fc4228d9b6573ae1b23d9a1558b.png" alt="image-20200708211609911"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2b96576e-c020-4117-a205-5c2dfca56393-3"><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/c3ed969b0d2bad704c22481208e5dd10.png" alt="image-20200708211637952"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 zGC 收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>回收废弃常量与回收 Java 堆中的对象非常类似。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。</p></li><li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，<u>通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</u>。</p>]]></content>
    
    
    <summary type="html">程序计数器、虚拟机栈、本地方法栈、堆、方法区</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://wuwawawa.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>类加载子系统</title>
    <link href="https://wuwawawa.github.io/posts/13cb3a0e.html"/>
    <id>https://wuwawawa.github.io/posts/13cb3a0e.html</id>
    <published>2023-07-04T01:50:25.000Z</published>
    <updated>2024-01-07T12:34:48.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存结构概述图"><a href="#内存结构概述图" class="headerlink" title="内存结构概述图"></a>内存结构概述图</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/e4bc9ed374db7f35e68f23f4813205bd.png" alt="image-20200705080719531" style="zoom:67%;" /></p><hr><hr><h2 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h2><mark class="hl-label blue">类加载器子系统作用</mark> <p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/3569bfb903e80b66ee7e972a6b4a5036.png" alt="image-20200705081813409"></p><ul><li><p>类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件开头有特定的文件标识。</p></li><li><p>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。</p></li><li><p><span class='p blue'>加载的类信息存放于一块称为方法区的内存空间。</span>除了类的信息外，<span class='p green'>方法区中还会存放运行时常量池信息</span>，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</p></li></ul><hr><hr><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/e8172076eaa7a152408633a353f06b2c.png" alt="image-20200705081913538"></p><ul><li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例。</li><li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在<code>方法区</code>。</li><li>在.class 文件-&gt; JVM -&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li></ul><mark class="hl-label blue">ClassLoader类介绍</mark> <p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/a22114b608dffe484041b591d486a7fd.png" alt="image-20200705103636003"></p><hr><hr><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *示例代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的加载过程是怎么样的呢?</p><ul><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li><li>加载失败则抛出异常</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/8cc54647114c456695ac352336c74600.png" alt="image-20200705082255746"></p><p>完整的流程图如下所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/image-20230223144619053.png" alt="image-20230223144619053"></p><hr><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ol><li><p>通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p><code>在内存中生成一个代表这个类的java.lang.Class对象</code>，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>补充：加载class文件的方式</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><hr><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><p>链接分为三个子阶段：<code>验证 -&gt; 准备 -&gt; 解析</code></p><div class="tabs" id="b2447a71-06b7-461a-9870-39ae327efdc0"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b2447a71-06b7-461a-9870-39ae327efdc0-1"><i class="fas fa-seedling"></i>验证</button></li><li class="tab"><button type="button" data-href="#b2447a71-06b7-461a-9870-39ae327efdc0-2"><i class="fas fa-leaf"></i>准备</button></li><li class="tab"><button type="button" data-href="#b2447a71-06b7-461a-9870-39ae327efdc0-3"><i class="fab fa-apple"></i>解析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b2447a71-06b7-461a-9870-39ae327efdc0-1"><p>确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p><p>主要包括四种验证，<span class='p green'>文件格式验证，元数据验证，字节码验证，符号引用验证</span>。</p><p><code>举例:</code></p><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b2447a71-06b7-461a-9870-39ae327efdc0-2"><p>为类变量<code>分配内存</code>并且设置该<code>类变量</code>的默认初始值，即零值，类常量的值在编译时就已经分配了</p><p><span class='p blue'>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化</span></p><p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中</p><p><code>举例：</code></p><p>代码：变量n2在准备阶段会赋初始值，但不是2，而是0，在初始化阶段会被赋值为 2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//实例属性，非静态变量，此阶段不分配内存 在&lt;init&gt; 阶段赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//静态变量，默认初始化为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">3</span>;<span class="comment">//static final 常量，为 3</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b2447a71-06b7-461a-9870-39ae327efdc0-3"><p>将常量池内的<span class='p red'>符号引用转换为直接引用</span>的过程。</p><p>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</p><p><code>符号引用:</code></p><p>反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/image-20230223145236317.png" alt="image-20230223145236317" style="zoom:67%;" /></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>什么情况下需要开始类加载过程的第一个阶段：加载？ Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了下面的几种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前开始)：</p><p><strong>类初始化阶段时机:</strong></p><ol><li><code>创建类的实例</code></li><li><code>访问某个类或接口的静态变量</code>，或者对该静态变量赋值</li><li>调用<code>类的静态方法</code></li><li><code>反射</code>（比如：Class.forName(“com.atguigu.Test”)）</li><li><code>初始化一个类的子类</code></li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><p><strong>注意：</strong></p><p>1.通过子类调用父类的静态成员时，只会初始化父类而不会初始化子类。 因为没有调用子类的相关静态成员。</p><p>2.调用静态成员时，会加载静态成员真正所在的类及其父类。 这也好理解，因为本类的父类没有加载就会先去加载父类。</p><p>3.类的加载成功后，即静态成员都被加载后，是不会再加载第二次的。只有非静态成员，如非静态成员变量、非静态代码块、非静态方法(不调用不加载)、构造方法都会被多次实例化的时候多次加载。</p><p>4.如果静态属性有 final 修饰时，即类常量，则不会加载，当成常量使用。</p><blockquote><p>例如：子类调用父类的静态成员时，只会初始化父类而不会初始化子类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass Init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 对于静态字段，只有直接定义了这个字段的类才会被初始化</span></span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperClass Init!</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>从输出结果中可以得出通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。<br>但是触发了子类的加载。通过-XX:+TraceClassLoading参数可以观察。结果如下图：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/70.png" alt="在这里插入图片描述"></p><blockquote><p>例如：访问静态常量并不会导致类的初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Begin:&quot;</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;内部静态常量：&quot;</span> + Out.Inner.in_val);</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;外部静态常量：&quot;</span> + Out.out_val);</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">System.out.println(Out.Inner.in_var);</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">System.out.println(Out.out_var);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Out</span> &#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">out_var</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">out_val</span> <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Outter&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">in_var</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">in_val</span> <span class="operator">=</span> <span class="number">222</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Inner&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Begin</span><span class="operator">:</span><span class="number">1533821440864</span></span><br><span class="line">内部静态常量：<span class="number">222</span></span><br><span class="line">外部静态常量：<span class="number">111</span></span><br><span class="line"><span class="built_in">Inner</span></span><br><span class="line"><span class="number">1533821440884</span></span><br><span class="line"><span class="variable">Outter</span></span><br><span class="line"><span class="number">1533821440895</span></span><br></pre></td></tr></table></figure><p>由结果可见：常量（static final 修饰的）在编译阶段会存入调用类的常量池中，因此调用其常量本质上并没有直接引用到定义常量的类，因此不会触发常量的类的初始化。</p><p>但如果使用函数等运行时才能获得结果的代码，来初始化类的静态常量，则使用此静态常量时会导致类的加载和初始化：</p><p><code>public static final long out_val = System.currentTimeMillis();</code></p><p>当使用到内部类\外部类的静态变量时，内部类\外部类才开始时初始化。</p><p>内部类的初始化不会使外部类初始化，即内部类加载完成，外部类可能还没有初始化，加载静态内部类的时候不会加载外部类。</p><p><strong>clinit()</strong></p><ol><li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</li><li>此方法不需定义，是javac编译器自动收集类中的所有<strong><code>类变量</code></strong>（静态成员变量）的赋值动作和<code>静态代码块</code>中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</li><li><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code>不同于类的构造器。</li><li>构造器是虚拟机视角下的<code>&lt;init&gt;()</code></li><li>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</li><li>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁，保证一个类只加载一次。</li></ol><blockquote><p>例1:代码中有static变量</p></blockquote><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/image-20230223145612775.png" alt="image-20230223145612775"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassInitTest</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">       num = <span class="number">2</span>;</span><br><span class="line">       number = <span class="number">20</span>;</span><br><span class="line">       System.out.println(num);</span><br><span class="line">       <span class="comment">//System.out.println(number);//报错：非法的前向引用。</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span></span><br><span class="line"><span class="comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span></span><br><span class="line"><span class="comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ClassInitTest.num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(ClassInitTest.number);<span class="comment">//10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><clinit字节码>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> putstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">4</span> iconst_2</span><br><span class="line"> <span class="number">5</span> putstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"> <span class="number">8</span> bipush <span class="number">20</span> <span class="comment">//先赋20</span></span><br><span class="line"><span class="number">10</span> putstatic #<span class="number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">13</span> getstatic #<span class="number">2</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">16</span> getstatic #<span class="number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> bipush <span class="number">10</span><span class="comment">//再赋10</span></span><br><span class="line"><span class="number">24</span> putstatic #<span class="number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;</span><br><span class="line"><span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当我们代码中包含static变量的时候，就会有clinit方法</p><p>没有static变量时，就不会有cinit方法，加上之后就有了</p><blockquote><p>第四点说明</p></blockquote><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/image-20230223145728185.png" alt="image-20230223145728185"></p><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><blockquote><p>第五点说明</p></blockquote><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><p>加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><blockquote><p>第六点说明</p></blockquote><p>必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始&quot;</span>);</span><br><span class="line">            <span class="type">DeadThread</span> <span class="variable">dead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadThread</span>();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadThread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;初始化当前类&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程2开始</span><br><span class="line">线程1开始</span><br><span class="line">线程2初始化当前类</span><br><span class="line"></span><br><span class="line">/然后程序卡死了</span><br></pre></td></tr></table></figure><p>程序卡死，分析原因：</p><ul><li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li><li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><hr><hr><h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>JVM 支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有 3 个，如下所示：</p><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1e553c6d5254f827d2dfab537bea3ab9.png" alt="image-20200705094149223"></p><p>这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p><blockquote><p>虚拟机自带的加载器</p></blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li>这个类加载使用 C/C++语言实现的，嵌套在 JVM 内部。</li><li>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 Java.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li></ul><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。</li><li>派生于 ClassLoader 类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li><p>java 语言编写，由 sun.misc.LaunchersAppClassLoader 实现</p></li><li><p>派生于 ClassLoader 类</p></li><li><p>父类加载器为扩展类加载器</p></li><li><p>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</p></li><li><p>该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载</p></li><li><p>通过 ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</p></li></ul><blockquote><p>用户自定义类加载器</p></blockquote><p><strong>什么时候需要自定义类加载器？</strong></p><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ol><li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li><li>修改类加载的方式</li><li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><p><strong>如何自定义类加载器？</strong></p><ol><li>开发人员可以通过继承抽象类 ava.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass() 方法，而是建议把自定义的类加载逻辑写在 findClass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p><code>代码示例</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//defineClass和findClass搭配使用</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, result, <span class="number">0</span>, result.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//自定义流的获取方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="comment">//从自定义路径中加载指定类:细节略</span></span><br><span class="line">        <span class="comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">customClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;One&quot;</span>, <span class="literal">true</span>, customClassLoader);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java 虚拟机对 class 文件采用的是<code>按需加载</code>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<code>双亲委派模式</code>，即把请求交由父类处理，它是一种任务委派模式。</p><mark class="hl-label green">工作原理</mark> <ul><li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/img/05fa27fcc38eeaaa5babff55a00882a3.png" alt="image-20200705105151258"></p><mark class="hl-label blue">举例1</mark> <p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.lang.<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.String();</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,atguigu.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        System.out.println(test.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,atguigu<span class="selector-class">.com</span></span><br><span class="line">sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">18</span>b4aac2</span><br></pre></td></tr></table></figure><p>程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。</p><p>把刚刚的类改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是自定义的String类的静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误: 在类 java.lang.String 中找不到 main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,String&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，该加载器正好负责String的加载，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p><mark class="hl-label green">举例2</mark> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShkStart</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited <span class="keyword">package</span> name: java.lang</span><br><span class="line">at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="number">662</span>)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">761</span>)</span><br><span class="line">at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="number">142</span>)</span><br><span class="line">at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="number">467</span>)</span><br><span class="line">at java.net.URLClassLoader.access$<span class="number">100</span>(URLClassLoader.java:<span class="number">73</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">368</span>)</span><br><span class="line">at java.net.URLClassLoader$<span class="number">1.</span>run(URLClassLoader.java:<span class="number">362</span>)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">361</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">335</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="number">495</span>)</span><br><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> </span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p><p><code>举例3</code></p><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双亲委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ol><p><strong>双亲委派机制优势</strong></p><p>通过上面的例子，我们可以知道，双亲机制可以</p><ol><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><blockquote><p><strong>沙箱安全机制</strong></p></blockquote><ol><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><hr><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p>如何判断两个class对象是否相同？</p></blockquote><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名</li><li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li><li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li></ol><blockquote><p>对类加载器的引用</p></blockquote><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）</li></ol><blockquote><p><strong>new一个对象的过程？</strong></p></blockquote><p>当虚拟机遇见new关键字的时候，首先判断该类是否已经加载，如果类没有加载，那么先执行类的加载机制，加载完成后再为对象分配空间、初始化等。详细过程如下：</p><p>　　1、加载阶段：</p><p>　　　　1）首先检查当前类是否被加载，如果没有被加载，执行类的加载机制</p><p>　　　　2）加载：就是将类的字节码文件，即class文件读入内存，并为之创建一个Class对象</p><p>　　　　3）验证：校验class文件是否符合虚拟机规范</p><p>　　　　4）准备：为静态变量赋默认值</p><p>　　　　5）解析：虚拟机将常量池内的符号引用替换为直接引用的过程</p><p>　　　　6）初始化：给静态变量赋定义的值、执行静态代码块，如果存在父类，先对父类进行初始化</p><p>　　2、创建对象分配内存空间</p><p>　　　　1）首先为对象在堆中分配大小合适的内存空间</p><p>　　　　2）接着为实例变量赋默认值</p><p>　　　　3）设置对象的头信息、对象hash码、GC分代年龄、元数据信息等</p><p>　　　　4）执行构造器</p>]]></content>
    
    
    <summary type="html">类加载过程、双亲委派机制</summary>
    
    
    
    <category term="Java" scheme="https://wuwawawa.github.io/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://wuwawawa.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
