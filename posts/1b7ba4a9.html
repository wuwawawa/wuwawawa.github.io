<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Redis原理 | LuckyBoy🥝</title><meta name="keywords" content="中间件,Redis,数据库"><meta name="author" content="LuckyBoy🥝"><meta name="copyright" content="LuckyBoy🥝"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="数据结构、网络模型、RESP协议"><meta property="og:type" content="article"><meta property="og:title" content="Redis原理"><meta property="og:url" content="https://wuwawawa.github.io/posts/1b7ba4a9.html"><meta property="og:site_name" content="LuckyBoy🥝"><meta property="og:description" content="数据结构、网络模型、RESP协议"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_64.webp"><meta property="article:published_time" content="2023-06-16T00:44:04.000Z"><meta property="article:modified_time" content="2023-06-17T13:33:10.931Z"><meta property="article:author" content="LuckyBoy🥝"><meta property="article:tag" content="中间件"><meta property="article:tag" content="Redis"><meta property="article:tag" content="数据库"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_64.webp"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://wuwawawa.github.io/posts/1b7ba4a9"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:{limitDay:365,position:"top",messagePrev:"It has been",messageNext:"days since the last update, the content of the article may be outdated."},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:640},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js",css:"https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Redis原理",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-17 21:33:10"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme"),o=(new Date).getHours();void 0===t?o<=6||o>=18?activateDarkMode():activateLightMode():"light"===t?activateLightMode():activateDarkMode();const a=saveToLocal.get("aside-status");void 0!==a&&("hide"===a?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248 626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="LuckyBoy🥝" type="application/atom+xml"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.webp" onerror='onerror=null,src="/assets/r1.jpg"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">91</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-home"></use></svg> <span class="menu_word" style="font-size:17px">首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--article"></use></svg> <span class="menu_word" style="font-size:17px">文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-guidang1"></use></svg> <span class="menu_word" style="font-size:17px">归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-sekuaibiaoqian"></use></svg> <span class="menu_word" style="font-size:17px">标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-fenlei"></use></svg> <span class="menu_word" style="font-size:17px">分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-pinweishenghuo"></use></svg> <span class="menu_word" style="font-size:17px">休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-yinle"></use></svg> <span class="menu_word" style="font-size:17px">八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-dianying1"></use></svg> <span class="menu_word" style="font-size:17px">影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-youxishoubing"></use></svg> <span class="menu_word" style="font-size:17px">游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-xiangzi"></use></svg> <span class="menu_word" style="font-size:17px">八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-tubiaozhizuomoban"></use></svg> <span class="menu_word" style="font-size:17px">画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-nvwumao"></use></svg> <span class="menu_word" style="font-size:17px">动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-zhifengche"></use></svg> <span class="menu_word" style="font-size:17px">网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shejiaoxinxi"></use></svg> <span class="menu_word" style="font-size:17px">社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-pengyouquan"></use></svg> <span class="menu_word" style="font-size:17px">朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-liuyan"></use></svg> <span class="menu_word" style="font-size:17px">留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-lianjie"></use></svg> <span class="menu_word" style="font-size:17px">友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-wangye"></use></svg> <span class="menu_word" style="font-size:17px">网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--tongjibiao"></use></svg> <span class="menu_word" style="font-size:17px">网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shujutongji1"></use></svg> <span class="menu_word" style="font-size:17px">文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-xianxingshalou"></use></svg> <span class="menu_word" style="font-size:17px">旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-maoliang"></use></svg> <span class="menu_word" style="font-size:17px">个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-qunliaotian"></use></svg> <span class="menu_word" style="font-size:17px">唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-love-sign"></use></svg> <span class="menu_word" style="font-size:17px">恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-paperplane"></use></svg> <span class="menu_word" style="font-size:17px">关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LuckyBoy🥝</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-home"></use></svg> <span class="menu_word" style="font-size:17px">首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--article"></use></svg> <span class="menu_word" style="font-size:17px">文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-guidang1"></use></svg> <span class="menu_word" style="font-size:17px">归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-sekuaibiaoqian"></use></svg> <span class="menu_word" style="font-size:17px">标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-fenlei"></use></svg> <span class="menu_word" style="font-size:17px">分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-pinweishenghuo"></use></svg> <span class="menu_word" style="font-size:17px">休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-yinle"></use></svg> <span class="menu_word" style="font-size:17px">八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-dianying1"></use></svg> <span class="menu_word" style="font-size:17px">影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-youxishoubing"></use></svg> <span class="menu_word" style="font-size:17px">游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-xiangzi"></use></svg> <span class="menu_word" style="font-size:17px">八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-tubiaozhizuomoban"></use></svg> <span class="menu_word" style="font-size:17px">画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-nvwumao"></use></svg> <span class="menu_word" style="font-size:17px">动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-zhifengche"></use></svg> <span class="menu_word" style="font-size:17px">网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shejiaoxinxi"></use></svg> <span class="menu_word" style="font-size:17px">社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-pengyouquan"></use></svg> <span class="menu_word" style="font-size:17px">朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-liuyan"></use></svg> <span class="menu_word" style="font-size:17px">留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-lianjie"></use></svg> <span class="menu_word" style="font-size:17px">友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-wangye"></use></svg> <span class="menu_word" style="font-size:17px">网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon--tongjibiao"></use></svg> <span class="menu_word" style="font-size:17px">网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-shujutongji1"></use></svg> <span class="menu_word" style="font-size:17px">文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-xianxingshalou"></use></svg> <span class="menu_word" style="font-size:17px">旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-maoliang"></use></svg> <span class="menu_word" style="font-size:17px">个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-qunliaotian"></use></svg> <span class="menu_word" style="font-size:17px">唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-love-sign"></use></svg> <span class="menu_word" style="font-size:17px">恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.3em;height:1.3em;vertical-align:-.15em;fill:currentColor;overflow:hidden"><use xlink:href="#icon-paperplane"></use></svg> <span class="menu_word" style="font-size:17px">关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg> <span>搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">Redis原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于</span> <time class="post-meta-date-created" datetime="2023-06-16T00:44:04.000Z" title="发表于 2023-06-16 08:44:04">2023-06-16</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-17T13:33:10.931Z" title="更新于 2023-06-17 21:33:10">2023-06-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">1.4w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Redis原理"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="动态字符串"><a href="#动态字符串" class="headerlink" title="动态字符串"></a>动态字符串</h3><p>我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。</p><p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：<br>获取字符串长度的需要通过运算<br>非二进制安全<br>不可修改<br>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。<br>例如，我们执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name admin</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>那么Redis将在底层创建两个SDS，其中一个是包含”name”的SDS，另一个是包含”admin””的SDS。</p><p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984624671.png" alt="1653984624671"></p><p>例如，一个包含字符串“name”的sds结构如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984648404.png" alt="1653984648404"></p><p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984787383.png" alt="1653984787383"></p><p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p><p>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</p><p>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984822363.png" alt="1653984822363"></p><mark class="hl-label red">优点</mark><p>① 获取字符串长度的时间复杂度为O(1）</p><p>② 支持动态扩容</p><p>③ 减少内存分配次数</p><p>④ 二进制安全</p><hr><h3 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h3><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。<br>结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> encoding;<span class="comment">/*编码方式，支持存放16位、32位、64位整数*/</span> </span><br><span class="line">	<span class="type">uint32_t</span> length;<span class="comment">/*元素个数*/</span></span><br><span class="line">	<span class="type">int8_t</span> contents[];<span class="comment">/*整数数组，保存集合数据*/</span> </span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16(sizeof(int16_t))<span class="comment">/*2字节整数，范围类似java的short*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32(sizeof(int32_t))<span class="comment">/*4字节整数，范围类似java的int*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64(sizeof(int64_t))<span class="comment">/*8字节整数，范围类似java的long*/</span></span></span><br></pre></td></tr></table></figure><p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985149557.png" alt="1653985149557"></p><p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：<br>encoding：4字节<br>length：4字节<br>contents：2字节 * 3 = 6字节</p><mark class="hl-label green">IntSet升级</mark><p>现在，假设有一个intset，元素为{5,10，20}，采用的编码是INTSET_ENC_INT16，则每个整数占2字节：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616110642298.png" alt="image-20230616110642298"></p><p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。<br>以当前案例来说流程如下：</p><ul><li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li><li>将待添加的元素放入数组末尾</li><li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985276621.png" alt="1653985276621"></p><mark class="hl-label blue">IntSet新增流程</mark><p>源码如下</p><div class="tabs" id="b59a24b2-347a-4c61-a4ad-db89c7792c05"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#b59a24b2-347a-4c61-a4ad-db89c7792c05-1"><i class="fas fa-seedling"></i>intsetAdd</button></li><li class="tab"><button type="button" data-href="#b59a24b2-347a-4c61-a4ad-db89c7792c05-2"><i class="fas fa-leaf"></i>intsetUpgradeAndAdd</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="b59a24b2-347a-4c61-a4ad-db89c7792c05-1"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985304075.png" alt="1653985304075"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="b59a24b2-347a-4c61-a4ad-db89c7792c05-2"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985327653.png" alt="1653985327653"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label green">小总结</mark><p>Intset可以看做是特殊的整数数组，具备一些特点：</p><ul><li>Redis会确保Intset中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><hr><h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。<br>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      <span class="comment">// Entry数组，数组中保存的是指向Entry的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     <span class="comment">// 哈希表数组的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// 哈希表数组的掩码，用于计算索引值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;     <span class="comment">// Entry个数</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;              <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;          <span class="comment">// 值</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;       <span class="comment">// 64位无符号整数</span></span><br><span class="line">        <span class="type">int64_t</span> s64;        <span class="comment">// 64位有符号整数</span></span><br><span class="line">        <span class="type">double</span> d;           <span class="comment">// 双精度浮点数</span></span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个哈希表节点的指针</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;     <span class="comment">// dict类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;     <span class="comment">// 私有数据，在做特殊hash运算时用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];       <span class="comment">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx;     <span class="comment">// rehash进度标识符，-1表示没有进行rehash操作</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">// rehash是否暂停，1则暂停，0则继续</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1=v1，假设k1的哈希值h =1，则1&amp;3 =1，因此k1=v1要存储到数组角标1位置。再来一个k2=v2,hash值相等。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985497735.png" alt="1653985497735"></p><p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653985640422.png" alt="1653985640422"></p><div class="tabs" id="30d4fd04-9ea3-400c-8733-b028dc42b438"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#30d4fd04-9ea3-400c-8733-b028dc42b438-1"><i class="fas fa-cat"></i>Dict的扩容</button></li><li class="tab"><button type="button" data-href="#30d4fd04-9ea3-400c-8733-b028dc42b438-2"><i class="fas fa-cookie-bite"></i>Dict的收缩</button></li><li class="tab"><button type="button" data-href="#30d4fd04-9ea3-400c-8733-b028dc42b438-3"><i class="fas fa-horse"></i>Dict的rehash</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="30d4fd04-9ea3-400c-8733-b028dc42b438-1"><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。<br>Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；</li><li>哈希表的 LoadFactor &gt; 5 ；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dicExpandIfNeeded</span><span class="params">(dict *d)</span>&#123;</span><br><span class="line">  <span class="comment">// 如果正在rehash，则返回ok</span></span><br><span class="line">  <span class="keyword">if</span>(dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line">  <span class="comment">// 如果哈希表为空，则初始化哈希表为默认大小：4</span></span><br><span class="line">  <span class="keyword">if</span>(d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d,DICT_HT_INITIAL_SIZE);</span><br><span class="line">  <span class="comment">// 当负载因子 (used/size）达到1以上，并且当前没有进行bgrewrite等子进程操作</span></span><br><span class="line">  <span class="comment">// 或者负载因子超过5，则进行 dictExpand，也就是扩容</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio) &amp;&amp;</span><br><span class="line">        dictTypeExpandAllowed(d))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 扩容大小为used+1，底层会对扩容大小做判断，实际上找的是第一个大于等于used+1的 2^n</span></span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="30d4fd04-9ea3-400c-8733-b028dc42b438-2"><p>Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor &lt; 0.1 时，会做哈希表收缩</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_hash.c # hashTypeDeleted() </span></span><br><span class="line"><span class="keyword">if</span> (dictDelete((dict*)o-&gt;ptr, field) == C_OK) &#123;</span><br><span class="line">    deleted = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 删除成功后，检查是否需要重置Dict大小，如果需要则调用dictResize重置</span></span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(o-&gt;ptr)) dictResize(o-&gt;ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// server.c 文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    <span class="comment">// entry数量</span></span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="comment">// size &gt; 4（哈希表初识大小）并且 负载因子低于0.1</span></span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp; (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> minimal;</span><br><span class="line">    <span class="comment">// 如果正在做bgsave或bgrewriteof或rehash，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) </span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 获取used，也就是entry个数</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="comment">// 如果used小于4，则重置为4</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="comment">// 重置大小为minimal，其实是第一个大于等于minimal的2^n</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="30d4fd04-9ea3-400c-8733-b028dc42b438-3"><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul></li><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx = 0，标示开始rehash</li><li><del>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</del></li><li>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><p>Dict的rehash并不是一次性完成的。试想一下，如果Dict中包含数百万的entry，要在一次rehash完成，极有可能导致主线程阻塞。因此Dict的rehash是分多次、渐进式的完成，因此称为渐进式rehash。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label blue">小总结</mark><p>Dict的结构：</p><ul><li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li><li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li></ul><p>Dict的伸缩：</p><ul><li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li><li>当LoadFactor小于0.1时，Dict收缩</li><li>扩容大小为第一个大于等于used + 1的2^n</li><li>收缩大小为第一个大于等于used 的2^n</li><li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li><li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li></ul><hr><h3 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h3><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616120637074.png" alt="image-20230616120637074"></p><div class="table-container"><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>长度</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>zlbytes</td><td>uint32_t</td><td>4 字节</td><td>记录整个压缩列表占用的内存字节数</td></tr><tr><td>zltail</td><td>uint32_t</td><td>4 字节</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</td></tr><tr><td>zllen</td><td>uint16_t</td><td>2 字节</td><td>记录了压缩列表包含的节点数量。 最大值为UINT16_MAX （65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td>entry</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td>zlend</td><td>uint8_t</td><td>1 字节</td><td>特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端。</td></tr></tbody></table></div><mark class="hl-label blue">ZipListEntry</mark><p>ZipList 中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986055253.png" alt="1653986055253"></p><ul><li><p>previous_entry_length：前一节点的长度，占1个或5个字节。</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul></li><li><p>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</p></li><li>contents：负责保存节点的数据，可以是字符串或整数</li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p><mark class="hl-label green">Encoding编码</mark><p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p><div class="table-container"><table><thead><tr><th>编码</th><th>编码长度</th><th>字符串大小</th></tr></thead><tbody><tr><td>\</td><td>00pppppp\</td><td></td><td>1 bytes</td><td>&lt;= 63 bytes</td></tr><tr><td>\</td><td>01pppppp\</td><td>qqqqqqqq\</td><td></td><td>2 bytes</td><td>&lt;= 16383 bytes</td></tr><tr><td>\</td><td>10000000\</td><td>qqqqqqqq\</td><td>rrrrrrrr\</td><td>ssssssss\</td><td>tttttttt\</td><td></td><td>5 bytes</td><td>&lt;= 4294967295 bytes</td></tr></tbody></table></div><p>例如，我们要保存字符串：“ab”和 “bc”</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986172002.png" alt="1653986172002"></p><p>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</p><div class="table-container"><table><thead><tr><th style="text-align:center">编码</th><th style="text-align:center">编码长度</th><th style="text-align:center">整数类型</th></tr></thead><tbody><tr><td style="text-align:center">11000000</td><td style="text-align:center">1</td><td style="text-align:center">int16_t（2 bytes）</td></tr><tr><td style="text-align:center">11010000</td><td style="text-align:center">1</td><td style="text-align:center">int32_t（4 bytes）</td></tr><tr><td style="text-align:center">11100000</td><td style="text-align:center">1</td><td style="text-align:center">int64_t（8 bytes）</td></tr><tr><td style="text-align:center">11110000</td><td style="text-align:center">1</td><td style="text-align:center">24位有符整数(3 bytes)</td></tr><tr><td style="text-align:center">11111110</td><td style="text-align:center">1</td><td style="text-align:center">8位有符整数(1 bytes)</td></tr><tr><td style="text-align:center">1111xxxx</td><td style="text-align:center">1</td><td style="text-align:center">直接在xxxx位置保存数值，范围从0001~1101(0-12)，减1后结果为实际值</td></tr></tbody></table></div><p>例如，一个ZipList中包含两个整数值：“2”和“5”</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616143324590.png" alt="image-20230616143324590"></p><mark class="hl-label red">ZipList的连锁更新问题</mark><p>ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：<br>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值<br>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据<br>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616145824215.png" alt="image-20230616145824215"></p><p>此时往头部添加一个长度大于等于254字节的entry</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986328124.png" alt="1653986328124"></p><p>ZipList这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p><mark class="hl-label blue">小总结</mark><p>ZipList特性：</p><ul><li>压缩列表的可以看做一种连续内存空间的”双向链表”</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生连续更新问题</li></ul><hr><h3 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h3><p>问题1：ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p><p>​ 答：为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p><p>问题2：但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p><p>​ 答：我们可以创建多个ZipList来分片存储数据。</p><p>问题3：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><p>​ 答：Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986474927.png" alt="1653986474927"></p><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。<br>如果值为正，则代表ZipList的允许的entry个数的最大值<br>如果值为负，则代表ZipList的最大内存大小，分5种情况：</p><ul><li>1：每个ZipList的内存占用不能超过4kb</li><li>2：每个ZipList的内存占用不能超过8kb</li><li>3：每个ZipList的内存占用不能超过16kb</li><li>4：每个ZipList的内存占用不能超过32kb</li><li>5：每个ZipList的内存占用不能超过64kb</li></ul><p>其默认值为 -2</p><p>除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩。通过配置项list-compress-depth来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p><p>0：特殊值，代表不压缩</p><p>1：标示QuickList的首尾各有1个节点不压缩，中间节点压缩</p><p>2：标示QuickList的首尾各有2个节点不压缩，中间节点压缩</p><p>以此类推</p><p>默认值： 0</p><p>以下是QuickList的和QuickListNode的结构源码：</p><div class="tabs" id="7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52-1"><i class="fas fa-atom"></i>QuickList</button></li><li class="tab"><button type="button" data-href="#7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52-2"><i class="far fa-sun"></i>QuickListNode</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">	<span class="comment">//头节点指针</span></span><br><span class="line">	quicklistNode *head;</span><br><span class="line">	<span class="comment">//尾节点指针</span></span><br><span class="line">	quicklistNode *tail;</span><br><span class="line">	<span class="comment">//所有ziplist的entry的数量 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">	<span class="comment">//ziplists总数量 </span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">	<span class="comment">//ziplist的entry上限，默认值-2 </span></span><br><span class="line">	<span class="type">int</span> fill : QL_FILL_BITS；</span><br><span class="line">	<span class="comment">//首尾不压缩的节点数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> compress : QL_COMP_BITS;</span><br><span class="line">	<span class="comment">//内存重分配时的书签数量及数组，一般用不到</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bookmark_count : QL_BM_BITS;</span><br><span class="line">	quicklistBookmark bookmarksD[];</span><br><span class="line">&#125; quicklist</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="7e84b56c-b0a5-4e0b-8fe8-c7bb22cafc52-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">  <span class="comment">//前一个节点指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">//下一个节点指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">//当前节点的ZipList指针</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">  <span class="comment">//当前节点的ZipList的字节大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">  <span class="comment">//当前节点的ZipList的entry个数 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;</span><br><span class="line">  <span class="comment">//编码方式：1， Ziplist; 2，lzf压缩模式 </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//数据容器类型（预留）：1，其它；2, ZipList</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//是否被解压缩。1：则说明被解压了，将来要重新压缩</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> attempted compress : <span class="number">1</span>;<span class="comment">//测试用</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> extra:<span class="number">10</span>;<span class="comment">/*预留字段*/</span> </span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>我们接下来用一段流程图来描述当前的这个结构</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986718554.png" alt="1653986718554"></p><mark class="hl-label blue">总结</mark><p>QuickList的特点：</p><ul><li>是一个节点为ZipList的双端链表</li><li>节点采用ZipList，解决了传统链表的内存占用问题</li><li>控制了ZipList大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存</li></ul><hr><h3 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h3><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p><p>作为一个链表，我们去访问首或尾的元素的时候，性能还是不错的，但是呢，现在要去访问队列中间的元素，比方说11，那这个时候啊你去查询的性能就比较差了，你不得不一个一个的去遍历。现在这个链表长度还比较短，只有20，那如果说现在这个列表里面达到了上千甚至数万个元素，要去访问中间元素的时候，要遍历的次数是不是可以达到数千甚至上万次。</p><p>为什么链表查询效率慢？就是因为链表它的指针跨度是一。每一个节点，它的指针永远指向的是下一个节点。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986771309.png" alt="1653986771309"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 最大的索引层级，默认是1</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele; <span class="comment">// 节点存储的值</span></span><br><span class="line">    <span class="type">double</span> score;<span class="comment">// 节点分数，排序、查找用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span; <span class="comment">// 索引跨度</span></span><br><span class="line">    &#125; level[]; <span class="comment">// 多级索引数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616095141891.png" alt="image-20230616095141891"></p><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：<br>元素按照升序排列存储<br>节点可能包含多个指针，指针跨度不同。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986877620.png" alt="1653986877620"></p><mark class="hl-label blue">小总结</mark><p>SkipList的特点：</p><ul><li>跳跃表是一个双向链表，每个节点都包含score和ele值</li><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ul><hr><h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653986956618.png" alt="1653986956618"></p><p>从Redis的使用者的角度来看，⼀个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，⽽value可以是多种数据类型，比如：<br>string, list, hash、set、sorted set等。我们可以看到，key的类型固定是string，而value可能的类型是多个。<br>⽽从Redis内部实现的⾓度来看，database内的这个映射关系是用⼀个dict来维护的。dict的key固定用⼀种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同⼀个dict内能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是robj，全名是redisObject。</p><p>Redis的编码方式</p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><p>Redis的编码方式</p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><div class="table-container"><table><thead><tr><th><strong>编号</strong></th><th><strong>编码方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>0</td><td>OBJ_ENCODING_RAW</td><td>raw编码动态字符串</td></tr><tr><td>1</td><td>OBJ_ENCODING_INT</td><td>long类型的整数的字符串</td></tr><tr><td>2</td><td>OBJ_ENCODING_HT</td><td>hash表（字典dict）</td></tr><tr><td>3</td><td>OBJ_ENCODING_ZIPMAP</td><td>已废弃</td></tr><tr><td>4</td><td>OBJ_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>5</td><td>OBJ_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>6</td><td>OBJ_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>7</td><td>OBJ_ENCODING_SKIPLIST</td><td>跳表</td></tr><tr><td>8</td><td>OBJ_ENCODING_EMBSTR</td><td>embstr的动态字符串</td></tr><tr><td>9</td><td>OBJ_ENCODING_QUICKLIST</td><td>快速列表</td></tr><tr><td>10</td><td>OBJ_ENCODING_STREAM</td><td>Stream流</td></tr></tbody></table></div><p>五种数据结构</p><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p><div class="table-container"><table><thead><tr><th><strong>数据类型</strong></th><th><strong>编码方式</strong></th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>int、embstr、raw</td></tr><tr><td>OBJ_LIST</td><td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td></tr><tr><td>OBJ_SET</td><td>intset、HT</td></tr><tr><td>OBJ_ZSET</td><td>ZipList、HT、SkipList</td></tr><tr><td>OBJ_HASH</td><td>ZipList、HT</td></tr></tbody></table></div><hr><hr><h2 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String是Redis中最常见的数据存储类型：</p><div class="tabs" id="8cde4759-907e-4ac2-862a-e7b98a34c3c1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#8cde4759-907e-4ac2-862a-e7b98a34c3c1-1"><i class="fas fa-seedling"></i>RAW</button></li><li class="tab"><button type="button" data-href="#8cde4759-907e-4ac2-862a-e7b98a34c3c1-2"><i class="fas fa-leaf"></i>EMBSTR</button></li><li class="tab"><button type="button" data-href="#8cde4759-907e-4ac2-862a-e7b98a34c3c1-3"><i class="fab fa-apple"></i>INT</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="8cde4759-907e-4ac2-862a-e7b98a34c3c1-1"><p>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512mb。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653987103450.png" alt="1653987103450"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8cde4759-907e-4ac2-862a-e7b98a34c3c1-2"><p>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时RedisObject与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616153706417.png" alt="image-20230616153706417"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="8cde4759-907e-4ac2-862a-e7b98a34c3c1-3"><p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616154241077.png" alt="image-20230616154241077"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label blue">测试</mark><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name jack</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen name</span><br><span class="line">(<span class="built_in">integer</span>) 44</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; strlen name</span><br><span class="line">(<span class="built_in">integer</span>) 45</span><br><span class="line">127.0.0.1:6379&gt; object encoding name</span><br><span class="line"><span class="string">&quot;raw&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding age</span><br><span class="line"><span class="string">&quot;int&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis的List类型可以从首、尾操作列表中的元素</p><p>哪一个数据结构能满足上述特征？</p><ul><li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li><li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li><li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li></ul><p>Redis的List结构类似一个双端链表，可以从首、尾操作列表中的元素：</p><p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p><p>在3.2版本之后，Redis统一采用QuickList来实现List。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653987313461.png" alt="1653987313461"></p><hr><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是Redis中的单列集合，满足下列特点：</p><ul><li>不保证有序性</li><li>保证元素唯一</li><li>求交集、并集、差集</li></ul><p>可以看出，Set对查询元素的效率要求非常高，思考一下，什么样的数据结构可以满足？</p><p>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null</p><p>当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616160631352.png" alt="image-20230616160631352"></p><p>注意：当插入的数据不是整数，IntSet就会转换成Dict。</p><hr><h3 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p><ul><li>可以根据score值排序后</li><li>member必须唯一</li><li>可以根据member查询分数</li></ul><p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。之前学习的哪种编码结构可以满足？</p><ul><li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li><li>HT（Dict）：可以键值存储，并且可以根据key找value</li></ul><div class="tabs" id="87d68fcd-a4ee-4ec3-8596-98d5831447c8"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#87d68fcd-a4ee-4ec3-8596-98d5831447c8-1"><i class="fas fa-seedling"></i>Zset结构</button></li><li class="tab"><button type="button" data-href="#87d68fcd-a4ee-4ec3-8596-98d5831447c8-2"><i class="fas fa-leaf"></i>createZsetObject</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="87d68fcd-a4ee-4ec3-8596-98d5831447c8-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">// Dict指针</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// SkipList指针</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="87d68fcd-a4ee-4ec3-8596-98d5831447c8-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">createZsetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 创建Dict</span></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建SkipList</span></span><br><span class="line">    zs-&gt;zsl = zslCreate(); </span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653992172526.png" alt="1653992172526"></p><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p><ul><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zadd添加元素时，先根据key找到zset，不存在则创建新的zset</span></span><br><span class="line">zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line"><span class="keyword">if</span> (checkType(c,zobj,OBJ_ZSET)) <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123; <span class="comment">// zset不存在</span></span><br><span class="line">    <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">        server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">    &#123; <span class="comment">// zset_max_ziplist_entries设置为0就是禁用了ZipList，</span></span><br><span class="line">        <span class="comment">// 或者value大小超过了zset_max_ziplist_value，采用HT + SkipList</span></span><br><span class="line">        zobj = createZsetObject();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则，采用 ZipList</span></span><br><span class="line">        zobj = createZsetZiplistObject();</span><br><span class="line">    &#125;</span><br><span class="line">    dbAdd(c-&gt;db,key,zobj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616165412835.png" alt="image-20230616165412835"></p><hr><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash结构与Redis中的Zset非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>区别如下：</p><ul><li>zset的键是member，值是score；hash的键和值都是任意值</li><li>zset要根据score排序；hash则无需排序</li></ul><p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可。</p><p>Hash结构默认采用ZipList编码，用以节省内存。</p><p>ZipList中相邻的两个entry 分别保存field和value当数据量较大时，Hash结构会转为HT编码，也就是Dict，</p><p>触发条件有两个：</p><p>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</p><p>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616170044461.png" alt="image-20230616170044461"></p><p>转换</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616170222695.png" alt="image-20230616170222695"></p><p>总之，ziplist本来就设计为各个数据项挨在⼀起组成连续的内存空间，这种结构并不擅长做修改操作。⼀旦数据发⽣改动，就会引发内存realloc，可能导致内存拷贝。</p><hr><hr><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="用户空间和内核态空间"><a href="#用户空间和内核态空间" class="headerlink" title="用户空间和内核态空间"></a>用户空间和内核态空间</h3><p>服务器大多都采用Linux系统，这里我们以Linux为例来讲解:</p><p>ubuntu和Centos 都是Linux的发行版，发行版可以看成对linux包了一层壳，任何Linux发行版，其系统内核都是Linux。我们的应用都需要通过Linux内核与硬件交互。</p><p>计算机硬件包括，如cpu，内存，网卡等等，内核（通过寻址空间）可以操作硬件的，但是内核需要不同设备的驱动，有了这些驱动之后，内核就可以去对计算机硬件去进行 内存管理，文件系统的管理，进程的管理等等。</p><p>我们想要用户的应用来访问，计算机就必须要通过对外暴露的一些接口，才能访问到，从而简介的实现对内核的操控，但是内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源，如果不加任何限制，用户去操作随意的去操作我们的资源，就有可能导致一些冲突，甚至有可能导致我们的系统出现无法运行的问题，因此我们需要把用户和<strong>内核隔离开</strong>。</p><p>进程的寻址空间会划分为两部分：内核空间、用户空间</p><p>用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问</p><p>内核空间可以执行特权命令（Ring0），调用一切系统资源</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616171453302.png" alt="image-20230616171453302" style="zoom:67%"></p><p>在linux中，他们权限分成两个等级，0和3，用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问内核空间可以执行特权命令（Ring0），调用一切系统资源，所以一般情况下，用户的操作是运行在用户空间，而内核运行的数据是在内核空间的，而有的情况下，一个应用程序需要去调用一些特权资源，去调用一些内核空间的操作，所以此时他俩需要在用户态和内核态之间进行切换。</p><p>比如：</p><p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p><p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p><p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p><p>针对这个操作：我们的用户在写读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的buffer中，然后再返回给应用程序，整体而言，速度慢，就是这个原因，为了加速，我们希望read也好，还是wait for data也最好都不要等待，或者时间尽量的短。</p><hr><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><hr><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待。</p><p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653897115346.png" alt="1653897115346"></p><mark class="hl-label blue">具体流程如下</mark><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616172336294.png" alt="image-20230616172336294"></p><hr><h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</p><p>阶段一：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户进程</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，直到数据就绪</li></ul><p>阶段二：</p><ul><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li><li>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653897490116.png" alt="1653897490116"></p><hr><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p><ul><li>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。</li><li>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</li></ul><p>比如服务端处理客户端Socket请求时，在单线程情况下，只能依次处理每一个socket，如果正在处理的socket恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有其它客户端socket都必须等待，性能自然会很差。</p><p>所以怎么看起来以上两种方式性能都不好</p><p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能自然会很差。</p><p>就比如服务员给顾客点餐，分两步：</p><ul><li>顾客思考要吃什么（等待数据就绪）</li><li>顾客想好了，开始点餐（读取数据）</li></ul><p>要提高效率有几种办法？</p><p>方案一：增加更多服务员（多线程）<br>方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）</p><blockquote><p>那么问题来了：用户进程如何知道内核中数据是否就绪呢？</p></blockquote><ul><li>文件描述符（File Descriptor）：简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</li><li>IO多路复用：是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</li></ul><p>阶段一：</p><ul><li>用户进程调用select，指定要监听的FD集合</li><li>内核监听FD对应的多个socket</li><li>任意一个或多个socket数据就绪则返回readable</li><li>此过程中用户进程阻塞</li></ul><p>阶段二：</p><ul><li>用户进程找到就绪的socket</li><li>依次调用recvfrom读取数据</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><p>当用户去读取数据的时候，不再去直接调用recvfrom了，而是调用select的函数，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</p><p>用IO复用模式，可以确保去读数据的时候，数据是一定存在的，他的效率比原来的阻塞IO和非阻塞IO性能都要高</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653898691736.png" alt="1653898691736" style="zoom:67%"></p><p>IO多路复用是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><p>其中select和pool相当于是当被监听的数据准备好之后，他会把你监听的FD整个数据都发给你，你需要到整个FD中去找，哪些是处理好了的，需要通过遍历的方式，所以性能也并不是那么好</p><p>而epoll，则相当于内核准备好了之后，他会把准备好的数据，直接发给你，咱们就省去了遍历的动作。</p><hr><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select是Linux最早是由的I/O多路复用技术：</p><p>简单说，就是我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的 ），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据，</p><p>比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再将处理掉没有准备好的数据，最后再将这个FD集合写回到用户态中去，此时用户态就知道了，奥，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求，我们会发现，这种模式下他虽然比阻塞IO和非阻塞IO好，但是依然有些麻烦的事情， 比如说频繁的传递fd集合，频繁的去遍历FD等问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类型别名 __fd_mask，本质是 long int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> __fd_mask;</span><br><span class="line"><span class="comment">/* fd_set 记录要监听的fd集合，及其对应状态 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// fds_bits是long类型数组，长度为 1024/32 = 32</span></span><br><span class="line">    <span class="comment">// 共1024个bit位，每个bit位代表一个fd，0代表未就绪，1代表就绪</span></span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; fd_set;</span><br><span class="line"><span class="comment">// select函数，用于监听fd_set，也就是多个fd的集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> nfds, <span class="comment">// 要监视的fd_set的最大fd + 1</span></span></span><br><span class="line"><span class="params">    fd_set *readfds, <span class="comment">// 要监听读事件的fd集合</span></span></span><br><span class="line"><span class="params">    fd_set *writefds,<span class="comment">// 要监听写事件的fd集合</span></span></span><br><span class="line"><span class="params">    fd_set *exceptfds, <span class="comment">// // 要监听异常事件的fd集合</span></span></span><br><span class="line"><span class="params">    <span class="comment">// 超时时间，null-用不超时；0-不阻塞等待；大于0-固定等待时间</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> timeval *timeout</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><div class="tabs" id="5e189b93-ed02-4460-b2cd-18f701c01df2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-1"><i class="fas fa-atom"></i>创建fd_set</button></li><li class="tab"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-2"><i class="far fa-sun"></i>执行select</button></li><li class="tab"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-3"><i class="fas fa-wind"></i>遍历fd_set</button></li><li class="tab"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-4"><i class="fas fa-fire-alt"></i>数据就绪</button></li><li class="tab"><button type="button" data-href="#5e189b93-ed02-4460-b2cd-18f701c01df2-5"><i class="fas fa-cookie-bite"></i>遍历fd_set</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5e189b93-ed02-4460-b2cd-18f701c01df2-1"><p>假如要监听 fd= 1, 2, 5</p><p>每个bit位代表一个fd</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616204442788.png" alt="image-20230616204442788" style="zoom:50%"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5e189b93-ed02-4460-b2cd-18f701c01df2-2"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616204552207.png" alt="image-20230616204552207" style="zoom:50%"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5e189b93-ed02-4460-b2cd-18f701c01df2-3"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616204629505.png" alt="image-20230616204629505" style="zoom:50%"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5e189b93-ed02-4460-b2cd-18f701c01df2-4"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616205131015.png" alt="image-20230616205131015" style="zoom:50%"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5e189b93-ed02-4460-b2cd-18f701c01df2-5"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616205352100.png" alt="image-20230616205352100" style="zoom:50%"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>select模式存在的问题：</p><p>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</p><p>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</p><p>fd_set监听的fd数量不能超过1024</p><hr><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p><p>IO流程：</p><ul><li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li><li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历fd，判断是否就绪</li><li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li><li>用户进程判断n是否大于0</li><li>大于0则遍历pollfd数组，找到就绪的fd</li></ul><p><strong>与select对比：</strong></p><ul><li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li><li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pollfd 中的事件类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN     <span class="comment">//可读事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT    <span class="comment">//可写事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR    <span class="comment">//错误事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL   <span class="comment">//fd未打开</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;     	  <span class="comment">/* 要监听的fd  */</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> events; <span class="comment">/* 要监听的事件类型：读、写、异常 */</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> revents;<span class="comment">/* 实际发生的事件类型 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// poll函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> pollfd *fds, <span class="comment">// pollfd数组，可以自定义大小</span></span></span><br><span class="line"><span class="params">    <span class="type">nfds_t</span> nfds, <span class="comment">// 数组元素个数</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout <span class="comment">// 超时时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><hr><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll模式是对select和poll的改进，它提供了三个函数：</p><p>第一个是：eventpoll的函数，他内部包含两个东西</p><p>一个是：</p><p>1、红黑树-&gt; 记录的事要监听的FD</p><p>2、一个是链表-&gt;一个链表，记录的是就绪的FD</p><p>紧接着调用epoll_ctl操作，将要监听的数据添加到红黑树上去，并且给每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，就是准备好了，现在就把fd把数据添加到list_head中去</p><p>3、调用epoll_wait函数</p><p>就去等待，在用户态创建一个空的events数组，当就绪之后，我们的回调函数会把数据添加到list_head中去，当调用这个函数的时候，会去检查list_head，当然这个过程需要参考配置的等待时间，可以等一定时间，也可以一直等， 如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的操作的数量，用户态的此时收到响应后，从events中拿到对应准备好的数据的节点，再去调用方法去拿数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>  <span class="title">rbr</span>;</span> <span class="comment">// 一颗红黑树，记录要监听的FD</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span><span class="comment">// 一个链表，记录就绪的FD</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1.创建一个epoll实例,内部是event poll，返回对应的句柄epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 2.将一个FD添加到epoll的红黑树中，并设置ep_poll_callback</span></span><br><span class="line"><span class="comment">// callback触发时，就把对应的FD加入到rdlist这个就绪列表中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd,  <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> op,    <span class="comment">// 要执行的操作，包括：ADD、MOD、DEL</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd,    <span class="comment">// 要监听的FD</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *event <span class="comment">// 要监听的事件类型：读、写、异常等</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">// 3.检查rdlist列表是否为空，不为空则返回就绪的FD的数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd,                   <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events, <span class="comment">// 空event数组，用于接收就绪的FD</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents,              <span class="comment">// events数组的最大长度</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout   <span class="comment">// 超时时间，-1用不超时；0不阻塞；大于0为阻塞时间</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><div class="tabs" id="ab16328b-43e8-47b1-a206-d6732070d977"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#ab16328b-43e8-47b1-a206-d6732070d977-1"><i class="fas fa-cat"></i>epoll_create</button></li><li class="tab"><button type="button" data-href="#ab16328b-43e8-47b1-a206-d6732070d977-2"><i class="fas fa-horse"></i>添加要监听的FD，关联callback</button></li><li class="tab"><button type="button" data-href="#ab16328b-43e8-47b1-a206-d6732070d977-3"><i class="fas fa-dove"></i>FD就绪</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="ab16328b-43e8-47b1-a206-d6732070d977-1"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617104551607.png" alt="image-20230617104551607" style="zoom:50%"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab16328b-43e8-47b1-a206-d6732070d977-2"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617104842869.png" alt="image-20230617104842869" style="zoom:50%"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="ab16328b-43e8-47b1-a206-d6732070d977-3"><p>就绪触发回调函数添加至就绪链表，拷贝到用户空间</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617105134155.png" alt="image-20230617105134155" style="zoom:50%"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>select模式存在的三个问题：</p><ul><li>能监听的FD最大不超过1024</li><li>每次select都需要把所有要监听的FD都拷贝到内核空间</li><li>每次都要遍历所有FD来判断就绪状态</li></ul><p>poll模式的问题：</p><ul><li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li></ul><p>epoll模式中如何解决这些问题的？</p><ul><li>基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高</li><li>每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li><li>利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下</li></ul><hr><h4 id="事件通知机制"><a href="#事件通知机制" class="headerlink" title="事件通知机制"></a>事件通知机制</h4><p>当FD有数据可读时，我们调用epoll_wait（或者select、poll）可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li><li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li></ul><p>举个栗子：</p><ul><li>假设一个客户端socket对应的FD已经注册到了epoll实例中</li><li>客户端socket发送了2kb的数据</li><li>服务端调用epoll_wait，得到通知说FD就绪</li><li>服务端从FD读取了1kb数据回到步骤3（再次调用epoll_wait，形成循环）</li></ul><p>结论</p><p>如果我们采用LT模式，因为FD中仍有1kb数据，则第⑤步依然会返回结果，并且得到通知<br>如果我们采用ET模式，因为第③步已经消费了FD可读事件，第⑤步FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时。</p><hr><h4 id="基于epoll的服务器端流程"><a href="#基于epoll的服务器端流程" class="headerlink" title="基于epoll的服务器端流程"></a>基于epoll的服务器端流程</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617111058655.png" alt="image-20230617111058655"></p><hr><h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>阶段一：</p><ul><li>用户进程调用sigaction，注册信号处理函数</li><li>内核返回成功，开始监听FD</li><li>用户进程不阻塞等待，可以执行其它业务</li><li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li></ul><p>阶段二：</p><ul><li>收到SIGIO回调信号</li><li>调用recvfrom，读取</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653911776583.png" alt="1653911776583"></p><hr><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p><p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653911877542.png" alt="1653911877542"></p><blockquote><p>对比</p></blockquote><p>IO操作是同步还是异步，关键看数据在内核空间与用户空间的拷贝过程（数据读写的IO操作），也就是阶段二是同步还是异步：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653912219712.png" alt="1653912219712"></p><hr><h3 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h3><mark class="hl-label blue">Redis到底是单线程还是多线程？</mark><ul><li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li><li>如果是聊整个Redis，那么答案就是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redis v4.0：引入多线程异步处理一些耗时较旧的任务，例如异步删除命令unlink</li><li>Redis v6.0：在核心网络模型中引入 多线程，进一步提高对于多核CPU的利用率</li></ul><p>因此，对于Redis的核心网络模型，在Redis 6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况。</p><mark class="hl-label green">为什么Redis要选择单线程？</mark><ul><li>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230616174058705.png" alt="image-20230616174058705" style="zoom:67%"></p><p>当我们的客户端想要去连接我们服务器，会去先到IO多路复用模型去进行排队，会有一个连接应答处理器，他会去接受读请求，然后又把读请求注册到具体模型中去，此时这些建立起来的连接，如果是客户端请求处理器去进行执行命令时，他会去把数据读取出来，然后把数据放入到client中， clinet去解析当前的命令转化为redis认识的命令，接下来就开始处理这些命令，从redis中的command中找到这些命令，然后就真正的去操作对应的数据了，当数据操作完成后，会去找到命令回复处理器，再由他将数据写出。</p><hr><hr><h2 id="Redis通讯协议-RESP协议"><a href="#Redis通讯协议-RESP协议" class="headerlink" title="Redis通讯协议-RESP协议"></a>Redis通讯协议-RESP协议</h2><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p><p>客户端（client）向服务端（server）发送一条命令</p><p>服务端解析并执行命令，返回响应结果给客户端</p><p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p><p>而在Redis中采用的是RESP（Redis Serialization Protocol）协议：</p><p>Redis 1.2版本引入了RESP协议</p><p>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</p><p>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性—客户端缓存</p><p>但目前，默认使用的依然是RESP2协议，也是我们要学习的协议版本（以下简称RESP）。</p><p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p><p>单行字符串：首字节是 ‘+’ ，后面跟上单行字符串，以CRLF（ “\r\n” ）结尾。例如返回”OK”： “+OK\r\n”</p><p>错误（Errors）：首字节是 ‘-’ ，与单行字符串格式一样，只是字符串是异常信息，例如：”-Error message\r\n”</p><p>数值：首字节是 ‘:’ ，后面跟上数字格式的字符串，以CRLF结尾。例如：”:10\r\n”</p><p>多行字符串：首字节是 ‘$’ ，表示二进制安全的字符串，最大支持512MB：</p><p>如果大小为0，则代表空字符串：”$0\r\n\r\n”</p><p>如果大小为-1，则代表不存在：”$-1\r\n”</p><p>数组：首字节是 ‘*’，后面跟上数组元素个数，再跟上元素，元素数据类型不限:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653982993020.png" alt="1653982993020"></p><hr><h3 id="基于Socket自定义Redis的客户端"><a href="#基于Socket自定义Redis的客户端" class="headerlink" title="基于Socket自定义Redis的客户端"></a>基于Socket自定义Redis的客户端</h3><p>Redis支持TCP通信，因此我们可以使用Socket来模拟客户端，与Redis服务端建立连接：</p><div class="tabs" id="37dd8520-68a9-4405-a84e-462cf9cac3c4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#37dd8520-68a9-4405-a84e-462cf9cac3c4-1"><i class="fas fa-bug"></i>main</button></li><li class="tab"><button type="button" data-href="#37dd8520-68a9-4405-a84e-462cf9cac3c4-2"><i class="fas fa-cannabis"></i>handleResponse</button></li><li class="tab"><button type="button" data-href="#37dd8520-68a9-4405-a84e-462cf9cac3c4-3"><i class="fas fa-candy-cane"></i>readBulkString</button></li><li class="tab"><button type="button" data-href="#37dd8520-68a9-4405-a84e-462cf9cac3c4-4"><i class="fas fa-child"></i>sendRequest</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="37dd8520-68a9-4405-a84e-462cf9cac3c4-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Socket s;</span><br><span class="line">    <span class="keyword">static</span> PrintWriter writer;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.建立连接</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;192.168.150.101&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6379</span>;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">            <span class="comment">// 2.获取输出流、输入流</span></span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream(), StandardCharsets.UTF_8));</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.发出请求</span></span><br><span class="line">            <span class="comment">// 3.1.获取授权 auth 123321</span></span><br><span class="line">            sendRequest(<span class="string">&quot;auth&quot;</span>, <span class="string">&quot;123321&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.2.set name 虎哥</span></span><br><span class="line">            sendRequest(<span class="string">&quot;mget&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;num&quot;</span>, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.解析响应</span></span><br><span class="line">            obj = handleResponse();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 5.释放连接</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="literal">null</span>) reader.close();</span><br><span class="line">                <span class="keyword">if</span> (writer != <span class="literal">null</span>) writer.close();</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="literal">null</span>) s.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37dd8520-68a9-4405-a84e-462cf9cac3c4-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">handleResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 读取首字节</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefix</span> <span class="operator">=</span> reader.read();</span><br><span class="line">    <span class="comment">// 判断数据类型标示</span></span><br><span class="line">    <span class="keyword">switch</span> (prefix) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="comment">// 单行字符串，直接读一行</span></span><br><span class="line">            <span class="keyword">return</span> reader.readLine();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="comment">// 异常，也读一行</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(reader.readLine());</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>: <span class="comment">// 数字</span></span><br><span class="line">            <span class="keyword">return</span> Long.parseLong(reader.readLine());</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: <span class="comment">// 多行字符串</span></span><br><span class="line">            <span class="comment">// 先读长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再读数据,读len个字节。我们假设没有特殊字符，所以读一行（简化）</span></span><br><span class="line">            <span class="keyword">return</span> reader.readLine();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> readBulkString();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;错误的数据格式！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37dd8520-68a9-4405-a84e-462cf9cac3c4-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">readBulkString</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取数组大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.parseInt(reader.readLine());</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义集合，接收多个元素</span></span><br><span class="line">    List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(len);</span><br><span class="line">    <span class="comment">// 遍历，依次读取每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        list.add(handleResponse());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="37dd8520-68a9-4405-a84e-462cf9cac3c4-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set name 虎哥</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">    writer.println(<span class="string">&quot;*&quot;</span> + args.length);</span><br><span class="line">    <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">        writer.println(<span class="string">&quot;$&quot;</span> + arg.getBytes(StandardCharsets.UTF_8).length);</span><br><span class="line">        writer.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    writer.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><hr><h2 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h2><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。<br>我们可以通过修改配置文件来设置Redis的最大内存：<code>maxmemory 1gb</code></p><p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：</p><ul><li>内存过期策略</li><li>内存淘汰策略</li></ul><hr><h3 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h3><p>在学习Redis缓存的时候我们说过，可以通过expire命令给Redis的key设置TTL（存活时间)</p><p>当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</p><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在之前学习过的Dict结构中。不过在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL。</p><p>Redis有16个数据库，每个数据库就是一个redisDb</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 存放所有key及value的地方，也被称为keyspace*/</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key*/</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="type">int</span> id;                     <span class="comment">/* Database ID，0~15 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;          <span class="comment">/* 记录平均TTL时长 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires_cursor; <span class="comment">/* expire检查时在dict中抽样的索引位置. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* 等待碎片整理的key列表. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653983606531.png" alt="1653983606531"></p><p>这里有两个问题需要我们思考：</p><blockquote><p>Redis是如何知道一个key是否过期呢？</p></blockquote><p>利用两个Dict分别记录key-value对及key-ttl对</p><blockquote><p>是不是TTL到期就立即删除了呢？</p></blockquote><div class="tabs" id="196f3c83-22e3-4425-bd7b-2acf7e57e000"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#196f3c83-22e3-4425-bd7b-2acf7e57e000-1"><i class="fas fa-cat"></i>惰性删除</button></li><li class="tab"><button type="button" data-href="#196f3c83-22e3-4425-bd7b-2acf7e57e000-2"><i class="fas fa-horse"></i>周期删除</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="196f3c83-22e3-4425-bd7b-2acf7e57e000-1"><p>惰性删除：顾明思议并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/image-20230617162012568.png" alt="image-20230617162012568"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="196f3c83-22e3-4425-bd7b-2acf7e57e000-2"><p>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的key，然后执行删除。</p><p>执行周期有两种：</p><ul><li><p>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为SLOW</p></li><li><p>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</p></li></ul><p>SLOW模式规则：</p><p>①执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</p><p>②执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</p><p>③逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</p><p>④如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</p><p>FAST模式规则（过期key比例小于10%不执行 ）：</p><p>①执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</p><p>②执行清理耗时不超过1ms</p><p>③逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</p><p>④如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束④</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><mark class="hl-label blue">小总结</mark><p>RedisKey的TTL记录方式：</p><p>在RedisDB中通过一个Dict记录每个Key的TTL时间</p><p>过期key的删除策略：</p><ul><li>惰性清理：每次查找key时判断是否过期，如果过期则删除</li><li>定期清理：定期抽样部分key，判断是否过期，如果过期则删除</li></ul><p>定期清理的两种模式：</p><ul><li>SLOW模式执行频率默认为10，每次不超过25ms</li><li>FAST模式执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms</li></ul><hr><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>内存淘汰：就是当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果服务器设置了server.maxmemory属性，并且并未有执行lua脚本</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="comment">// 尝试进行内存淘汰performEvictions</span></span><br><span class="line">        <span class="type">int</span> out_of_memory = (performEvictions() == EVICT_FAIL);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label blue">淘汰策略</mark><p>Redis支持8种不同策略来选择要删除的key：</p><ul><li><p>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p></li><li><p>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</p></li><li><p>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</p></li><li><p>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</p></li><li><p>allkeys-lru： 对全体key，基于LRU算法进行淘汰</p></li><li><p>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</p></li><li><p>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</p></li><li><p>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰</p><p>比较容易混淆的有两个：</p><ul><li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li><li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</li></ul></li></ul><p>Redis的数据都会被封装为RedisObject结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;        <span class="comment">// 对象类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS;  <span class="comment">// LRU：以秒为单位记录最近一次访问时间，长度24bit LFU：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</span></span><br><span class="line">    <span class="type">int</span> refcount;           <span class="comment">// 引用计数，计数为0则可以回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;              <span class="comment">// 数据指针，指向真实数据</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p><ul><li>生成0~1之间的随机数R</li><li>计算 (旧次数 * lfu_log_factor + 1)，记录为P</li><li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</li></ul><p>最后用一副图来描述当前的这个流程吧</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/1653984085095.png" alt="1653984085095"></p></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Redis原理</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://wuwawawa.github.io/posts/1b7ba4a9.html">https://wuwawawa.github.io/posts/1b7ba4a9.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>LuckyBoy🥝</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-06-16</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-06-17</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>中间件</a><a class="post-meta__tags" href="/tags/Redis/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>Redis</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>数据库</a></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/db4d2069.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_63.webp" onerror='onerror=null,src="/assets/r2.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis高级</div></div></a></div><div class="next-post pull-right"><a href="/posts/b543ced0.html"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_65.webp" onerror='onerror=null,src="/assets/r2.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RabbitMQ概述</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6dfcb629.html" title="Redis基础"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_61.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-06-07</div><div class="title">Redis基础</div></div></a></div><div><a href="/posts/1bd023c5.html" title="Redis实战"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_62.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-06-12</div><div class="title">Redis实战</div></div></a></div><div><a href="/posts/db4d2069.html" title="Redis高级"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_63.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-06-15</div><div class="title">Redis高级</div></div></a></div><div><a href="/posts/8086094.html" title="MyBatisPlus"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_57.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-06-01</div><div class="title">MyBatisPlus</div></div></a></div><div><a href="/posts/66abc186.html" title="MyBatisPlus原理解析"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_58.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-06-02</div><div class="title">MyBatisPlus原理解析</div></div></a></div><div><a href="/posts/acfac54a.html" title="MyBatis源码解析"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_55.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2023-05-31</div><div class="title">MyBatis源码解析</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:700">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">Redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">动态字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntSet"><span class="toc-text">IntSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dict"><span class="toc-text">Dict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZipList"><span class="toc-text">ZipList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QuickList"><span class="toc-text">QuickList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SkipList"><span class="toc-text">SkipList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisObject"><span class="toc-text">RedisObject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">五种数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZSET"><span class="toc-text">ZSET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash"><span class="toc-text">Hash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%A9%BA%E9%97%B4"><span class="toc-text">用户空间和内核态空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="toc-text">阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-text">非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#poll"><span class="toc-text">poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-text">小总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">事件通知机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B5%81%E7%A8%8B"><span class="toc-text">基于epoll的服务器端流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="toc-text">信号驱动IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="toc-text">异步IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-text">Redis网络模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE-RESP%E5%8D%8F%E8%AE%AE"><span class="toc-text">Redis通讯协议-RESP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESocket%E8%87%AA%E5%AE%9A%E4%B9%89Redis%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">基于Socket自定义Redis的客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-text">Redis内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9Fkey%E5%A4%84%E7%90%86"><span class="toc-text">过期key处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-text">内存淘汰策略</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color:transparent"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2024</b></span><span><b>&nbsp;&nbsp;By LuckyBoy🥝</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading()),setTimeout((function(){preloader.endLoading()}),5e3),document.getElementById("loading-box").addEventListener("click",(()=>{preloader.endLoading()}))</script><div class="js-pjax"><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null))},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js").then(t):setTimeout(t,0)};btf.loadComment(document.getElementById("twikoo-wrap"),o)})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.tocScrollFn&&window.removeEventListener("scroll",window.tocScrollFn),window.scrollCollect&&window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),document.getElementById("rightside").style.cssText="opacity: ''; transform: ''",window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://wuwawawa.github.io/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 算法学习笔记 (15)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://wuwawawa.github.io/categories/Java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍟 Java笔记 (30)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://wuwawawa.github.io/categories/数据库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 数据库笔记 (19)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://wuwawawa.github.io/categories/设计模式/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 设计模式笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://wuwawawa.github.io/categories/Spring/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🌸 Spring笔记 (14)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://wuwawawa.github.io/categories/中间件/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍕 中间件笔记 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://wuwawawa.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(33.333333333333336% - 5px);background:#e9e9e9;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_swiper_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),a.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/397c083a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_43.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/397c083a.html&quot;);" href="javascript:void(0);" alt="">Java8新特性</a><div class="blog-slider__text">Lambda表达式、函数式接口、Stream API</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/397c083a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3f9c0b8e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3f9c0b8e.html&quot;);" href="javascript:void(0);" alt="">3.共享模型之管程</a><div class="blog-slider__text">共享问题、synchronized、线程安全分析、Monitor、wait/notify、线程状态转换、活跃性、Lock</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3f9c0b8e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/9c5b9bb4.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_8.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/9c5b9bb4.html&quot;);" href="javascript:void(0);" alt="">7.1共享模型之工具</a><div class="blog-slider__text">线程池、AQS、ReentrantLock、Semaphore等锁的原理</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/9c5b9bb4.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f9285b5c.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/cover_9.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f9285b5c.html&quot;);" href="javascript:void(0);" alt="">关于字符串字面量进入到字符串常量池的时机</a><div class="blog-slider__text">字符串常量池的一些问题</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f9285b5c.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lmy-picbed.oss-cn-hangzhou.aliyuncs.com/blog/default_cover_60.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>function gitcalendar_injector_config(){document.getElementById("gitZone").insertAdjacentHTML("afterbegin",'<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>'),console.log("已挂载gitcalendar")}document.getElementById("gitZone")&&"/site/census/"===location.pathname&&(gitcalendar_injector_config(),GitCalendarInit("/api?null",["#d9e0df","#c6e0dc","#a8dcd4","#9adcd2","#89ded1","#77e0d0","#5fdecb","#47dcc6","#39dcc3","#1fdabe","#00dab9"],"null"))</script></body></html>